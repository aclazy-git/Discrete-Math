例1说明了怎么用正则表达式来定义正则集合。

例1 正则表达式 $10^{*}$ 、 $(10)^{*}$ 、 $0\bigcup 01$ 、 $0(0\bigcup 1)^{*}$ 和 $(0^{*}1)^{*}$ 所规定的正则集合中有哪些字符串？

解这些正则表达式所表示的正则集合如表1所示。读者可以自行验证。

表1  

<table><tr><td>表达式</td><td>字符串</td><td>表达式</td><td>字符串</td></tr><tr><td>10*</td><td>1后面跟任意多个0(也可以没有0)</td><td>0(0∪1)*</td><td>以0开头的任意字符串</td></tr><tr><td>(10)*</td><td>10的任意多个副本(包括空串)</td><td>(0*1)*</td><td>不以0结尾的任意字符串</td></tr><tr><td>0∪01</td><td>字符串0或01</td><td></td><td></td></tr></table>

正如例2所示，找到一个表示给定集合的正则表达式是非常棘手的。

例2 找到表示下列集合的正则表达式。

(a)长度为偶数的比特串构成的集合。

(b) 以 0 作为结束并且不包含 11 的比特串构成的集合。

(c) 包含奇数个 0 的比特串构成的集合。

解 (a) 为了找到长度为偶数的比特串构成的集合的正则表达式，我们可以利用这个事实，该字符串是由空串或者长度为2的比特串连接构成的。长度为2的比特串构成的集合可以通过正则表达式 $(00 \cup 01 \cup 10 \cup 11)$ 来表示。因此，长度为偶数的比特串的集合可以通过 $(00 \cup 01 \cup 10 \cup 11)^*$ 来表示。

(b) 以 0 作为结束且不包含 11 的比特串可以由一个或者多个形如 0 或者 10 这样的比特串连接构成。（注意，这样一个比特串一定包含形如 00 或者 10 这样形式的比特串；这样一个比特串也不能以单个 1 作为结束，因为我们知道它以 0 作为结束）。由此得出结论，不包含 11 且以 0 作为结束的比特串构成的集合可以由正则表达式 $(\mathbf{0} \cup \mathbf{10})^{*}(\mathbf{0} \cup \mathbf{10})$ 来表达。[注意，由正则表达式 $(\mathbf{0} \cup \mathbf{10})^{*}$ 表达的集合包含比特串，而不属于这个集合，因为比特串并不是以 0 作为结束的。]

(c)包含奇数个0的比特串至少包含一个0。属于该集合的比特串的形式是以空串，或者多个1开始后跟一个0，然后，后跟空串或者多个1。也就是说，每一个这样的比特串都是具有 $1^{j}01^{k}$ 的形式(其中 $j$ ， $k$ 为非负整数)。由于这样的比特串包含奇数个0，所以最初部分之后的其余位可以被分成以0开始，其后还有1个0这样形式的段。每个段的形式是 $01^{p}01^{q}(p,q$ 是非负整数)。因此，正则表达式 $1^{*}01^{*}(01^{*}01^{*})^{*}$ 可以表示具有奇数个0的比特串构成的集合。

# 13.4.2 克莱因定理

1956年，克莱因证明了正则集合就是有限状态自动机识别的集合。因此，这个重要结论称为克莱因定理。

定理1克莱因定理一个集合是正则的，当且仅当它可由一个有限状态自动机识别。

克莱因定理是自动机理论的中心定理之一，我们只证明必要性部分，即证明每个正则集合都可由一个有限状态自动机识别。充分性部分，有限状态自动机识别的集合都是正则的，留作练习。

证明 正则集合是通过正则表达式定义的，而正则表达式是递归定义的。所以，如果我们能证明下列事情，那么我们就证明了每个正则集合都可由一个有限状态自动机识别。

1)证明 $\varnothing$ 可由一个有限状态自动机识别。  
2)证明 $\{\lambda\}$ 可由一个有限状态自动机识别。  
3) 证明 $\{a\}$ 可由一个有限状态自动机识别，其中 $a$ 是 $I$ 中的符号。  
4)当 $A$ 和 $B$ 都可由有限状态自动机识别时，证明 $AB$ 也可由有限状态自动机识别。

5)当 $A$ 和 $B$ 都可由有限状态自动机识别时，证明 $A\cup B$ 也可由有限状态自动机识别。  
6)当 $A$ 可由有限状态自动机识别时，证明 $A^{*}$ 也可由有限状态自动机识别。

下面分别讨论每个任务。第一，证明 $\varnothing$ 可以由非确定性的有限状态自动机来识别。为此，需要构造一个没有终结状态的自动机。图1a就是这样的一个自动机。

![](42e8e2f6ff7790bb6a9c72f01dfc625c37c782d79a3dd28e1f157b6e779d618d.jpg)  
图1 识别某些基本集合的非确定性的有限状态自动机

第二，证明 $\{\lambda\}$ 也可由有限状态自动机来识别。为此需要构造一个识别空串 $\lambda$ 的自动机，并且除了 $\lambda$ 之外，它不识别任何其他的字符串。这个自动机可以这样来构造：初始状态 $s_0$ 也用作终结状态，并且对于任何其他的字符串，没有转移能将 $s_0$ 变为终结状态。图1b就是这样的一个非确定性的自动机。

第三，证明 $\{a\}$ 也可由非确定性的有限状态自动机来识别。为此构造如下机器：初始状态是 $s_0$ ，终结状态是 $s_1$ ，对于输入 $a$ 有一个从 $s_0$ 到 $s_1$ 的转移，且没有其他的转移。这个机器识别的唯一的字符串是 $a$ 。这个机器如图1c所示。

第四，证明如果 $A$ 和 $B$ 都是可由有限状态自动机识别的语言，则 $AB$ 和 $A \cup B$ 也可由有限状态自动机识别。设 $A$ 是由 $M_A = (S_A, I, f_A, s_A, F_A)$ 识别的， $B$ 是由 $M_B = (S_B, I, f_B, s_B, F_B)$ 识别的。

先来构造识别 $A$ 与 $B$ 的连接 $AB$ 的有限状态自动机 $M_{AB} = (S_{AB}, I, f_{AB}, s_{AB}, F_{AB})$ ，它是由识别 $A$ 和 $B$ 的两个机器串联而成的，这样 $A$ 中的字符串将这个组合机器从 $M_A$ 的初始状态 $s_A$ 变为 $M_B$ 的初始状态 $s_B$ 。 $B$ 中的字符串应该将这个组合机器从 $s_B$ 变为此组合机器的一个终结状态。因此我们进行如下构造。令 $S_{AB}$ 是 $S_A \cup S_B$ [注意我们假设 $S_A$ 和 $S_B$ 不相交]。初始状态 $s_{AB}$ 就是 $s_A$ ；终结状态集 $F_{AB}$ 或者是 $M_B$ 的终结状态集，或者当且仅当 $\lambda \in A \cap B$ 时还包括 $s_{AB}$ 。 $M_{AB}$ 中的转移除了包括 $M_A$ 和 $M_B$ 中的全部转移之外，还有一些新的转移。对于 $M_A$ 中每个导致终结状态的转移，在 $M_{AB}$ 中增加一个在同一个输入上从同一个状态到 $s_B$ 的转移。这样， $A$ 中的字符串就将 $M_{AB}$ 从 $s_{AB}$ 变为 $s_B$ ，然后 $B$ 中的字符串将 $s_B$ 变为 $M_{AB}$ 的一个终结状态。而且，对于每个从 $s_B$ 出发的转移，还在 $M_{AB}$ 中增加一个从 $s_{AB}$ 到同一个状态的转移。图2a包括了这个构造的所有说明。

现在构造识别 $A \cup B$ 的机器 $M_{A \cup B} = \{S_{A \cup B}, I, f_{A \cup B}, s_{A \cup B}, F_{A \cup B}\}$ 。这个自动机是将 $M_A$ 和 $M_B$ 并行组合起来的，它使用一个新的初始状态，此初始状态具有 $s_A$ 和 $s_B$ 所具有的转移。令 $S_{A \cup B} = S_A \cup S_B \cup \{s_{A \cup B}\}$ ，其中， $s_{A \cup B}$ 是 $M_{A \cup B}$ 的新初始状态。当 $\lambda \in A \cup B$ 时，令终结状态集 $F_{A \cup B}$ 是 $F_A \cup F_B \cup \{s_{A \cup B}\}$ ，否则为 $F_A \cup F_B$ 。 $M_{A \cup B}$ 中的转移包括了 $M_A$ 和 $M_B$ 中的所有转移，而且对输入 $i$ 从 $s_A$ 到状态 $s$ 的每个转移，包括一个对输入 $i$ 从 $s_{A \cup B}$ 到状态 $s$ 的转移；对输入 $i$ 从 $s_B$ 到状态 $s$ 的每个转移，包括一个在输入 $i$ 从 $s_{A \cup B}$ 到状态 $s$ 的转移。这样，在这个新机器中， $A$ 中的字符串将从 $s_{A \cup B}$ 导致一个终结状态， $B$ 中的字符串也将从 $s_{A \cup B}$ 导致一个终结状态。图2b说明了 $M_{A \cup B}$ 的构造。

最后，构造识别 $A^{*}$ 的机器 $M_{A^{*}} = (S_{A^{*}}, I, f_{A^{*}}, s_{A^{*}}, F_{A^{*}})$ ，其中 $A^{*}$ 是 $A$ 的克莱因闭包。令 $S_{A^{*}}$ 包含 $S_{A}$ 中所有状态和一个附加状态 $s_{A^{*}}$ ，它是这个新机器的初始状态。终结状态集 $F_{A^{*}}$ 包含了 $F_{A}$ 中所有状态和初始状态 $s_{A^{*}}$ ，因为必须要识别 $\lambda$ 。为了识别 $A$ 中任意多个字符串的连接，我们包括 $M_{A}$ 中的所有转移，以及与从 $s_{A}$ 出发的转移相匹配的从 $s_{A^{*}}$ 出发的转移、与从 $s_{A}$ 出发的转移相匹配的从每个终结状态出发的转移。有了这个转移集，对于由 $A$ 中的一些字符串连接而成的字符串，当 $A$ 中的第一个字符串读完时，它将 $s_{A}$ 变为一个终结状态，当 $A$ 中的第二个字符串读完时，它又回到一个终结状态，等等。图2c说明了我们刚才的构造。

![](67db16c3a36aaac04a86130cc2a843589aa86f93d79c77c7f5c306be6beb4029.jpg)

![](f3c3f9da52d584000a8c39b1d2ad04c0283b22165dd5243d520e40262ef230bf.jpg)

![](f19a4a6aa2246633d3dcaf5b76efcf080afaed56e94bc3c2cd6377f1da36e00f.jpg)  
图2构造识别连接、并以及克莱因闭包的自动机

用以上描述的过程，可以对任意正则集合构造一个非确定性的有限状态自动机。下面用例3来说明这一点。

例3构造一个非确定性的有限状态自动机来识别正则集合 $1^{*}\cup 01$

解首先，构造一个机器来识别 $1^{*}$ 。为此，先构造一个识别1的机器，再使用在定理1的证明中描述的构造 $M_{A^*}$ 的方法。其次，构造识别01的机器。先分别构造识别0和1的机器，再使用在定理1的证明中描述的构造 $M_{AB}$ 的方法。最后，用在定理1的证明中描述的构造 $M_{A\cup B}$ 的文法，构造识别 $1^{*}\bigcup 01$ 的机器。所构造的有限状态自动机如图3所示。上述各个机器中的状态被标以不同的下标，即使对从以前机器中继承下来的状态也是如此。注意，这样构造的机器并不是识别 $1^{*}\bigcup 01$ 的最简单的机器。图3b是识别同一个集合但简单得多的机器。

![](820bfff285b447c1d0907ef564187b5977f75d83071d3932e3acf871c34a0496.jpg)  
图3识别 $1^{*}\bigcup 01$ 的非确定性的有限状态自动机

# 13.4.3 正则集合和正则文法

在13.1节中介绍了短语结构文法，还定义了各种不同类型的文法。特别是，定义了正则文法（或3型文法），这是一个形如 $G = (V, T, S, P)$ 的文法，文法的每个产生式的形式是 $S \rightarrow \lambda$ ， $A \rightarrow a$ 或 $A \rightarrow aB$ ，其中 $a$ 是终结符， $A$ 和 $B$ 是非终结符。正如名称所暗示的，正则文法

和正则集合之间具有紧密的联系。

定理2 一个集合可以由正则文法生成，当且仅当它是一个正则集合。

证明 首先证明正则文法生成的集合是正则集合。设 $G = (V, T, S, P)$ 是一个正则文法，其生成的集合是 $L(G)$ 。为了证明 $L(G)$ 是正则的，我们构造一个非确定性的有限状态自动机 $M = (S, I, f, s_0, F)$ 来识别 $L(G)$ 。对 $G$ 的每个非终结符 $A$ ，状态集 $S$ 都包含一个相应的状态 $s_A$ ， $S$ 还包含一个终结状态状态 $s_F$ 。初始状态 $s_0$ 是从起始符号 $S$ 构造的。 $M$ 的转移是根据 $G$ 的产生式按以下方式构造的：如果 $A \rightarrow a$ 是一个产生式，则包括一个对输入 $a$ 从 $s_A$ 到 $s_F$ 的转移；如果 $A \rightarrow aB$ 是一个产生式，则包括一个在输入 $a$ 上从 $s_A$ 到 $s_B$ 的转移。终结状态集包括 $s_F$ ，如果 $S \rightarrow \lambda$ 是 $G$ 中的产生式，则还要包括 $s_0$ 。不难证明， $M$ 识别的语言与文法 $G$ 生成的语言相等，即 $L(M) = L(G)$ 。这只要确定导致终结状态的词即可。详细证明留作练习。

在给出反方向的证明之前，先说明怎么构造一个非确定性的机器，它能识别由一个正则文法产生的集合。

例4构造一个非确定性的有限状态自动机，使之识别正则文法 $G = (V,T,S,P)$ 生成的语言，其中 $V = \{0,1,A,S\}$ ， $T = \{0,1\}$ ， $P$ 中的产生式为 $S\to 1A$ ， $S\to 0$ ， $S\to \lambda$ ， $A\to 0A$ $A\to 1A$ 和 $A\to 1$ 。

解图4是识别 $L(G)$ 的非确定性的有限状态自动机的状态图。这个自动机是根据上面证明描述的过程构造的。在这个自动机中， $s_0$ 是对应 $S$ 的状态， $s_1$ 是对应 $A$ 的状态， $s_2$ 是终结状态。

现在来完成定理2的证明。

证明 现在证明，如果一个集合是正则的，则存在一个生成它的正则文法。设 $M$ 是识别这个集合的一个有限状态机且具有性质： $M$ 的初始状态 $s_0$ 对任何转移都不是下一个状态。（可以根据练习20找到这样机器。）文法 $G = (V, T, S, P)$ 的定义为： $G$ 的符号集 $V$ 是这样形成的，对 $S$ 的每个状态和 $I$ 中的每个输入符号，指派 $V$ 中一个符号。 $G$ 的终结符集 $T$ 是集合 $I$ 。起始符号 $S$ 是根据初始状态 $s_0$ 构造的符号。 $G$ 的产生式集 $P$ 是根据 $M$ 中的转移构造的。特别地，如果对输入 $a$ 状态 $s$ 变为一个终结状态，则 $P$ 中就包括产生式 $A_s \rightarrow a$ ，其中 $A_s$ 是根据状态 $s$ 构造的非终结符。如果对输入 $a$ 状态 $s$ 变为状态 $t$ ，则 $P$ 中就包括产生式 $A_s \rightarrow aA_t$ 。 $P$ 中包括产生式 $S \rightarrow \lambda$ ，当且仅当 $\lambda \in L(M)$ 。因为 $G$ 的产生式对应于 $M$ 的转移，且导致终结符的产生式对应于导致终结状态的转移，因此不难证明 $L(G) = L(M)$ 。详细证明留作练习。

例5说明怎么根据自动机来构造文法，使得该文法生成的语言就是这个自动机识别的语言。

例5求一个正则文法，使之生成的集合是图5表示的有限状态自动机所识别的正则集合。

解 生成该自动机所识别集合的文法为 $G = (V, T, S, P)$ ，其中 $V = \{S, A, B, 0, 1\}$ ，其符号 $S, A, B$ 分别对应于状态 $s_0, s_1$ 和 $s_2$ ， $T = \{0, 1\}$ ， $S$ 是起始符号，产生式为 $S \rightarrow 0A$ ， $S \rightarrow 1B$ ， $S \rightarrow 1$ ， $S \rightarrow \lambda$ ， $A \rightarrow 0A$ ， $A \rightarrow 1B$ ， $A \rightarrow 1$ ， $B \rightarrow 0A$ ， $B \rightarrow 1B$ 和 $B \rightarrow 1$ 。

![](4583d22bff081eba52f3be47200197413a662c6a8bb5b04febef4d51e498940e.jpg)  
图4识别 $L(G)$ 的非确定性的有限状态自动机

![](32822426ae8d0ba5c046945bd30b1f7e2631715e9679143ec3556e90f28d8981.jpg)  
图5 一个有限状态自动机

# 13.4.4 一个不能由有限状态自动机识别的集合

我们知道，一个集合能够由有限状态自动机识别当且仅当它是正则的。现在通过给出这样一个集合来证明存在不是正则的集合。证明这个集合不是正则的技术是一个重要方法，可以用来证明某类集合不是正则的。

例6 集合 $\{0^n 1^n | n = 0, 1, 2, \dots\}$ 是由所有先是一列0，后跟同样个数的1的字符串构成的。证明这个集合不是正则的。

解 假如这个集合是正则的，则存在一个有限状态自动机 $M = (S, I, f, s_0, F)$ 识别它。设 $N$ 是这个机器中状态的个数，即 $N = |S|$ 。因为 $M$ 能识别所有这样构成的字符串：先是一列0，后跟同样个数的1，所以它必定能识别 $0^N 1^N$ 。设 $s_0, s_1, s_2, \dots, s_{2N}$ 是如下得到的状态序列：以 $s_0$ 开始，以 $0^N 1^N$ 中的符号作为输入，且满足 $s_1 = f(s_0, 0), s_2 = f(s_1, 0), \dots, s_N = f(s_{N-1}, 0), s_{N+1} = f(s_N, 1), \dots, s_{2N} = f(s_{2N-1}, 1)$ 。注意 $s_{2N}$ 是一个终结状态。

因为只有 $N$ 个状态，所以根据鸽巢原理，在 $s_0, \dots, s_N$ 这头 $N + 1$ 个状态中，至少有两个是相同的。假设 $s_i$ 、 $s_j$ 是这样两个相同的状态（ $0 \leqslant i < j \leqslant N$ ），则这表示 $f(s_i, 0^t) = s_j$ ，其中 $t = j - i$ 。由此可知， $t$ 次使用输入0后，可以得到一个从 $s_i$ 回到它自己的循环，如状态图6所示。

![](76ebcf9bc70bcb9c05b2f20b24f6973207c949d46261ec08b0bf1d8eba18f7c9.jpg)  
图6 $0^{N}1^{N}$ 所产生的通路

现在考虑输入字符串 $0^{N}0^{t}1^{N} = 0^{N + t}1^{N}$ 。此字符串的前半部分比后半部分多了 $t$ 个连续的0。因为这个字符串不具有形式 $0^{n}1^{n}$ （因为其中0的个数比1的个数多），所以不能被 $M$ 识别，因此 $f(s_{0},0^{N + t}1^{N})$ 也就不是终结状态。但当用 $0^{N + t}1^{N}$ 作为输入时，得到的结束状态与以前一样，即 $s_{2N}$ 。其理由是此字符串中额外的 $t$ 个0只是领着我们沿着那个循环多走一次，并将 $s_i$ 再带回它自己（如图6所示）。然后，此字符串的剩余部分所导致的状态与以前完全相同。这个矛盾证明了 $\{0^n 1^n |n = 1,2,\dots \}$ 不是正则的。

# 13.4.5 一些更强大的机器

很多计算都不能用有限状态自动机来完成，这类机器的局限性是它们只有有限的存储，因而限制了它们识别那些不是正则的语言，如 $\{0^{n}1^{n}\mid n = 0,1,2,\dots \}$ 。因为一个集合是正则的，当且仅当它是一个正则文法生成的语言，例6证明了没有正则文法能够生成集合 $\{0^n 1^n\mid n = 0$ $1,2,\dots \}$ 。但是，有一个上下文无关文法能够生成这个集合，此文法就是13.1节例5所给出的文法。

由于有限状态自动机的局限性，所以有必要使用其他更加强大的计算模型。下推自动机就是这样一个模型。下推自动机除了包括有限状态自动机的所有部件外，还有一个栈，此栈能够提供无限的存储。可以将符号放在栈顶，也可从栈顶弹出符号。下推自动机以两种方式识别集合。其一，如果一个集合是所有这样的字符串构成的，当它们作为输入时产生空栈，则此集合

能被识别。其二，如果一个集合是所有这样的字符串构成的，当它们作为输入时导致终结状态，则此集合能被识别。可以证明，一个集合能被下推自动机识别当且仅当它是一个上下文无关文法生成的语言。

但是，还有一些集合不能表示成上下文无关文法生成的语言，如集合 $\{0^n 1^n 2^n \mid n = 0, 1, 2, \dots\}$ 。我们将指出为什么这个集合不能被下推自动机识别，但不给出证明，因为还没有介绍所需的方法。（但本章的补充练习28给出了一个证明方法。）可以使用栈来查看一个字符串是否以一列0开始，后再跟相同个数的1，做法是对每个0（只要读到多个0时）在栈上放一个符号，对每个1（只要读到的0后面多个1时）从栈中弹出一个这样符号。但这个过程一旦完成，栈就空了，也就无法判断此字符串中是否还有与0个数相同的一列2。

还有一种比下推自动机更强大的机器，叫作线性有界自动机，它能识别如 $\{0^{n}1^{n}2^{n}\mid n = 0$ $1,2,\dots \}$ 的集合。特别地，线性有界自动机能够识别上下文有关文法。但是，这些机器不能识别短语结构文法生成的所有语言。为避免特殊类型机器的局限性，我们使用一种称为图灵机的模型，这种机器是以英国数学家图灵的名字命名的。图灵机除了包括有限状态自动机的所有部件外，还有一个带，其两端都是无限的。图灵机具有在带上读和写的能力，还能沿着带子左右移动。图灵机能够识别短语结构文法生成的所有语言。另外，它还能用来为在计算机器上执行的所有计算建模。由于这个能力，图灵机在理论计算机科学中得到了广泛的研究。13.5节将简要介绍图灵机。

# 练习

1. 用文字描述下列每个正则集合中的字符串。

a) $1^{*}0$

b) $\mathbf{1}^{*}\mathbf{00}^{*}$

c)111U001

d) $(1\bigcup 00)^{*}$

e) $(\mathbf{00}^{\star}\mathbf{1})^{\star}$

f) $(\mathbf{0}\bigcup \mathbf{1})(\mathbf{0}\bigcup \mathbf{1})^{*}\mathbf{00}$

2. 用文字描述下列每个正则集合中的字符串。

a)001\*

b) $(01)^{*}$

c)01U001\*

d)0(11U0)*

e) $(101^{*})^{*}$

f) $((\mathbf{0}^{*}\bigcup \mathbf{1})\mathbf{11}$

Links

![](60f99305426cf067c477f4ab01826b7af3c46bb279f6deb24ce005c0b86e2f01.jpg)  
Science Source

艾伦·莫思森·图灵（Alan Mathison Turing，1912—1954）图灵的出生并不寻常。他是父亲在印度民政部供职时孕于母腹，但他出生在伦敦。他在孩提时代就对化学和机械着迷，并做过大量化学实验。图灵曾就读于英国的谢伯恩寄宿学校。1931年，他获得了剑桥大学国王学院的奖学金。在毕业论文中，他重新发现了统计学中的一个著名定理——中心极限定理。在完成毕业论文后，他被选为该学院的研究员。1935年，他对数理逻辑中的判定问题着了迷。这是由伟大的德国数学家希尔伯特提出的一个问题，即是否有一个能用于判断任何命题是否为真的一般方法。图灵喜欢跑步（后来，跑步成为他的一项业余爱好，并参加了比赛）。一天，在他跑完

步休息的时候，他发现了解决判定问题的关键。在他的解决方案中，他发明了现今称为图灵机的东西，并用它作为计算机器的最初模型。利用这个机器，他发现了一个不能用一般方法判定的问题，这也被他称为可计算数的问题。

从1936年至1938年，图灵在普林斯顿大学访问，期间与丘奇(Alonzo Church)一起工作。丘奇也解决了希尔伯特的判定问题。1939年，图灵回到了国王学院。但在第二次世界大战期间，他加入了英国外交部，从事破译德国密码的工作。他对机械的德国密码机Enigma的破解为赢得这场战争发挥了不可替代的作用。

第二次世界大战后，图灵从事早期计算机的研发工作。他对机器的思考能力产生了浓厚的兴趣。他认为如果一台计算机在对问题的书面答复中与人没有区别，则应该认为它是具备“思考”能力的。他对生物学也很感兴趣，曾经写过关于有机体形式的形成和发展的书。1954年，图灵服氰化物自杀，没有留下遗言做明确解释。也许，涉及同性恋关系的法律困扰以及法院强迫他进行荷尔蒙治疗以减少他的性冲动的行为，是促使他自杀的原因。

3. 判断 0101 是否属于下列正则集合。

a)01\*0

b)0(11)\* (01)\*

c) $\mathbf{0}(10)^{*}1^{*}$

d) $0^{*}10(0\bigcup 1)$

e) $(01)^{*}(11)^{*}$

f) $\mathbf{0}^{*}$ (10U11）\*

g)0\*10\*11

h)01(01U0)1\*

4. 判断1011是否属于下列正则集合。

a) $10^{*}1^{*}$

b) $0^{*}(10\bigcup 11)^{*}$

c)1(01)\*1\*

d) $1^{*}\mathbf{01}(\mathbf{0}\bigcup \mathbf{1})$

e) $(10)^{*}(11)^{*}$

f)1(00)\* (11)\*

g) (10)* 1011

h) $(1\bigcup 00)(01\bigcup 01)^{*}$

5. 用正则表达式表达下列集合。

a) 包含字符串 0、11、010 的集合。  
b)3个0后面跟两个或两个以上0形成的字符串的集合。  
c)字符串的长度为奇数的集合。  
d)只包含一个1的字符串的集合。  
e)以1结束，并且并不包含000形成的字符串的集合。

6. 用正则表达式表达下列集合。

a)集合中所有字符串的长度是0、1、2。  
b) 集合中的字符串是由两个 0，后跟 0 个或多个 1，并且以 0 作为结束的字符串构成。  
c) 集合中的字符串每遇到一个 1，后跟两个 0。  
d) 集合中的字符串以 00 作为结束，并且不包含 11。  
e) 集合中的字符串包含偶数个 1。

7. 用正则表达式表达下列每个集合。

a)一个或更多的0后面跟一个1形成的字符串的集合。  
b)两个或两个以上符号后面跟3个或3个以上0形成的字符串的集合。  
c)一个0前没有1或一个1前没有0的字符串的集合。  
d)集合包含这样的字符串：先是个数与 $2\mathrm{mod}3$ 相等的一字符串1，后面是偶数个0。

8.构造确定性的有限状态自动机来识别下列包含在 $I^{*}$ 中的集合（其中 $I$ 是一个字母表）。

a)0

b) $\{\lambda\}$

c) $\{a\}$ , 其中 $a \in I$

9.构造非确定性的有限状态自动机来识别练习8中的每个集合。

10. 求识别下列集合的非确定性的有限状态自动机。

a) $\{\lambda, 0\}$

b) $\{0, 11\}$

c）{0，11，000}

* 11. 证明：若 $A$ 是一个正则集合，则 $A$ 中字符串的逆串构成的集合 $A^R$ 也是正则的。

12. 用克莱因定理的证明中描述的构造方法，求识别下列集合的非确定性的有限状态自动机。

a)01\*

b) $(\mathbf{0} \cup \mathbf{1}) \mathbf{1}^{*}$

c)00 $(1^{*}\bigcup 10)$

13. 用克莱因定理的证明中描述的构造方法，求识别下列集合的非确定性的有限状态自动机。

a) $0^{*}1^{*}$

b) $(\mathbf{0}\bigcup \mathbf{11})^{*}$

c) $\mathbf{01}^*\bigcup \mathbf{00}^*\mathbf{1}$

14.构造非确定性的有限状态自动机，用它识别正则文法 $G = (V,T,S,P)$ 生成的语言，其中 $V = \{0$ $1,S,A,B\}$ ， $T = \{0,1\}$ ， $S$ 是起始符号，产生式集合为

a) $S \rightarrow 0A$ ， $S \rightarrow 1B$ ， $A \rightarrow 0$ ， $B \rightarrow 0$

b) $S \rightarrow 1A$ ， $S \rightarrow 0$ ， $S \rightarrow \lambda$ ， $A \rightarrow 0B$ ， $B \rightarrow 1B$ ， $B \rightarrow 1$

c) $S \rightarrow 1B$ ， $S \rightarrow 0$ ， $A \rightarrow 1A$ ， $A \rightarrow 0B$ ， $A \rightarrow 1$ ， $A \rightarrow 0$ ， $B \rightarrow 1$

在练习 $15\sim 17$ 中，构造正则文法 $G = (V,T,S,P)$ ，使之生成的语言是所给的有限状态机识别的语言。

15.

![](6065c5b96a764018899b4e6f8f6331006202673b04616145b997414720d20092.jpg)

16.

![](f46e1c6ddae88849d612fd580a6f9613cc94d94d42e2ab91a89f64dfc4d1b78a.jpg)

17.

![](f41465bb010d54b3e93b7b8399a660f0cd6df53deb76b6ea39a09e39e0544844.jpg)

Links

18. 在定理2的证明中，从正则文法构造了一个有限状态自动机。证明：此自动机识别这个文法生成的集合。  
19. 在定理2的证明中，从一个有限状态自动机构造了一个正则文法。证明：此文法生成这个自动机识别的集合。  
20. 证明：每个非确定性的有限状态自动机等价于另一个这样的非确定性的有限状态自动机，它的初始状态永不会被再次访问。  
*21. 设 $M = (S, I, f, s_0, F)$ 是一个确定性的有限状态自动机。证明： $M$ 识别的语言 $L(M)$ 是无限的当且仅当存在一个能被 $M$ 识别的词 $x$ 满足 $l(x) \geqslant |S|$ 。  
22. 用来证明某个集合不是正则的一个重要技术是泵引理。泵引理表述为：如果 $M = (S, I, f, s_0, F)$ 是一个确定性的有限状态自动机， $x$ 是 $M$ 识别的语言 $L(M)$ 中的一个串， $l(x) \geqslant |S|$ ，则存在 $I^*$ 中的字符串 $u, v$ 和 $w$ ，使得 $x = uvw$ ， $l(uv) \leqslant |S|$ ， $l(v) \geqslant 1$ ，且 $uv^i w \in L(M) (i = 0, 1, 2, \dots)$ 。证明泵引理。[提示：使用例5中的思想。]  
* 23. 使用练习22中的泵引理证明：集合 $\{0^{2n}1^n \mid n = 0, 1, 2, \dots\}$ 不是正则的。  
* 24. 使用练习22中的泵引理证明：集合 $\{1^{n^2} \mid n = 0, 1, 2, \dots\}$ 不是正则的。  
* 25. 使用练习22中的泵引理证明： $\{0,1\}$ 上所有回文构成的集合不是正则的。[提示：考察形如 $0^{N}10^{N}$ 的串。]  
**26. 证明：被有限状态自动机识别的集合是正则的。（这是克莱因定理的充分性部分。）

假设 $L$ 是 $I^{*}$ 的子集，其中 $I$ 表示非空符号集合。如果 $x \in I^{*}$ ，则令 $L / x = \{z \in I^{*} \mid xz \in L\}$ 。如果 $L / x \neq L / y$ ，则说对于 $x \in I^{*}$ 和 $y \in I^{*}$ ， $x$ 和 $y$ 关于 $L$ 是可区分的。对于字符串 $z$ ，如果 $xz \in L$ ，但 $yz \notin L$ ，或者 $xz \notin L$ ，但 $yz \in L$ ，则称字符串 $z$ 关于 $L$ 用来区分 $x$ 和 $y$ 。当 $L / x = L / y$ ，我们说 $x$ 和 $y$ 关于 $L$ 是不可区分的。

27. 令 $L$ 表示所有以01作为结束的比特串构成的集合。证明11和10关于 $L$ 是可区分的，1和11关于 $L$ 是不可区分的。  
28. 假设 $M = (S, I, f, s_0, F)$ 是确定性的有限状态自动机。证明：如果 $x$ 和 $y$ 是集合 $I^*$ 中的两个关于 $L(M)$ 可区分的字符串，那么 $f(s_0, x) \neq f(s_0, y)$ 。  
* 29. 假设 $L$ 是 $I^{*}$ 的子集，并且对于某个正整数 $n$ ，在集合 $I^{*}$ 中有 $n$ 个字符串使它们关于 $L$ 互相可区分。证明：每个能识别 $L$ 的确定性的有限状态自动机至少具有 $n$ 个状态。  
*30. 令 $L_{n}$ 表示比特串集合，该集合中的字符串至少具有 $n$ 位，并且每个字符串从最后数的第 $n$ 位是 0。使用练习 29 的思想来证明能识别 $L_{n}$ 的确定性的有限状态自动机至少具有 $2^{n}$ 个状态。  
* 31. 使用练习29的思想来证明由回文形式字符串构成的集合是非正则的。

# 13.5 图灵机

# 13.5.1 引言

Links

本章前面部分研究的有限状态自动机不能作为计算的通用模型，因为它们有其自身的局限性。例如，有限状态自动机虽然能识别正则集合，但不能识别许多很容易描述的集合，如 $\{0^n 1^n | n \geqslant 0\}$ ，计算机使用存储才能识别这些集合。可以用有限状态自动机来计算一些相对简单的函数（如两个数的和），但不能用它们来计算计算机所计算的函数（如两个数的积）。为了克服这些不足，我们使用一种更强大的机器，称为图灵机，它是以著名数学家和计算机科学家图

灵（Alan Turing)的名字命名的，他在20世纪30年代发明了这种机器。

图灵机主要由一个控制器和一个纸带组成，控制器在任何时候都处于有限多个不同状态中的某个状态，纸带被分成许多方格，且两端都是无限的。当图灵机的控制器沿着纸带来回移动时，它能够在带上读和写，并根据所读的纸带符号改变状态。图灵机比有限状态自动机更强大，因为它有存储能力，而有限状态自动机却没有。我们将说明怎么用图灵机来识别集合，包括识别有限状态自动机不能识别的集合，还将说明怎么用图灵机来计算函数。图灵机是计算的最通用模型，本质上，它能做计算机能做的任何事情。注意图灵机比带有有限存储能力的真实计算机更强大。

# 13.5.2 图灵机的定义

下面给出图灵机的形式化定义。之后将根据它的控制头的动作来解释这个形式化定义，控制头的动作包括读或写纸带上的符号以及沿着纸带左右移动。

定义1 图灵机 $T = (S, I, f, s_0)$ 由下列各部分组成：有限状态集 $S$ ，包含空白符 $B$ 的字母表 $I$ ，从 $S \times I$ 到 $S \times I \times \{R, L\}$ 的部分函数 $f$ ，及初始状态 $s_0$ 。

在2.3节中，部分函数只对定义域中的某些元素有定义。这意味着上述部分函数 $f$ 对于某些（状态，符号）对没有定义。但对于有定义的对，只有唯一一个三元组（状态，符号，方向）与之对应。称与图灵机中定义的部分函数相对应的5元组是该机器的转移规则。

为了用机器的观点来解释这个定义，考察控制器和纸带，如图1所示，纸带被分成小方格，且两端都是无限的，在任何时刻其上都只有有限多个非空白符。图灵机运行的每一步动作依赖于部分函数对当前状态和纸带符号的值。

![](d18f52ac7d9c39b0b8ec1544a83823590caf3011d63cdeed2b65448e13bed6ab.jpg)  
图1 图灵机的表示

在每一步，控制器读当前纸带符号 $x$ 。如果控制器处于状态 $s$ ，且部分函数 $f$ 在 $(s, x)$ 处由 $f(s, x) = (s', x', d)$ 定义，则控制器：

1)进入状态 $s^{\prime}$   
2)在当前方格中擦掉 $x$ ，并写上符号 $x^{\prime}$   
3)如果 $d = R$ ，向右移动一个方格；如果 $d = L$ ，向左移动一个方格。

我们将这一步写成五元组 $(s, x, s', x', d)$ 。如果部分函数 $f$ 在 $(s, x)$ 处没有定义，则图灵机 $T$ 就停机。

定义一个图灵机的常用方法是指明形如 $(s, x, s', x', d)$ 的五元组构成的一个集合。当使用这个定义时，就隐式定义了状态集和输入字母表。

在运行开始的时候，总假设图灵机处于初始状态 $s_0$ ，且处于纸带上最左边的非空白符上。如果带上都是空白符，则控制头可以处于任何方格上。控制头所在的最左边的非空白符位置称为该机器的初始位置。

例1 说明了图灵机是怎么运行的。

例1下列7个五元组定义一个图灵机 $T$ ： $(s_0, 0, s_0, 0, R)$ ， $(s_0, 1, s_1, 1, R)$ ， $(s_0, B, s_3, B, R)$ ， $(s_1, 0, s_0, 0, R)$ ， $(s_1, 1, s_2, 0, L)$ ， $(s_1, B, s_3, B, R)$ ， $(s_2, 1, s_3, 0, R)$ 。当 $T$ 在图2a所示的纸带上运行时，最后的纸带是什么？

![](bf452a77cd0051ba282c232b974d9d6e3f0fa49043fb2d6ba4c0ec48e99724c0.jpg)

![](9b52c77614a5d94c2505db2bd51461878d7c9ea4a2387ae7e3b9a9a98fe2cffa.jpg)

![](c4991e4359ec20ad5eb2b0f54cad6e77c5d587be75bf8c92cc0e2850d520f1fb.jpg)

![](342a1bd4a5b3bff61caedbc2aa927ff8f1baa4b9da99087f25beb58968e5ad79.jpg)

![](fc97a3176f8ea1f0817744a8b6cb82edda5fcea490d36f6bb395119d9e99f4f2.jpg)

![](7ea397a51f3cfd5cd6db0d4757af1f0d215a503f8bd3a8f7d5f95a84832c3c51.jpg)

![](2da7dcf98e0a1724fc67a87a95ec26d0a973f2525b0bc48856be039dad139574.jpg)  
图2 图灵机 $T$ 在图1所示纸带上运行的步骤

解 在开始运行时， $T$ 处于状态 $s_0$ ，且在纸带上最左边的非空白符上。第一步，根据五元组 $(s_0, 0, s_0, 0, R)$ ，读最左边的非空白方格中的0，保持状态 $s_0$ ，在此方格中写0，向右移动一个方格。第二步，根据五元组 $(s_0, 1, s_1, 1, R)$ ，读当前方格中的1，进入状态 $s_1$ ，在这方格中写1，向右移动一个方格。第三步，根据五元组 $(s_1, 0, s_0, 0, R)$ ，读当前方格中的0，进入状态 $s_0$ ，在该方格中写0，向右移动一个方格。第四步，根据五元组 $(s_0, 1, s_1, 1, R)$ ，读当前方格中的1，进入状态 $s_1$ ，在该方格中写1，向右移动一个方格。第五步，根据五元组 $(s_1, 1, s_2, 0, L)$ ，读当前方格中的1，进入状态 $s_2$ ，在该方格中写0，向左移动一个方格。第六步，根据五元组 $(s_2, 1, s_3, 0, R)$ ，读当前方格中的1，进入状态 $s_3$ ，在该方格中写0，向右移动一个方格。最后，机器在第七步停机，因为在这个机器的描述中，没有五元组是以

$(s_3,0)$ 开头的。所有这些步骤如图2所示。

注意， $T$ 将纸带上第一对连续的1变为0后停机。

# 13.5.3 用图灵机识别集合

可以用图灵机来识别集合。为此，如下定义终结状态的概念。图灵机 $T$ 的终结状态是这样的状态：在描述 $T$ 的五元组中，此状态不是任何五元组的第一个状态（例如，例1中的状态 $s_3$ ）。

现在定义图灵机识别一个字符串的含义是什么。给定一个字符串，我们在连续的方格中写此字符串中连续的符号。

定义2 设 $V$ 是字母表 $I$ 的一个子集。图灵机 $T = (S, I, f, s_0)$ 识别 $V^*$ 中的字符串 $x$ 当且仅当若将 $x$ 写在纸带上， $T$ 从初始位置开始运行，则 $T$ 能在一个终结状态停机。称 $T$ 能识别 $V^*$ 的子集 $A$ ，如果 $x$ 能被 $T$ 识别当且仅当 $x$ 属于 $A$ 。

注意，为了识别 $V^{*}$ 的子集 $A$ ，我们可以使用不在 $V$ 中的符号。也就是说，输入字母表 $I$ 也许包含不是 $V$ 中的符号。这些额外的符号常用来当作标记(见例3)。

什么情况下图灵机 $T$ 不识别 $V^{*}$ 中的字符串 $x$ 呢？答案是，当 $x$ 的符号放在 $T$ 的纸带上的连续方格中， $T$ 从初始位置开始运行时，若 $T$ 不停机，或者虽然停机，但不在终结状态停机，则 $T$ 不识别 $x$ 。（读者应该明白，这是定义图灵机如何识别集合的许多方法中的一种。）

例2说明了这个概念。

例2 求一个图灵机，使之能识别第二位是1的比特串构成的集合，即正则集合 $(0\cup 1)1(0\cup 1)^{*}$ 。

解 我们想要如下的图灵机，它从最左边的非空白带方格开始运行，然后向右移动，同时判断第二个符号是否为1。若第二个符号是1，则机器应该进入终结状态；如果第二个不是1，则机器不能停机，或者在一个非终结状态下停机。

为了构造这样的图灵机，应该包括五元组 $(s_0, 0, s_1, 0, R)$ 和 $(s_0, 1, s_1, 1, R)$ 来读第一个符号，并进入状态 $s_1$ 。下一步，添加五元组 $(s_1, 0, s_2, 0, R)$ 和 $(s_1, 1, s_3, 1, R)$ 来读第二个符号，当这个符号是0时，进入状态 $s_2$ ；当这个符号是1时，进入状态 $s_3$ 。我们不希望使第二位是0的字符串也被识别，所以 $s_2$ 不可能是终结状态。我们希望 $s_3$ 是终结状态。所以我们要加入五元组 $(s_2, 0, s_2, 0, R)$ 。因为我们不想识别空串和只有一位的字符串，所以还加入五元组 $(s_0, B, s_2, 0, R)$ 和 $(s_1, B, s_2, 0, R)$ 。

由上述7个五元组组成的图灵机 $T$ 在终结状态 $s_3$ 终止当且仅当此比特串至少有2位，并且第二位是1。如果此比特串少于两位，或者其第二位不是1，则机器将在非终结状态 $s_2$ 终止。

给定一个正则集合，可以构造一个总是向右移动的图灵机来识别它（如例2）。为了构造这样的图灵机，先构造一个识别此集合的有限状态自动机，然后再用此有限状态自动机的转移函数构造一个图灵机，使之总向右移动。

下面说明怎么构造图灵机来识别非正则集合。

例3 求识别集合 $\{0^n 1^n | n \geqslant 1\}$ 的图灵机。

解为了构造这样图灵机，使用辅助带符号 $M$ 作为标记。令 $V = \{0,1\}$ ， $I = \{0,1,M\}$ 我们希望只识别 $V^{*}$ 中的字符串。我们还有一个终结状态 $s_6$ 。图灵机依次用 $M$ 替换字符串中最左边的0，并用 $M$ 替换字符串中最右边的1，这样在纸带上左右移动。它能在一个终结状态终止当且仅当这个字符串的构成是一列0后跟一列相同个数的1。

虽然这很容易描述，图灵机也很容易执行，但我们想要使用的图灵机本身却有点复杂。标记 $M$ 是用来跟踪已经检查过的最左边和最右边的符号。所用的五元组是： $(s_0, 0, s_1, M, R)$ ， $(s_1, 0, s_1, 0, R)$ ， $(s_1, 1, s_1, 1, R)$ ， $(s_1, M, s_2, M, L)$ ， $(s_1, B, s_2, B, L)$

$(s_2, 1, s_3, M, L)$ ， $(s_3, 1, s_3, 1, L)$ ， $(s_3, 0, s_4, 0, L)$ ， $(s_3, M, s_5, M, R)$ ， $(s_4, 0, s_4, 0, L)$ ， $(s_4, M, s_0, M, R)$ ， $(s_5, M, s_6, M, R)$ 。例如，当机器从开始一直运行到停机时，字符串 000111 将依次变成 M00111、M0011M、MM011M、MM01MM、MMM1MM、MMM1MM。注意，仅显示了变化的部分，大多数步骤中比特串没有变化。

解释这个图灵机的动作和它为什么能识别集合 $\{0^n 1^n | n \geqslant 1\}$ 将留给读者作为练习（本节练习13）。

可以证明，一个集合能被图灵机识别当且仅当它是0型文法生成的集合，即短语结构文法生成的集合。这里略去它的证明。

# 13.5.4 用图灵机计算函数

可以将图灵机看作能求部分函数的值的计算机。为了理解这一点，假设给定输入字符串 $x$ 时图灵机 $T$ 能够停机，且停机时，字符串 $y$ 在它的纸带上。因此可以定义 $T(x) = y$ 。 $T$ 的定义域是使 $T$ 能停机的字符串构成的集合。对于输入 $x$ ，若 $T$ 不停机，则 $T(x)$ 没有定义。将图灵机看成计算字符串的函数值的机器是有用的，但怎么用图灵机来计算定义在整数、整数对或整数三元组等上的函数呢？

为了将图灵机看作计算 $k$ 元非负整数集合到非负整数集合的函数（这样的函数称为数论函数）的计算机，需要找到在纸带上表示整数的 $k$ 元组的方法。为此，我们使用整数的一元表示，即将非负整数 $n$ 表示成有 $n + 1$ 个1的字符串。例如，0表示成字符串1、5表示成字符串11111。为了表示 $k$ 元组 $(n_{1}, n_{2}, \dots, n_{k})$ ，我们先写 $n_{1} + 1$ 个1，后面跟一个星号，再跟 $n_{2} + 1$ 个1，再跟一个星号，等等，以 $n_{k} + 1$ 个1结尾。例如，四元组(2，0，1，3)可以表示成字符串 $111 * 1 * 11 * 1111$ 。

现在能将图灵机看成计算一系列数论函数 $T$ ， $T^2$ ，…， $T^k$ ，…。函数 $T^k$ 是根据 $T$ 在 $k$ 元整数组上的动作定义的。 $k$ 元整数组被表示成用星号隔开的一些一元表示。

例4 构造一个图灵机，它将两个非负整数相加。

解需要构造图灵机来计算函数 $f(n_{1},n_{2}) = n_{1} + n_{2}$ 。将对 $(n_{1},n_{2})$ 表示成这样的字符串：先是 $n_1 + 1$ 个1，后面跟一个星号，再跟 $n_2 + 1$ 个1。机器 $T$ 应以这个字符串作为输入，并在纸带上产生 $n_1 + n_2 + 1$ 个1作为输出。实现这个任务的一个方法是，机器从输入字符串最左边的1开始运行，执行去掉这个1的步骤。若 $n_1 = 0$ ，则停机，此时，星号之前已没有1了。在剩下的1中，用最左边的1替换星号，然后停机。下列五元组能做到这一点： $(s_0,1,s_1,B,R)$ 中 $(s_1,\ast ,s_3,B,R),(s_1,1,s_2,B,R),(s_2,1,s_2,1,R),(s_2,\ast ,s_3,1,R)$

不幸的是，即使是相对简单的函数，构造图灵机来计算它也是极为费力的。例如，在许多书中都有计算两个非负整数乘积的图灵机，此图灵机有31个五元组和11个状态。如果构造计算相对简单的函数的图灵机都是挑战性的，那么我们对构造更加复杂函数的图灵机还有什么指望呢？简化这个问题的一个方法是使用多带图灵机（它同时使用不止一个带子），并给出构造复合函数的多带图灵机的方法。可以证明：对任何多带图灵机，存在一个单带图灵机，使得它们能做完全相同的事情。

# 13.5.5 不同类型的图灵机

图灵机的定义有许多变种。可用很多方法来扩展图灵机的能力。例如，可以允许图灵机在一步中左移、右移或根本不动；允许图灵机操作多个带子， $n$ 个带的图灵机可以用 $(2 + 3n)$ 元组来描述；允许带是二维的，即在每一步可以上下左右移动，而不像在一维带上那样只向左或向右移动；还可以允许有多个带头，它们能同时读不同的方格。而且，可以允许图灵机是非确定性的，即允许（状态，带符号）对作为第一个元素出现在多于五元组的图灵机中。也可以用多种方法来削减图灵机的能力。例如，可以限制带只在一个方向是无限的；或者可以限制带字母表只有两个符号。图灵机的所有这些变种都已被详细地研究过。

重要的是，不管使用哪个变种的图灵机，或者使用变种图灵机的哪个组合，都决不会增加或减少机器的能力。这些变种的任何一个能做的事，本节定义的图灵机都能做到，反之亦然。这些变种之所以还有用，是因为有些时候，在做某些特殊任务时，使用它们比只使用定义1定义的图灵机容易很多。它们永远不会扩展机器的能力。有时候，多种类型的图灵机是非常有用的。例如，证明对于每个非确定性的图灵机，都有一个确定性的图灵机，二者能识别相同的语言。我们就可以用具有3个带的确定性的图灵机来证明。（关于图灵机的变种以及它们之间等价性表示的细节内容，可参考[HoMoU101]。）

除了引入图灵机的概念外，图灵还证明了，当给定目标图灵机的编码和输入后，可以构造一个能模仿该图灵机计算的单图灵机。这样的图灵机称为通用图灵机。（如果想了解更多关于通用图灵机的内容，可参考关于计算理论的书籍，如[Si06]。）

# 13.5.6 丘奇-图灵论题

图灵机还是相对简单的。它只能有有限多个状态，每一次它们只能在一维带上读或写一个符号。但结果表明，图灵机是极其强大的。我们已经看到，可以构造图灵机来执行数的加法和乘法。对于能够用一个算法计算的特殊函数，虽然很难实际构造图灵机来计算它们，但这样的图灵机总是能够找到的。这也正是图灵发现这种机器的最初目的。而且，可以用大量的证据来说明丘奇-图灵论题，该论题为对于任何可用有效算法来求解的问题，都存在解该问题的图灵机。但它还是称为是论题，而不是定理，因为有效算法可解的概念是非形式化的且是不严格的。相反，图灵机定义的可解性概念是形式化的且是严格的。当然，对于任何问题，只要它能够用带有用某种语言写成的程序的计算机来解，即使使用了无限多的存储空间，都应该认为是有效可解的。（注意：不同于现实世界中的计算机只有有限的存储空间，图灵机具有无限的存储空间。）

人们发明了许多形式理论来刻画有效可计算性概念，其中有图灵的理论、丘奇的 $\lambda$ 演算以及克莱因和波斯特(Post)提出的理论。这些理论表面上看起来十分不同，但令人惊奇的是，它们都是等价的，因为可以证明它们定义了完全相同的函数类。由此可以看出，图灵的思想虽然是在现代计算机发明之前形成的，但确实描述了计算机最根本的能力。有兴趣的读者如果想讨论这些不同的理论以及它们的等价性，可以查阅计算理论方面的书籍，例如[HoMoU101]和[Si96]。

本节的剩余部分将简单地研究丘奇-图灵论题的一些结果，并且描述图灵机在算法复杂度方面的重要作用。我们的目标是介绍理论计算科学中的重要思想，引导有兴趣的同学深入学习。我们将很快地介绍许多领域，而不会详细地讲解细节内容。我们的讨论与本书前面部分关于计算理论的章节有着紧密的联系。

# 13.5.7 计算复杂度、可计算性和可判定性

贯穿全书，我们已经讨论了很多问题的计算复杂度。我们用解决这些问题的最有效算法的操作次数来描述这些问题的复杂度。算法使用的基本操作之间差异很大。我们已经用位操作、整数的比较、算术运算等作为标准，度量了不同问题的复杂度。在3.3节中，我们用计算复杂度把问题进行了分类。然而，用于度量计算复杂度的操作类型之间千差万别，所以这个定义是不准确的。图灵机提供了一种方法，能够使计算复杂度的概念更为准确。若丘奇-图灵论题为真，就可以得到如果某问题可以用一个有效的算法来解决，那么一定有一个图灵机来解决这个问题。当图灵机用来解决这个问题时，把问题的输入编码成符号串写在图灵机的纸带上。如何为输入编码，取决于输入的定义域。例如，把正整数编码成字符串1。我们还可以采用别的方法来表达整数对、负整数等。同样，对于图算法，我们需要采用一种方法把图编码成符号串。可以用多种方法来解决这个问题，比如可以基于邻接表或邻接矩阵（把如何构造邻接表或邻接矩阵的细节省略了）。然而，由于图灵机经常可以把一种编码方式改为另一种编码，所以只要对输入的编码方式比较有效，采用何种方法都无关紧要。现在，我们就采用这种模型把3.3节

介绍的有关计算复杂度的一些概念准确化。

使用图灵机最容易研究的一类问题就是那些可以用“是”或者“不是”来回答的问题。

定义3 判定问题是指判断某个特定类型的命题是否为真。判定问题也被称为“是或不是”问题。

对于一个判定问题，我们想知道是否存在一个算法，能判断某个特定类型的命题是否为真。例如，判断某个特定整数 $n$ 是否是素数的某类命题。由于关于问题“ $n$ 是否是素数”的答案可能是“是”或“否”，因此该问题是一个判定问题。对于这个判定问题，我们可能想知道是否有算法能够判定关于该问题的描述正确与否，也就是说，对于一个整数 $n$ ，判断 $n$ 是否为素数。答案就是有一个判断某个数是否为素数的算法。特别地，在3.5节中我们讨论了这样一个算法，也就是对于一个正整数 $n$ ，通过检查该数是否能被不超过其平方根的素数整除来判断该数是否是素数。（还有很多其他的方法来判定一个正整数是否为素数。）对于使判定问题答案为正确的输入是所有可能输入的一个子集。也就是说，它是输入字符串集合的子集。换句话说，解决“是不是问题”与识别某个语言是相同的，该语言包含了所有比特串，这些比特串代表着使该问题的答案为“是”的输入值。因此，解决“是不是”问题与识别某个由使答案为“是”的某些输入值组成的语言是相同的。

可判定性 当有一个有效的算法能够判断判定问题的某个解是否正确时，我们说这个问题是可解的或者说是可判定的。例如，“判定一个正整数是否是素数”这样一个问题就是一个可解的问题。然而，如果不存在一个算法来解决某个问题，那么就称该问题是不可解的或者说不可判定的。为了证明某个问题是可解的，只需要构造一个算法来判定某类特定的描述是否正确。另一方面，为了证明某个问题是不可解的，需要证明不存在这样一个判定算法就可以了（事实上，我们试图找到这样的算法，但失败了，不能证明该问题是不可解的）。

如果只研究判定问题，看上去好像我们只研究自己感兴趣的一小部分问题。然而，大多数问题都可以改写为判定问题。把本书研究的问题改写为判定问题是非常复杂的，详细过程我们不在这里讨论了。感兴趣的读者可以查询计算理论的参考书目，例如[Wo87]，该书详细解释了如何把旅行商问题(在10.6节讨论)改写为判定问题。（要把旅行商问题改写为判定问题，我们首先要讨论这样一个判定问题，是否存在一条权值不超过 $k$ 的哈密尔顿回路，其中 $k$ 是正整数。经过努力，对于不同 $k$ 值，采用该问题的解找到哈密尔顿回路的最小可能值是完全有可能的。）

在3.1节中，我们介绍了停机问题，并且证明它是不可解的。由于该过程的概念定义不是很准确，所以3.1节的讨论有些非正式。停机问题的准确定义可以借助图灵机来完成。

定义4 停机问题是一种判定问题，对于给定的输入字符串 $x$ ，图灵机 $T$ 最后是否能停机。

有了停机问题的定义以后，我们有了定理1。

定理1 停机问题是不可解的判定问题。也就是说，当给定图灵机 $T$ 的编码以及输入字符串 $x$ ，没有图灵机能够判断图灵机 $T$ 从写在纸带上的 $x$ 开始，最终是否停机。

这里我们仍然应用3.1节定理1给出的非形式化定义的停机问题的证明。

其他不可解问题还包括：

(i)判定两个上下文无关文法是否能产生相同的字符串集合。

(ii)对于给定的一些绝热瓦，允许重复使用，但不能相互重叠，是否能覆盖整个平面。

(iii)希尔伯特的第十个问题：对于任意多个未知数的整系数不定方程，要求给出一个可行的方法，使得借助于它，通过有限次运算，可以判定该方程有无整数解。（这个问题是1900年希尔伯特提出的著名的23个问题序列中的第十个。他预见到，解决这些问题所做的工作对于推动20世纪数学进程的发展会起到重要作用。俄国数学家马蒂亚塞维奇在1970年证明了希尔

伯特第十个问题的不可解性。）

可计算性 如果一个函数可以被图灵机计算，那么就称其是可计算的，否则是不可计算的。使用一个可数的参数来证明存在不可计算的数论问题是相对比较简单容易的（见2.5节练习39）。然而，实际产生这样一个函数并不容易。作为本节练习31前导文中定义的忙碌海狸函数就是一个不可计算函数的例子。一种证明该函数不可计算的方法就是证明它比任意一个可计算函数增长得快（见练习32）。

需要注意的是，每一个判定问题都可以被重构成一个函数计算的问题，也就是，当问题的解是“是”则函数值为1，否则为0。一个判定问题是可解的，当且仅当采用这种方法构造的函数是可计算的。

P类和NP类在3.3节我们非正式地定义了P类和NP类问题。现在我们可以使用确定性的和非确定性的图灵机的概念来精确地定义其概念。

我们首先详细说明确定性的和非确定性的图灵机之间的区别。本节研究的图灵机都是确定性的。在确定性的图灵机 $T = (S, I, f, s_0)$ 中，转移规则是由从 $S \times I$ 到 $S \times I \times \{R, L\}$ 的部分转移函数来定义的。因此，图灵机的转移规则表示为五元组 $(s, x, s', x', d)$ ，没有两个转移规则以相同的数对 $(s, x)$ 开始。其中 $s$ 是当前状态， $x$ 是当前纸带上的符号， $s'$ 是下一个状态， $x'$ 是在纸带上代替 $x$ 的符号， $d$ 是图灵机在纸带上运行的方向。

在非确定性的图灵机中，允许的步骤是由一个包含五元组的关系而不是部分转移函数来定义。去掉了没有两个转移规则以相同的数对 $(s, x)$ 开始的限制。也就是说，有不止一条转移规则以同一个（状态，纸带符号）开始。因此，在非确定性的图灵机中，对于某些正在读取的当前状态和纸带符号对，存在转移的选择。在非确定性的图灵机的每步操作中，机器根据当前状态和纸带符号对的值，从多个转移规则中选择一个。选择哪一步可以看作“猜”。与确定性的图灵机一样，如果没有以当前状态和纸带符号定义的转移规则，则非确定性的图灵机停机。给定一个非确定性的图灵机 $T$ ，我们说字符串 $x$ 可以被图灵机 $T$ 识别，当且仅当机器从写在纸带上的 $x$ 的初始位置开始时，存在以终结状态结束的转移序列。如果 $x$ 可被 $T$ 识别，当且仅当 $x \in A$ ，则称图灵机 $T$ 可以识别集合 $A$ 。如果非确定性的图灵机 $T$ 能够识别所有使得判定问题解为正确的输入值构成的集合，则称判定问题可被 $T$ 解。

定义5 如果一个判定问题能由确定性的图灵机在多项式时间内求解，则该问题属于P类问题，即多项式时间问题。也就说，如果一个确定性的图灵机 $T$ 和一个多项式 $\mathbb{P}$ ，对于该问题的任何长度为 $n$ 的字符串， $T$ 都能在 $P(n)$ 步内停机，我们说该问题属于P类。如果一个判定问题能由非确定性的图灵机在多项式时间内求解，则该问题属于NP类问题，即非确定性的多项式时间问题。也就是说，对于任一判定问题，如果存在一个非确定性的图灵机 $T$ 和一个多项式 $P$ ，对于该问题的任何长度为 $n$ 的实例， $T$ 都能在 $P(n)$ 步内停机，则称该问题是NP类问题。

P类问题称为易处理的问题，而不属于P类问题称为不易处理的问题。对于某个P类问

Links

![](029780b397acb0dd3496689d70e7fde624ea6095ec9bccd2b71de929d7ae5111.jpg)  
$\odot$ University Archives. Department of Rare Books and Special Collections. Princeton University Library

丘奇（Alonzo Church，1903—1995）丘奇出生于华盛顿特区，曾在哥廷根跟随希尔伯特学习，后来又转学到阿姆斯特丹。从1927年到1967年，他在普林斯顿大学执教，1967年他调到加州大学洛杉矶分校。丘奇是符号逻辑学会的创始人之一。他对可计算性理论做出了实质性的贡献，其中包括对判定问题的解答、 $\lambda$ 演算的发明，以及对现今称为丘奇-图灵论题的陈述。克莱因和图灵都是丘奇的学生。他在度过了90岁生日后依旧在发表文章。

题，一定存在一个确定的图灵机能够在多项式时间内，判定由判定命题所陈述的该类中的一个特定命题是否正确。例如，判定某个数在长度为 $n$ 的序列中是否存在，有一个易处理问题（对于该问题的证明，这里不做详细解释。当采用图灵机时，本书曾描述的用于算法分析的基本思想可用于此）。对于一个 NP 类问题，当给出关于该问题的某个正确陈述时，只有能在多项式时间内判定其对错的非确定性图灵机才是必要的，对每一个当前的状态和纸带上的符号，该图灵机在每一步都能在允许的步骤内做出正确的猜测。非确定性的图灵机能够很容易地确定图中的一条简单回路穿过每个顶点一次而且仅一次，因此判定某个图是否存在哈密尔顿回路这个问题是 NP 类问题。这需要在依次增加边以形成回路时，做出一系列的正确的猜测。由于每个确定性的图灵机也可以看作（状态，纸带符号）对只在转移规则中出现一次的非确定性的图灵机，所以 $P \subseteq NP$ 。

在计算机科学中，目前所知的最困惑的一个问题就是，是否有 $\mathrm{NP} \subseteq \mathrm{P}$ ，也就是说，是否 $\mathrm{P} = \mathrm{NP}$ 。正如3.3节提到的，有一类重要的问题，即NP完全问题，一个问题是NP完全的，如果它属于NP类，并且如果能证明当它属于P类时，所有NP类的问题都属于P类，那么该问题是NP完全的。也就是说，一个问题是NP完全的，如果存在一个能够在多项式时间内求解该问题的算法，意味着对于每个NP类问题，都存在一个能够在多项式时间内求解该问题的算法。本书中，我们已经讨论了几个不同的NP完全问题，例如判定一个简单图是否存在哈密尔顿回路以及判定一个 $n$ 元命题是否是重言式。

# 练习

1. 设 $T$ 是下列五元组定义的图灵机： $(s_0, 0, s_1, 1, R)$ ， $(s_0, 1, s_1, 0, R)$ ， $(s_0, B, s_1, 0, R)$ ， $(s_1, 0, s_2, 1, L)$ ， $(s_1, 1, s_1, 0, R)$ 和 $(s_1, B, s_2, 0, L)$ 。对于下列的初始纸带，判断 $T$ 停机时的最终纸带。假设 $T$ 从初始位置开始执行。

a)   
b)   
c)   
d)

2. 设 $T$ 是下列五元组定义的图灵机： $(s_0, 0, s_1, 0, R)$ ， $(s_0, 1, s_1, 0, L)$ ， $(s_0, B, s_1, 1, R)$ ， $(s_1, 0, s_2, 1, R)$ ， $(s_1, 1, s_1, 1, R)$ ， $(s_1, B, s_2, 0, R)$ 和 $(s_2, B, s_3, 0, R)$ 。对于下列的初始纸带，判断 $T$ 停机时的最终纸带。假设 $T$ 从初始位置开始执行。

a)   
b）  
c）  
d)

3. 对于由五元组 $(s_0, 0, s_0, 0, R)$ ， $(s_0, 1, s_1, 0, R)$ ， $(s_0, B, s_2, B, R)$ ， $(s_1, 0, s_1, 0, R)$ ， $(s_1, 1, s_0, 1, R)$ 和 $(s_1, B, s_2, B, R)$ 描述的图灵机，当给定

a)11作为输入时，它能做什么？  
b) 任意一个比特串作为输入时，它能做什么？

4. 对于五元组 $(s_0, 0, s_0, 1, R)$ ， $(s_0, 1, s_0, 1, R)$ ， $(s_0, B, s_1, B, L)$ ， $(s_1, 1, s_2, 1, R)$ 描述的图灵机，当给定

a)101 作为输入时，它能做什么？  
b)一个任意的比特串作为输入时，它能做什么？

5. 对于五元组 $(s_0, 1, s_1, 0, R)$ ， $(s_1, 1, s_1, 1, R)$ ， $(s_1, 0, s_2, 0, R)$ ， $(s_2, 0, s_3, 1, L)$ ， $(s_2, 1, s_2, 1, R)$ ， $(s_3, 1, s_3, 1, L)$ ， $(s_3, 0, s_4, 0, L)$ ， $(s_4, 1, s_4, 1, L)$ ， $(s_4, 0, s_0, 1, R)$ 描述的图灵机，当给定

a)11作为输入时，它能做什么？  
b) 全部由 1 构成的比特串形成的集合作为输入时，它能做什么？

6.构造一个纸带符号为0、1和 $B$ 的图灵机，对于给定的输入比特串，在带的最末端增加一个1，而其余符号保持不变。  
7.构造一个纸带符号为0、1和 $B$ 的图灵机，它将纸带上第一个0替换为1，而其余符号保持不变。  
8.构造一个纸带符号为0、1和 $B$ 的图灵机，对于给定的输入比特串，它将纸带上所有0替换为1，而所有的1保持不变。  
9.构造一个纸带符号为0、1和 $B$ 的图灵机，对于给定的输入比特串，它将纸带上除最左边的1以外的所有1替换为0，而其余符号保持不变。  
10. 构造一个纸带符号为 0、1 和 $B$ 的图灵机，对于给定的输入比特串，它将带上首先出现的两个连续的 1 替换为 0，而其余符号保持不变。  
11. 构造一个图灵机，它识别的集合是所有以0结尾的比特串组成的集合。  
12. 构造一个图灵机，它识别的集合是所有至少包含两个 1 的比特串组成的集合。  
13. 构造一个图灵机，它识别的集合是所有包含偶数个 1 的比特串组成的集合。  
14. 对于例3中的图灵机，若从下列每个字符串开始运行，写出其每一步的带内容。

a)0011

b)00011

c)101100

d)000111

15. 例3中的图灵机识别一个字符串当且仅当此字符串具有形式 $0^{n}1^{n}$ （其中 $n$ 是一个正整数），试说明原因。

* 16. 构造识别集合 $\{0^{2n}1^n \mid n \geqslant 0\}$ 的图灵机。

* 17. 构造识别集合 $\{0^n 1^n 2^n \mid n \geqslant 0\}$ 的图灵机。

18. 构造一个图灵机，它计算函数 $f(n) = n + 2$ ，其中 $n$ 是非负整数。

19. 构造一个图灵机，它计算下列函数：当 $n \geq 3$ 时， $f(n) = n - 3$ ；当 $n = 0$ ，1，2时， $f(n) = 0$ ，其中 $n$ 是非负整数。

20. 构造一个图灵机，它计算函数 $f(n) = n \mod 3$ 。

21. 构造一个图灵机，它计算下列函数：当 $n \geq 5$ 时， $f(n) = 3$ ；当 $n = 0$ ，1，2，3或4时， $f(n) = 0$ 。

22. 构造一个图灵机，它计算下列函数： $f(n) = 2n$ ，其中 $n$ 是非负整数。

23. 构造一个图灵机，它计算下列函数： $f(n) = 3n$ ，其中 $n$ 是非负整数。

24. 构造一个图灵机，它计算下列函数：对于所有非负整数对 $n_1$ 和 $n_2$ ， $f(n_1, n_2) = n_2 + 2$ 。

* 25. 构造一个图灵机，它计算下列函数：对于所有非负整数 $n_1$ 和 $n_2$ ， $f(n_1, n_2) = \min \{n_1, n_2\}$ 。

26.构造一个图灵机，它计算下列函数：对于所有非负整数 $n_1$ 和 $n_2$ ， $f(n_{1},n_{2}) = n_{1} + n_{2} + 1$

假设 $T_{1}$ 和 $T_{2}$ 是图灵机，分别具有不相交的状态集 $S_{1}$ 和 $S_{2}$ ，转移函数分别为 $f_{1}$ 和 $f_{2}$ 。我们可以采用如下的方式来定义图灵机 $T_{1}T_{2}$ ，即 $T_{1}$ 和 $T_{2}$ 的合成。 $T_{1}T_{2}$ 的状态集是 $S_{1} \cup S_{2}$ 。 $T_{1}T_{2}$ 以 $T_{1}$ 的起始状态开始。首先，使用函数 $f_{1}$ 执行 $T_{1}$ 的转移，但不包括使得 $T_{1}$ 停机的那一步。然后，对使得 $T_{1}$ 停机的所有移动，除移动到 $T_{2}$ 的开始状态外，都执行相同的 $T_{1}$ 转移。从这点来看， $T_{1}T_{2}$ 的移动与 $T_{2}$ 的移动相同。

27. 通过求练习18和练习22构造的图灵机的合成，构造一个图灵机计算函数 $f(n) = 2n + 2$ 。

28. 通过求练习18和练习23构造的图灵机的合成，构造一个图灵机计算函数 $f(n) = 3(n + 2) = 3n + 6$ 。

29. 下列哪些问题是判定问题？

a)比 $n$ 小的最小素数是多少？  
b)图 $G$ 是否是二分图？  
c)给定字符串的集合，是否有有限状态自动机能识别该集合？  
d)给定一个棋盘和某种类型的多格骨牌(参见1.8节)，棋盘是否可用这种类型的骨牌平铺？

30. 下列哪些问题是判定问题？

a) 正整数序列 $a_1, a_2, \dots, a_n$ 是否是递增序列？  
b)简单图 $G$ 的顶点是否可用3种颜色着色，使得没有相邻的顶点着色相同。  
c) 图 $G$ 中度数最大的顶点是什么？  
d) 给定两个有限状态机，它们是否能识别相同的语言？

Links

设 $B(n)$ 是具有 $n$ 个状态且字母表为 $\{1, B\}$ 的图灵机从空白带开始运行后在纸带上所能打印的 1 的最大个数。根据给定的值 $n$ 确定 $B(n)$ 这个问题称为忙碌海狸问题（busy beaver problem），该问题由拉多（Tibor Rado）于 1962 年首先研究。现在已经知道， $B(2) = 4$ ， $B(3) = 6$ ， $B(4) = 13$ 。但当 $n \geqslant 5$ 时， $B(n)$ 等于什么还不知道。 $B(n)$ 增长得很快，目前所知 $B(5) \geqslant 4098$ ， $B(6) \geqslant 3.5 \times 10^{18267}$ 。

* 31. 通过寻找下面的图灵机来证明 $B(2)$ 至少是 4: 该图灵机有两个状态, 字母表是 $\{1, B\}$ , 在停机时, 纸带上有 4 个连续的 1。

**32. 证明：函数 $B(n)$ 不能用任何图灵机来计算。[提示：假设有一个图灵机用二进制计算 $B(n)$ 。构造一个图灵机 $T$ ，从空白带开始，写下 $n$ 的二进制表示，计算 $B(n)$ 并表示成二进制，然后将 $B(n)$ 从二进制表示转换为一元表示。证明当 $n$ 充分大时， $T$ 的状态数可以小于 $B(n)$ ，导致矛盾。]

# 关键术语和结论

# 术语

字母表或词汇表（alphabet or vocabulary）：用来构造字符串的元素组成的集合。

语言（language）：字母表上所有字符串构成的集合的一个子集。

短语结构文法 $(V, T, S, P)$ , phrase-structure grammar: 语言的一种描述, 包括字母表 $V$ 、终结符集 $T$ 、起始符号 $S$ 和产生式集 $P$ 。

产生式 $w \rightarrow w_{1}$ (the production $w \rightarrow w_{1}$ )：只要语言的某个字符串中出现了 $w$ ，就可将此字符串中的 $w$ 替换为 $w_{1}$ 。

$w_{1} \Rightarrow w_{2}$ （由 $w_{1}$ 派生 $w_{2}$ ， $w_{2}$ is directly derivable from $w_{1}$ ）： $w_{2}$ 是从 $w_{1}$ 按如下方式得到的：用产生式将 $w_{1}$ 中的某个字符串替换为另一个字符串。

$w_{1} \Rightarrow w_{2}$ （由 $w_{1}$ 派生 $w_{2}$ ， $w_{2}$ is derivable from $w_{1}$ ）： $w_{2}$ 是从 $w_{1}$ 按如下方式得到的：用一系列产生式将某些字符串替换为另一些字符串。

0型文法（type 0 grammar）：任意短语结构文法。

1型文法(type 1 grammar)：是一种短语结构文法，但其产生式都具有形式 $w_{1} \rightarrow w_{2}$ ，其中 $w_{1} = lAr$ 和 $w_{2} = lwr$ ，其中 $A \in N$ ； $l$ ， $r$ ， $w \in (N \cup T)^{*}$ 且 $w \neq \lambda$ 或 $w_{1} = S$ 和 $w_{2} = \lambda$ ，但 $S$ 不能出现在任何其他产生式的右边。

2型(或上下文无关)文法(type 2, or context-free grammar): 是一种短语结构文法, 但其产生式都具有形式 $A \rightarrow w_{1}$ , 其中 $A$ 是一个非终结符。

3型(或正则)文法(type3，or regular grammar)：是一种短语结构文法，其产生式的形式是 $A\rightarrow aB$ ， $A\rightarrow a$ 或 $S\rightarrow \lambda$ ，其中 $A,B$ 是非终结符， $S$ 是起始符， $a$ 是一个终结符。

派生(或语法分析)树(derivation(or parse)tree): 一个带根的有序树, 其根表示 2 型文法的起始符, 内部顶点表示非终结符, 叶表示终结符, 顶点的儿子是产生式右边按从左到右顺序排列的符号, 父亲表示的符号都在左边。

巴克斯-诺尔范式(Backus-Naur form)：上下文无关文法的一种描述，在这种描述中，将左边非终结符相同的所有产生式合并成一个式子，式子的右边是这些产生式不同的右边，并用竖线符将其分开，用尖括号将非终结符括起来，符号 $\rightarrow$ 被换成 $\because =$ 。

有限状态机器（S，I，O，f，g，s0）或米兰机（finite-state machine（S，I，O，f，g，s0）or a Mealy machine)：一个六元组，包括状态集S、输入字母表I、输出字母表O、转移函数 $f$ （对每个状态与输入对，指派下一个状态）、输出函数 $g$ （对每个状态与输入对，指派一个输出)和一个起始符 $s_0$ 。

$AB(A$ 和 $B$ 的连接，concatenation of $A$ and $B$ )：由 $A$ 中的字符串和 $B$ 中的字符串连接而成的字符串构成的集合。

$\mathbf{A}^{*}$ （ $A$ 的克莱因闭包，Kleene closure of $A$ ）：由 $A$ 中任意多个字符串连接而成的字符串构成的集合。

确定性的有限状态自动机（ $S$ ， $I$ ， $f$ ， $s_0$ ， $F$ ，deterministic finite-state automaton）：一个五元组，包括状态集 $S$ 、输入字母表 $I$ 、转移函数 $f$ （对每个状态与输入对，指派下一个状态）、起始符 $s_0$ 和终结状态集 $F$ 。

非确定性的有限状态自动机（S，I， $f$ ， $s_0$ ， $F$ ，nondeterministic finite-state automaton)：一个五元组，包括状态集 $S$ 、输入字母表 $I$ 、转移函数 $f$ （对每个状态与输入对，指派下一个可能状态的集合)、起始

符 $s_0$ 和终结状态集 $F$ 。

自动机识别的语言（language recognized by an automaton）：将自动机从初始状态带到终结状态的输入字符串构成的集合。

正则表达式(regular expression)：如下递归定义的表达式， $\varnothing$ 、 $\lambda$ 和输入字母表中的每个符号 $x$ 都是正则表达式；当 $\mathbf{A}$ 和 $\mathbf{B}$ 是正则表达式时， $(\mathbf{AB})$ 、 $(\mathbf{A} \cup \mathbf{B})$ 和 $\mathbf{A}^*$ 都是正则表达式。

正则集合(regular set)：正则表达式定义的集合。

图灵机 $(T = S, I, f, s_0, \text{ Turing machine})$ ：由下列各部分组成的四元组：有限状态集 $S$ 、包含空白符 $B$ 的字母表 $I$ 、从 $S \times I$ 到 $S \times I \times \{R, L\}$ 的一个部分函数、初始状态 $s_0$ 。

非确定性的图灵机(nondeterministic Turing machine)：对于每个(状态，纸带符号)对可能包含不止一条转换规则的图灵机。

判定问题(decision problem)：是指这样一类问题，判断某个特定类型的命题中的命题是否为真。

可解问题(solvable problem)：该问题的性质是具有一个有效的算法能够求解该问题的所有实例。

不可解问题(unsolvable problem)：该问题的性质是不存在一个有效的算法能够求解该问题的所有实例。

可计算函数（computable function）：函数值可以通过图灵机来计算的函数。

不可计算函数（uncomputable function）：函数值不可以通过图灵机来计算的函数。

P类，多项式时间问题类(P，the class of polynomial-time problems)：该类问题能由确定性的图灵机在输入大小的多项式时间内求解。

NP类，非确定性多项式时间问题类(NP，the class of nondeterministic polynomial-time problems)：一个问题能由非确定性的图灵机在输入大小的多项式时间内求解，则该问题属于NP类问题。

NP完全(NP-complete)：该类问题是NP类问题的子集，并且该类问题具有这样的性质，如果其中之一属于P类，则NP类中的所有问题也都属于P类。

# 结论

对每个非确定性的有限状态自动机，存在一个确定性的有限状态自动机，它们识别相同的集合。

克莱因定理(Kleene's theorem)：一个集合是正则的当且仅当它可由一个有限状态自动机来识别。

一个集合是正则的当且仅当它可由一个正则文法生成。

停机问题是不可解的。

# 复习题

1. a) 定义短语结构文法。

b）“一个字符串可以由短语结构文法从字符串 $w$ 派生出来”的含义是什么？

2. a) 什么是短语结构文法生成的语言？

b)设短语结构文法 $G$ 如下：词汇表为 $\{S,0,1\}$ ，终结符集为 $T = \{0,1\}$ ，起始符号为 $S$ ，产生式为 $S\to 000S$ 和 $S\rightarrow 1$ 。 $G$ 生成的语言是什么？

c)给出生成集合 $\{01^n\mid n = 0$ ，1，2，…}的短语结构文法。

3. a) 定义一个 1 型文法。

b)给出一个是文法但不是1型文法的例子。

c)定义2型文法。

d)给出一个是1型文法但不是2型文法的例子。

e)定义一个3型文法。

f) 给出一个是 2 型文法但不是 3 型文法的例子。

4. a) 定义一个正则文法。

b)定义一个正则语言。

c) 证明：集合 $\{0^m 1^n \mid m, n = 0, 1, 2, \dots\}$ 是一个正则语言。

5. a) 什么是巴克斯-诺尔范式？

b) 选择英语的一个子集，给出其巴克斯-诺尔范式。

6. a) 什么是有限状态机？

b)说明怎么用有限状态机建立下列自动售货机的模型：它只接受25分硬币，在放入75分之后，它发售一瓶软饮料。

7. 求能被如下的确定性的有限状态自动机识别的字符串的集合。

8. 构造一个确定性的有限状态自动机能识别以1开始，并且以1结束的字符串形成的集合。

![](e14ad8bdaaee726c71978d913f7ae428683bb1fc0191f47997e54aa1adc9e048.jpg)

9. a) 什么是一个字符串集合的克莱因闭包？

b)求集合 $\{11,0\}$ 的克莱因闭包。

10. a)定义一个有限状态自动机。

b）“一个字符串由一个有限状态自动机识别”的含义是什么？

11. a)定义一个非确定性的有限状态自动机。  
b)试证：对于每个非确定性的有限状态自动机，存在一个确定性的有限状态自动机，它们识别相同的语言。  
12. a) 定义一个集合 $I$ 上的正则表达式集。  
b)解释怎么用正则表达式表示正则集合。  
13.叙述克莱因定理。  
14. 试证：一个集合可由正则文法生成当且仅当它是一个正则集合。  
15. 给出一个不能由有限状态自动机识别的集合的例子，并证明没有有限状态自动机能够识别它。  
16. 定义一个图灵机。  
17. 描述如何用图灵机来识别集合。  
18. 描述如何用图灵机计算数论函数。  
19. 什么是不可解的判定问题？给出一个例子。

# 补充练习

* 1. 求识别下列每个语言的一个短语结构文法。

a)形如 $0^{2n}1^{3n}$ 的比特串的集合，其中 $n$ 是一个非负整数。  
b)比特串的集合，其中0的个数是1的个数的两倍。  
c)形如 $w^2$ 的比特串的集合，其中 $\mathcal{W}$ 是比特串。

* 2. 求产生集合 $\{0^{2^n} \mid n \geqslant 0\}$ 的一个短语结构文法。

在练习3和4中， $G = (V,T,S,P)$ 是一个上下文无关文法，其中 $V = \{(\cdot ,\cdot),S,A,B\}$ ， $T = \{(.,)\}$ ， $S$ 是起始符号，产生式有 $S\rightarrow A$ ， $A\to AB$ ， $A\to B$ ， $B\to (A)$ ， $B\to ()$ ， $S\to \lambda$ 。

3.构造下列字符串的派生树。

a）（）

b）（（）

c）（（（）））

* 4. 证明: $L(G)$ 就是第 5 章补充练习 59 的前导文中定义的括号的合式串集合。

称一个上下文无关文法是二义的，如果 $L(G)$ 中有一个词有两个派生，且将这两个派生看作带根的有序树时，产生两个不同的派生树。

5. 设文法 $G = (V, T, S, P)$ ，其中 $V = \{0, S\}$ ， $T = \{0\}$ ， $S$ 是起始符号，产生式有 $S \rightarrow 0S$ ， $S \rightarrow S0$ 和 $S \rightarrow 0$ 。构造 $0^3$ 的两个不同派生树，从而证明 $G$ 是二义的。

6. 设文法 $G = (V, T, S, P)$ 为： $V = \{0, S\}$ ， $T = (0)$ ， $S$ 是起始符号，产生式有 $S \rightarrow 0S$ 和 $S \rightarrow 0$ 。证明 $G$ 是非二义的。

7. 设 $A$ 和 $B$ 是 $V^{*}$ 的两个有限子集，其中 $V$ 是一个字母表。问 $\left|AB\right| = \left|BA\right|$ 肯定成立吗？

8. 设 $V$ 是一个字母表， $A$ 、 $B$ 和 $C$ 是 $V^{*}$ 的子集。证明或反证下列各式。

a) $A(B\bigcup C) = AB\bigcup AC$

b) $A(B\cap C) = AB\cap AC$

c) $(AB)C = A(BC)$

d) $(A\bigcup B)^{*} = A^{*}\bigcup B^{*}$

9. 设 $V$ 是一个字母表， $A$ 和 $B$ 是 $V^{*}$ 的子集。从 $A^{*} \subseteq B^{*}$ 能否推出 $A \subseteq B$ ?

10. 正则表达式 $(2^{*})(0 \cup (12^{*}))^{*}$ 表示的字符串集合是什么（字符串的符号在集合 $\{0, 1, 2\}$ 中）？如下递归定义集合 $I$ 上正则表达式的星高度 $h(\mathbf{E})$ ：

$h(\emptyset) = 0$

若 $\mathbf{x}\in I$ ，则 $h(\mathbf{x}) = 0$

若 $\mathbf{E}_1$ 和 $\mathbf{E}_2$ 是正则表达式，则 $h((\mathbf{E}_1 \cup \mathbf{E}_2)) = h((\mathbf{E}_1 \mathbf{E}_2)) = \max(h(\mathbf{E}_1), h(\mathbf{E}_2))$ ；若 $\mathbf{E}$ 是正则表达式，则 $h(\mathbf{E}^*) = h(\mathbf{E}) + 1$ 。

11. 求下列正则表达式的星高度：

a) $0^{*}1$

b) $0^{*}1^{*}$

c) $(\mathbf{0}^{*}\mathbf{01})^{*}$

d）（ $(0^{*}1)^{*})^{*}$

e) $(\mathbf{010}^{*})(\mathbf{1}^{*}\mathbf{01}^{*})^{*}((\mathbf{01})^{*}(\mathbf{10})^{*})^{*}$

f）((((0\*1)\*0\*)1)\*

* 12. 对下列每个正则表达式，求一个表示相同语言但具有最小星高度的正则表达式。

a) $(\mathbf{0}^{*}\mathbf{1}^{*})^{*}$

b) $(\mathbf{0}(\mathbf{01}^{*}\mathbf{0})^{*})^{*}$

c) $(\mathbf{0}^{*}\bigcup (\mathbf{01})^{*}\bigcup \mathbf{1}^{*})^{*}$

13. 构造一个带输出的有限状态机，若到目前为止读到的输入比特串中含有 4 个或 4 个以上的 1，则它输出 1。然后再构造一个确定性的有限状态自动机来识别这个集合。

14. 构造一个带输出的有限状态机器，若到目前为止读到的输入比特串中含有 4 个或 4 个以上连续的 1，则它输出 1。然后再构造一个确定性的有限状态自动机来识别这个集合。

15. 构造一个带输出的有限状态机器，若到目前为止读到的输入比特串以4个或4个以上连续的1结尾，则它输出1。然后再构造一个确定性的有限状态自动机来识别这个集合。

16. 在有限状态机中，称状态 $s'$ 是从状态 $s$ 可达的，如果存在输入字符串 $x$ 使得 $f(s, x) = s'$ 。称状态 $s$ 是瞬变的，若没有非空输入字符串 $x$ 使得 $f(s, x) = s$ 。称状态 $s$ 是一个沉积点，若对于任意输入字符串 $x$ 都有 $f(s, x) = s$ 。对下列状态图所示的有限状态机，回答问题 $a \sim d$ 。

a)哪些状态是从 $s_0$ 可达的？  
b)哪些状态是从 $s_2$ 可达的？  
c)哪些状态是瞬变的？  
d)哪些状态是沉积点？

![](34f3c8cfccea6baa2b219ee0ea8c932cf3a149fc525f334f238e494f5de3bde4.jpg)

* 17. 设集合 $S$ 、 $I$ 和 $O$ 都是有限集合，且 $|S| = n$ 、 $|I| = k$ 、 $|O| = m$ 。

a)可以构造多少个不同的有限状态机(米兰机) $M = (S,I,O,f,g,s_0)$ （其中初始状态 $s_0$ 可以任意选择）？  
b)可以构造多少个不同的摩尔机 $M = (S,I,O,f,g,s_0)$ （其中初始状态 $s_0$ 可以任意选择）？

* 18. 设集合 $S$ 和 $I$ 是有限集合，且 $|S| = n$ ， $|I| = k$ 。在下列情形下，存在多少个不同的有限状态自动机（ $S, I, f, s_0, F$ ）（其中初始状态 $s_0$ 以及由 $S$ 的终结状态构成的子集 $F$ 可以任意选择）？

a)如果机器是确定性的。  
b)如果机器是非确定性的。（注意：这包括确定性的自动机。）

19. 对于具有如下状态图的非确定性的自动机，构造一个与之等价的确定性的有限状态自动机。

![](7df7bcaccdf7ed50157c53273763b5b2d4db2f7939f2ec189d2f17e1585eb0c2.jpg)

20. 练习19中的自动机识别的语言是什么？  
21. 构造有限状态自动机识别下列集合。

a) $\mathbf{0}^{*}(10)^{*}$

b) $(\mathbf{01}\bigcup \mathbf{111})^{*}\mathbf{10}^{*}(\mathbf{0}\bigcup \mathbf{1})$

c) $(\mathbf{001}\bigcup (\mathbf{11})^{*})^{*}$

* 22. 求表示由0和1组成的下列字符串集合的正则表达式。

a) 偶数个 1 与奇数个 0 交替出现。

b)包含至少2个连续的0或3个连续的1。

c)不包含3个连续的0或2个连续的1。

* 23. 证明：若 $A$ 是一个正则集合，则 $\overline{A}$ 也是。  
* 24. 证明：若 $A$ 和 $B$ 都是正则集合，则 $A \cap B$ 也是。  
* 25. 求识别由0和1组成的下列字符串集合的有限状态自动机。

a) 以不超过 3 个连续的 0 开始，且至少包含 2 个连续的 1。  
b)包含偶数个符号，且不含101。  
c)有3个由2个或2个以上的1组成的块，且有至少2个0。

* 26. 用13.4节的练习22所给的泵引理证明： $\{0^{2^n} \mid n \in \mathbf{N}\}$ 不是正则的。  
* 27. 用13.4节的练习22所给的泵引理证明： $\{1^p \mid p$ 是素数\}不是正则的。  
*28. 对于上下文无关语言，有与正则集合的泵引理类似的结果。设 $L(G)$ 是上下文无关语言 $G$ 识别的语言。此结果是存在常量 $N$ ，如果 $z$ 是 $L(G)$ 中的一个词，且 $l(z) \geqslant N$ ，则 $z$ 可以写成 $uvwxy$ ，其中 $l(vwx) \leqslant N$ ， $l(vx) \geqslant 1$ ，且 $uv^iwx^iy$ 属于 $L(G)(i = 0, 1, 2, 3, \cdots)$ 。用这个结果证明，不存在上下文无关文法 $L(G)$ 满足 $\{0^n 1^n 2^n | n = 0, 1, 2, \cdots\}$ 。  
* 29. 构造一个能计算函数 $f\left( {{n}_{1},{n}_{2}}\right)  = \max \left( {{n}_{1},{n}_{2}}\right)$ 的图灵机。  
* 30. 构造一个图灵机，它能计算如下函数：当 $n_2 \geqslant n_1$ 时， $f(n_1, n_2) = n_2 - n_1$ ；当 $n_2 < n_1$ 时， $f(n_1, n_2) = 0$ 。

# 计算机课题

# 按给定的输入和输出写程序。

1. 给定短语结构文法的产生式，根据乔姆斯基分类方法，判断此文法所在的类。

2. 给定短语结构文法的产生式，求使用 20 条或更少的产生式规则生成的所有字符串。

3. 给定2型文法的巴克斯-诺尔范式，求使用20条或更少的规则生成的所有字符串。

* 4. 给定一个上下文无关文法的产生式和一个字符串，如果这个字符串在此文法生成的语言中，产生这个字符串的派生树。

5. 给定一个摩尔机的状态表和一个输入字符串，产生此机器生成的输出字符串。

6. 给定一个米兰机的状态表和一个输入字符串，产生此机器生成的输出字符串。

7. 给定一个确定性的有限状态自动机的状态表和一个字符串，判断这个字符串能否由此自动机识别。

8. 给定一个非确定性的有限状态自动机的状态表和一个字符串，判断这个字符串能否由此自动机识别。

*9. 给定一个非确定性的有限状态自动机的状态表，构造一个识别相同语言的确定性的有限状态自动机的状态表。

**10. 给定一个正则表达式，构造一个非确定性的有限状态自动机，识别这个表达式表示的集合。

11. 给定一个正则文法，构造一个有限状态自动机识别这个文法生成的语言。

12. 给定一个有限状态自动机，构造一个正则文法生成这个自动机所识别的语言。

* 13. 给定一个图灵机，求一个给定的输入字符串所产生的输出字符串。

# 计算和探索

用一个计算程序或你自己编写出的程序做下面的练习。

1. 通过检查所有具有两个状态且字母表为 $\{1, B\}$ 的图灵机，求解两个状态的忙碌海狸问题。  
*2. 通过检查所有具有3个状态且字母表为{1，B}的图灵机，求解3个状态的忙碌海狸问题。  
**3. 通过检查所有具有4个状态且字母表为 $\{1, B\}$ 的图灵机，求具有4个状态的忙碌海狸机器。  
**4. 尽力解5个状态的忙碌海狸问题，进展越多越好。   
**5. 尽力解6个状态的忙碌海狸问题，进展越多越好。

# 写作课题

用本教材以外的资料，按下列要求写成论文。

1. 描述怎么用利登梅耶系统(Lidenmeyer system)建立某种类型植物的生长模型。利登梅耶系统用带产生式的文法来建立植物生长的各种不同方式的模型。

2. 对于各种程序设计语言，如 Java、LISP、ADA 和数据库语言 SQL，给出描述其语法的巴克斯-诺尔范式（或扩展的巴克斯-诺尔范式）规则。  
3. 解释在拼写检查程序中，怎么使用有限状态机。  
4. 解释在网络协议研究中，怎么使用有限状态机。  
5. 解释在语音识别程序中，怎么使用有限状态机。  
6. 比较摩尔机和米兰机在设计硬件系统和计算机软件中的应用。  
7. 解释概念“有限状态自动机极小化”。给出一个程序来实现这个极小化。  
8. 给出细胞自动机的定义，以“生命的游戏”（Game of Life)为例，解释它们的应用。  
9. 定义下推自动机，解释怎么用下推自动机来识别集合。下推自动机能识别哪些集合？给出验证你的答案正确性的证明概要。  
10. 定义线性有界自动机，解释怎么用线性有界自动机来识别集合。线性有界自动机能识别哪些集合？给出验证你的答案正确性的证明概要。  
11. 查找图灵对现称为图灵机的机器的原始定义。他定义这种机器的动机是什么？  
12. 描述“通用图灵机”（Universal Turing Machine)的概念。解释怎么构造这样的机器。  
13. 解释能够用非确定性的图灵机而不能用确定性的图灵机的应用种类。  
14. 证明：一个图灵机能够模拟一个非确定性的图灵机的任何动作。  
15. 证明：一个集合能被图灵机识别当且仅当它能由短语结构文法生成。  
16. 描述 $\lambda$ 演算的基本概念。解释怎么用它来研究函数的可计算性。  
17. 试证：一个具有 $n$ 个带的图灵机能做的任何事情，本章所定义的图灵机也都能做。  
18. 试证：一个在两个方向都有无限带的图灵机能做的任何事情，只在一个方向有无限带的图灵机也都能做。

# 实数和正整数的公理

本书中，我们假设了一组实数集合和正整数集合的显式公理。在这个附录中，我们将列出这些公理并解释如何从这些公理导出一些在正文中不加证明就引用的基本事实。

# A. 1 实数公理

标准的实数公理包括：域（或代数）公理，用于规定基本算术运算的法则；序公理，用于规定实数的顺序性质。

域公理 首先介绍域公理。通常，我们将两个实数 $x$ 与 $y$ 的和以及积分别记作 $x + y$ 和 $x \cdot y$ 。（注意， $x$ 与 $y$ 的积通常记作 $xy$ 而省略表示乘法的点。在本附录中，我们不用这种简化符号，但是在正文中会用到。）另外，通常约定，先做乘法后做加法，除非使用了括号。尽管这些陈述也是公理，但通常称为是定律或法则。这些公理的前两条告诉我们当把两个实数相加或相乘时，结果还是一个实数。这就是封闭律。

- 加法封闭律 对于所有实数 $x$ 和 $y$ , $x + y$ 是实数。  
- 乘法封闭律 对于所有实数 $x$ 和 $y$ ， $x \cdot y$ 是实数。

接下来两个公理告诉我们当把三个实数相加或相乘时，无论什么运算顺序都能得到同样的结果。这就是结合律。

- 加法结合律 对于所有实数 $x$ 、 $y$ 和 $z$ ， $(x + y) + z = x + (y + z)$ 。  
- 乘法结合律 对于所有实数 $x$ 、 $y$ 和 $z$ ， $(x \cdot y) \cdot z = x \cdot (y \cdot z)$ 。

另外两个代数公理告诉我们，对两个数做加法或乘法时顺序并不重要。这就是交换律。

- 加法交换律 对于所有实数 $x$ 和 $y$ , $x + y = y + x$ 。  
- 乘法交换律 对于所有实数 $x$ 和 $y$ , $x \cdot y = y \cdot x$ 。

接下来两个公理告诉我们0和1分别是实数集的加法单位元和乘法单位元。即，当我们对一个实数加0或者乘1时不会改变这个实数。这就是单位元律。

- 加法单位元律 对于每个实数 $x$ ， $x + 0 = 0 + x = x$ 。  
- 乘法单位元律 对于每个实数 $x$ ， $x\cdot 1 = 1\cdot x = x$

虽然这看起来很明显，但我们还是需要下面的公理。

- 单位元公理 加法单位元 0 和乘法单位元 1 是不一样的，即 $0 \neq 1$ 。

还有两个公理告诉我们，对于每个实数，都存在一个实数加上该实数后得到0；而对于每个非零实数，都存在一个实数乘上该实数后得到1。这就使逆律。

- 加法的逆律 对于每个实数 $x$ ，存在一个实数 $-x$ （称为 $x$ 的加法逆）使得 $x + (-x) = (-x) + x = 0$ 。  
- 乘法的逆律 对于每个非零实数 $x$ ，存在一个实数 $1/x$ （称为 $x$ 的乘法逆）使得 $x \cdot (1/x) = (1/x) \cdot x = 1$ 。

实数的最后一个代数公理是分配律，它告诉我们乘法对加法可分配。即，先把一对实数相加再乘以第三个实数，或者先将两个实数中的每一个与第三个实数相乘再把两个乘积相加，我们将得到同样的结果。

- 分配律 对于所有实数 $x, y$ 和 $z$ ，有 $x \cdot (y + z) = x \cdot y + x \cdot z$ 和 $(x + y) \cdot z = x \cdot z + y \cdot z$ 。

序公理 接下来，我们叙述实数的序公理，它规定了实数集上的“大于”（记作 $\geqslant$ ）的性质。当 $x$ 大于 $y$ 时，我们写成 $x > y$ （和 $y < x$ ；当 $x > y$ 或 $x = y$ 时，我们写成 $x \geqslant y$ （和 $y \leqslant x$ ）。

第一个公理告诉我们，给定两个实数，恰好有三种可能性之一发生：两个数相等；第一个数大于第二个数；第二个数大于第一个数。这就是三分律。

- 三分律 对于所有实数 $x$ 和 $y$ ， $x = y$ 、 $x > y$ 、 $y > x$ 中恰好有一个为真。

接下来的公理称为传递律，它告诉我们，如果第一个数大于第二个数而第二个数又大于第三个数，则第一个数大于第三个数。

- 传递律 对于所有实数 $x$ 、 $y$ 和 $z$ ，如果 if $x > y$ 和 $y > z$ ，则 $x > z$ 。

我们还有两个相容律，它告诉我们当在一个大于关系的两边加上一个数时，大于关系依然成立；当在一个大于关系两边乘上一个正整数（即满足 $x > 0$ 的实数 $x$ ）时，大于关系依然成立。

- 加法相容律 对于所有实数 $x$ 、 $y$ 和 $z$ ，如果 $x > y$ ，则 $x + z > y + z$ 。

- 乘法相容律 对于所有实数 $x$ 、 $y$ 和 $z$ ，如果 $x > y$ 和 $z > 0$ ，则 $x \cdot z > y \cdot z$ 。

我们留给读者(参见练习15)来证明对于所有实数 $x$ 、 $y$ 和 $z$ ，如果 $x > y$ 和 $z < 0$ ，则 $x \cdot z < y \cdot z$ 。即在一个不等式两边乘以一个负实数改变不等式的方向。

实数集的最后一个公理是完备性。在叙述该公里前，还需要一些定义。首先，给定实数的一个非空子集 $A$ ，我们说实数 $b$ 是 $A$ 的一个上界，如果对于 $A$ 中的每个实数 $a$ 有 $b \geqslant a$ 。一个实数 $s$ 是 $A$ 的最小上界，如果 $s$ 是 $A$ 的一个上界且只要 $t$ 是 $A$ 的一个上界时就有 $s \leqslant t$ 。

$\bullet$ 完备性 实数的每个有上界的非空子集均有一个最小上界。

# A.2 利用公理证明基本事实

我们所列的公理可以用来证明许多之前常常引用而又没有显式证明的性质。这里给出一些能用公理证明的结论的例子，而将更多性质的证明留作练习。虽然要证明的结论看似相当明显，但仅用我们给出的公理证明还是富有挑战性的。

定理1 实数的加法单位元0是唯一的。

证明为了证明实数的加法单位元0是唯一的，假设 $0^{\prime}$ 也是一个实数的加法单位元。这意味着当 $x$ 是实数时有 $0^{\prime} + x = x + 0^{\prime} = x$ 。由加法单位元律可得 $0 + 0^{\prime} = 0^{\prime}$ 。因为 $0^{\prime}$ 是加法单位元，所以我们知道 $0 + 0^{\prime} = 0$ 。从而可得 $0 = 0^{\prime}$ ，因为两者均等于 $0 + 0^{\prime}$ 。这就证明了0是实数唯一的加法单位元。

定理2 实数 $x$ 的加法逆是唯一的。

证明 令 $x$ 为实数。假设 $y$ 和 $z$ 均为 $x$ 的加法逆。则，

$$
\begin{array}{l} y = 0 + y \\ = (z + x) + y \\ = z + (x + y) \\ = z + 0 \\ = z \\ \end{array}
$$

由加法单位元律  
因为 $z$ 是 $x$ 的加法逆  
由加法的结合律   
因为 $y$ 是 $x$ 的加法逆  
由加法单位元律。

从而可得 $y = z$ 。

定理1和2告诉我们加法单位元和加法逆是唯一的。定理3和4告诉我们乘法单位元和非零实数的乘法逆也是唯一的。证明留作练习。

定理3 实数的乘法单位元1是唯一的。

定理4 非零实数 $x$ 的乘法逆是唯一的。

定理5 对于每个实数 $x$ ， $x\cdot 0 = 0$ 。

证明 假设 $x$ 是实数。由加法逆律，存在一个实数 $y$ 是 $x \cdot 0$ 的加法逆，所以有 $x \cdot 0 + y = 0$ 。由加法单位元律， $0 + 0 = 0$ 。利用分配律，可知 $x \cdot 0 = x \cdot (0 + 0) = x \cdot 0 + x \cdot 0$ 。从而

可得

$$
0 = x \cdot 0 + y = (x \cdot 0 + x \cdot 0) + y
$$

接下来，注意由加法结合律以及因为 $x\cdot 0 + y = 0$ ，可得

$$
(x \cdot 0 + x \cdot 0) + y = x \cdot 0 + (x \cdot 0 + y) = x \cdot 0 + 0
$$

最后，由加法单位元律，可知 $x\cdot 0 + 0 = x\cdot 0$ 。因此， $x\cdot 0 = 0$

定理6 对于所有实数 $x$ 和 $y$ ，如果 $x\cdot y = 0$ ，则 $x = 0$ 或 $y = 0$ 。

证明 假设 $x$ 和 $y$ 是实数且 $x \cdot y = 0$ 。如果 $x \neq 0$ ，则由乘法逆律， $x$ 有一乘法逆 $1 / x$ 使得 $x \cdot (1 / x) = (1 / x) \cdot x = 1$ 。因为 $x \cdot y = 0$ ，所以由定理5可得 $(1 / x) \cdot (x \cdot y) = (1 / x) \cdot 0 = 0$ 。利用乘法结合律，有 $((1 / x) \cdot x) \cdot y = 0$ 。这意味着 $1 \cdot y = 0$ 。由乘法单位元律，可知 $1 \cdot y = y$ 所以 $y = 0$ 。因此，或者 $x = 0$ 或者 $y = 0$ 。

定理7 实数集的乘法单位元1大于加法单位元0。

证明 由三分律可知， $0 = 1$ ， $0 > 1$ ，或者 $1 > 0$ 。由单位元公理可知， $0 \neq 1$ 。

所以，假设 $0 > 1$ 。我们证明这个假设会导致矛盾。由加法逆律，1有加法逆-1满足 $1 + (-1) = 0$ ；加法相容性告诉我们， $0 + (-1) > 1 + (-1) = 0$ ；加法单位元律告诉我们， $0 + (-1) = -1$ 。因此， $-1 > 0$ ，而由乘法相容性可得， $(-1)\cdot (-1) > (-1)\cdot 0$ 。由定理5，最后一个不等式的右边是0。由分配律可得， $(-1)\cdot (-1) + (-1)\cdot 1 = (-1)\cdot (-1 + 1) = (-1)\cdot 0 = 0$ 。所以，最后这个不等式的左边， $(-1)\cdot (-1)$ ，是-1唯一的加法逆，所以该不等式的左边等于1。因此最后这个不等式变成了 $1 > 0$ ，与三分律矛盾，因为我们已经假设了 $0 > 1$ 。

因为我们知道 $0 \neq 1$ 而 $0 > 1$ 也是不可能的，所以由三分律可得结论 $1 > 0$ 。

接下来的定理告诉我们，对于每个实数都存在一个整数（这里的整数是指0、任意多个1的和，以及这些和的加法逆）大于该实数。这个结论归功于希腊数学家阿基米德。这个结论可以在欧几里得的《Elements》第5卷中找到。

定理8 阿基米德性质 对于每个实数 $x$ 存在一个整数 $n$ ，使得 $n > x$ 。

证明 假设 $x$ 是一个实数，使得对每个整数 $n$ 都有 $n \leqslant x$ 。则 $x$ 是整数集合的一个上界。由完备性可得，整数集合有一个最小上界 $M$ 。因为 $M - 1 < M$ 而 $M$ 是整数集合的最小上界，所以 $M - 1$ 不是整数集合的上界。这意味着存在一个整数 $n$ 满足 $n > M - 1$ 。这蕴含着 $n + 1 > M$ ，与 $M$ 是整数集合的上界矛盾。

# Links

![](90023d07f2e59681a805569230c2e0e4719bd231ceacf4fd12ae2f33ec306059.jpg)  
©Hulton-Deutsch/Hulton-Deutsch Collection/Corbis via Getty Images

阿基米德(Archimedes，公元前287年一公元前212年）阿基米德是古代最伟大的科学家和数学家之一。他出生在叙拉古，一个位于西西里岛的希腊城邦国家。他父亲Phidias是一位天文学家。阿基米德在埃及的亚历山大接受的教育。完成学业后重返叙拉古，并在那里度过终生。很少有人知道他的个人生活，我们甚至不知道他是否结婚生子。公元前212年，罗马人入侵叙拉古时阿基米德被罗马士兵杀害。

阿基米德在几何学上做出了许多重要发现。他在二千多年前所描述的曲线下面积的计算方法被重新发明后成为积分学的一部分。阿基米德还发明了一种方法来表示采用常规希腊方法表达不了的大整数。他发现了计算球体以及其他固体物的体积的方法，他计算了 $\pi$ 的近似值。阿基米德是一位杰出的工程师和发明家。他的抽水机器，现在称为是阿基米德螺旋抽水机，至今还在应用。或许他最著名的发现是浮力原理，它告

诉我们浸入液体中的物体会变轻，变轻的量正好等于它所排开的液体的重量。有些历史故事告诉我们阿基米德是最早的裸奔者，当他有了这个发现时，赤裸着身体在叙拉古的街道上奔跑并高喊“尤里卡”（意思是“我发现了”）。第二次布匿战争时期，他还巧妙地利用机器阻挡了围攻叙拉古的罗马大军好几年。

# A.3 正整数集合的公理

现在要列的公理规定正整数集合作为整数集合的子集必须满足4个关键的性质。在本书中，我们假定这些公理为真。

- 公理1 数1是正整数。  
- 公理2 如果 $n$ 是正整数，则 $n + 1$ ，即 $n$ 的后继，也是正整数。  
- 公理3 每个大于1的正整数是一个正整数的后继。  
- 公理4 良序性 正整数集合的每个非空子集都有一个最小元。

5.1节和5.2节已经证明了良序原理等价于数学归纳法原理。

- 数学归纳法原理 如果 $S$ 是正整数集合使得 $1 \in S$ 且对于所有正整数 $n$ , 如果 $n \in S$ , 则 $n + 1 \in S$ , 则 $S$ 就是正整数集合。

大多数数学家认为实数系统是已经存在的，且实数是满足这个附录里列出的公理。可是，19世纪的数学家开发了一些技术，从最基本的数的集合出发来构造实数集合。（实数构造过程有时候在数学本科生的高级课程中学习。例如，可以在[Mo91]中找到一种处理方式。）过程的第一步是利用公理 $1\sim 3$ 、良序性或数学归纳法公理来构造正整数集合。然后，再定义正整数的加法和乘法。一旦有了定义，可以利用整数序偶的等价类来构造整数集合，其中 $(a,b)\sim (c,d)$ 当且仅当 $a + d = b + c$ 。整数的加法和乘法可以利用这些序偶来定义（参见练习21）。（等价关系和等价类在第9章中讨论了。）接下来，再利用整数序偶的等价类来构造有理数集合，这里序偶中第二个整数不能为零，其中 $(a,b)\approx (c,d)$ 当且仅当 $a\cdot d = b\cdot c$ 。有理数的加法和乘法可以利用这些序偶来定义（参见练习22）。利用无限序列，可以从有理数集合来构造实数集合。有兴趣的读者会发现值得阅读这样构造步骤的更多细节。

# 练习

在你解答这些练习时，给出的证明中只能用到这个附录中的公理和定理。

1. 证明定理3，它叙述实数的乘法单位元是唯一的。  
2. 证明定理4，它叙述对于每个非零实数 $x$ ， $x$ 的乘法逆是唯一的。  
3. 证明对于所有实数 $x$ 和 $y$ ，有 $(-x) \cdot y = x \cdot (-y) = -(x \cdot y)$ 。  
4. 证明对于所有实数 $x$ 和 $y$ ，有 $-(x + y) = (-x) + (-y)$ 。  
5. 证明对于所有实数 $x$ 和 $y$ ，有 $(-x) \cdot (-y) = x \cdot y$ 。  
6. 证明对于所有实数 $x$ 、 $y$ 和 $z$ ，如果 $x + z = y + z$ ，则 $x = y$ 。  
7. 证明对于每个实数 $x$ ，有 $-(-x) = x$ 。

用 $x - y = x + (-y)$ 来定义实数 $x$ 和 $y$ 的差 $x - y$ ，其中 $-y$ 是 $y$ 的加法逆；并用 $x / y = x\cdot (1 / y)$ 来定义商 $x / y$ ，其中 $y\neq 0$ ， $1 / y$ 是 $y$ 的乘法逆。

8. 证明对于所有实数 $x$ 和 $y$ ， $x = y$ 当且仅当 $x - y = 0$ 。  
9. 证明对于所有实数 $x$ 和 $y$ ，有 $-x - y = -(x + y)$ 。  
10. 证明对于所有非零实数 $x$ 和 $y$ , $1 / (x / y) = y / x$ , 其中 $1 / (x / y)$ 是 $x / y$ 的乘法逆。  
11. 证明对于所有实数 $w, x, y$ 和 $z$ ，如果 $x \neq 0$ 且 $z \neq 0$ ，则 $(w / x) + (y / z) = (w \cdot z + x \cdot y) / (x \cdot z)$ 。  
12. 证明对于每个正实数 $x$ ， $1/x$ 也是一个正实数。  
13. 证明对于所有正实数 $x$ 和 $y$ , $x \cdot y$ 也是一个正实数。  
14. 证明对于所有实数 $x$ 和 $y$ ，如果 $x > 0$ 且 $y < 0$ ，则 $x \cdot y < 0$ 。  
15. 证明对于所有实数 $x$ 、 $y$ 和 $z$ ，如果 $x > y$ 且 $z < 0$ ，则 $x \cdot z < y \cdot z$ 。  
16. 证明对于每个实数 $x$ ， $x \neq 0$ 当且仅当 $x^2 > 0$ 。  
17. 证明对于所有实数 $w, x, y$ 和 $z$ ，如果 $w < x$ 且 $y < z$ ，则 $w + y < x + z$ 。  
18. 证明对于所有正实数 $x$ 和 $y$ ，如果 $x < y$ ，则 $1 / x > 1 / y$ 。  
19. 证明对于每个正实数 $x$ ，存在一个正整数 $n$ 使得 $n \cdot x > 1$ 。

* 20. 证明每两个不同的实数之间存在一个有理数（即具有 $x / y$ 形式的数，其中 $x$ 和 $y$ 是整数且 $y \neq 0$ ）。练习21和22涉及本书第9章中讨论的等价关系的概念。  
*21. 定义正整数序偶集合上的关系～如下： $(w, x) \sim (y, z)$ 当且仅当 $w + z = x + y$ 。证明运算 $[(w, x)]_{\sim} + [(y, z)]_{\sim} = [(w + y, x + z)]_{\sim}$ 和 $[(w, x)]_{\sim} \cdot [(y, z)]_{\sim} = [(w \cdot y + x \cdot z, x \cdot y + w \cdot z)]_{\sim}$ 是良定义的，即它们不依赖于计算所选取的等价类的代表元。  
*22. 定义整数序偶(第二个元素非零)上的关系 $\approx$ 如下： $(w, x) \approx (y, z)$ 当且仅当 $w \cdot z = x \cdot y$ 。证明运算 $[(w, x)]_{\approx} + [(y, z)]_{\approx} = [(w \cdot z + x \cdot y, x \cdot z)]_{\approx}$ 和 $[(w, x)]_{\approx} \cdot [(y, z)]_{\approx} = [(w \cdot y, x \cdot z)]_{\approx}$ 是良定义的，即它们不依赖于计算所选取的等价类的代表元。

# 指数与对数函数

在这个附录中我们将回顾指数函数和对数函数的一些基本性质。这些性质全书都会用到。需要进一步了解这些方面的学生可以参考初等数学或微积分的书籍，例如在推荐读物中提到的那些书籍。

# B. 1 指数函数

令 $n$ 是正整数， $b$ 是一个固定的正实数。函数 $f_{b}(n) = b^{n}$ 定义为

$$
f _ {b} (n) = b ^ {n} = b \cdot b \cdot b \cdot \dots \cdot b
$$

这里等式右边是 $n$ 个 $b$ 相乘。

我们可以用微积分中的技术对于所有实数 $x$ 来定义函数 $f_{b}(x) = b^{x}$ 。函数 $f_{b}(x) = b^{x}$ 称为是以 $b$ 为底的指数函数。这里我们不讨论当 $x$ 不是整数时如何计算以 $b$ 为底的指数函数的值。

指数函数所满足的两个重要性质由定理1给出。其证明和相关性质可以在微积分教材中找到。

定理1 令 $b$ 是一个正实数， $x$ 和 $y$ 是实数。则

1) $b^{x + y} = b^x b^y$ ，且  
2) $(b^{x})^{y} = b^{xy}$

某些指数函数的函数图如图1所示。

![](0ae8e172dfb025af3384e35090cc84a4c890e4af6382d34d6202f2337976b448.jpg)  
图1 以 $1 / 2$ 、2和5为底的指数函数图

# B. 2 对数函数

假设 $b$ 是一个实数， $b > 1$ 。则指数函数 $b^{x}$ 是严格递增的（在微积分中已证的事实）。这是一个从实数集到非负实数集的一个一一对应。因此，这个函数具有逆函数 $\log_b x$ ，称为以 $b$ 为底的对数函数。换言之，如果 $b$ 是一个大于 1 的实数而 $x$ 是一个正实数，则

$$
b ^ {\log_ {b} x} = x
$$

这个函数在 $x$ 点的值称为是以 $b$ 为底 $x$ 的对数。

由定义可得

$$
\log_ {b} b ^ {x} = x
$$

定理2给出了对数函数的一些重要性质。

定理2 令 $b$ 是大于1的实数。则

1） $\log_b(xy) = \log_bx + \log_by$ ，当 $x$ 和 $y$ 是正实数时，且  
2) $\log_b(x^y) = y\log_bx$ ，当 $x$ 是正实数而 $y$ 是实数时。

证明 因为 $\log_b(xy)$ 是满足 $b^{\log_b(xy)} = xy$ 的唯一实数，所以为证明第1部分只要证明 $b^{\log_b x + \log_b y} = xy$ 即可。由定理1的第1部分，有

$$
\begin{array}{l} b ^ {\log_ {b} x + \log_ {b} y} = b ^ {\log_ {b} x} b ^ {\log_ {b} y} \\ = x y \\ \end{array}
$$

为证明第2部分，只要证明 $b^{y \log_b x} = x^y$ 即可。由定理1的第2部分，有

$$
\begin{array}{l} b ^ {y \log_ {b} x} = (b ^ {\log_ {b} x}) ^ {y} \\ = x ^ {y} \\ \end{array}
$$

下面的定理将两个不同底的对数联系起来。

定理3对数底的转换公式令 $a$ 和 $b$ 是大于1的实数，令 $\mathcal{X}$ 是正实数。则

$$
\log_ {a} x = \log_ {b} x / \log_ {b} a
$$

证明 为了证明这个结果，只需要证明

$$
b ^ {\log_ {a} x \cdot \log_ {b} a} = x
$$

即可。由定理1的第2部分，有

$$
\begin{array}{l} b ^ {\log_ {a} x \cdot \log_ {b} a} = (b ^ {\log_ {b} a}) ^ {\log_ {a} x} \\ = a ^ {\log_ {a} x} \\ = x. \\ \end{array}
$$

得证。

因为本书中对数最常用的底是 $b = 2$ ，所以本书通篇将用记号 $\log x$ 来记 $\log_2x$ 。

函数 $f(x) = \log x$ 的图如图2所示。根据定理3，当底数 $b$ 不是2时，可以得到一个函数 $(1 / \log b)\log x$ ，即函数 $\log x$ 的常量倍数。

![](56ef3716e0e1bd249b86839ceeb67d61e28607570e6ad6da0cfb17ecee89448e.jpg)  
图2 $f(x) = \log x$ 的图

# 练习

1. 将下列数量表达为 2 的幂次。

a) $2\cdot 2^{2}$

b) $(2^{2})^{3}$

c) $2^{(2^2)}$

2. 计算下列各值。

a) $\log_21024$

b) $\log_21 / 4$

c)log48

3. 假设 $\log_4 x = y$ ，其中 $x$ 是一个正实数。计算下列各值。

a) $\log_2x$

b) $\log_8 x$

c) $\log_{16}x$

4. 令 $a, b$ 和 $c$ 是正实数。证明 $a^{\log_b c} = c^{\log_b a}$

5. 对于所有实数 $x$ ，画出 $f(x) = b^{x}$ 的函数图，如果 $b$ 取值为

a)3

b)1/3

c)1

6. 对于正实数 $x$ ，画出 $f(x) = \log_b x$ 的函数图，如果 $b$ 取值为

a)4

b)100

c)1000

# 伪代码

本书中的算法采用自然语言和伪代码描述。伪代码是介于过程步骤的自然语言描述和用实际编程语言描述过程的规范之间的一种中间体。采用伪代码的优势包括书写和理解的简单性以及容易从伪代码生成实际(各类编程语言的)计算机代码。这里描述我们使用的伪代码中特定类型的语句或高级指令。伪代码中每条语句可以翻译成某种特定编程语言的一条或多条语句，这些语句有的可以翻译成一条或多条（很可能是很多）计算机的低级指令。

该附录描述本书使用的伪代码的格式和语法。伪代码的设计目标是其基本结构类似于常用编程语言中的结构，如目前教学中最常用的 $\mathrm{C}++$ 和Java。然而，我们用的伪代码会比正式编程语言更宽松些，因为我们将允许使用自然语言的步骤描述。

该附录并不是为了做形式化研究。相反，只是为学生在学习本书中给出的算法描述以及当他们要用伪代码来完成练习时作为一种参考指南。

# C. 1 过程语句

算法的伪代码以一个过程语句开始，给出算法的名称、列出输入变量、描述每个输入变量的类型。例如，语句

procedure maximum(L: 整数列表)

就是算法的伪代码描述的第一条语句，该算法起名为 maximum，它找出整数列表 L 中的最大值。

# C. 2 赋值和其他类型的语句

赋值语句用来将值赋给变量。在赋值语句中左边是变量名而右边是一个可能涉及常量、已经被赋值的变量或过程中定义的函数的表达式。右边可以包含任何普通的算术运算。可是，在本书的伪代码中，它可以包含任何良定义的运算，即使这个运算只有在实际编程语言中用许多条语句才能实现。

符号：=用于表示赋值。这样，赋值语句具有下列形式：

变量 $\coloneqq$ 表达式

例如，语句

$$
\max  := a
$$

将 $a$ 的值赋给变量 $\max$ 。像下面这样的语句

$x\coloneqq$ 列表 $L$ 中的最大整数

也是可以使用的。它将 $x$ 设置成列表 $L$ 中的最大整数。要将这条语句翻译成实际编程语言时可能需要用到多条语句。另外，指令

交换 $a$ 和 $b$

可以用来交换 $a$ 和 $b$ 。我们也可以用若干条语句来表达这一条语句(参见练习2)，但是为了简单，我们经常首选采用这种简化的伪代码形式。

# C. 3 注释

在本书的伪代码中，花括号内的语句不会被执行。这样的语句用作注释或提醒以便解释过程是如何工作的。例如，语句

$\{x$ 是 $L$ 中的最大元素 $\}$

可以用来提醒读者在过程执行到这一点时变量 $x$ 等于列表 $L$ 中的最大元素。

# C. 4 条件结构

我们会用到的条件结构的最简单形式是

```txt
if条件then语句 
```

或

if条件then

一组语句

这里，检查条件，如果为真，则执行给出的语句或一组语句。特别是，伪代码

if条件then

语句1

语句2

语句3

中

语句 $n$

告诉我们如果条件为真，一组语句中的语句是按顺序执行的。

例如，3.1节的算法1，找出整数集合中的最大元，我们使用条件语句来检查对于每个变量是否 $\max < a_{i}$ 。如果是，则将 $a_{i}$ 的值赋给 $\max$ 。

通常，我们需要使用更为一般的结构。当我们希望在指定条件为真时做一件事，而为假时做另一件事时就要用到这样的结构。我们使用结构

if条件then语句1

else语句2

注意语句1和语句2中的一条或两条可以替换为一组语句。

有时，我们需要用更为通用的条件语句形式。条件结构的通用形式是

if条件1then语句1

else if条件2then语句2

else if条件3then语句3

中

else if条件 $n$ then语句 $n$

else语句 $n + 1$

当使用这个结构时，如果条件1为真，则执行语句1，然后程序退出该结构。另外，如果条件1为假，程序检查条件2，如果为真，则执行语句2，等等。这样，如果前面 $n - 1$ 个条件没有一个成立，但是条件 $n$ 成立，则执行语句 $n$ 。最后，如果条件1、条件2、…、条件 $n$ 中没有一个为真，则执行语句 $n + 1$ 。注意 $n + 1$ 条语句中的任何一个均可以替换成一组语句。

# C. 5 循环结构

本书中的伪代码有两种类型的循环结构。第一个是“for”结构，它具有下列形式

for变量：=初值 to 终值 语句

或

for变量：=初值 to 终值一组语句

其中初值和终值是整数。这里，循环开始时，如果初值小于等于终值，就将初值赋给变量，然后用变量的这个值执行这个结构后面的语句。然后变量加1，用变量的这个新值执行语句或一组语句。重复这一过程直到变量等于终值为止。在用等于终值的变量执行指令后，算法进入下一个语句。当初值大于终值时，循环中的语句不会被执行。

我们可以用“for”循环结构来找出正整数1到 $n$ 的总和，伪代码如下。

sum $:=0$ for $i:=1$ to $n$ sum $:=\mathrm{sum}+i$

另外，本书还会用到更为通用的“for”语句，形式如下：

for所有具有某种性质的元素

这意味着接下来的语句或一组语句会针对具有某种性质的元素被连续执行。

我们将使用的第二类循环结构是“while”结构。具有下列形式：

while条件语句

或

while条件一组语句

当使用这种结构时，检查给定的条件，如果为真，则执行后面的语句，这可能会影响作为条件的一部分变量的值。当这些指令执行后，如果条件依然为真，再次执行这些指令。重复这一过程直到条件变成假为止。作为一个例子，我们可以用下列一组包含“while”结构的伪代码找出整数1到 $n$ 的总和。

sum $: = 0$ while $n > 0$ sum $\coloneqq$ sum+n $n\coloneqq n - 1$

注意任何“for”结构都可以转换成一个“while”结构（参见练习3）。可是，通常理解“for”结构更容易些。所以，当有可能时，我们优先使用“for”结构而不是相应的“while”结构。

# C.6 嵌套循环

循环或条件语句中经常会用到其他循环或条件语句。本书所用的伪代码中，我们采用连续的缩进来表示嵌套的循环，这就是循环中的循环，以及哪个语句组对应哪个循环。

# C.7 过程中使用过程

我们可以在一个过程中使用另一个过程（或者在递归程序中使用自身），只需简单地写出另一过程的名称，加上过程的输入。例如，

```txt
max(L) 
```

用输入列表 $L$ 来执行max过程。当那个过程的所有步骤执行完毕后，继续执行本过程中的下一条语句。

# C. 8 返回语句

我们用一个return语句来说明一个过程在什么地方产生输出。return语句具有下列形式

return $x$

产生 $x$ 当前值作为输出。输出 $x$ 可以涉及一个或多个函数的值，包括正在计算中的同一个函数，但位于更小处的值。例如，语句

return $f(n - 1)$

用来以 $n - 1$ 为输入调用该算法。这意味着用等于 $n - 1$ 的输入再次运行该算法。

# 练习

1. 下列两个赋值语句构成的语句组有什么区别？

$a:=b$ $b:=c$ $b:=c$ 和 $a:=b$

2. 给出一个过程，利用赋值语句来交换变量 $x$ 和 $y$ 的值。为此，最少需要多少个赋值语句？

3. 证明下列形式的循环

for $i\coloneqq$ 初值to终值

语句

可以写成“while”结构。

# 推荐读物

可供更深入学习本书相关主题的资源有印刷品和相关网站。印刷品就在本节描述。阅读材料按章节列出并按特定主题介绍。特别值得一提的还有一些通用的参考文献。罗森(Rosen)撰写的《离散和组合数学手册》(Hand book of Discrete and Combinatorial Mathematics)[Ro00]是一本综合性的参考书，你会发现这是一本特别有用的书。关于离散数学应用的更多详情可以在Michaels和Rosen的[MiRo91]中找到，这个在本书的配套网站上也有在线版。关于计算机科学的许多主题，也包括本书讨论的主题的更深入论述可参考Gruska的[Gr97]。本书中提到的许多数学家和计算机科学家的传记信息可以在Gillispie[Gi70]和MacTutor网站(http://www-history.mcs.st-and.ac.uk/)上找到。

要寻找相关的网站，可以参考本书配套网站上网络资源指南中给出的链接。配套网站的地址是 www.mhhe.com/rosen。

# 第1章

一个有趣的学习逻辑的方法是阅读LewisCarroll的书[Ca78]。逻辑的一般性参考文献包括M.Huth和M.Ryan的[HuRy04]、Mendelson的[Me09]、Stoll的[St74]以及Suppes的[Su87]。关于离散数学中逻辑的综述性文献可参见Gries和Schneider的[GrSc93]。系统规范说明的讨论可参见Ince的[In93]。Smullyan的骑士和无赖谜题在[Sm78]中有介绍。他撰写了许多有趣的关于逻辑谜题的书，包括[Sm92]和[Sm98]。Prolog语言在Nilsson和Maluszynski的[NiMa95]以及Clocksin和Mellish的[ClMe94]中有深入的讨论。证明的基本方法可参见Cupillari的[Cu05]、Morash的[Mo91]、Solow的[So09]、Velleman的[Ve06]和Wolf的[Wo98]。构造证明的科学方法和技巧在Pólya的三本书[Po62]、[Po71]和[Po90]中有非常有意思的讨论。涉及使用多米诺和多联多米诺骨牌来拼接棋盘问题的讨论可参见Golomb的[Go94]和Martin的[Ma91]。

# 第2章

Lin和Lin的[LiLi81]是一本易读的关于集合及其应用的教科书。集合论的公理化发展可以参见Halmos的[Ha60]、Monk的[Mo69]、Pinter的[Pi14]和Stoll的[St74]。Brualdi的[Br09]，以及Reingold、Nievergelt和Deo的[ReNiDe77]包含了多重集的介绍。模糊集及其在专家系统和人工智能方面的应用在Negoita的[Ne85]和Zimmerman的[Zi91]中有论述。微积分方面的书籍，如Apostol的[Ap67]、Spivak的[Sp94]，以及Thomas和Finney[ThFi96]，包含对函数的讨论。关于整数序列的最好的书是Sloan和Plouffe的[S1Pl95]。关于证明的书籍，如[Ve06]，通常会有某种程度的可数性论述。Stanat和McAllister的[StMc77]有一完整章节论述可数性。Aigner和Ziegler的[AiZi14]的第17章给出了关于基数和连续统假设的非常好的讨论。关于计算机科学所需数学基础的讨论可参见Arbib、Kfoury和Moll的[ArKfMo80]、Bobrow和Arbib的[BoAr74]、Beckman的[Be80]，以及Tremblay和Manohar的[TrMa75]。矩阵及其运算在所有线性代数书籍中都有论述，如Curtis的[Cu84]和Strang的[St09]。

# 第3章

Knuth的[Kn77]和Wirth的[Wi84]是关于算法主题最易理解的入门文章。算法入门的最佳书籍有Cormen、Leierson、Rivest和Stein的[CoLeRiSt09]以及Kleinberg和Tardos的[KlTa05]。关于函数大 $O$ 估算的更广泛的资料可参见Knuth的[Kn97a]。关于算法及其复杂度的一般性参考文献包括Aho、Hopcroft和Ullman的[AhHoUl74]，Baase和VanGelder的[BaGe99]，Cormen、Leierson、Rivest和Stein的[CoLeRiSt09]，Gonnet的[Go84]，Goodman和

Hedetniemi 的 [GoHe77], Harel 的 [Ha87], Horowitz 和 Sahni 的 [HoSa82], Kreher 和 Stinson 的 [KrSt98], Knuth 撰写的关于计算机程序设计技巧的著名的系列丛书 [Kn97a]、[Kn97b] 和 [Kn98], Kronsjö 的 [Kr87], Levitin 的 [Le06], Manber 的 [Ma89], Pohl 和 Shaw 的 [PoSh81], Purdom 和 Brown 的 [PuBr85], Rawlins 的 [Ra92], Sedgewick 的 [Se03], Wilf 的 [Wi02], 以及 Wirth 的 [Wi76]。排序和搜索算法及其复杂度的深入研究可参见 Knuth 的 [Kn98]。

# 第4章

关于数论的参考文献包括 Hardy 和 Wright 的 [HaWrWiHe08], LeVeque 的 [Le77], Rosen [Ro10], 以及 Stark 的 [St78]。更多有关数论的历史可参见 Ore[Or88]。计算机算术的算法讨论在 Knuth 的 [Kn97b] 以及 Pohl 和 Shaw 的 [PoSh81] 中有讨论。更多关于寻找素数和因子分解算法的信息可参见 Crandall 和 Pomerance 的 [CrPo10]。数论在密码学中的应用可参见 Denning 的 [De82], Menezes、vanOorschot 和 Vanstone 的 [MeOoVa97], Rosen 的 [Ro10], Seberry 和 Pieprzyk 的 [SePi89], Sinkov 的 [Si66], 以及 Stinson 的 [St05]。Rivest、Shamir 和 Adleman 在 [RiShAd78] 中描述了 RSA 公共密钥系统。有关 Cocks 的发现可参见 [Si99], 这也提供了关于密码学历史的一个有趣的故事。

# 第5章

数学归纳法的入门介绍可参见[Gu10]和Sominskii的[So61]。全面介绍数学归纳法和递归定义的书籍包括Liu的[Li85]，Sahni的[Sa85]，Stanat和McAllister的[StMc77]，以及Tremblay和Manohar的[TrMa75]。计算几何在[DeOr11]和[Or00]中有论述。1928年，由W.Ackermann引入的Ackermann函数出现在递归函数论中（例如，参见Beckman的[Be80]和McNaughton的[Mc82])以及某些集合论算法的复杂度分析中(参见Tarjan的[Ta83])。递归论的研究可参见Roberts的[Ro86]，Rohl的[Ro84]，以及Wand的[Wa80]。程序正确性以及用来证明程序正确的推理机的有关讨论可参考Alagic和Arbib[AlAr78]，Anderson的[An79]，Backhouse的[Ba86]，Sahni的[Sa85]，以及Stanat和McAllister的[StMc77]。

# 第6章

计数技术及其应用的一般性参考文献包括Allenby和Slomson的[AlSl10]，Anderson的[An89]，Berman和Fryer的[BeFr72]，Bogart的[Bo00]，Bona的[Bo07]，Bose和Manvel的[BoMa86]，Brualdi的[Br09]，Cohen的[Co78]，Grimaldi的[Gr03]，Gross的[Gr07]，Liu的[Li68]，Pólya、Tarjan和Woods的[PoTaWo83]，Riordan的[Ri58]，Roberts和Tesman的[RoTe03]，Tucker的[Tu06]，以及Williamson的[Wi85]。Vilenkin的[Vi71]包含了一组组合问题及解答。一组更难一些的组合问题可参见Lovasz的[Lo79]。关于IP地址和数据报的相关信息可参Comer的[Co05]。鸽巢原理的应用可参见Brualdi的[Br09]，Liu的[Li85]，以及Roberts和Tesman的[RoTe03]。一组广泛的组合恒等式可以在Riordan的[Ri68]以及Benjamin和Quinn的[BeQu03]中找到。组合算法，包括生成排列和组合的算法，在Even的[Ev73]，Lehmer的[Le64]，以及Reingold、Nievergelt和Deo的[ReNiDe77]中有描述。

# 第7章

离散概率论的一些有用的参考文献包括Feller的[Fe68]，Nabin的[Na00]，以及Ross的[Ro09a]。Ross的[Ro02]侧重于概率论在计算机科学中的应用，给出了许多平均情形复杂度分析的例子，并涵盖了随机方法。Aho和Ullman的[AhUl95]有对概率论在计算机科学中的重要的多方面论述，其中包括概率论的编程应用。随机方法的讨论占据了Aigner和Ziegler[AiZi14]中一章的篇幅，该书是一部专著，致力于聪敏、有启发和漂亮的证明，也就是Paul Erdős所描述的来自《天书》(The Book)的证明。随机方法更广泛的论述可参见Alon和Spencer的[AlSp00]。Bayes定理在[PaPi01]中有论述。更多有关垃圾邮件过滤的资料可以在[Zd05]中找到。

# 第8章

利用递推关系建立不同的模型可参见Roberts和Tesman的[RoTe03]以及Tucker的[Tu06]。常系数线性齐次递推关系和相关的非齐次递推关系的完整讨论可参见Brualdi的[Br09], Liu的[Li68], 以及Mattson的[Ma93]。分而治之算法及其复杂度分析在Roberts和Tesman的[RoTe03]以及Stanat和McAllister的[StMc77]中有论述。整数和矩阵的快速乘法的描述可以在Aho、Hopcroft和Ullman的[AhHoUl74]以及Knuth的[Kn97b]中找到。关于生成函数的一个非常好的介绍可参见Polya、Tarjan和Woods的[PoTaWo83]。生成函数的深入研究可参考Brualdi的[Br09], Cohen的[Co78], Graham、Knuth和Patashnik的[GrKnPa94], Grimaldi的[Gr03], 以及Roberts和Tesman的[RoTe03]。更多容斥原理的应用可参见Liu的[Li85]和[Li68], Roberts和Tesman的[RoTe03], 以及Ryser的[Ry63]。

# 第9章

关系（包括等价关系和偏序关系）的一般性参考文献有Bobrow和Arbib的[BoAr74]，Grimaldi的[Gr03]，Sanhi的[Sa85]，以及Tremblay和Manohar的[TrMa75]。Date的[Da82]以及Aho和Ullman的[AhUl95]给出了关于数据库关系模型的讨论。Roy和Warshall撰写的寻找传递闭包的原始论文可分别在[Ro59]和[Wa62]中找到。有向图的研究可参见Chartrand、Lesniak和Zhang的[ChLeZh05]，Gross和Yellen的[GrYe05]，Robinson和Foulds的[RoFo80]，Roberts和Tesman的[RoTe03]，以及Tucker的[Tu06]。格在信息流中的应用在Denning的[De82]中有讨论。

# 第10章

图论的一般性参考文献包括 Agnarsson 和 Greenlaw 的 [AgGr06]、Aldous、Wilson 和 Best 的 [AlWiBe00]，Behzad 和 Chartrand 的 [BeCh71]，Chartrand、Lesniak 和 Zhang 的 [ChLeZh05]，Chartrand 和 Zhang 的 [ChZh04]，Bondy 和 Murty 的 [BoMu10]，Chartrand 和 Oellermann 的 [ChOe93]，Graver 和 Watkins 的 [GrWa77]，Roberts 和 Tesman 的 [RoTe03]，Tucker 的 [Tu06]，West 的 [We00]，Wilson 的 [Wi85]，以及 Wilson 和 Watkins 的 [WiWa90]。图论的大量应用可参见 Chartrand 的 [Ch77]，Deo 的 [De74]，Foulds 的 [Fo92]，Roberts 和 Tesman 的 [RoTe03]，Roberts 的 [Ro76]，Wilson 和 Beineke 的 [WiBe79]，以及 McHugh 的 [Mc90]。利用图论研究社交网络及其他类型网络的深入讨论可参见 Easley 和 Kleinberg 的 [EaKl10] 以及 Newman 的 [Ne10]。涉及大图 (包括 Web 图) 的应用可参见 Hayes 的 [Ha00a] 和 [Ha00b]。图论算法的综述性描述可参见 Gibbons 的 [Gi85] 以及 Kocay 和 Kreher 的 [KoKr04]。图论算法的其他文献包括 Buckley 和 Harary 的 [BuHa90]，Chartrand 和 Oellermann 的 [ChOe93]，Chachra、Ghare 和 Moore 的 [ChGhMo79]，Even 的 [Ev73] 和 [Ev79]，Hu 的 [Hu82]，以及 Reingold、Nievergelt 和 Deo 的 [ReNiDe77]。欧拉关于哥尼斯堡七桥问题的原始论文的翻译版可在 Euler 的 [Eu53] 中找到。Dijkstra 算法的研究可参见 Gibbons 的 [Gi85]，Liu 的 [Li85]，以及 Reingold、Nievergelt 和 Deo 的 [ReNiDe77]。Dijkstra 原始论文可在 [Di59] 中找到。Kuratowski 定理的证明可在 Harary 的 [Ha69] 和 Liu 的 [Li68] 中找到。图的交叉数和厚度的研究可参见 Chartrand、Lesniak 和 Zhang 的 [ChLeZh05]。图着色和四色定理的文献可参考 Barnette 的 [Ba83] 以及 Saaty 和 Kainen 的 [SaKa86]。四色定理最初的攻克在 Appel 和 Haken 的 [ApHa76] 中有记录。图着色的应用在 Roberts 和 Tesman [RoTe03] 中有描述。图论的历史可参考 Biggs、Lloyd 和 Wilson 的 [BiLlWi86]。并行处理的互联网络在 Akl 的 [Ak89] 以及 Siegel 和 Hsu 的 [SiHs88] 中有讨论。

# 第11章

树的研究可参见Deo的[De74]，Grimaldi的[Gr03]，Knuth的[Kn97a]，Roberts和Tesman的[RoTe03]，以及Tucker的[Tu06]。树在计算机科学中的应用在Gotlieb和Gotlieb的[GoGo78]，Horowitz和Sahni的[HoSa82]，以及Knuth的[Kn97a，98]中均有描述。

Roberts和Tesman的[RoTe03]讨论了树在许多不同领域中的应用。组合博弈论的研究参见[AlNoWo07]、[BeCoGu01]和[Bel]前缀码和哈夫曼编码可参见Hamming的[Ha80]。回溯是一种古老的技术，Lucas在1891年撰写的书[Lu91]中就有用它来求解maze谜题。如何利用回溯技术求解问题的广泛讨论可参见Reingold、Niewergelt和Deo的[ReNiDe77]。Gibbons的[Gi85]以及Reingold、Niewergelt和Deo的[ReNiDe77]包含生成树和最小生成树的构造算法的讨论。寻找最小生成树算法的背景及历史可参见Graham和Hell的[GrHe85]。Prim和Kruskal分别在[Pr57]和[Kr56]中描述了他们寻找最小生成树的算法。Sollin的算法是一个非常适合并行处理的算法例子，虽然Sollin从未发表过算法，但他的算法在Even的[Ev73]以及Goodman和Hedetniemi的[GoHe77]中均有描述。

# 第12章

布尔代数的研究可参见Hohn的[Ho66]，Kohavi的[Ko86]，以及Tremblay和Manohar的[TrMa75]。布尔代数在逻辑电路和开关电路中的应用在Hayes的[Ha93]，Hohn的[Ho66]，Katz和Borriello的[KaBo04]，以及Kohavi的[Ko86]中均有描述。用图来研究积之和表达式的极小化的原始论文是Karnaugh的[Ka53]以及Veitch的[Ve52]。Quine-McCluskey方法的介绍可参见McCluskey的[Mc56]以及Quine的[Qu52]和[Qu55]。阈值函数的讨论参见Kohavi的[Ko86]。

# 第13章

形式语法、自动机理论和计算理论的一般性参考文献包括 Davis、Sigal 和 Weyuker 的 [DaSiWe94]，Denning、Dennis 和 Qualitz 的 [DeDeQu81]，Hopcroft、Motwani 和 Ullman 的 [HoMoUl06]，Hopkin 和 Moss 的 [HoMo76]，Lewis 和 Papadimitriou 的 [LePa97]，McNaughton 的 [Mc82]，以及 Sipser 的 [Si06]。米勒机和摩尔机最早由 Mealy [Me55] 以及 Moore [Mo56] 引入。Kleene 定理的原始证明可以在 [Kl56] 中找到。功能强大的计算模型，包括下推自动机和图灵机，在 Brookshear 的 [Br89]，Hennie 的 [He77]，Hopcroft 和 Ullman 的 [HoUl79]，Hopkin 和 Moss 的 [HoMo76]，Martin 的 [Ma03]，Sipser 的 [Si06]，以及 Wood 的 [Wo87] 中均有讨论。Barwise 和 Etchemendy 的 [BaEt93] 是很好的图灵机入门读物。关于图灵机及相关机器的历史和应用的有趣文章可在 Herken 的 [He88] 中找到。忙碌海狸机最早由 Rado 在 [Ra62] 中提出，有关信息可参见 Dewdney 的 [De84] 和 [De93]，Herken 的 [He88] 中 Brady 的论文，以及 Wood 的 [Wo87]。

# 附录

关于实数和整数公理的讨论可参见Morash的[Mo91]。指数和对数函数的详细处理可参考微积分书籍，如Apostol的[Ap67]，Spivak的[Sp94]，以及Thomas和Finney的[ThFi96]。Pohl和Shaw的[PoSh81]使用了具有附录C中所描述的同样特性的伪代码形式。大多数关于算法的书籍，如Cormen、Leierson、Rivest和Stein的[CoLeRiSt09]以及Kleinberg和Tardos的[KlTa05]，都会使用一种与本书伪代码类似的伪代码版本。

# 参考文献

[AgGr06] G. Agnarsson and R. Greenlaw, Graph Theory: Modeling, Applications, and Algorithms, Prentice Hall, Englewood Cliffs, NJ, 2006.   
[Ag15] C. C. Aggarwal, Data Mining, The Textbook, Springer, New York, 2015.   
[AhHoUI74] A. V. Aho, J. E. Hopcroft, and J. D. Ullman, The Design and Analysis of Computer Algorithms, Addison-Wesley, Reading, MA, 1974.   
[AhUI95] Alfred V. Aho and Jeffrey D. Ullman, Foundations of Computer Science, C Edition, Computer Science Press, New York, 1995.   
[AiZi14] Martin Aigner and Gunter M. Ziegler, Proofs from THE BOOK, 5th ed., Springer, Berlin, 2014.   
[Ak89] S. G. Akl, The Design and Analysis of Parallel Algorithms, Prentice Hall, Englewood Cliffs, NJ, 1989.   
[AlAr78] S. Alagic and M. A. Arbib, The Design of Well-Structured and Correct Programs, Springer-Verlag, New York, 1978.   
[AlNoWo07] Michael H. Albert, Richard J. Nowakowski, and David Wolfe, Lessons in Play: An Introduction to Combinatorial Game Theory, A.K. Peters, Natick, MA, 2007.   
[AlWiBe00] J. M. Aldous, R. J. Wilson, and S. Best, Graphs and Applications: An Introductory Approach, Springer, New York, 2000.   
[AlSi10] R.B.J.T. Allenby and A. Slomson, How to Count: An Introduction to Combinatorics, 2d ed., Chapman and Hall/CRC, Boca Raton, Florida, 2010.   
[AlSp00] Noga Alon and Joel H. Spencer, The Probabilistic Method, 2d ed., Wiley, New York, 2000.   
[An89] I. Anderson, A First Course in Combinatorial Mathematics, 2d ed., Oxford University Press, New York, 1989.   
[An79] R. B. Anderson, Proving Programs Correct, Wiley, New York, 1979.   
[Ap67] T. M. Apostol, Calculus, Vol. I, 2d ed., Wiley, New York, 1967.   
[ApHa76] K. Appel and W. Haken, "Every Planar Map Is 4-colorable," Bulletin of the AMS, 82 (1976), 711-712.   
[ArKfMo80] M. A. Arbib, A. J. Kfoury, and R. N. Moll, A Basis for Theoretical Computer Science, Springer-Verlag, New York, 1980.   
[AvCh90] B. Averbach and O. Chein, Problem Solving Through Recreational Mathematics, W.H. Freeman, San Francisco, 1980.   
[BaGe99] S. Baase and A. Van Gelder, Computer Algorithms: Introduction to Design and Analysis, 3d ed., Addison-Wesley, Reading, MA, 1999.   
[Ba86] R. C. Backhouse, Program Construction and Verification, Prentice-Hall, Englewood Cliffs, NJ, 1986.   
[Ba83] D. Barnette, Map Coloring, Polyhedra, and the Four-Color Problem, Mathematical Association of America, Washington, DC, 1983.   
[BaEt93] Jon Barwise and John Etchemendy, Turing's World 3.0 for the Macintosh, CSLI Publications, Stanford, CA, 1993.   
[Be11] József Beck, Combinatorial Games: Tic-Tac-Toe Theory, Cambridge, 2011.   
[Be80] F. S. Beckman, Mathematical Foundations of Programming, Addison-Wesley, Reading, MA, 1980.

[BeCh71] M. Behzad and G. Chartrand, Introduction to the Theory of Graphs, Allyn & Bacon, Boston, 1971.   
[BeQu03] A. Benjamin and J. J. Quine, Proofs that Really Count, Mathematical Association of America, Washington, DC, 2003.   
[Be86] J. Bentley, Programming Pearls, Addison-Wesley, Reading, MA, 1986.   
[BeFr72] G. Berman and K. D. Fryer, Introduction to Combinatorics, Academic Press, New York, 1972.   
[BeCoGu01] Elwyn R. Berlekamp, John H. Conwayk, and Richard K. Guy, Winning Ways for Your Mathematical Plays, Volumes 1-4, 2001-2004.   
[BiLiWi99] N. L. Biggs, E. K. Lloyd, and R. J. Wilson, Graph Theory 1736-1936, Oxford University Press, Oxford, England, 1999.   
[BoAr74] L. S. Bobrow and M. A. Arbib, Discrete Mathematics, Saunders, Philadelphia, 1974.   
[Bo00] K. P. Bogart, Introductory Combinatorics, 3d ed. Academic Press, San Diego, 2000.   
[Bo07] M. Bona, Enumerative Combinatorics, McGraw-Hill, New York, 2007.   
[BoMu10] J. A. Bondy and U. S. R. Murty, Graph Theory with Applications, Springer, New York, 2010.   
[Bo04] P. Bork, L. J. Jensen, C. von Mering, A. K. Ramani, I. Lee, and E. M. Marcotte, "Protein interaction networks from yeast to human," Current Opinion in Structural Biology, 14 (2004), 292-299.   
[BoMa86] R. C. Bose and B. Manvel, Introduction to Combinatorial Theory, Wiley, New York, 1986.   
[Bo14] T. Bousch, “La quatrième tour de Hanoi,” Bulletin of the Belgian Mathematical Society Simon Stevin 21 (2014) 895-912.   
[Bo00] A. Brodera, R. Kumar, F. Maghoula, P. Raghavan, S. Rajagopalan, R. Statac, A. Tomkins, and Janet Wiener, "Graph structure in the Web," Computer Networks, 33 (2000), 309-320.   
[Br89] J. G. Brookshear, Theory of Computation, Benjamin Cummings, Redwood City, CA, 1989.   
[Br09] R. A. Brualdi, Introductory Combinatorics, 5th ed., Prentice-Hall, Englewood Cliffs, NJ, 2009.   
[BuHa90] F. Buckley and F. Harary, Distance in Graphs, Addison-Wesley, Redwood City, CA, 1990.   
[Ca79] L. Carmony, "Odd Pie Fights," Mathematics Teacher 72 (January, 1979), 61-64.   
[Ca78] L. Carroll, Symbolic Logic, Crown, New York, 1978.   
[ChGhMo79] V. Chachra, P. M. Ghare, and J. M. Moore, Applications of Graph Theory Algorithms, North-Holland, New York, 1979.   
[Ch77] G. Chartrand, Graphs as Mathematical Models, Prindle, Weber & Schmidt, Boston, 1977.   
[ChLeZh15] G. Chartrand, L. Lesniak, and P. Zhang, Graphs and Digraphs, 6th ed., Chapman and Hall/CRC, Boca Raton, 2015.   
[ChOe93] G. Chartrand and O. R. Oellermann, Applied Algorithmic Graph Theory, McGraw-Hill, New York, 1993.

[ChZh04] G. Chartrand and P. Zhang, Introduction to Graph Theory, McGraw-Hill, New York, 2004.   
[ClMe94] W. F. Clocksin and C. S. Mellish, Programming in Prolog, 4th ed., Springer-Verlag, New York, 1994.   
[Co78] D. I. A. Cohen, Basic Techniques of Combinatorial Theory, Wiley, New York, 1978.   
[Co05] D. Comer, Internetworking with TCP/IP, Principles, Protocols, and Architecture, Vol. 1, 5th ed., Prentice-Hall, Englewood Cliffs, NJ, 2005.   
[CoLeRiSt09] T. H. Cormen, C. E. Leierson, R. L. Rivest, and C. Stein, Introduction to Algorithms, 3rd ed., MIT Press, Cambridge, MA, 2009.   
[CrPo10] Richard Crandall and Carl Pomerance, 2d ed., Prime Numbers: A Computational Perspective, Springer-Verlag, New York, 2010.   
[Cu05] Antonella Cupillari, The Nuts and Bolts of Proofs, 3d ed., Academic Press, San Diego, 2005.   
[Cu84] C. W. Curtis, Linear Algebra, Springer-Verlag, New York, 1984.   
[Da82] C. J. Date, An Introduction to Database Systems, 3d ed., Addison-Wesley, Reading, MA, 1982.   
[DaSiWe94] M. Davis, R. Sigal, and E. J. Weyuker, Computability, Complexity, and Languages, 2d ed., Academic Press, San Diego, 1994.   
[Da10] T. Davis, "The Mathematics of Selenium," November, 2010, available at http://geometer.org/mathcircles/selenium.pdf   
[De82] D. E. R. Denning, Cryptography and Data Security, Addison-Wesley, Reading, MA, 1982.   
[DeDeQu81] P. J. Denning, J. B. Dennis, and J. E. Qualitz, Machines, Languages, and Computation, Prentice-Hall, Englewood Cliffs, NJ, 1981.   
[De74] N. Deo, Graph Theory with Applications to Engineering and Computer Science, Prentice-Hall, Englewood Cliffs, NJ, 1974.   
[DeOr11] S. L. Devadoss and J. O'Rourke, Discrete and Computational Geometry, Princeton University Press, Princeton, NJ, 2011.   
[De02] K. Devlin, The Millennium Problems: The Seven Greatest Unsolved Mathematical Puzzles of Our Time, Basic Book, New York, 2002.   
[De84] A. K. Dewdney, "Computer Recreations," Scientific American, 251, no. 2 (August 1984), 19-23; 252, no. 3 (March 1985), 14-23; 251, no. 4 (April 1985), 20-30.   
[De93] A. K. Dewdney, The New Turing Omnibus: Sixty-Six Excursions in Computer Science, W. H. Freeman, New York, 1993.   
[Di59] E. Dijkstra, “Two Problems in Connexion with Graphs,” Numerische Mathematik, 1 (1959), 269-271.   
[EaK10] D. Easley and J. Kleinberg, Networks, Crowds, and Markets: Reasoning About a Highly Connected World, Cambridge University Press, New York, 2010.   
[Eu53] L. Euler, “The Koenigsberg Bridges,” Scientific American, 189, no. 1 (July 1953), 66–70.   
[Ev73] S. Even, Algorithmic Combinatorics, Macmillan, New York, 1973.   
[Ev79] S. Even, Graph Algorithms, Computer Science Press, Rockville, MD, 1979.   
[Fe68] W. Feller, An Introduction to Probability Theory and Its Applications, Vol. 1, 3d ed., Wiley, New York, 1968.

[Fo92] L. R. Foulds, Graph Theory Applications, Springer-Verlag, New York, 1992.   
[GaJo79] Michael R. Garey and David S. Johnson, Computers and Intractability: A Guide to NP-Completeness, Freeman, New York, 1979.   
[Gi85] A. Gibbons, Algorithmic Graph Theory, Cambridge University Press, Cambridge, England, 1985.   
[Gi70] C. C. Gillispie, ed., Dictionary of Scientific Biography, Scribner's, New York, 1970.   
[Go94] S. W. Golomb, Polyominoes, Princeton University Press, Princeton, NJ, 1994.   
[Go84] G. H. Gonnet, Handbook of Algorithms and Data Structures, Addison-Wesley, London, 1984.   
[GoHe77] S. E. Goodman and S. T. Hedetniemi, Introduction to the Design and Analysis of Algorithms, McGraw-Hill, New York, 1977.   
[GoGo78] C. C. Gotlieb and L. R. Gotlieb, Data Types and Structures, Prentice-Hall, Englewood Cliffs, NJ, 1978.   
[GrHe85] R. L. Graham and P. Hell, "On the History of the Minimum Spanning Tree Problem," Annals of the History of Computing, 7 (1985), 43-57.   
[GrKnPa94] R. L. Graham, D. E. Knuth, and O. Patashnik, Concrete Mathematics, 2d ed., Addison-Wesley, Reading, MA, 1994.   
[GrRoSp90] Ronald L. Graham, Bruce L. Rothschild, and Joel H. Spencer, Ramsey Theory, 2d ed., Wiley, New York, 1990.   
[GrWa77] J. E. Graver and M. E. Watkins, Combinatorics with Emphasis on the Theory of Graphs, Springer-Verlag, New York, 1977.   
[GrSc93] D. Gries and F. B. Schneider, A Logical Approach to Discrete Math, Springer-Verlag, New York, 1993.   
[Gr03] R. P. Grimaldi, Discrete and Combinatorial Mathematics, 5th ed., Addison-Wesley, Reading, MA, 2003.   
[Gr07] J. L. Gross, Combinatorial Methods with Computer Applications, Chapman and Hall/CRC, Boca Raton, FL, 2007.   
[GrYe05] J. L. Gross and J. Yellen, Graph Theory and Its Applications, 2d ed., CRC Press, Boca Raton, FL, 2005.   
[GrYe03] J. L. Gross and J. Yellen, Handbook of Graph Theory, CRC Press, Boca Raton, FL, 2003.   
[Gr90] Jerrold W. Grossman, Discrete Mathematics: An Introduction to Concepts, Methods, and Applications, Macmillan, New York, 1990.   
[Gr97] J. Gruska, Foundations of Computing, International Thomsen Computer Press, London, 1997.   
[Gu10] D. A. Gunderson, Handbook of Mathematical Induction, Chapman and Hall/CRC, Boca Raton, Florida, 2010.   
[Ha60] P. R. Halmos, Naive Set Theory, D. Van Nostrand, New York, 1960.   
[Ha80] R. W. Hamming, Coding and Information Theory, Prentice-Hall, Englewood Cliffs, NJ, 1980.   
[Ha69] F. Harary, Graph Theory, Addison-Wesley, Reading, MA, 1969.   
[HaWrWiHe08] G. H. Hardy, E. M. Wright, A. Wiles, and R. Heath-Brown, An Introduction to the Theory of Numbers, 6th ed., Oxford University Press, USA, New York, 2008.   
[Ha87] D. Harel, Algorithmics, The Spirit of Computing, Addison-Wesley, Reading, MA, 1987.   
[Ha00a] Brian Hayes, "Graph-Theory in Practice, Part I," American Scientist, 88, no. 1 (2000), 9-13.

[Ha0b] Brian Hayes, "Graph-Theory in Practice, Part II," American Scientist, 88, no. 2 (2000), 104-109.   
[Ha93] John P. Hayes, Introduction to Digital Logic Design Addison-Wesley, Reading, MA, 1993.   
[He77] F. Hennie, Introduction to Computability, Addison-Wesley, Reading, MA, 1977.   
[He88] R. Herken, The Universal Turing Machine, A Half-Century Survey, Oxford University Press, New York; 1988.   
[Ho76] C. Ho, "Decomposition of a Polygon into Triangles," Mathematical Gazette, 60 (1976), 132-134.   
[Ho99] D. Hofstadter, Gödel, Escher, Bach: An Internal Golden Braid, Basic Books, New York, 1999.   
[Ho66] F. E. Hohn, Applied Boolean Algebra, 2d ed., Macmillan, New York, 1966.   
[HoMoU106] J. E. Hopcroft, R. Motwani, and J. D. Ullman, Introduction to Automata Theory, Languages, and Computation 3d ed., Addison-Wesley, Boston, MA, 2006.   
[HoMo76] D. Hopkin and B. Moss, Automata, Elsevier, North-Holland, New York, 1976.   
[HoSa82] E. Horowitz and S. Sahni, Fundamentals of Computer Algorithms, Computer Science Press, Rockville, MD, 1982.   
[Hu82] T. C. Hu, Combinatorial Algorithms, Addison-Wesley, Reading, MA, 1982.   
[Hu07] W. Huber, V. J. Carey, L. Long, S. Falcon, and R. Gentleman, "Graphs in molecular biology," BMC Bioinformatics 8 (Supplement 6) (2007).   
[HuRy04] M. Huth and M. Ryan, Logic in Computer Science, 2d ed., Cambridge University Press, Cambridge, England, 2004.   
[In93] D. C. Ince, An Introduction to Discrete Mathematics, Formal System Specification, and Z, 2d ed., Oxford, New York, 1993.   
[KaMo64] D. Kalish and R. Montague, Logic: Techniques of Formal Reasoning, Harcourt, Brace, Jovanovich, New York, 1964.   
[Ka53] M. Karnaugh, "The Map Method for Synthesis of Combinatorial Logic Circuits," Transactions of the AIEE, part I, 72 (1953), 593-599.   
[KaBo04] R. H. Katz and G. Borriello, Contemporary Logic Design, Prentice-Hall, Englewood Cliffs, NJ, 2004.   
[K156] S. C. Kleene, “Representation of Events by Nerve Nets,” in Automata Studies, 3–42, Princeton University Press, Princeton, NJ, 1956.   
[KlTa05] J. Kleinberg and E. Tardos, Algorithm Design Addison-Wesley, Boston, 2005.   
[Kn77] D. E. Knuth, "Algorithms," Scientific American, 236, no. 4 (April 1977), 63-80.   
[Kn97a] D. E. Knuth, The Art of Computer Programming, Vol. I: Fundamental Algorithms, 3d ed., Addison-Wesley, Reading, MA, 1997.   
[Kn97b] D. E. Knuth, The Art of Computer Programming, Vol. II: Seminumerical Algorithms, 3d ed., Addison-Wesley, Reading, MA, 1997.   
[Kn98] D. E. Knuth, The Art of Computer Programming, Vol. III: Sorting and Searching, 2d ed., Addison-Wesley, Reading, MA, 1998.   
[KoKr04] W. Kocay and D. L. Kreher, Graph Algorithms and Optimization, Chapman and Hall/CRC, Boca Raton, Florida, 2004.

[Ko86] Z. Kohavi, Switching and Finite Automata Theory, 2d ed., McGraw-Hill, New York, 1986.   
[KrSt98] Donald H. Kreher and Douglas R. Stinson, Combinatorial Algorithms: Generation, Enumeration, and Search, CRC Press, Boca Raton, FL, 1998.   
[Kr87] L. Kronsjö, Algorithms: Their Complexity and Efficiency, 2d ed., Wiley, New York, 1987.   
[Kr56] J. B. Kruskal, "On the Shortest Spanning Subtree of a Graph and the Traveling Salesman Problem," Proceedings of the AMS, 1 (1956), 48-50.   
[La10] J. C. Lagarias (ed.), The Ultimate Challenge: The $3x + 1$ Problem, The American Mathematical Society, Providence, 2010.   
[Le06] A. V. Levitin, Introduction to the Design and Analysis of Algorithms, 2d ed., Addison-Wesley, Boston, MA, 2006.   
[Le64] D. H. Lehmer, “The Machine Tools of Combinatorics,” in E. F. Beckenbach (ed.), Applied Combinatorial Mathematics, Wiley, New York, 1964.   
[Le77] W. J. LeVeque, Fundamentals of Number Theory, Addison-Wesley, Reading, MA, 1977.   
[LePa97] H. R. Lewis and C. H. Papadimitriou, Elements of the Theory of Computation, 2d ed., Prentice-Hall, Englewood Cliffs, NJ, 1997.   
[LiLi81] Y. Lin and S. Y. T. Lin, Set Theory with Applications, 2d ed., Mariner, Tampa, FL, 1981.   
[Li68] C. L. Liu, Introduction to Combinatorial Mathematics, McGraw-Hill, New York, 1968.   
[Li85] C. L. Liu, Elements of Discrete Mathematics, 2d ed., McGraw-Hill, New York, 1985.   
[Lo79] L. Lovász, Combinatorial Problems and Exercises, North-Holland, Amsterdam, 1979.   
[Lu91] E. Lucas, Récréations Mathématiques, Gauthier-Villars, Paris, 1891.   
[Ma89] U. Manber, Introduction to Algorithms: A Creative Approach, Addison-Wesley, Reading, MA, 1989.   
[Ma91] G. E. Martin, Polyominoes: A Guide to Puzzles and Problems in Tiling, Mathematical Association of America, Washington, DC, 1991.   
[Ma03] J. C. Martin, Introduction to Languages and the Theory of Computation, 3d ed., McGraw-Hill, New York, 2003.   
[Ma93] H. F. Mattson, Jr., Discrete Mathematics with Applications, Wiley, New York, 1993.   
[Mc56] E. J. McCluskey, Jr., "Minimization of Boolean Functions," Bell System Technical Journal, 35 (1956), 1417-1444.   
[Mc90] J. A. McHugh, Algorithmic Graph Theory, Prentice-Hall, Englewood Cliffs, NJ, 1990.   
[Mc82] R. McNaughton, Elementary Computability, Formal Languages, and Automata, Prentice-Hall, Englewood Cliffs, NJ, 1982.   
[Me55] G. H. Mealy, “A Method for Synthesizing Sequential Circuits,” Bell System Technical Journal, 34 (1955), 1045–1079.   
[Me09] E. Mendelson, Introduction to Mathematical Logic, 5th ed., Chapman and Hall/CRC Press, Boca Raton, 2009.   
[MeOoVa97] A. J. Menezes, P. C. van Oorschoot, S. A. Vanstone, Handbook of Applied Cryptography, CRC Press, Boca Raton, FL, 1997.

[MiRo91] J. G. Michaels and K. H. Rosen, Applications of Discrete Mathematics, McGraw-Hill, New York, 1991.   
[Mo69] J. R. Monk, Introduction to Set Theory, McGraw-Hill, New York, 1969.   
[Mo91] R. P. Morash, Bridge to Abstract Mathematics, McGraw-Hill, New York, 1991.   
[Mo56] E. F. Moore, "Gedanken-Experiments on Sequential Machines," in Automata Studies, 129-153, Princeton University Press, Princeton, NJ, 1956.   
[Na00] Paul J. Nabin, Duelling Idiots and Other Probability Puzzlers, Princeton University Press, Princeton, NJ, 2000.   
[Ne85] C. V. Negoita, Expert Systems and Fuzzy Systems, Benjamin Cummings, Menlo Park, CA, 1985.   
[Ne10] M. Newman, Networks: An Introduction, Oxford University Press, New York, 2010.   
[NiMa95] Ulf Nilsson and Jan Maluszynski, Logic, Programming, and Prolog, 2d ed., Wiley, Chichester, England, 1995.   
[Or00] J. O'Rourke, Computational Geometry in C, Cambridge University Press, New York, 2000.   
[Or63] O. Ore, Graphs and Their Uses, Mathematical Association of America, Washington, DC, 1963.   
[Or88] O. Ore, Number Theory and its History, Dover, New York, 1988.   
[PaPi01] A. Papoulis and S. U. Pillai, Probability, Random Variables, and Stochastic Processes, McGraw-Hill, New York, 2001.   
[Pe87] A. Pelc, "Solution of Ulam's Problem on Searching with a Lie," Journal of Combinatorial Theory, Series A, 44 (1987), 129-140.   
[Pe09] M. S. Petrovic, *Famous Puzzles of Great Mathematicians*, American Mathematical Society, Providence, 2009.   
[Pi14] C. Pinter, A Book of Set Theory, Dover, New York, 2014.   
[PoSh81] I. Pohl and A. Shaw, The Nature of Computation: An Introduction to Computer Science, Computer Science Press, Rockville, MD, 1981.   
[Po62] George Pólya, Mathematical Discovery, Vols. 1 and 2, Wiley, New York, 1962.   
[Po71] George Polya, How to Solve It, Princeton University Press, Princeton, NJ, 1971.   
[Po90] George Polya, Mathematics and Plausible Reasoning, Princeton University Press, Princeton, NJ, 1990.   
[PoTaWo83] G. Polya, R. E. Tarjan, and D. R. Woods, Notes on Introductory Combinatorics, Birkhäuser, Boston, 1983.   
[Pr57] R. C. Prim, "Shortest Connection Networks and Some Generalizations," Bell System Technical Journal, 36 (1957), 1389-1401.   
[PuBr85] P. W. Purdom, Jr. and C. A. Brown, The Analysis of Algorithms, Holt, Rinehart & Winston, New York, 1985.   
[Qu52] W. V. Quine, "The Problem of Simplifying Truth Functions," American Mathematical Monthly, 59 (1952), 521-531.   
[Qu55] W. V. Quine, “A Way to Simplify Truth Functions,” American Mathematical Monthly, 62 (1955), 627-631.   
[Ra62] T. Rado, "On Non-Computable Functions," Bell System Technical Journal (May 1962), 877-884.   
[Ra92] Gregory J. E. Rawlins, Compared to What? An Introduction to the Analysis of Algorithms, Computer Science Press, New York, 1992.

[ReNiDe77] E. M. Reingold, J. Nievergelt, and N. Deo, Combinatorial Algorithms: Theory and Practice, Prentice-Hall, Englewood Cliffs, NJ, 1977.   
[Ri58] J. Riordan, An Introduction to Combinatorial Analysis, Wiley, New York, 1958.   
[Ri68] J. Riordan, Combinatorial Identities, Wiley, New York, 1968.   
[RiShAd78] R. Rivest, A. Shamir, and L. Adleman, "A Method for Obtaining Digital Signatures and Public-Key Cryptosystems," Communications of the Association for Computing Machinery, 31, no. 2 (1978), 120-128.   
[Ro86] E. S. Roberts, Thinking Recursively, Wiley, New York, 1986.   
[Ro76] F. S. Roberts, Discrete Mathematics Models, Prentice-Hall, Englewood Cliffs, NJ, 1976.   
[RoTe03] F. S. Roberts and B. Tesman, Applied Combinatorics, 2d ed., Prentice-Hall, Englewood Cliffs, NJ, 2003.   
[RoFo80] D. F. Robinson and L. R. Foulds, Digraphs: Theory and Techniques, Gordon and Breach, New York, 1980.   
[Ro84] J. S. Rohl, Recursion via Pascal, Cambridge University Press, Cambridge, England, 1984.   
[Ro10] K. H. Rosen, Elementary Number Theory and Its Applications, 6th ed., Pearson, Boston, 2010.   
[Ro18] K. H. Rosen, Handbook of Discrete and Combinatorial Mathematics, 2d ed., CRC Press, Boca Raton, FL, 2018.   
[Ro09] Jason Rosenhouse, The Monty Hall Problem, Oxford University Press, New York, 2009.   
[Ro09a] Sheldon M. Ross, A First Course in Probability Theory, 7th ed., Prentice-Hall, Englewood Cliffs, NJ, 2009.   
[Ro02] Sheldon M. Ross, Probability Models for Computer Science, Harcourt/Academic Press, San Diego, 2002.   
[Ro59] B. Roy, "Transitivite et Connexite," C.R. Acad. Sci. Paris, 249 (1959), 216.   
[Ry63] H. Ryser, Combinatorial Mathematics, Mathematical Association of America, Washington, DC, 1963.   
[SaKa86] T. L. Saaty and P. C. Kainen, The Four-Color Problem: Assaults and Conquest, Dover, New York, 1986.   
[Sa85] S. Sahni, Concepts in Discrete Mathematics, Camelot, Minneapolis, 1985.   
[Sa00] K. Sayood, Introduction to Data Compression, 2d ed., Academic Press, San Diego, 2000.   
[SePi89] J. Seberry and J. Pieprzyk, Cryptography: An Introduction to Computer Security, Prentice-Hall, Englewood Cliffs, NJ, 1989.   
[Se03] R. Sedgewick, Algorithms in Java, 3d ed., Addison-Wesley, Reading, MA, 2003.   
[SiHs88] H. J. Siegel and W. T. Hsu, "Interconnection Networks," in Computer Architectures, V. M. Milutinovic (ed.), North-Holland, New York, 1988, pp. 225-264.   
[Si99] S. Singh, The Code Book, Doubleday, New York, 1999.   
[Si66] A. Sinkov, Elementary Cryptanalysis, Mathematical Association of America, Washington, DC, 1966.   
[Si06] M. Sipser, Introduction to the Theory of Computation, Course Technology, Boston, 2006.   
[S1P195] N. J. A. Sloane and S. Plouffe, The Encyclopedia of Integer Sequences, Academic Press, New York, 1995.

[Sm78] Raymond Smullyan, What Is the Name of This Book?: The Riddle of Dracula and Other Logical Puzzles, Prentice-Hall, Englewood Cliffs, NJ, 1978.   
[Sm92] Raymond Smullyan, Lady or the Tiger? And Other Logic Puzzles Including a Mathematical Novel That Features Godel's Great Discovery, Times Book, New York, 1992.   
[Sm98] Raymond Smullyan, The Riddle of Scheherazade: And Other Amazing Puzzles, Ancient & Modern, Harvest Book, Fort Washington, PA, 1998.   
[So09] Daniel Solow, How to Read and Do Proofs: An Introduction to Mathematical Thought Processes, 5th ed., Wiley, New York, 2009.   
[So61] I. S. Sominskii, Method of Mathematical Induction, Blaisdell, New York, 1961.   
[Sp94] M. Spivak, *Calculus*, 3d ed., Publish or Perish, Wilmington, DE, 1994.   
[StMc77] D. Stanat and D. F. McAllister, Discrete Mathematics in Computer Science, Prentice-Hall, Englewood Cliffs, NJ, 1977.   
[St78] H. M. Stark, An Introduction to Number Theory, MIT Press, Cambridge, MA, 1978.   
[St05] Douglas R. Stinson, Cryptography, Theory and Practice, 3d ed., Chapman and Hall/CRC, Boca Raton, FL, 2005.   
[St94] P. K. Stockmeyer, "Variations on the Four-Post Tower of Hanoi Puzzle," Congressus Numerantium 102 (1994), 3-12.   
[St74] R. R. Stoll, Sets, Logic, and Axiomatic Theories, 2d ed., W. H. Freeman, San Francisco, 1974.   
[St09] G. W. Strang, Linear Algebra and Its Applications, 4th ed., Wellesley Cambridge Press, Wellesley, MA, 2009.   
[Su87] P. Suppes, Introduction to Logic, D. Van Nostrand, Princeton, NJ, 1987.   
[Ta83] R. E. Tarjan, Data Structures and Network Algorithms, Society for Industrial and Applied Mathematics, Philadelphia, 1983.   
[ThFi96] G. B. Thomas and R. L. Finney, Calculus and Analytic Geometry, 9th ed., Addison-Wesley, Reading, MA, 1996.   
[TrMa75] J. P. Tremblay and R. P. Manohar, Discrete Mathematical Structures with Applications to Computer Science, McGraw-Hill, New York, 1975.

[Tu06] Alan Tucker, Applied Combinatorics, 5th ed., Wiley, New York, 2006.   
[Ve52] E. W. Veitch, "A Chart Method for Simplifying Truth Functions," Proceedings of the ACM (1952), 127-133.   
[Ve06] David Velleman, How to Prove It: A Structured Approach, Cambridge University Press, New York, 2006.   
[Vi71] N. Y. Vilenkin, Combinatorics, Academic Press, New York, 1971.   
[Wa80] M. Wand, Induction, Recursion, and Programming, North-Holland, New York, 1980.   
[Wa62] S. Warshall, “A Theorem on Boolean Matrices,” Journal of the ACM, 9 (1962), 11-12.   
[We00] D. B. West, Introduction to Graph Theory, 2d ed., Prentice Hall, Englewood Cliffs, NJ, 2000.   
[Wi02] Herbert S. Wilf, Algorithms and Complexity, 2d ed., A. K. Peters, Natick, MA, 2002.   
[Wi85] S. G. Williamson, Combinatorics for Computer Science, Computer Science Press, Rockville, MD, 1985.   
[Wi85a] R. J. Wilson, Introduction to Graph Theory, 3d ed., Longman, Essex, England, 1985.   
[WiBe79] R. J. Wilson and L. W. Beineke, Applications of Graph Theory, Academic Press, London, 1979.   
[WiWa90] R. J. Wilson and J. J. Watkins, Graphs, An Introductory Approach, Wiley, New York, 1990.   
[Wi76] N. Wirth, Algorithms + Data Structures = Programs, Prentice-Hall, Englewood Cliffs, NJ, 1976.   
[Wi84] N. Wirth, “Data Structures and Algorithms,” Scientific American, 251 (September 1984), 60–69.   
[W098] Robert S. Wolf, Proof, Logic, and Conjecture: The Mathematician's Toolbox, W. H. Freeman, New York, 1998.   
[W087] D. Wood, Theory of Computation, Harper & Row, New York, 1987.   
[Zd05] J. Zdziarski, Ending Spam: Bayesian Content Filtering and the Art of Statistical Language Classification, No Starch Press, San Francisco, 2005.   
[Zi91] H. J. Zimmermann, Fuzzy Set Theory and Its Applications, 2d ed., Kluwer, Boston, 1991.

![](cfaf06d3e5c90ff2d92f627fabd81e7b8f144b9bd17110bc294a55966a10f8c6.jpg)

# 算法导论（原书第3版）

作者：Thomas H. Cormen等  
ISBN: 978-7-111-40701-0 定价：128.00元

![](5998f262e9e0ac862d02188e519745d5fbafa1ee6560f03f16991a5937e9b76a.jpg)

# C程序设计语言（第2版·新版）

作者：Brian W. Kernighan等  
ISBN: 978-7-111-12806-0 定价：30.00元

![](8d38df9bd216ba2ce96e318a556f9e8832f80d7d46e5827e0f0e1327f3836e83.jpg)

# 深入理解计算机系统（

作者：Randal E. Brya  
ISBN: 978-7-111-54493-7

![](8079fad1e05373ca20f486c610790f76912485fd0bc03da2cf8d245380406be5.jpg)

# 与设计：硬件/软件接口（原书第5版）

作者：David Patterson等78-7-111-50482-5定价：99.00元

# 离散数学及其应用 原书第8版

# Discrete Mathematics and Its Applications Eighth Edition

本书是介绍离散数学理论和方法的经典教材，被全球数百所高校采用，获得了极大的成功。第8版做了与时俱进的更新，添加了多重集、字符串匹配算法、同态加密、数据挖掘中的关联规则、语义网络等内容，同时更新了配套教辅资源，成为更加实用的教学工具。本书可作为1~2个学期的离散数学课程教材，适用于数学、计算机科学、计算机工程、信息技术等专业的学生。

# 本书特色

例题：共800多道例题，用于阐明概念、建立不同主题之间的关联以及介绍实际应用。  
- 应用：涉及的领域包括计算机科学、数据网络、心理学、化学、工程学、语言学、生物学、商业和因特网等，展示了离散数学的实用性。  
- 算法：每一章都介绍了一些关键算法，提供伪代码，并简要分析其计算复杂度。  
历史资料：给出了89位数学家和计算机科学家的简短传记，帮助读者了解不同技术的历史背景和发展轨迹。  
- 练习、复习题和补充练习：共有4200多道难度各异的练习题，可以满足不同层次学生的需求。此外，还有一些研究性题目，帮助学生通过计算来探索新知识和新想法。

![](97bdc6fd384ad14addbcc731348686b9ce4bddb2fa83a61195354aa0cc9588cb.jpg)

www.mheducation.com

![](3f3eb625002761113a0e20dadf66019e2b834786f9b6c95547f059cb71784ea6.jpg)

华章教育服务微信号

![](7ad1417f4b0f96ae16859490e3b15404659b4bc2dfa746df103cf197ea6035a7.jpg)