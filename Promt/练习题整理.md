作为一个 Obsidian 笔记格式化专家，我需要你利用 MCP 工具读取我的 CSS 文件，解析出所有的 Callout 类型，并根据文本内容自动应用格式转换。

### 1. 核心任务：CSS 分析与锚点规则
请首先读取文件：`D:\Obsidian\Discrete-Math\.obsidian\snippets\math-note.css`

**任务 A：建立类型映射**
查找文件中的 `.callout[data-callout="..."]` 定义，建立关键词映射表：
* `data-callout="theorem"` -> 关键词 "定理" -> 类型 `[!theorem]`
* `data-callout="definition"` -> 关键词 "定义" -> 类型 `[!definition]`
* `data-callout="instance"` -> 关键词 "例"、"例题" -> 类型 `[!instance]`
* `data-callout="question"` -> 关键词 "练习"、"习题" -> 类型 `[!question]`
* (请根据文件实际内容补全其他类型，如 `proof`, `solution`, `note` 等)

**任务 B：通用锚点生成规则 (重要修改)**
不再使用硬编码的锚点。请遵循以下**动态生成规则**：
1.  **提取前缀**：获取 Callout 类型英文名称的**前 3 个字母** (全小写)。
    * 例如：`instance` -> `ins`, `theorem` -> `the`, `definition` -> `def`, `question` -> `que`.
2.  **组合锚点**：
    * **单体模式 (Scenario A)**：使用 `^[前3字母]-[编号]`（如果文本中有编号），或仅 `^[前3字母]`（如果无编号）。
    * **列表模式 (Scenario B)**：使用 `^[前3字母]-[题号]`。

---

### 2. 转换逻辑与场景区分
接收到 Markdown 文本后，请先判断结构，再执行转换：

**场景 A：单体结构 (例题、定理、定义)**
* **适用**：文本以“例X”、“定理X”、“定义X”开头，通常包含详细的解题或证明过程。
* **外层**：`>[!类型] 标题 [编号]` (例如 `>[!instance] 例 16`)
* **内层**：识别“解”或“证明”，转换为折叠块 `>>[!solution]-` 或 `>>[!proof]-`。
* **锚点**：放在块最后一行。
    * 示例：`instance` 类型 -> `^ins-16` (优先带编号) 或 `^ins`。

**场景 B：批量列表结构 (练习题)**
* **适用**：文本包含连续的编号列表 (1., 2., ... 或 a), b)...)，通常在“练习”标题下。
* **规则**：**必须逐题拆分**，禁止合并！
* **格式**：
    * 每题独立一个 `>[!question]` 块。
    * 标题：`>[!question] 练习 [题号]`。
    * 锚点：`^que-[题号]` (取 `question` 前3字母 + 题号)。

---

### 3. 学习示例 (Few-Shot)

**示例 1：场景 A (动态锚点演示)**
*Input:*
定理3 (德摩根律) ...
证明 ...
*Output:*
>[!theorem] 定理 3 (德摩根律)
>...
>>[!proof]- 证明
>>...
>^the-3
*(注意：theorem -> 取前3字母 the -> ^the-3)*

**示例 2：场景 B (练习题拆分)**
*Input:*
练习
1. 命题A...
2. 命题B...
*Output:*
>[!question] 练习 1
>命题A...
>^que-1

>[!question] 练习 2
>命题B...
>^que-2

---

### 4. 执行指令
1.  **Step 1**: 读取 CSS 文件，列出你识别到的所有类型及其对应的**3字母锚点前缀** (例如: "识别到 theorem -> 前缀 the")。
2.  **Step 2**: 确认无误后，等待我发送 Markdown 内容并开始转换。****