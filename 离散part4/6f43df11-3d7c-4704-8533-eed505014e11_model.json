[
    [
        {
            "type": "page_number",
            "bbox": [
                0.126,
                0.036,
                0.162,
                0.049
            ],
            "angle": 0,
            "content": "578"
        },
        {
            "type": "header",
            "bbox": [
                0.207,
                0.034,
                0.284,
                0.05
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "image",
            "bbox": [
                0.242,
                0.093,
                0.4,
                0.152
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.304,
                0.165,
                0.336,
                0.179
            ],
            "angle": 0,
            "content": "\\(K_{2,3}\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.613,
                0.093,
                0.769,
                0.151
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.675,
                0.165,
                0.708,
                0.18
            ],
            "angle": 0,
            "content": "\\(K_{3,3}\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.177,
                0.207,
                0.465,
                0.265
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.305,
                0.279,
                0.337,
                0.293
            ],
            "angle": 0,
            "content": "\\(K_{3,5}\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.513,
                0.209,
                0.868,
                0.265
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.675,
                0.279,
                0.708,
                0.293
            ],
            "angle": 0,
            "content": "\\(K_{2,6}\\)"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.43,
                0.303,
                0.615,
                0.318
            ],
            "angle": 0,
            "content": "图9 一些完全二分图"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.332,
                0.946,
                0.464
            ],
            "angle": 0,
            "content": "例14 任务分配 假设1个组中有 \\(m\\) 个员工，需要完成 \\(n\\) 种不同的工作，其中 \\(m \\geqslant n\\) 。每个员工都受过相关培训，能够完成这 \\(n\\) 个工作中的1种或多种。我们希望可以为每个员工分配一个工作。为了完成这个任务，我们可以使用图为员工的能力建模。用顶点表示每一个员工和每一个工作。对于每个员工，在表示他和他受过培训工作的顶点之间建立一条边。注意，这个图的顶点集合被划分为两个不相交的集合，员工的集合和工作的集合，而且每条边都连接着一个员工和一个工作。因此，这个图是二分图，划分是 \\((E, J)\\)，其中 \\(E\\) 是员工的集合，\\(J\\) 是工作的集合。下面我们考虑两种不同的场景。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.468,
                0.946,
                0.542
            ],
            "angle": 0,
            "content": "第一，假设1组有4个员工：Alvarez、Berkowitz、Chen和Davis。假设完成项目1需要做4个工作：需求、架构、实现和测试。假设Alvarez受过需求和测试的培训；Berkowitz受过架构、实现和测试的培训；Chen受过需求、架构和实现的培训；Davis仅受过需求的培训。我们使用图10a中的二分图为这些员工的能力建模。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.544,
                0.946,
                0.617
            ],
            "angle": 0,
            "content": "第二，假设这个组中第2个小组也有4个员工：Washington、Xuan、Ybarra和Ziegler。假设完成项目2也需要和完成项目1一样完成相同的4种工作。假设Washington受过架构的培训；Xuan受过需求、实现和测试的培训；Ybarra受过架构的培训；Ziegler受过需求、架构和测试的培训。我们使用图10b中的二分图为这些员工的能力建模。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.62,
                0.946,
                0.692
            ],
            "angle": 0,
            "content": "为了完成项目1，我们必须为每个工作分配一个员工以保证每个工作都有员工来做并且没有员工分配的工作多于一个。如图10a所示（其中灰色线表示工作分配），我们可以通过给Alvarez分配测试、给Berkowitz分配实现、给Chen分配架构和给Davis分配需求来完成这个要求。"
        },
        {
            "type": "image",
            "bbox": [
                0.156,
                0.701,
                0.487,
                0.806
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.304,
                0.816,
                0.324,
                0.828
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "image",
            "bbox": [
                0.56,
                0.7,
                0.895,
                0.807
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.715,
                0.816,
                0.736,
                0.828
            ],
            "angle": 0,
            "content": "b）"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.39,
                0.84,
                0.661,
                0.856
            ],
            "angle": 0,
            "content": "图10 为受训员工分配工作建模"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.866,
                0.946,
                0.921
            ],
            "angle": 0,
            "content": "为了完成项目2，我们也必须为每个工作分配一个员工以保证每个工作都有员工来做并且没有员工分配的工作多于一个。但是这是不可能的，因为只有Xuan和Ziegler两个员工至少受过需求、实现和测试这3个工作之一的培训。因此，没有办法为这3个工作分配3个不同的员"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.76,
                0.04,
                0.865,
                0.055
            ],
            "angle": 0,
            "content": "图 579"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.095,
                0.49,
                0.111
            ],
            "angle": 0,
            "content": "工且每个工作都能分配一个受过相关培训的员工。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.114,
                0.896,
                0.322
            ],
            "angle": 0,
            "content": "寻找一种把工作分配给员工的方法可以视为在图模型中寻求匹配，其中，在简单图 \\(G = (V, E)\\) 中的一个匹配 \\(M\\) 就是图中边集 \\(E\\) 的子集，该子集中没有两条边关联相同的顶点。换句话说，匹配是边的子集，假设 \\(\\{s, t\\}\\) 和 \\(\\{u, v\\}\\) 是匹配中不同的边，那么 \\(s\\)、\\(t\\)、\\(u\\) 和 \\(v\\) 是不同的顶点。若一个顶点是匹配 \\(M\\) 中的一条边的端点，则称该顶点在 \\(M\\) 中被匹配；否则称为未被匹配。包含最多边数的一个匹配称为最大匹配。在二分图 \\(G = (V, E)\\) 中的一个匹配 \\(M\\)，其划分为 \\((V_1, V_2)\\)，若 \\(V_1\\) 中的每个顶点都是匹配中的边的端点或 \\(|M| = |V_1|\\)，则称匹配 \\(M\\) 是从 \\(V_1\\) 到 \\(V_2\\) 的完全匹配。例如，在给员工分配工作的过程中，要把最多数量的工作分配给员工，我们可以在表示员工能力的图模型中求一个最大匹配。要把所有的工作都分配给员工，我们就要从工作集合到员工集合求一个完全匹配。在例 14 中，我们为项目 1 找到了一个从工作集合到员工集合的完全匹配，并且这个匹配是一个最大匹配。我们也证明了在项目 2 中，不存在从工作集合到员工集合的完全匹配。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.324,
                0.531,
                0.341
            ],
            "angle": 0,
            "content": "下面通过一个例子说明如何使用匹配为婚姻建模。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.345,
                0.896,
                0.461
            ],
            "angle": 0,
            "content": "例15岛上的婚姻假设在一个岛上有 \\(m\\) 个男人和 \\(n\\) 个女人。每个人都有一个可接受为配偶的异性的成员列表。我们构造一个二分图 \\(G = (V_{1}, V_{2})\\)，其中 \\(V_{1}\\) 是男人的集合，\\(V_{2}\\) 是女人的集合，如果男人和女人都把对方作为可接受的配偶，就在男人和女人之间建立一条边。这个图的匹配包括了边的两个端点是夫妻对的边的集合。该图的最大匹配是有可能结为夫妻的最大的夫妻对的集合，该图关于 \\(V_{1}\\) 的完全匹配是可以结为夫妻的集合，其中每个男人都可以结婚，但可能并不包括所有的女人。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.462,
                0.894,
                0.518
            ],
            "angle": 0,
            "content": "完全匹配的充分必要条件 设 \\((V_{1}, V_{2})\\) 是二分图 \\(G = (V, E)\\) 的一个二部划分，下面我们关注如何判断从 \\(V_{1}\\) 到 \\(V_{2}\\) 的完全匹配是否存在的问题。下面我们介绍一个定理，该定理提供了一组存在完全匹配的充分必要条件。该定理由菲利普·霍尔(Philip Hall)在1935年证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.526,
                0.886,
                0.564
            ],
            "angle": 0,
            "content": "定理5霍尔婚姻定理 带有二部划分 \\((V_{1},V_{2})\\) 的二分图 \\(G = (V,E)\\) 中有一个从 \\(V_{1}\\) 到\\(V_{2}\\) 的完全匹配当且仅当对于 \\(V_{1}\\) 的所有子集 \\(A\\) ，有 \\(\\mid N(A)\\mid \\geqslant \\mid A\\mid\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.573,
                0.896,
                0.648
            ],
            "angle": 0,
            "content": "证明 我们首先证明定理的必要条件。假设从 \\(V_{1}\\) 到 \\(V_{2}\\) 存在一个完全匹配 \\(M\\)。那么，若 \\(A \\subseteq V_{1}\\)，对于 \\(A\\) 中的每个顶点 \\(v \\in A\\)，在 \\(M\\) 中存在一条边连接 \\(v\\) 和 \\(V_{2}\\) 中的一个顶点。因此，在 \\(V_{2}\\) 中与 \\(V_{1}\\) 中的顶点相邻的顶点的个数至少与 \\(V_{1}\\) 中的顶点个数一样多。由此可得 \\(|N(A)| \\geqslant |A|\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.65,
                0.894,
                0.668
            ],
            "angle": 0,
            "content": "为了证明定理的充分条件（这是更难的部分），我们需要证明若对于所有的 \\(A \\subseteq V_1\\)，有"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.678,
                0.095,
                0.692
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.05,
                0.71,
                0.191,
                0.824
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.055,
                0.827,
                0.188,
                0.847
            ],
            "angle": 0,
            "content": "Courtesy of the Edinburgh Mathematical Society"
        },
        {
            "type": "text",
            "bbox": [
                0.209,
                0.71,
                0.896,
                0.796
            ],
            "angle": 0,
            "content": "菲利普·霍尔（Philip Hall，1904—1982）霍尔出生于英国伦敦的一个普通家庭，他的母亲是一名裁缝。他读公立小学期间就获得了为贫困学生设立的专项奖学金，大学期间又荣获了剑桥大学国王学院的奖学金资助。1925年，他取得了学士学位。一年以后，由于没有想清楚今后的职业发展方向，他参加了公务员考试，失败之后，他决定重新回到剑桥继续学业。"
        },
        {
            "type": "text",
            "bbox": [
                0.209,
                0.798,
                0.896,
                0.849
            ],
            "angle": 0,
            "content": "1927年，霍尔成功竞选为国王学院的研究员。不久，他就在群论领域取得了重大的发现，也就是为后人所熟知的霍尔定理。1933年至1941年间，他在剑桥大学担任讲师。第二次世界大战期间，他在布莱切利园负责密码解译工作，多次破译意大"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.854,
                0.896,
                0.887
            ],
            "angle": 0,
            "content": "利和日本的密电。战争结束后，霍尔重新回到国王学院，职位迅速得到了提升。1953年，霍尔被提拔为数学系教授，之后的近十年里，他卓著的研究成果为20世纪60年代群论的飞速发展做出了巨大的贡献。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.89,
                0.896,
                0.941
            ],
            "angle": 0,
            "content": "霍尔酷爱诗歌，能用英语、意大利语和日语三种语言诵读诗歌。除此之外，他对艺术、音乐和植物学也有着浓厚的兴趣。他为人非常低调，极不喜欢在公众面前露脸。尽管如此，他正派的为人、过人的智慧和敏锐的判断力备受推崇，同时，他也深受学生的爱戴。"
        },
        {
            "type": "image",
            "bbox": [
                0.909,
                0.65,
                0.94,
                0.676
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.136,
                0.041,
                0.172,
                0.054
            ],
            "angle": 0,
            "content": "580"
        },
        {
            "type": "header",
            "bbox": [
                0.217,
                0.04,
                0.292,
                0.054
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.095,
                0.951,
                0.131
            ],
            "angle": 0,
            "content": "\\(|N(A)| \\geqslant |A|\\)，那么存在一个从 \\(V_{1}\\) 到 \\(V_{2}\\) 的完全匹配 \\(M\\)。我们将对 \\(|V_{1}|\\) 使用强归纳法进行证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.134,
                0.951,
                0.19
            ],
            "angle": 0,
            "content": "基础步骤：若 \\(|V_{1}| = 1\\) ，则 \\(V_{1}\\) 只包含一个顶点 \\(\\upsilon_0\\) 。因为 \\(|N(\\{v_0\\})|\\geqslant |N\\{v_0\\}| = 1\\) ，所以至少有一条边连接顶点 \\(\\upsilon_0\\) 和一个顶点 \\(\\omega_0\\in V_2\\) 。任何一条这样的边都是从 \\(V_{1}\\) 到 \\(V_{2}\\) 的一个完全匹配。"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.193,
                0.47,
                0.209
            ],
            "angle": 0,
            "content": "归纳步骤：我们首先描述归纳假设。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.212,
                0.951,
                0.248
            ],
            "angle": 0,
            "content": "归纳假设：令 \\(k\\) 是一个正整数。若 \\(G = (V, E)\\) 是带有二部划分 \\((V_{1}, V_{2})\\) 的二分图，且 \\(|V_{1}| = j \\leqslant k\\)，则对于所有的 \\(A \\subseteq V_{1}\\) 满足 \\(|N(A)| \\geqslant |A|\\)，就存在一个从 \\(V_{1}\\) 到 \\(V_{2}\\) 的完全匹配。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.251,
                0.953,
                0.345
            ],
            "angle": 0,
            "content": "假设 \\(H = (W,F)\\) 是由二部划分 \\((W_{1},W_{2})\\) 构成的二分图且 \\(\\left|W_1\\right| = k + 1\\) 。我们分两种情况证明归纳假设成立。第一种情况应用于对所有的整数 \\(j\\) 且 \\(1\\leqslant j\\leqslant k\\) 时， \\(W_{1}\\) 中每个含有 \\(j\\) 个元素的集合中的顶点都至少与 \\(W_{2}\\) 中的 \\(j + 1\\) 个顶点相邻。第二种情况应用于对所有的整数 \\(j\\) 且\\(1\\leqslant j\\leqslant k\\) 时，存在一个含有 \\(j\\) 个顶点的子集 \\(W_{1}^{\\prime}\\) ，且在 \\(W_{2}\\) 中恰有 \\(j\\) 个邻居和这些顶点相邻。因为不是情况1就是情况2成立，所以我们在归纳步骤只需考虑这两种情况。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.348,
                0.954,
                0.462
            ],
            "angle": 0,
            "content": "第一种情况：假设对所有的整数 \\(j\\) ，且 \\(1 \\leqslant j \\leqslant k\\) ，\\(W_{1}\\) 中每个含有 \\(j\\) 个元素的集合中的顶点都至少与 \\(W_{2}\\) 中的 \\(j + 1\\) 个顶点相邻。选择一个顶点 \\(v \\in W_{1}\\) 和一个元素 \\(w \\in N(\\{v\\})\\) ，根据假设 \\(|N(\\{v\\})| \\geqslant |N\\{v\\}| = 1\\) ，一定存在这样的 \\(v\\) 和 \\(w\\) 。从 \\(H\\) 中删除 \\(v\\) 和 \\(w\\) 以及所有与它们相关联的边。由此得到一个二部划分为 \\((W_{1} - \\{v\\}, W_{2} - \\{w\\})\\) 的二分图 \\(H'\\) 。因为 \\(|W_{1} - \\{v\\}| = k\\) ，所以根据归纳假设可知存在一个从 \\(W_{1} - \\{v\\}\\) 到 \\(W_{2} - \\{w\\}\\) 的完全匹配。在这个匹配中加入从 \\(v\\) 到 \\(w\\) 的边，就得到一个从 \\(W_{1}\\) 到 \\(W_{2}\\) 的完全匹配。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.464,
                0.954,
                0.539
            ],
            "angle": 0,
            "content": "第二种情况：假设对所有的整数 \\(j\\) 且 \\(1 \\leqslant j \\leqslant k\\)，存在一个含有 \\(j\\) 个顶点的子集 \\(W_{1}^{\\prime}\\)，且在 \\(W_{2}\\) 中恰有 \\(j\\) 个邻居和这些顶点相邻。令 \\(W_{2}^{\\prime}\\) 是这些邻居顶点的集合。根据归纳假设可知，存在一个从 \\(W_{1}^{\\prime}\\) 到 \\(W_{2}^{\\prime}\\) 的完全匹配。从 \\(W_{1}\\) 和 \\(W_{2}\\) 中删除这 \\(2j\\) 个顶点以及与它们相关联的边，就得到一个二部划分为 \\((W_{1} - W_{1}^{\\prime}, W_{2} - W_{2}^{\\prime})\\) 的二分图 \\(K\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.541,
                0.954,
                0.636
            ],
            "angle": 0,
            "content": "我们将证明在图 \\(K\\) 中，对于 \\(W_{1} - W_{1}^{\\prime}\\) 中的所有子集 \\(A\\) ，满足 \\(\\left|N(A)\\right|\\geqslant \\left|A\\right|\\) 。如果不成立，则存在一个关于 \\(W_{1} - W_{1}^{\\prime}\\) 的含有 \\(t\\) 个顶点的子集，其中 \\(1\\leqslant t\\leqslant k + 1 - j\\) ，并且这个子集中的顶点在 \\(W_{2} - W_{2}^{\\prime}\\) 中的邻接顶点数少于 \\(t\\) 个。那么 \\(W_{1}\\) 中包含 \\(j + t\\) 个顶点的子集，该子集包含\\(W_{1}\\) 中这 \\(t\\) 个顶点和我们从 \\(W_{1}\\) 中移除的 \\(j\\) 个顶点，在 \\(W_{2}\\) 中小于 \\(j + t\\) 个邻居顶点，这与对于所有的 \\(A\\subseteq W_1\\) 有 \\(\\mid N(A)\\mid \\geqslant \\mid A\\mid\\) 矛盾。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.638,
                0.954,
                0.674
            ],
            "angle": 0,
            "content": "因此，根据归纳假设，图 \\(K\\) 有一个完全匹配。把这个完全匹配和从 \\(W_{1}^{\\prime}\\) 到 \\(W_{2}^{\\prime}\\) 的完全匹配合并，就得到一个从 \\(W_{1}\\) 到 \\(W_{2}\\) 的完全匹配。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.676,
                0.954,
                0.713
            ],
            "angle": 0,
            "content": "我们已经证明在两种情况下，都存在一个从 \\(W_{1}\\) 到 \\(W_{2}\\) 的完全匹配。这就完成了归纳步骤和定理的证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.715,
                0.954,
                0.77
            ],
            "angle": 0,
            "content": "我们使用强归纳法证明了霍尔婚姻定理。尽管我们的证明是正确的，但仍然存在一些不足。特别是，还不能基于该证明构建一个求二分图完全匹配的算法。若要了解能够作为算法基础的构造性证明，请参考[Gi85]。"
        },
        {
            "type": "title",
            "bbox": [
                0.114,
                0.78,
                0.428,
                0.797
            ],
            "angle": 0,
            "content": "10.2.6 特殊类型图的一些应用"
        },
        {
            "type": "text",
            "bbox": [
                0.153,
                0.8,
                0.823,
                0.817
            ],
            "angle": 0,
            "content": "本节将介绍其他一些图模型，这涉及本节前面讨论过的一些特殊类型的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.822,
                0.954,
                0.9
            ],
            "angle": 0,
            "content": "例16 局域网 在一座大楼里，像小型计算机和个人计算机这样的计算机，以及像打印机和绘图仪这样的外设，都可以用局域网来连接。有些这样的网络是基于星形拓扑，其中所有设备都连接到中央控制设备。局域网可以用图11a所示的完全二分图 \\(K_{1,n}\\) 来表示。通过中央控制设备在设备间传输信息。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.902,
                0.954,
                0.937
            ],
            "angle": 0,
            "content": "另一个局域网是基于环形拓扑，其中每个设备都连接到两个其他设备。带环形拓扑的局域网可以用图11b所示的 \\(n\\) 圈图 \\(C_n\\) 来建模。消息围绕着圈从设备送到设备，直到抵达消息目的地为止。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.771,
                0.046,
                0.874,
                0.061
            ],
            "angle": 0,
            "content": "图 581"
        },
        {
            "type": "image",
            "bbox": [
                0.248,
                0.105,
                0.368,
                0.184
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.299,
                0.196,
                0.317,
                0.207
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "image",
            "bbox": [
                0.409,
                0.115,
                0.54,
                0.18
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.466,
                0.196,
                0.485,
                0.207
            ],
            "angle": 0,
            "content": "b）"
        },
        {
            "type": "image",
            "bbox": [
                0.586,
                0.115,
                0.717,
                0.18
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.645,
                0.196,
                0.663,
                0.207
            ],
            "angle": 0,
            "content": "c）"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.31,
                0.216,
                0.655,
                0.232
            ],
            "angle": 0,
            "content": "图11 局域网的星形、环形以及混合拓扑"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.242,
                0.907,
                0.278
            ],
            "angle": 0,
            "content": "最后，有些局域网采用这两种拓扑的混合形式。消息围绕着环或通过中央设备来传送。这样的冗余使得网络更加可靠。带冗余的局域网可用图11c所示的轮图 \\(W_{n}\\) 来建模。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.283,
                0.907,
                0.379
            ],
            "angle": 0,
            "content": "例17 并行计算的互连网络 许多年来，计算机执行程序是一次完成一个操作。因此，为解决问题而写的算法都设计成一次执行一步，这样的算法称为串行的（几乎所有本书描述的算法都是串行的）。不过，像气象模拟、医学图像分析以及密码分析等许多高强度计算问题，即使在超级计算机上，也不能通过串行操作在合理的时间范围内解决。而且，计算机执行基本操作的速度还存在物理限制，所以总是有问题不能用串行操作在合理的时间范围内解决。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.382,
                0.907,
                0.456
            ],
            "angle": 0,
            "content": "并行处理利用由多个独立处理器（每个处理器有自己的内存）组成的计算机，以克服只有单个处理机的计算机的局限性。并行算法把问题分成可并发解决的若干子问题，那么可以设计并行算法，用带有多处理器的计算机来快速解决问题。在并行算法中，单个指令流控制着算法的执行，包括把子问题传送到不同的处理器，以及把子问题的输入和输出定向到适当的处理器。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.457,
                0.909,
                0.532
            ],
            "angle": 0,
            "content": "采用并行处理时，一个处理器需要另一个处理器产生的输出。因此这些处理器需要互连。可用适当类型的图来表示带有多重处理器的计算机中处理器的互连网络。在以下讨论中，将要描述最常用类型的并行处理器互连网络。用来实现具体并行算法的互连网络的类型取决于处理器之间交换数据的需求、所需要的速度，当然还有可用的硬件等。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.534,
                0.909,
                0.627
            ],
            "angle": 0,
            "content": "最简单却又最昂贵的网络互连处理器，在每对处理器之间有一个双向连接。当有 \\( n \\) 个处理器时，这样的网络表示成 \\( n \\) 个顶点上的完全图 \\( K_{n} \\) 。不过，这种类型的互连网络有严重的问题，因为它所需要的连接数太大。实际上，处理器的直接连接数目是有限的，所以当处理器数很大时，处理器不能直接连接到所有其他处理器。例如，当有64个处理器时，就需要 \\( C(64,2) = 2016 \\) 个连接，每个处理器都得直接连接到其他63个处理器。"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.629,
                0.909,
                0.665
            ],
            "angle": 0,
            "content": "另一方面，互连 \\(n\\) 个处理器的最简单方式或许是使用称为线性阵列的排列方式。除了 \\(P_{1}\\) 和 \\(P_{n}\\) 以外的每个处理器 \\(P_{i}\\) 都通过双向连接与相邻处理器 \\(P_{i-1}\\) 和 \\(P_{i+1}\\) 连接。\\(P_{1}\\) 只连接 \\(P_{2}\\)，\\(P_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.667,
                0.587,
                0.741
            ],
            "angle": 0,
            "content": "只连接 \\(P_{n - 1}\\) 。图12显示了6个处理器的线性阵列。线性阵列的优点是每个处理器最多有2个和其他处理器的直接连接。这种方式的缺点是为了让处理器共享信息，有时需要使用大量的称为跳(hop)的中间连接。"
        },
        {
            "type": "image",
            "bbox": [
                0.621,
                0.67,
                0.871,
                0.695
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.623,
                0.702,
                0.869,
                0.718
            ],
            "angle": 0,
            "content": "图12 6个处理器的线性阵列"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.744,
                0.91,
                0.779
            ],
            "angle": 0,
            "content": "栅格网络(或二维阵列)是一种通用的互连网络。在这样的网络中，处理器个数是一个完全平方数，比方说 \\(n = m^2\\) 。\\(n\\) 个处理器标记成 \\(P(i, j)\\)，\\(0 \\leqslant i \\leqslant m - 1\\)，\\(0 \\leqslant j \\leqslant m - 1\\)。双向连接把"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.781,
                0.596,
                0.936
            ],
            "angle": 0,
            "content": "处理器 \\(P(i, j)\\) 连接到它的 4 个相邻处理器 \\(P(i \\pm 1, j)\\) 和 \\(P(i, j \\pm 1)\\)，只要这些处理器是在栅格里。（注意，栅格角上的 4 个处理器只有 2 个相邻处理器，边界上其他处理器只有 3 个相邻处理器。有时也用每个处理器恰有 4 个连接的变种的栅格网络，见本节练习 74。）栅格网络限制了每个处理器的连接数。某些成对处理器之间的通信需要 \\(O(\\sqrt{n}) = O(m)\\) 个中间连接（见本节练习 75）。表示 16 个处理器的栅格网络如图 13 所示。"
        },
        {
            "type": "image",
            "bbox": [
                0.631,
                0.784,
                0.871,
                0.923
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.624,
                0.927,
                0.878,
                0.942
            ],
            "angle": 0,
            "content": "图13 16个处理器的栅格网络"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.134,
                0.048,
                0.171,
                0.062
            ],
            "angle": 0,
            "content": "582"
        },
        {
            "type": "header",
            "bbox": [
                0.216,
                0.047,
                0.292,
                0.063
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.103,
                0.956,
                0.235
            ],
            "angle": 0,
            "content": "超立方体是互连网络的一个重要类型。在这样的网络中，处理器个数是2的幂，\\(n = 2^{m}\\)。\\(n\\) 个处理器标记成 \\(P_{0}, P_{1}, \\dots, P_{n-1}\\)。每个处理器都有到其他 \\(m\\) 个处理器的双向连接。连接到处理器 \\(P_{i}\\) 上的处理器，其下标的二进制表示与 \\(i\\) 的二进制表示恰恰有1位不同。超立方体网络在每个处理器的直接连接数与保证处理器通信的中间连接数之间取得了平衡。已经用超立方体网络建造了许多计算机，而且用超立方体网络设计了许多算法。\\(m\\) 立方体图 \\(Q_{m}\\) 表示带 \\(n = 2^{m}\\) 个处理器的超立方体网络。图14显示了8个处理器的超立方体网络（图14显示了一种与图6不同的画 \\(Q_{3}\\) 的方式）。"
        },
        {
            "type": "image",
            "bbox": [
                0.304,
                0.24,
                0.76,
                0.298
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.388,
                0.306,
                0.673,
                0.323
            ],
            "angle": 0,
            "content": "图14 8个处理器的超立方体网络"
        },
        {
            "type": "title",
            "bbox": [
                0.108,
                0.341,
                0.359,
                0.358
            ],
            "angle": 0,
            "content": "10.2.7 从旧图构造新图"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.361,
                0.955,
                0.472
            ],
            "angle": 0,
            "content": "有时解决问题只需要图的一部分。例如，只关心大型计算机网络中涉及纽约、丹佛、底特律以及亚特兰大的计算机中心的那一部分。所以我们可以忽略其他的计算机中心以及没有连接到这4个特定的计算机中心的任何2个的所有电话线路。在大型网络的图模型中，可以删除除这4个顶点之外的计算机中心所对应的顶点，可以删除所有与所删除顶点关联的边。当从图中删除了边和顶点，不删除所保留边的端点时，就得到一个更小的图，这样的图称为原图的子图。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.48,
                0.945,
                0.518
            ],
            "angle": 0,
            "content": "定义7 图 \\(G = (V, E)\\) 的子图是图 \\(H = (W, F)\\)，其中 \\(W \\subseteq V\\) 且 \\(F \\subseteq E\\)。若 \\(H \\neq G\\)，则称图 \\(G\\) 的子图 \\(H\\) 是 \\(G\\) 的真子图。"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.526,
                0.942,
                0.544
            ],
            "angle": 0,
            "content": "已知一个图的顶点集合，我们可以由图中的顶点和连接这些顶点的边得到这个图的子图。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.551,
                0.945,
                0.589
            ],
            "angle": 0,
            "content": "定义8 令 \\(G = (V, E)\\) 是一个简单图。图 \\((W, F)\\) 是由顶点集 \\(V\\) 的子集 \\(W\\) 导出的子图，其中边集 \\(F\\) 包含 \\(E\\) 中的一条边当且仅当这条边的两个端点都在 \\(W\\) 中。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.599,
                0.954,
                0.638
            ],
            "angle": 0,
            "content": "例18 图15所示的图 \\(G\\) 是 \\(K_{5}\\) 的一个子图。若我们在图 \\(G\\) 中增加一条连接 \\(c\\) 和 \\(e\\) 的边，就得到一个由 \\(W = \\{a, b, c, e\\}\\) 导出的子图。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.641,
                0.577,
                0.715
            ],
            "angle": 0,
            "content": "删除或增加图中的边已知图 \\(G = (V,E)\\) ，边\\(e\\in E\\) ，我们可以通过删除边 \\(\\mathcal{E}\\) 得到图 \\(G\\) 的一个子图。所得到的子图，记作 \\(G - e\\) ，和图 \\(G\\) 具有相同的顶点集 \\(V\\) 。它的边集是 \\(E - e\\) 。所以，"
        },
        {
            "type": "equation",
            "bbox": [
                0.242,
                0.718,
                0.438,
                0.734
            ],
            "angle": 0,
            "content": "\\[\nG - e = (V, E - \\{e \\})\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.736,
                0.577,
                0.791
            ],
            "angle": 0,
            "content": "类似地，若 \\(E^{\\prime}\\) 是 \\(E\\) 的子集，我们可以通过从图中删除 \\(E^{\\prime}\\) 中的边得到图 \\(G\\) 的子图。所得到的子图和图 \\(G\\) 具有相同的顶点集 \\(V\\) 。它的边集是 \\(E - E^{\\prime}\\) 。"
        },
        {
            "type": "image",
            "bbox": [
                0.591,
                0.643,
                0.958,
                0.753
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.68,
                0.759,
                0.866,
                0.775
            ],
            "angle": 0,
            "content": "图15 \\(K_{5}\\) 的一个子图"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.794,
                0.955,
                0.849
            ],
            "angle": 0,
            "content": "我们可以通过在图中增加一条连接图 \\(G\\) 中已有的两个顶点的边 \\(e\\) 得到一个新的更大的图。我们把在图 \\(G\\) 中增加一条新边，该边连接原图中两个原本不相关联的顶点，所得到的新图记作 \\(G + e\\) 。所以"
        },
        {
            "type": "equation",
            "bbox": [
                0.43,
                0.852,
                0.632,
                0.869
            ],
            "angle": 0,
            "content": "\\[\nG + e = (V, E \\cup \\{e \\})\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.871,
                0.954,
                0.907
            ],
            "angle": 0,
            "content": "\\(G + e\\) 的顶点集和图 \\(G\\) 的顶点集相同，它的边集是图 \\(G\\) 的边集和集合 \\(\\{e\\}\\) 的并集。（从一个图中删除一条边和增加一条边的例子参见例19。）"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.911,
                0.956,
                0.947
            ],
            "angle": 0,
            "content": "边的收缩 有时，当我们从图中删除一条边后，我们不希望将该边的端点作为独立的顶点保留在所得到的子图中。在这种情况下，我们进行边的收缩，删除端点为 \\(u\\) 和 \\(v\\) 的边 \\(e\\) ，把 \\(u\\)"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.769,
                0.038,
                0.874,
                0.052
            ],
            "angle": 0,
            "content": "图 583"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.093,
                0.907,
                0.242
            ],
            "angle": 0,
            "content": "和 \\(v\\) 合并成一个新的顶点 \\(\\varpi\\) ，对每一条以 \\(u\\) 或 \\(v\\) 为端点的边，将该边 \\(u\\) 或 \\(v\\) 的位置替换成 \\(\\varpi\\) 且另一个端点不变。因此在图 \\(G = (V,E)\\) 中，对端点为 \\(u\\) 和 \\(v\\) 的边 \\(e\\) 进行收缩得到一个新图 \\(G^{\\prime} = (V^{\\prime},E^{\\prime})\\) （这不是 \\(G\\) 的子图），其中 \\(V^{\\prime} = V - \\{u,v\\} \\cup \\{w\\}\\) ， \\(E^{\\prime}\\) 包含 \\(E\\) 中不以 \\(u\\) 或 \\(v\\) 为端点的边以及连接 \\(\\varpi\\) 与集合 \\(V\\) 中所有与 \\(u\\) 或 \\(v\\) 相邻的顶点的边。例如，收缩图16中图 \\(G_{1}\\) 中连接顶点 \\(e\\) 和 \\(c\\) 的边，得到一个包含顶点 \\(a,b,d\\) 和 \\(\\varpi\\) 的新图 \\(G_{1}^{\\prime}\\) 。与在 \\(G_{1}\\) 中一样，在 \\(G_{1}^{\\prime}\\) 中有一条连接 \\(a\\) 和 \\(b\\) 的边，以及一条连接 \\(a\\) 和 \\(d\\) 的边。在 \\(G_{1}^{\\prime}\\) 中还有一条边连接 \\(b\\) 和 \\(\\varpi\\) ，该边替换了 \\(G_{1}\\) 中连接 \\(b\\) 和 \\(c\\) 的边以及连接 \\(b\\) 和 \\(e\\) 的边，在 \\(G_{1}^{\\prime}\\) 中还有一条边连接 \\(d\\) 和 \\(\\varpi\\) ，该边替换了 \\(G_{1}\\) 中连接 \\(d\\) 和 \\(e\\) 的边。（在一个图中收缩一条边的例子同样参见例19。）"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.246,
                0.906,
                0.32
            ],
            "angle": 0,
            "content": "从图中删除顶点 当我们从图 \\(G = (V, E)\\) 删除一个顶点 \\(v\\) 以及所有与它相关联的边时，就得到图 \\(G\\) 的一个子图，记作 \\(G - v\\) 。注意，\\(G - v = (V - v, E')\\)，其中 \\(E'\\) 是 \\(G\\) 中不与 \\(v\\) 相关联的边的集合。类似地，若 \\(V'\\) 是 \\(V\\) 的子集，则图 \\(G - V'\\) 是子图 \\((V - V', E')\\)，其中 \\(E'\\) 是 \\(G\\) 中不与 \\(V'\\) 中的顶点相关联的边的集合。（从一个图中删除一个顶点的例子参见例19。）"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.325,
                0.886,
                0.342
            ],
            "angle": 0,
            "content": "例19图16显示了无向图 \\(G\\) 以及在 \\(G\\) 上进行不同的操作得到的4张不同的图，分别是："
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.347,
                0.54,
                0.363
            ],
            "angle": 0,
            "content": "(a) \\(G - \\{b, c\\}\\)，在图 \\(G\\) 中删除边 \\(\\{b, c\\}\\) 构造的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.366,
                0.546,
                0.382
            ],
            "angle": 0,
            "content": "(b) \\(G + \\{e, d\\}\\)，在图 \\(G\\) 中增加边 \\(\\{e, d\\}\\) 构造的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.386,
                0.903,
                0.42
            ],
            "angle": 0,
            "content": "(c) \\(G\\) 的收缩图，在图 \\(G\\) 中，用新顶点 \\(f\\) 替换边 \\(\\{b, c\\}\\)，使用新边 \\(\\{a, f\\}\\)、\\(\\{f, d\\}\\) 和 \\(\\{f, e\\}\\) 替换边 \\(\\{c, d\\}\\)、\\(\\{a, b\\}\\)、\\(\\{b, e\\}\\) 和 \\(\\{c, e\\}\\) 构造的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.423,
                0.75,
                0.44
            ],
            "angle": 0,
            "content": "(d) \\(G - c\\) ，在图 \\(G\\) 中删除顶点 \\(c\\) 以及边 \\(\\{b,c\\} ,\\{c,d\\}\\) 和 \\(\\{c,e\\}\\) 构造的图。"
        },
        {
            "type": "list",
            "bbox": [
                0.055,
                0.347,
                0.903,
                0.44
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.059,
                0.446,
                0.229,
                0.525
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.246,
                0.446,
                0.415,
                0.525
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.318,
                0.529,
                0.344,
                0.541
            ],
            "angle": 0,
            "content": "(a)"
        },
        {
            "type": "image",
            "bbox": [
                0.435,
                0.446,
                0.605,
                0.525
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.485,
                0.529,
                0.534,
                0.541
            ],
            "angle": 0,
            "content": "(b）"
        },
        {
            "type": "image",
            "bbox": [
                0.638,
                0.448,
                0.76,
                0.525
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.707,
                0.538,
                0.734,
                0.55
            ],
            "angle": 0,
            "content": "(c）"
        },
        {
            "type": "image",
            "bbox": [
                0.811,
                0.449,
                0.901,
                0.525
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.846,
                0.538,
                0.874,
                0.55
            ],
            "angle": 0,
            "content": "(d)"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.267,
                0.559,
                0.692,
                0.573
            ],
            "angle": 0,
            "content": "图16 图 \\(G\\) 和在 \\(G\\) 上进行不同的操作得到的4张图"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.584,
                0.903,
                0.619
            ],
            "angle": 0,
            "content": "图的并集可以用各种方式组合两个或更多的图。包含这些图的所有顶点和边的新图被称为这些图的并图。两个简单图的并图的更正式的定义如下。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.628,
                0.895,
                0.666
            ],
            "angle": 0,
            "content": "定义9 两个简单图 \\(G_{1} = (V_{1}, E_{1})\\) 和 \\(G_{2} = (V_{2}, E_{2})\\) 的并图是带有顶点集 \\(V_{1} \\cup V_{2}\\) 和边集 \\(E_{1} \\cup E_{2}\\) 的简单图。\\(G_{1}\\) 和 \\(G_{2}\\) 的并图表示成 \\(G_{1} \\cup G_{2}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.678,
                0.482,
                0.695
            ],
            "angle": 0,
            "content": "例20 求图17a所示的图 \\(G_{1}\\) 和 \\(G_{2}\\) 的并图。"
        },
        {
            "type": "image",
            "bbox": [
                0.134,
                0.707,
                0.317,
                0.824
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.267,
                0.833,
                0.395,
                0.848
            ],
            "angle": 0,
            "content": "a）简单图 \\(G_{1}\\) 和 \\(G_{2}\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.346,
                0.706,
                0.524,
                0.824
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.619,
                0.704,
                0.826,
                0.824
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.642,
                0.833,
                0.782,
                0.847
            ],
            "angle": 0,
            "content": "b）它们的并 \\(G_{1}\\cup G_{2}\\)"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.382,
                0.857,
                0.579,
                0.872
            ],
            "angle": 0,
            "content": "图17 并图的产生过程"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.883,
                0.905,
                0.918
            ],
            "angle": 0,
            "content": "解 并图 \\(G_{1} \\cup G_{2}\\) 的顶点集是两个顶点集的并，即 \\(\\{a, b, c, d, e, f\\}\\) 。并图的边集是两个边集的并。并图显示在图 17b 中。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.128,
                0.038,
                0.164,
                0.052
            ],
            "angle": 0,
            "content": "584"
        },
        {
            "type": "header",
            "bbox": [
                0.209,
                0.037,
                0.286,
                0.052
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "title",
            "bbox": [
                0.101,
                0.102,
                0.148,
                0.118
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.122,
                0.881,
                0.137
            ],
            "angle": 0,
            "content": "在练习 \\(1\\sim 3\\) 中，求所给无向图的顶点数、边数以及每个顶点的度。指出所有的孤立点和悬挂点。"
        },
        {
            "type": "image",
            "bbox": [
                0.101,
                0.14,
                0.344,
                0.239
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.389,
                0.14,
                0.69,
                0.239
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.1,
                0.242,
                0.434,
                0.334
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.336,
                0.701,
                0.351
            ],
            "angle": 0,
            "content": "4. 求练习 \\(1 \\sim 3\\) 中每个图的顶点的度之和，并验证它等于图中边数的2倍。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.353,
                0.631,
                0.368
            ],
            "angle": 0,
            "content": "5. 是否存在一个有 15 个顶点而且每个顶点的度都为 5 的简单图？"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.37,
                0.786,
                0.386
            ],
            "angle": 0,
            "content": "6. 证明：在一次聚会上全体人员的握手次数之和是偶数。假设无人自己与自己握手。"
        },
        {
            "type": "list",
            "bbox": [
                0.099,
                0.336,
                0.786,
                0.386
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.388,
                0.844,
                0.403
            ],
            "angle": 0,
            "content": "在练习 \\(7\\sim 9\\) 中，对给定的有向多重图，确定顶点数和边数，并求出每个顶点的入度和出度。"
        },
        {
            "type": "image",
            "bbox": [
                0.101,
                0.406,
                0.263,
                0.506
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.346,
                0.407,
                0.51,
                0.507
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.596,
                0.406,
                0.856,
                0.506
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.509,
                0.948,
                0.541
            ],
            "angle": 0,
            "content": "10. 对练习 \\(7\\sim 9\\) 中的每个图，直接确定每个顶点的入度之和与出度之和。证明：它们都等于图中的边数。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.544,
                0.461,
                0.559
            ],
            "angle": 0,
            "content": "11. 构造图2中带有向边的图的基本无向图。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.561,
                0.948,
                0.611
            ],
            "angle": 0,
            "content": "12. 在相识关系图中（其中顶点表示世界上所有的人），顶点的度表示什么？在这个图中，一个顶点的邻居表示什么？孤立点和悬挂点表示什么？在一项研究中，估计在这个图中顶点的平均度是 1000。就这个模型而言，这意味着什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.613,
                0.891,
                0.629
            ],
            "angle": 0,
            "content": "13. 在学术合作图中，顶点的度表示什么？一个顶点的邻居表示什么？孤立点和悬挂点表示什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.631,
                0.871,
                0.646
            ],
            "angle": 0,
            "content": "14. 在好莱坞图里，顶点的度表示什么？一个顶点的邻居表示什么？孤立点和悬挂点表示什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.648,
                0.948,
                0.68
            ],
            "angle": 0,
            "content": "15. 在 10.1 节例 4 所描述的电话呼叫图中，顶点的入度和出度表示什么？在这个图的无向图版本中，顶点的度表示什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.683,
                0.657,
                0.698
            ],
            "angle": 0,
            "content": "16. 在 10.1 节例 5 所描述的网络图中，顶点的入度和出度表示什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.701,
                0.611,
                0.716
            ],
            "angle": 0,
            "content": "17. 在为循环赛建模的有向图中，顶点的入度和出度表示什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.718,
                0.683,
                0.733
            ],
            "angle": 0,
            "content": "18. 证明：在至少含有两个顶点的简单图中，一定有两个顶点的度相同。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.736,
                0.692,
                0.751
            ],
            "angle": 0,
            "content": "19. 利用练习 18 证明：在一个小组中，至少有两个人具有相同的朋友数。"
        },
        {
            "type": "list",
            "bbox": [
                0.101,
                0.509,
                0.948,
                0.751
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.754,
                0.258,
                0.768
            ],
            "angle": 0,
            "content": "20. 画出下列各图。"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.771,
                0.177,
                0.785
            ],
            "angle": 0,
            "content": "a) \\(K_{7}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.323,
                0.771,
                0.376,
                0.785
            ],
            "angle": 0,
            "content": "b) \\(K_{1,8}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.523,
                0.771,
                0.574,
                0.785
            ],
            "angle": 0,
            "content": "c) \\(K_{4,4}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.134,
                0.788,
                0.174,
                0.802
            ],
            "angle": 0,
            "content": "d) \\(C_7\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.323,
                0.788,
                0.365,
                0.802
            ],
            "angle": 0,
            "content": "e) \\(W_{7}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.523,
                0.789,
                0.561,
                0.802
            ],
            "angle": 0,
            "content": "f) \\(Q_{4}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.805,
                0.948,
                0.837
            ],
            "angle": 0,
            "content": "在练习 \\(21\\sim 25\\) 中，判断图是否为二分图。你将发现使用定理4，对判断是否可能为每个顶点赋予红色或蓝色，以使没有两个相邻的顶点赋予相同的颜色是有用的。"
        },
        {
            "type": "image",
            "bbox": [
                0.101,
                0.841,
                0.25,
                0.936
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.334,
                0.841,
                0.559,
                0.932
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.645,
                0.841,
                0.865,
                0.936
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.752,
                0.042,
                0.859,
                0.057
            ],
            "angle": 0,
            "content": "图 585"
        },
        {
            "type": "image",
            "bbox": [
                0.04,
                0.097,
                0.381,
                0.206
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.464,
                0.097,
                0.688,
                0.239
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.242,
                0.365,
                0.257
            ],
            "angle": 0,
            "content": "26. 对哪些 \\( n \\) 值来说，下列图是二分图？"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.261,
                0.114,
                0.274
            ],
            "angle": 0,
            "content": "a) \\(K_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.242,
                0.261,
                0.282,
                0.274
            ],
            "angle": 0,
            "content": "b) \\(C_n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.41,
                0.261,
                0.453,
                0.274
            ],
            "angle": 0,
            "content": "c) \\(W_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.581,
                0.261,
                0.62,
                0.274
            ],
            "angle": 0,
            "content": "d) \\(Q_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.278,
                0.889,
                0.329
            ],
            "angle": 0,
            "content": "27. 设一个大学工程学院的计算机支撑小组有 4 个员工。每个员工被分配支持 4 个不同的领域之一：硬件、软件、网络和无线。假设 Ping 能够胜任支持硬件、网络和无线；Quiggley 能够胜任支持软件和网络；Ruiz 能够胜任支持网络和无线；Sitea 能够胜任支持硬件和软件。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.332,
                0.49,
                0.346
            ],
            "angle": 0,
            "content": "a)使用二分图为4个员工和他们能胜任的工作建模。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.349,
                0.75,
                0.364
            ],
            "angle": 0,
            "content": "b)使用霍尔定理判断是否存在一种分配方案，使每个员工都分配一个能支持的领域。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.368,
                0.694,
                0.382
            ],
            "angle": 0,
            "content": "c)如果存在一个使每个员工都分配一个能支持领域的分配方案，求出该方案。"
        },
        {
            "type": "list",
            "bbox": [
                0.073,
                0.332,
                0.75,
                0.382
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.385,
                0.889,
                0.455
            ],
            "angle": 0,
            "content": "28. 设一个新公司有 5 名员工：Zamora、Agraharam、Smith、Chou 和 Macintyre。每名员工承担下列 6 种责任之一：策划、宣传、销售、市场、开发以及工业关系。每名员工能够做这些工作中的一种或多种：Zamora 能做策划、销售、市场或工业关系；Agraharam 能做策划或开发；Smith 能做宣传、销售或工业关系；Chou 能做策划、销售或工业关系；Macintyre 能做策划、宣传、销售或工业关系。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.457,
                0.38,
                0.471
            ],
            "angle": 0,
            "content": "a)使用二分图对这些员工的能力建模。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.474,
                0.51,
                0.489
            ],
            "angle": 0,
            "content": "b)找出一个责任指派，使得每个员工被指定一种责任。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.493,
                0.565,
                0.507
            ],
            "angle": 0,
            "content": "c) 你在 b 中找到的责任匹配是完全匹配吗？它是最大匹配吗？"
        },
        {
            "type": "list",
            "bbox": [
                0.073,
                0.457,
                0.565,
                0.507
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.51,
                0.889,
                0.597
            ],
            "angle": 0,
            "content": "29. 假设一个岛上有 5 位年轻女子和 5 位年轻男子。每位男子都愿意娶岛上的某些女子，而每位女子都愿意嫁给任何一位愿意娶她的男子。假设 Sandeep 愿意娶 Tina 和 Vandana；Barry 愿意娶 Tina、Xia 和 Uma；Teja 愿意娶 Tina 和 Zelda；Anil 愿意娶 Vandana 和 Zelda；Emilio 愿意娶 Tina 和 Zelda。使用霍尔定理证明：不存在岛上年轻男子和年轻女子的匹配使得每一个年轻男子都能和他想娶的年轻女子进行匹配。"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.599,
                0.889,
                0.668
            ],
            "angle": 0,
            "content": "30. 假设一个岛上有 5 位年轻女子和 6 位年轻男子，每位女子都愿意嫁给岛上的某些男子，而每位男子都愿意娶任何一位愿意嫁给他的女子。设 Anna 愿意嫁给 Jason、Larry 和 Matt；Barbara 愿意嫁给 Kevin 和 Larry；Carol 愿意嫁给 Jason、Nick 和 Oscar；Diane 愿意嫁给 Jason、Larry、Nick 和 Oscar；Elizabeth 愿意嫁给 Jason 和 Matt。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.671,
                0.492,
                0.686
            ],
            "angle": 0,
            "content": "a)使用二分图对这个岛上可能的婚姻关系进行建模。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.689,
                0.825,
                0.704
            ],
            "angle": 0,
            "content": "b)找出这个岛上的年轻男女的一个匹配方案，使得每个年轻女子都嫁给一个她愿意嫁给的人。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.708,
                0.53,
                0.722
            ],
            "angle": 0,
            "content": "c) 你在 b 中找到的匹配是完全匹配吗？它是最大匹配吗？"
        },
        {
            "type": "list",
            "bbox": [
                0.073,
                0.671,
                0.825,
                0.722
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.035,
                0.725,
                0.889,
                0.776
            ],
            "angle": 0,
            "content": "*31. 设存在一个整数 \\( k \\)，使得荒岛上的每个男人都愿意娶该岛上的恰好 \\( k \\) 个女人，而且该岛上的每一个女人都愿意嫁给的男人也恰好是 \\( k \\) 个。同时假设一个男人愿意娶一个女人当且仅当这个女人愿意嫁给他。证明：可能存在岛上男人和女人的匹配，使得每一个人都能和其愿意嫁/娶的人进行匹配。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.779,
                0.889,
                0.812
            ],
            "angle": 0,
            "content": "*32. 假设 \\( {2n} \\) 名网球运动员参加循环赛。每个球员在连续 \\( {2n} - 1 \\) 天内都恰好和其他玩家有一场比赛。每场比赛有一个赢家和一个输家。证明每天选择一个获胜的玩家而不选择同一玩家两次是可能的。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.814,
                0.889,
                0.847
            ],
            "angle": 0,
            "content": "*33. 假设在一次抽奖中，有 \\( m \\) 人被选为中奖者，每个中奖者可以从不同的奖品中选取两个奖品。证明若有 \\( 2m \\) 个每个中奖者都想要的奖品，则每个中奖者都能选择两个他们想要的奖品。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.85,
                0.889,
                0.923
            ],
            "angle": 0,
            "content": "*34. 在本练习中，我们证明 Øystein Ore 的一个定理。假设 \\(G = (V, E)\\) 是带有二部划分 \\((V_1, V_2)\\) 的二分图且 \\(A \\subseteq V_1\\) 。证明 \\(V_1\\) 中与 \\(G\\) 匹配的端点的最大顶点数等于 \\(\\left|V_1\\right| - \\max_{A \\subseteq V_1} \\operatorname{def}(A)\\)，其中 \\(\\operatorname{def}(A) = |A| - |N(A)|\\)。（这里 \\(\\operatorname{def}(A)\\) 称为 \\(A\\) 的缺陷。）[提示：通过在 \\(V_2\\) 中增加 \\(\\max_{A \\subseteq V_1} \\operatorname{def}(A)\\) 个新顶点，并把它们与 \\(V_1\\) 中的顶点相连得到一个更大的图。]"
        },
        {
            "type": "list",
            "bbox": [
                0.035,
                0.725,
                0.889,
                0.923
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.927,
                0.253,
                0.941
            ],
            "angle": 0,
            "content": "35. 对练习1中的图，求："
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.137,
                0.042,
                0.174,
                0.057
            ],
            "angle": 0,
            "content": "586"
        },
        {
            "type": "header",
            "bbox": [
                0.218,
                0.041,
                0.295,
                0.057
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.098,
                0.429,
                0.112
            ],
            "angle": 0,
            "content": "a)由顶点 \\( a \\) 、 \\( b \\) 、 \\( c \\) 和 \\( f \\) 导出的子图。"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.116,
                0.515,
                0.131
            ],
            "angle": 0,
            "content": "b) 收缩连接 \\( b \\) 和 \\( f \\) 的边，从 \\( G \\) 得到的新图 \\( G_{1} \\)。"
        },
        {
            "type": "list",
            "bbox": [
                0.139,
                0.098,
                0.515,
                0.131
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.133,
                0.722,
                0.148
            ],
            "angle": 0,
            "content": "36. 令 \\(n\\) 为正整数。证明：由 \\(K_{n}\\) 的顶点集的非空子集导出的子图是完全图。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.151,
                0.416,
                0.166
            ],
            "angle": 0,
            "content": "37. 下列图有多少个顶点和多少条边？"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.169,
                0.186,
                0.184
            ],
            "angle": 0,
            "content": "a) \\(K_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.348,
                0.169,
                0.39,
                0.184
            ],
            "angle": 0,
            "content": "b) \\(C_n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.516,
                0.169,
                0.56,
                0.183
            ],
            "angle": 0,
            "content": "c) \\(W_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.187,
                0.198,
                0.201
            ],
            "angle": 0,
            "content": "d) \\(K_{m,n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.349,
                0.187,
                0.388,
                0.201
            ],
            "angle": 0,
            "content": "e) \\(Q_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.204,
                0.953,
                0.235
            ],
            "angle": 0,
            "content": "一个图的度序列是由该图的各个顶点的度按非递增顺序排列的序列。例如，本节例1中图 \\(G\\) 的度序列就是4，4，4，3，2，1，0。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.239,
                0.422,
                0.254
            ],
            "angle": 0,
            "content": "38. 求练习 \\(21 \\sim 25\\) 中各个图的度序列。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.257,
                0.34,
                0.271
            ],
            "angle": 0,
            "content": "39. 求下列各个图的度序列。"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.275,
                0.186,
                0.289
            ],
            "angle": 0,
            "content": "a) \\(K_{4}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.349,
                0.275,
                0.388,
                0.289
            ],
            "angle": 0,
            "content": "b) \\(C_4\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.517,
                0.275,
                0.56,
                0.289
            ],
            "angle": 0,
            "content": "c) \\(W_{4}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.293,
                0.196,
                0.307
            ],
            "angle": 0,
            "content": "d) \\(K_{2,3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.349,
                0.293,
                0.388,
                0.307
            ],
            "angle": 0,
            "content": "e) \\(Q_{3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.31,
                0.709,
                0.325
            ],
            "angle": 0,
            "content": "40. 二分图 \\(K_{m,n}\\) 的度序列是什么（其中 \\(m, n\\) 是正整数）？并解释你的答案。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.328,
                0.632,
                0.342
            ],
            "angle": 0,
            "content": "41. 图 \\(K_{n}\\) 的度序列是什么（其中 \\(n\\) 是正整数）？并解释你的答案。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.345,
                0.686,
                0.36
            ],
            "angle": 0,
            "content": "42. 若图的度序列是 4, 3, 3, 2, 2, 则它有多少条边? 画出这样的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.363,
                0.713,
                0.377
            ],
            "angle": 0,
            "content": "43. 若图的度序列是5，2，2，2，2，1，则它有多少条边？画出这样的图。"
        },
        {
            "type": "list",
            "bbox": [
                0.108,
                0.328,
                0.713,
                0.377
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.381,
                0.706,
                0.395
            ],
            "angle": 0,
            "content": "如果序列 \\(d_{1}\\) ， \\(d_{2}\\) ，…， \\(d_{n}\\) 是一个简单图的度序列，那么该序列是成图的。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.398,
                0.766,
                0.413
            ],
            "angle": 0,
            "content": "44. 判断下列序列是否是成图的。如果是，请画出一个图使其具有给定的度序列。"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.416,
                0.312,
                0.43
            ],
            "angle": 0,
            "content": "a)5，4，3，2，1，0"
        },
        {
            "type": "text",
            "bbox": [
                0.382,
                0.416,
                0.55,
                0.429
            ],
            "angle": 0,
            "content": "b)6，5，4，3，2，1"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.434,
                0.311,
                0.447
            ],
            "angle": 0,
            "content": "c)2，2，2，2，2"
        },
        {
            "type": "text",
            "bbox": [
                0.381,
                0.434,
                0.55,
                0.447
            ],
            "angle": 0,
            "content": "d)3，3，3，2，2，2"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.452,
                0.311,
                0.465
            ],
            "angle": 0,
            "content": "e)3，3，2，2，2，2"
        },
        {
            "type": "text",
            "bbox": [
                0.381,
                0.452,
                0.548,
                0.464
            ],
            "angle": 0,
            "content": "f)1，1，1，1，1，1"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.47,
                0.311,
                0.483
            ],
            "angle": 0,
            "content": "g)5，3，3，3，3，3"
        },
        {
            "type": "text",
            "bbox": [
                0.381,
                0.47,
                0.55,
                0.482
            ],
            "angle": 0,
            "content": "h)5，5，4，3，2，1"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.486,
                0.766,
                0.501
            ],
            "angle": 0,
            "content": "45. 判断下列序列是否是成图的。如果是，请画出一个图使其具有给定的度序列。"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.505,
                0.286,
                0.518
            ],
            "angle": 0,
            "content": "a)3，3，3，3，2"
        },
        {
            "type": "text",
            "bbox": [
                0.382,
                0.505,
                0.522,
                0.518
            ],
            "angle": 0,
            "content": "b)5，4，3，2，1"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.523,
                0.282,
                0.536
            ],
            "angle": 0,
            "content": "c)4，4，3，2，1"
        },
        {
            "type": "text",
            "bbox": [
                0.382,
                0.523,
                0.523,
                0.536
            ],
            "angle": 0,
            "content": "d)4，4，3，3，3"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.541,
                0.282,
                0.553
            ],
            "angle": 0,
            "content": "e)3，2，2，1，0"
        },
        {
            "type": "text",
            "bbox": [
                0.382,
                0.541,
                0.519,
                0.553
            ],
            "angle": 0,
            "content": "f)1，1，1，1，1"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.557,
                0.953,
                0.59
            ],
            "angle": 0,
            "content": "* 46. 设 \\(d_{1}, d_{2}, \\cdots, d_{n}\\) 是成图序列。证明：存在顶点为 \\(v_{1}, v_{2}, \\cdots, v_{n}\\) 的简单图，使得对于 \\(i = 1, 2, \\cdots, n\\)，\\(\\deg(v_{i}) = d_{i}\\)，且 \\(v_{1}\\) 与 \\(v_{2}, \\cdots, V_{d_{1} + 1}\\) 相邻。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.593,
                0.953,
                0.626
            ],
            "angle": 0,
            "content": "* 47. 证明：一个由非负整数按非递增排列的序列 \\(d_{1}, d_{2}, \\cdots, d_{n}\\) 是成图序列当且仅当把序列 \\(d_{2}-1, \\cdots, d_{d_{1}+1}-1, d_{d_{1}+2}, \\cdots, d_{n}\\) 中的元素重新排序为非递增而得到的序列是成图序列。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.629,
                0.851,
                0.643
            ],
            "angle": 0,
            "content": "* 48. 运用练习 47 的结论构造一个递归算法来判断一个非递增的正整数序列是否为成图序列。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.647,
                0.953,
                0.697
            ],
            "angle": 0,
            "content": "49. 证明：每个非负整数构成的非递增序列，如果其元素之和为偶数，则都是某个伪图的度序列。伪图是允许有环的无向图。[提示：首先通过给每个顶点添加尽可能多的环来构造一个图，然后添加一些边连接度为奇数的顶点。解释为什么这种构造方法能够证明此问题。]"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.7,
                0.486,
                0.715
            ],
            "angle": 0,
            "content": "50. 至少带有 1 个顶点的 \\(K_{2}\\) 的子图有多少个？"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.718,
                0.486,
                0.732
            ],
            "angle": 0,
            "content": "51. 至少带有 1 个顶点的 \\(K_{3}\\) 的子图有多少个？"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.736,
                0.487,
                0.75
            ],
            "angle": 0,
            "content": "52. 至少带有 1 个顶点的 \\(W_{3}\\) 的子图有多少个？"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.754,
                0.323,
                0.768
            ],
            "angle": 0,
            "content": "53. 画出下图的所有子图。"
        },
        {
            "type": "list",
            "bbox": [
                0.096,
                0.557,
                0.953,
                0.768
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.143,
                0.771,
                0.268,
                0.87
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.872,
                0.928,
                0.887
            ],
            "angle": 0,
            "content": "54. 设 \\(G\\) 是带有 \\(v\\) 个顶点和 \\(e\\) 条边的图。设 \\(M\\) 是 \\(G\\) 的顶点的最大度，\\(m\\) 是 \\(G\\) 的顶点的最小度。证明："
        },
        {
            "type": "text",
            "bbox": [
                0.144,
                0.891,
                0.235,
                0.904
            ],
            "angle": 0,
            "content": "a) \\(2e / v\\geqslant m\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.324,
                0.891,
                0.417,
                0.904
            ],
            "angle": 0,
            "content": "b) \\(2e / v\\leqslant M\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.908,
                0.955,
                0.94
            ],
            "angle": 0,
            "content": "若简单图中每个顶点的度都相等，则这个图称为正则的。若正则图中每个顶点的度都为 \\(n\\)，则这个图称为 \\(n\\) 正则的。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.78,
                0.033,
                0.887,
                0.048
            ],
            "angle": 0,
            "content": "图 587"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.088,
                0.391,
                0.103
            ],
            "angle": 0,
            "content": "55. 对哪些 \\(n\\) 值来说，下列图是正则图？"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.107,
                0.143,
                0.121
            ],
            "angle": 0,
            "content": "a) \\(K_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.232,
                0.107,
                0.272,
                0.121
            ],
            "angle": 0,
            "content": "b) \\(C_n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.363,
                0.108,
                0.406,
                0.121
            ],
            "angle": 0,
            "content": "c) \\(W_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.497,
                0.108,
                0.537,
                0.121
            ],
            "angle": 0,
            "content": "d) \\(Q_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.125,
                0.431,
                0.139
            ],
            "angle": 0,
            "content": "56. 对哪些 \\(m\\) 和 \\(n\\) 的值来说，\\(K_{m,n}\\) 是正则图？"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.143,
                0.512,
                0.157
            ],
            "angle": 0,
            "content": "57. 度都为 4 而且带有 10 条边的正则图有多少个顶点？"
        },
        {
            "type": "list",
            "bbox": [
                0.067,
                0.125,
                0.512,
                0.157
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.161,
                0.699,
                0.175
            ],
            "angle": 0,
            "content": "在练习 \\(58\\sim 60\\) 中，求给定简单图对的并图（假设带有相同端点的边是相同的）。"
        },
        {
            "type": "text",
            "bbox": [
                0.068,
                0.179,
                0.095,
                0.192
            ],
            "angle": 0,
            "content": "58."
        },
        {
            "type": "image",
            "bbox": [
                0.098,
                0.178,
                0.235,
                0.294
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.264,
                0.198,
                0.374,
                0.294
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.423,
                0.179,
                0.449,
                0.192
            ],
            "angle": 0,
            "content": "59."
        },
        {
            "type": "image",
            "bbox": [
                0.453,
                0.179,
                0.571,
                0.276
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.603,
                0.179,
                0.728,
                0.276
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.068,
                0.297,
                0.095,
                0.31
            ],
            "angle": 0,
            "content": "60."
        },
        {
            "type": "image",
            "bbox": [
                0.098,
                0.297,
                0.215,
                0.393
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.24,
                0.298,
                0.358,
                0.395
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.397,
                0.916,
                0.43
            ],
            "angle": 0,
            "content": "61. 简单图 \\(G\\) 的补图 \\(\\overline{G}\\) 与 \\(G\\) 有相同的顶点。两个顶点在 \\(\\overline{G}\\) 中相邻，当且仅当它们在 \\(G\\) 中不相邻。画出下列各图。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.432,
                0.147,
                0.448
            ],
            "angle": 0,
            "content": "a) \\(\\overline{K_n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.215,
                0.434,
                0.272,
                0.447
            ],
            "angle": 0,
            "content": "b) \\(\\overline{K_{m,n}}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.343,
                0.434,
                0.382,
                0.447
            ],
            "angle": 0,
            "content": "c) \\(\\overline{C_n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.453,
                0.434,
                0.496,
                0.447
            ],
            "angle": 0,
            "content": "d) \\(\\overline{Q_n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.453,
                0.622,
                0.467
            ],
            "angle": 0,
            "content": "62. 若 \\(G\\) 是有 15 条边的简单图且 \\(\\overline{G}\\) 有 13 条边，则 \\(G\\) 有多少个顶点？"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.471,
                0.526,
                0.485
            ],
            "angle": 0,
            "content": "63. 若简单图 \\(G\\) 有 \\(v\\) 个顶点和 \\(e\\) 条边，则 \\(\\overline{G}\\) 有多少条边？"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.489,
                0.557,
                0.503
            ],
            "angle": 0,
            "content": "64. 若简单图 \\(G\\) 的度序列为 4, 3, 3, 2, 2。求 \\(\\overline{G}\\) 的度序列。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.507,
                0.567,
                0.521
            ],
            "angle": 0,
            "content": "65. 若简单图 \\(G\\) 的度序列为 \\(d_{1}\\), \\(d_{2}\\), \\(\\cdots\\), \\(d_{n}\\) 。求 \\(\\overline{G}\\) 的度序列。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.526,
                0.605,
                0.539
            ],
            "angle": 0,
            "content": "66. 证明：若 \\(G\\) 是有 \\(v\\) 个顶点和 \\(e\\) 条边的简单二分图，则 \\(e \\leqslant v^2 / 4\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.543,
                0.593,
                0.557
            ],
            "angle": 0,
            "content": "67. 证明：若 \\(G\\) 是有 \\(n\\) 个顶点的简单图，则 \\(G\\) 和 \\(\\overline{G}\\) 的并图是 \\(K_{n}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.561,
                0.915,
                0.593
            ],
            "angle": 0,
            "content": "* 68. 描述判定图是否为二分图的算法。可基于事实：一个图是二分图当且仅当可以用两种不同的颜色为它的顶点着色使得没有着相同颜色的两个顶点是相邻的。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.597,
                0.902,
                0.611
            ],
            "angle": 0,
            "content": "有向图 \\(G = (V,E)\\) 的逆图，记作 \\(G^{\\mathrm{conv}}\\) ，是有向图 \\((V,F)\\) ，其中 \\(G^{\\mathrm{conv}}\\) 中边的集合 \\(F\\) 由改变 \\(E\\) 中边的方向得到。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.615,
                0.426,
                0.629
            ],
            "angle": 0,
            "content": "69. 画出10.1节练习 \\(7\\sim 9\\) 中每个图的逆图。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.633,
                0.443,
                0.647
            ],
            "angle": 0,
            "content": "70. 证明：当 \\(G\\) 是有向图时，有 \\((G^{\\mathrm{conv}})^{\\mathrm{conv}} = G\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.651,
                0.748,
                0.665
            ],
            "angle": 0,
            "content": "71. 证明：图 \\(G\\) 是它自身的逆图，当且仅当 \\(G\\) 所关联的关系（参见9.3节）是对称的。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.669,
                0.915,
                0.721
            ],
            "angle": 0,
            "content": "72. 证明：如果一个二分图 \\(G = (V, E)\\) 对于某个正整数 \\(n\\) 是 \\(n\\) 正则的（参见练习55的前导文），且 \\((V_1, V_2)\\) 是 \\(V\\) 的一个二部划分，则 \\(\\left|V_1\\right| = \\left|V_2\\right|\\) 。也就是，证明：\\(n\\) 正则二分图的顶点集的二部划分得到的两个顶点集一定包含相同个数的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.725,
                0.408,
                0.739
            ],
            "angle": 0,
            "content": "73. 画出9个并行处理器互连的栅格网络。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.743,
                0.915,
                0.775
            ],
            "angle": 0,
            "content": "74. 在互连 \\(n = m^2\\) 个处理器的栅格网络的变种中，处理器 \\(P(i, j)\\) 连接 4 个处理器 \\(P((i \\pm 1) \\bmod m, j)\\) 和 \\(P(i, (j \\pm 1) \\bmod m)\\)，使得连接沿栅格的边卷绕。画出有 16 个处理器的这种变种的栅格网络。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.781,
                0.864,
                0.795
            ],
            "angle": 0,
            "content": "75. 证明：在 \\(n = m^2\\) 个处理器的栅格网络中，用 \\(O(\\sqrt{n}) = O(m)\\) 个跳就能让每一对处理器互相通信。"
        },
        {
            "type": "list",
            "bbox": [
                0.055,
                0.453,
                0.915,
                0.795
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.071,
                0.81,
                0.39,
                0.83
            ],
            "angle": 0,
            "content": "10.3 图的表示和图的同构"
        },
        {
            "type": "title",
            "bbox": [
                0.071,
                0.838,
                0.208,
                0.855
            ],
            "angle": 0,
            "content": "10.3.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.068,
                0.859,
                0.916,
                0.894
            ],
            "angle": 0,
            "content": "图的表示方式有很多种。本章将看到，选择最方便的表示有助于对图的处理。本节将要说明如何用多种不同的方式来表示图。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.897,
                0.916,
                0.933
            ],
            "angle": 0,
            "content": "有时，两个图具有完全相同的形式，从某种意义上就是两个图的顶点之间存在着一一对应，这个对应保持边的对应关系。在这种情形下，就说这两个图是同构的。判断两个图是否同"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.113,
                0.034,
                0.149,
                0.047
            ],
            "angle": 0,
            "content": "588"
        },
        {
            "type": "header",
            "bbox": [
                0.194,
                0.032,
                0.271,
                0.047
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.088,
                0.489,
                0.105
            ],
            "angle": 0,
            "content": "构，这是本节将要研究的一个重要图论问题。"
        },
        {
            "type": "title",
            "bbox": [
                0.087,
                0.116,
                0.269,
                0.133
            ],
            "angle": 0,
            "content": "10.3.2 图的表示"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.136,
                0.929,
                0.172
            ],
            "angle": 0,
            "content": "表示不带多重边的图的一种方式是列出这个图的所有边。另一种表示不带多重边的图的方式是用邻接表，它给出了与图中每个顶点相邻的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.177,
                0.479,
                0.195
            ],
            "angle": 0,
            "content": "例1 用邻接表描述图1所示的简单图。"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.2,
                0.529,
                0.216
            ],
            "angle": 0,
            "content": "解表1列出了与图的每个顶点相邻的顶点。"
        },
        {
            "type": "image",
            "bbox": [
                0.189,
                0.23,
                0.404,
                0.359
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.242,
                0.361,
                0.352,
                0.376
            ],
            "angle": 0,
            "content": "图1 简单图"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.562,
                0.228,
                0.746,
                0.242
            ],
            "angle": 0,
            "content": "表 1 简单图的邻接表"
        },
        {
            "type": "table",
            "bbox": [
                0.489,
                0.244,
                0.821,
                0.363
            ],
            "angle": 0,
            "content": "<table><tr><td>顶点</td><td>相邻顶点</td></tr><tr><td>a</td><td>b,c,e</td></tr><tr><td>b</td><td>a</td></tr><tr><td>c</td><td>a,d,e</td></tr><tr><td>d</td><td>c,e</td></tr><tr><td>e</td><td>a,c,d</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.387,
                0.807,
                0.426
            ],
            "angle": 0,
            "content": "例2 通过列出图中每个顶点发出的边的所有终点，表示图2所示的有向图。解表2表示图2所示的有向图。"
        },
        {
            "type": "image",
            "bbox": [
                0.189,
                0.439,
                0.431,
                0.575
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.256,
                0.577,
                0.365,
                0.592
            ],
            "angle": 0,
            "content": "图2 有向图"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.564,
                0.438,
                0.746,
                0.452
            ],
            "angle": 0,
            "content": "表 2 有向图的邻接表"
        },
        {
            "type": "table",
            "bbox": [
                0.49,
                0.453,
                0.821,
                0.573
            ],
            "angle": 0,
            "content": "<table><tr><td>起 点</td><td>终 点</td></tr><tr><td>a</td><td>b, c, d, e</td></tr><tr><td>b</td><td>b, d</td></tr><tr><td>c</td><td>a, c, e</td></tr><tr><td>d</td><td></td></tr><tr><td>e</td><td>b, c, d</td></tr></table>"
        },
        {
            "type": "title",
            "bbox": [
                0.089,
                0.616,
                0.27,
                0.633
            ],
            "angle": 0,
            "content": "10.3.3 邻接矩阵"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.636,
                0.934,
                0.691
            ],
            "angle": 0,
            "content": "若图中有许多边，则把图表示成边的表或邻接表不便于执行图的算法。为了简化计算，可用矩阵表示图。在此，将给出常用的两种表示图的矩阵的类型。一种类型是基于顶点的相邻关系，另一种类型是基于顶点与边的关联关系。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.694,
                0.934,
                0.77
            ],
            "angle": 0,
            "content": "假设 \\(G = (V, E)\\) 是简单图，其中 \\(|V| \\cong n\\)。假设把 \\(G\\) 的顶点任意地排列成 \\(v_{1}, v_{2}, \\dots, v_{n}\\)。对这个顶点序列来说，\\(G\\) 的邻接矩阵 \\(\\mathbf{A}\\)（或 \\(\\mathbf{A}_{G}\\)）是一个 \\(n \\times n\\) 的 0-1 矩阵，它满足这样的性质：当 \\(v_{i}\\) 和 \\(v_{j}\\) 相邻时第 \\((i, j)\\) 项是 1，当 \\(v_{i}\\) 和 \\(v_{j}\\) 不相邻时第 \\((i, j)\\) 项是 0。换句话说，若邻接矩阵是 \\(\\mathbf{A} = [a_{ij}]\\)，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.355,
                0.772,
                0.667,
                0.81
            ],
            "angle": 0,
            "content": "\\[\na _ {i j} = \\left\\{ \\begin{array}{l l} 1 & \\{v _ {i}, v _ {j} \\} \\text {是} G \\text {的 一 条 边} \\\\ 0 & \\text {否 则} \\end{array} \\right.\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.129,
                0.815,
                0.461,
                0.833
            ],
            "angle": 0,
            "content": "例3 用邻接矩阵表示图3所示的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.129,
                0.838,
                0.607,
                0.854
            ],
            "angle": 0,
            "content": "解 把顶点排列成 \\(a, b, c, d\\) 。表示这个图的矩阵是"
        },
        {
            "type": "equation",
            "bbox": [
                0.451,
                0.858,
                0.575,
                0.929
            ],
            "angle": 0,
            "content": "\\[\n\\left[ \\begin{array}{c c c c} 0 & 1 & 1 & 1 \\\\ 1 & 0 & 1 & 0 \\\\ 1 & 1 & 0 & 0 \\\\ 1 & 0 & 0 & 0 \\end{array} \\right]\n\\]"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.757,
                0.03,
                0.863,
                0.045
            ],
            "angle": 0,
            "content": "图 589"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.088,
                0.569,
                0.105
            ],
            "angle": 0,
            "content": "例4 画出具有顶点顺序 \\(a, b, c, d\\) 的邻接矩阵的图。"
        },
        {
            "type": "equation",
            "bbox": [
                0.406,
                0.112,
                0.531,
                0.184
            ],
            "angle": 0,
            "content": "\\[\n\\left[ \\begin{array}{c c c c} 0 & 1 & 1 & 0 \\\\ 1 & 0 & 0 & 1 \\\\ 1 & 0 & 0 & 1 \\\\ 0 & 1 & 1 & 0 \\end{array} \\right]\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.187,
                0.449,
                0.204
            ],
            "angle": 0,
            "content": "解图4显示了这个邻接矩阵对应的图。"
        },
        {
            "type": "image",
            "bbox": [
                0.191,
                0.21,
                0.314,
                0.31
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.196,
                0.318,
                0.306,
                0.333
            ],
            "angle": 0,
            "content": "图3 简单图"
        },
        {
            "type": "image",
            "bbox": [
                0.626,
                0.211,
                0.745,
                0.31
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.576,
                0.318,
                0.796,
                0.333
            ],
            "angle": 0,
            "content": "图4 给定的邻接矩阵的图"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.34,
                0.893,
                0.376
            ],
            "angle": 0,
            "content": "注意，图的邻接矩阵依赖于所选择的顶点的顺序。因此带 \\(n\\) 个顶点的图有 \\(n!\\) 个不同的邻接矩阵，因为 \\(n\\) 个顶点有 \\(n!\\) 个不同的顺序。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.378,
                0.892,
                0.433
            ],
            "angle": 0,
            "content": "简单图的邻接矩阵是对称的，即 \\(a_{ij} = a_{ji}\\) ，因为当 \\(\\boldsymbol{v}_i\\) 和 \\(\\boldsymbol{v}_j\\) 相邻时，这两个项都是1，否则都是0。另外，因为简单图无环，所以每一项 \\(a_{ii}, i = 1,2,3,\\dots ,n\\) ，都是0。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.435,
                0.721,
                0.51
            ],
            "angle": 0,
            "content": "邻接矩阵也可用来表示带环和多重边的无向图。把顶点 \\(a_{i}\\) 上的环表示成邻接矩阵第 \\((i,i)\\) 位置上的1。当出现多重边连接相同的顶点对 \\(v_{i}\\) 和 \\(v_{j}\\) 时，邻接矩阵不再是0-1矩阵，因为邻接矩阵的第 \\((i,j)\\) 项等于与 \\(\\{v_i,v_j\\}\\) 关联的边数。包括多重图与伪图在内的所有无向图都具有对称的邻接矩阵。"
        },
        {
            "type": "image",
            "bbox": [
                0.737,
                0.402,
                0.895,
                0.509
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.769,
                0.518,
                0.86,
                0.533
            ],
            "angle": 0,
            "content": "图5伪图"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.515,
                0.44,
                0.532
            ],
            "angle": 0,
            "content": "例5 用邻接矩阵表示图5所示的伪图。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.537,
                0.467,
                0.553
            ],
            "angle": 0,
            "content": "解 顶点顺序为 \\(a, b, c, d\\) 的邻接矩阵是"
        },
        {
            "type": "equation",
            "bbox": [
                0.408,
                0.557,
                0.534,
                0.628
            ],
            "angle": 0,
            "content": "\\[\n\\left[ \\begin{array}{c c c c} 0 & 3 & 0 & 2 \\\\ 3 & 0 & 1 & 1 \\\\ 0 & 1 & 1 & 2 \\\\ 2 & 1 & 2 & 0 \\end{array} \\right]\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.631,
                0.895,
                0.685
            ],
            "angle": 0,
            "content": "我们曾在第9章里用0-1矩阵表示有向图。若有向图 \\(G = (V, E)\\) 从 \\(\\boldsymbol{v}_i\\) 到 \\(\\boldsymbol{v}_j\\) 有边，则它的矩阵在 \\((i, j)\\) 位置上有1，其中 \\(v_1, v_2, \\dots, v_n\\) 是有向图任意的顶点序列。换句话说，若 \\(\\mathbf{A} = [a_{ij}]\\) 是相对于这个顶点列表的邻接矩阵，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.311,
                0.687,
                0.627,
                0.724
            ],
            "angle": 0,
            "content": "\\[\na _ {i j} = \\left\\{ \\begin{array}{l l} 1 & \\{v _ {i}, v _ {j} \\} \\text {是} G \\text {的 一 条 边} \\\\ 0 & \\text {否 则} \\end{array} \\right.\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.726,
                0.821,
                0.743
            ],
            "angle": 0,
            "content": "有向图的邻接矩阵不一定是对称的，因为当从 \\(v_{i}\\) 到 \\(v_{j}\\) 有边时，从 \\(v_{j}\\) 到 \\(v_{i}\\) 可以没有边。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.745,
                0.895,
                0.781
            ],
            "angle": 0,
            "content": "邻接矩阵也可用来表示有向多重图。同样，当有连接两个顶点的同向多重边时，这样的矩阵不是0-1矩阵。在有向多重图的邻接矩阵中， \\(a_{ij}\\) 等于关联到 \\((v_i, v_j)\\) 的边数。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.782,
                0.895,
                0.874
            ],
            "angle": 0,
            "content": "在邻接表和邻接矩阵之间取舍 当一个简单图包含的边相对较少，即该图是一个稀疏图时，通常邻接表比邻接矩阵更适合表示它。例如，如果每个顶点的度都不超过 \\(c\\)，\\(c\\) 是一个比 \\(n\\) 小很多的常数，则每个邻接表包含 \\(c\\) 个或更少的顶点。所以整个邻接表中的元素不超过 \\(cn\\) 个。另一方面，该图的邻接矩阵含有 \\(n^2\\) 个元素。但是，需要注意的是，稀疏图的邻接矩阵是稀疏矩阵，即矩阵中只有少量元素不为 0。有专门的技术表示和处理稀疏矩阵。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.877,
                0.895,
                0.932
            ],
            "angle": 0,
            "content": "现在设想一个稠密的简单图，它含有很多条边，例如，它含有的边数超过所有可能的边数的一半。在这种情形下，用邻接矩阵来表示图就比用邻接表好。为了知道原因，我们来比较判断某条边 \\(\\{v_{i}, v_{j}\\}\\) 是否存在的复杂度。在邻接矩阵中，可以通过查看第 \\((i, j)\\) 个元素来决定这"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.13,
                0.031,
                0.169,
                0.045
            ],
            "angle": 0,
            "content": "590"
        },
        {
            "type": "header",
            "bbox": [
                0.211,
                0.03,
                0.29,
                0.046
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.087,
                0.951,
                0.161
            ],
            "angle": 0,
            "content": "条边是否存在。如果该元素是1，边就存在；如果是0，边就不存在。所以，只需要一次比较，即将第 \\((i,j)\\) 个元素与0比较，就可以判断这条边是否存在。而另一方面，如果使用邻接表表示这个图，就需要搜索 \\(v_{i}\\) 或 \\(v_{j}\\) 的链表中的顶点才能判断这条边是否存在。当图含有的边很多时，就需要 \\(\\Theta (|V|)\\) 次的比较。"
        },
        {
            "type": "title",
            "bbox": [
                0.103,
                0.174,
                0.287,
                0.191
            ],
            "angle": 0,
            "content": "10.3.4 关联矩阵"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.196,
                0.951,
                0.251
            ],
            "angle": 0,
            "content": "表示图的另一种常用方式是用关联矩阵。设 \\(G = (V, E)\\) 是无向图。设 \\(v_{1}, v_{2}, \\dots, v_{n}\\) 是图 \\(G\\) 的顶点，而 \\(e_{1}, e_{2}, \\dots, e_{m}\\) 是该图的边。相对于 \\(V\\) 和 \\(E\\) 的这个顺序的关联矩阵是 \\(n \\times m\\) 的矩阵 \\(\\mathbf{M} = [m_{ij}]\\)，其中"
        },
        {
            "type": "equation",
            "bbox": [
                0.384,
                0.254,
                0.666,
                0.291
            ],
            "angle": 0,
            "content": "\\[\nm _ {i j} = \\left\\{ \\begin{array}{l l} 1 & \\text {当 边} e _ {j} \\text {关 联} v _ {i} \\text {时} \\\\ 0 & \\text {否 则} \\end{array} \\right.\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.295,
                0.478,
                0.313
            ],
            "angle": 0,
            "content": "例6 用关联矩阵表示图6所示的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.318,
                0.293,
                0.335
            ],
            "angle": 0,
            "content": "解 关联矩阵是"
        },
        {
            "type": "equation",
            "bbox": [
                0.3,
                0.34,
                0.524,
                0.452
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{c c c c c c} & e _ {1} & e _ {2} & e _ {3} & e _ {4} & e _ {5} & e _ {6} \\\\ v _ {1} & 1 & 1 & 0 & 0 & 0 & 0 \\\\ v _ {2} & 0 & 0 & 1 & 1 & 0 & 1 \\\\ v _ {3} & 0 & 0 & 0 & 0 & 1 & 1 \\\\ v _ {4} & 1 & 0 & 1 & 0 & 0 & 0 \\\\ v _ {5} & 0 & 1 & 0 & 1 & 1 & 0 \\end{array}\n\\]"
        },
        {
            "type": "image",
            "bbox": [
                0.738,
                0.336,
                0.931,
                0.426
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.78,
                0.434,
                0.892,
                0.448
            ],
            "angle": 0,
            "content": "图6 无向图"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.457,
                0.949,
                0.492
            ],
            "angle": 0,
            "content": "关联矩阵也可用来表示多重边和环。在关联矩阵中用各项相等的列来表示多重边，因为这些边关联同一对顶点。用只有一项等于1的列来表示环，它对应于环所关联的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.497,
                0.499,
                0.515
            ],
            "angle": 0,
            "content": "例7 用关联矩阵表示图7所示的伪图。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.52,
                0.336,
                0.536
            ],
            "angle": 0,
            "content": "解 这个图的关联矩阵是"
        },
        {
            "type": "equation",
            "bbox": [
                0.27,
                0.542,
                0.554,
                0.654
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{c c c c c c c c c} & e _ {1} & e _ {2} & e _ {3} & e _ {4} & e _ {5} & e _ {6} & e _ {7} & e _ {8} \\\\ v _ {1} & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 \\\\ v _ {2} & 0 & 1 & 1 & 1 & 0 & 1 & 1 & 0 \\\\ v _ {3} & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 \\\\ v _ {4} & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 \\\\ v _ {5} & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 \\end{array}\n\\]"
        },
        {
            "type": "image",
            "bbox": [
                0.743,
                0.549,
                0.931,
                0.628
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.79,
                0.637,
                0.882,
                0.653
            ],
            "angle": 0,
            "content": "图7伪图"
        },
        {
            "type": "title",
            "bbox": [
                0.104,
                0.668,
                0.289,
                0.685
            ],
            "angle": 0,
            "content": "10.3.5 图的同构"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.691,
                0.95,
                0.764
            ],
            "angle": 0,
            "content": "我们经常需要知道是否有可能以同样的方式来画出两个图。也就是说，当我们忽略图中的顶点的标识时，这两个图是否具有相同的结构。例如，在化学中，用图为化合物建模（我们将在后面进行描述）。不同的化合物可能分子式相同但结构不同。这样的化合物不能用同样方式画出的图来表示。表示过去已知化合物的图可以用来判定想象中的新化合物是否已经研究过。"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.767,
                0.611,
                0.783
            ],
            "angle": 0,
            "content": "对具有同样结构的图来说，存在着一些有用的术语。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.791,
                0.943,
                0.869
            ],
            "angle": 0,
            "content": "定义1 设 \\(G_{1} = (V_{1}, E_{1})\\) 和 \\(G_{2} = (V_{2}, E_{2})\\) 是简单图，若存在一对一的和映上的从 \\(V_{1}\\) 到 \\(V_{2}\\) 的函数 \\(f\\)，且 \\(f\\) 具有这样的性质：对 \\(V_{1}\\) 中所有的 \\(a\\) 和 \\(b\\) 来说，\\(a\\) 和 \\(b\\) 在 \\(G_{1}\\) 中相邻当且仅当 \\(f(a)\\) 和 \\(f(b)\\) 在 \\(G_{2}\\) 中相邻，则称 \\(G_{1}\\) 与 \\(G_{2}\\) 是同构的。这样的函数 \\(f\\) 称为同构。两个不同构的简单图称为非同构的。"
        },
        {
            "type": "page_footnote",
            "bbox": [
                0.147,
                0.915,
                0.879,
                0.93
            ],
            "angle": 0,
            "content": "\\(\\ominus\\) 同构(isomorphism)这个词来自两个希腊语字根：表示“相等”的isos和表示“形式”的morphe。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.769,
                0.039,
                0.873,
                0.053
            ],
            "angle": 0,
            "content": "图 591"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.094,
                0.905,
                0.131
            ],
            "angle": 0,
            "content": "换句话说，当两个简单图同构时，两个图的顶点之间具有保持相邻关系的一一对应。简单图的同构是一个等价关系（我们把这个验证留作练习49）。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.135,
                0.637,
                0.153
            ],
            "angle": 0,
            "content": "例8 证明：图8所示的图 \\(G = (V,E)\\) 和 \\(H = (W,F)\\) 同构。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.158,
                0.556,
                0.289
            ],
            "angle": 0,
            "content": "解函数 \\(f\\) 定义为 \\(f(u_{1}) = v_{1}\\) ， \\(f(u_{2}) = v_{4}\\) ， \\(f(u_{3}) = v_{3}\\) ， \\(f(u_{4}) = v_{2}\\) ，它是 \\(V\\) 和 \\(W\\) 之间的一一对应。为了看出这个对应保持相邻关系，注意 \\(G\\) 中相邻的顶点是 \\(u_{1}\\) 和 \\(u_{2}, u_{1}\\) 和 \\(u_{3}, u_{2}\\) 和 \\(u_{4}\\) ，以及 \\(u_{3}\\) 和 \\(u_{4}\\) ，由 \\(f(u_{1}) = v_{1}\\) 和 \\(f(u_{2}) = v_{4}\\) 、 \\(f(u_{1}) = v_{1}\\) 和 \\(f(u_{3}) = v_{3}\\) 、 \\(f(u_{2}) = v_{4}\\) 和 \\(f(u_{4}) = v_{2}\\) ，以及 \\(f(u_{3}) = v_{3}\\) 和 \\(f(u_{4}) = v_{2}\\) 所组成的每一对顶点都是在 \\(H\\) 中相邻的。"
        },
        {
            "type": "image",
            "bbox": [
                0.569,
                0.162,
                0.696,
                0.268
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.746,
                0.16,
                0.907,
                0.268
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.671,
                0.273,
                0.804,
                0.288
            ],
            "angle": 0,
            "content": "图8 图 \\(G\\) 和 \\(H\\)"
        },
        {
            "type": "title",
            "bbox": [
                0.06,
                0.298,
                0.398,
                0.317
            ],
            "angle": 0,
            "content": "10.3.6 判定两个简单图是否同构"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.319,
                0.905,
                0.374
            ],
            "angle": 0,
            "content": "判断两个简单图是否同构常常是一件困难的事情。在两个带有 \\(n\\) 个顶点的简单图的顶点集之间有 \\(n!\\) 种可能的一一对应。若 \\(n\\) 太大，则通过检验每一种对应来看它是否保持相邻关系是不可行的。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.376,
                0.906,
                0.45
            ],
            "angle": 0,
            "content": "有时说明两个图不同构并不困难。特别是，如果能找到某个属性，两个图中只有一个图具有这个属性，但该属性应该在同构时保持，就可以说这两个图不同构。这种在图的同构中保持的属性称为图形不变量。例如，同构的简单图必须具有相同的顶点数，因为在这些图的顶点集之间有一一对应。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.452,
                0.906,
                0.527
            ],
            "angle": 0,
            "content": "同构的简单图还必须有相同的边数，因为在顶点之间的一一对应建立了边之间的一一对应。另外，同构的简单图的对应顶点的度必须相同。即在图 \\(G\\) 中顶点 \\(\\mathcal{V}\\) 的度为 \\(d\\) ，在图 \\(H\\) 中必须有一个对应的顶点 \\(f(v)\\) ，其度为 \\(d\\) ，因为在图 \\(G\\) 中顶点 \\(\\boldsymbol{\\varpi}\\) 与 \\(\\mathcal{V}\\) 相邻，当且仅当在图 \\(H\\) 中\\(f(v)\\) 与 \\(f(w)\\) 相邻。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.531,
                0.392,
                0.549
            ],
            "angle": 0,
            "content": "例9 说明图9所示的图不同构。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.554,
                0.55,
                0.608
            ],
            "angle": 0,
            "content": "解 \\(G\\) 和 \\(H\\) 都具有5个顶点6条边。不过，\\(H\\) 有1个度为1的顶点 \\(e\\) ，而 \\(G\\) 没有度为1的顶点。所以 \\(G\\) 与 \\(H\\) 不是同构的。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.611,
                0.549,
                0.704
            ],
            "angle": 0,
            "content": "顶点数、边数以及顶点的度都是在同构下的不变量。若两个简单图的这些量有任何不同，则这两个图就不是同构的。不过，当这些不变量都相同时，也不一定意味着两个图是同构的。目前还没有已知的用来判定简单图是否同构的不变量集。"
        },
        {
            "type": "image",
            "bbox": [
                0.568,
                0.557,
                0.691,
                0.706
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.756,
                0.557,
                0.884,
                0.706
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.658,
                0.71,
                0.793,
                0.725
            ],
            "angle": 0,
            "content": "图9 图 \\(G\\) 和 \\(H\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.709,
                0.474,
                0.727
            ],
            "angle": 0,
            "content": "例10 判定图10所示的图是否是同构的。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.731,
                0.906,
                0.767
            ],
            "angle": 0,
            "content": "解 图 \\(G\\) 和 \\(H\\) 都具有8个顶点和10条边。它们都具有4个度为2的顶点和4个度为3的顶点。因为这些不变量都相同，所以它们可能会是同构的。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.769,
                0.906,
                0.824
            ],
            "angle": 0,
            "content": "然而 \\(G\\) 和 \\(H\\) 不是同构的。为了看明白这一点，注意因为在 \\(G\\) 中 \\(\\deg(a) = 2\\)，所以 \\(a\\) 必然对应于 \\(H\\) 中的 \\(t\\)、\\(u\\)、\\(x\\) 或 \\(y\\)，因为这些顶点是 \\(H\\) 中的度为 2 的顶点。然而，\\(H\\) 中的这 4 个顶点的每一个都与 \\(H\\) 中另一个度为 2 的顶点相邻，但是在 \\(G\\) 中 \\(a\\) 却不是这样的。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.826,
                0.906,
                0.881
            ],
            "angle": 0,
            "content": "看出 \\(G\\) 与 \\(H\\) 不同构的另一种方式是，注意，若这两个图同构，则由度为3的顶点和连接它们的边所组成的 \\(G\\) 和 \\(H\\) 的子图一定是同构（读者应当验证它）。然而图11所示的这些子图却不是同构的。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.884,
                0.906,
                0.939
            ],
            "angle": 0,
            "content": "为了说明从图 \\(G\\) 的顶点集到图 \\(H\\) 的顶点集的函数 \\(f\\) 是一个同构，需要说明 \\(f\\) 保持边的存在和缺失关系。一种有助于这样做的方式是利用邻接矩阵。具体地说，为了说明 \\(f\\) 是一个同构，可以说明 \\(G\\) 的邻接矩阵与 \\(H\\) 的邻接矩阵相同，其中 \\(G\\) 的邻接矩阵的行和列的标记都是 \\(G\\)"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.135,
                0.038,
                0.172,
                0.052
            ],
            "angle": 0,
            "content": "592"
        },
        {
            "type": "header",
            "bbox": [
                0.216,
                0.037,
                0.294,
                0.053
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.094,
                0.951,
                0.13
            ],
            "angle": 0,
            "content": "的顶点， \\(H\\) 的邻接矩阵的行和列的标记都是 \\(G\\) 的对应顶点在 \\(f\\) 下的像。例11解释如何这样做。"
        },
        {
            "type": "image",
            "bbox": [
                0.108,
                0.136,
                0.326,
                0.237
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.209,
                0.244,
                0.227,
                0.256
            ],
            "angle": 0,
            "content": "G"
        },
        {
            "type": "image",
            "bbox": [
                0.332,
                0.138,
                0.55,
                0.236
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.432,
                0.244,
                0.449,
                0.256
            ],
            "angle": 0,
            "content": "H"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.255,
                0.265,
                0.399,
                0.279
            ],
            "angle": 0,
            "content": "图10 图 \\(G\\) 和 \\(H\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.624,
                0.151,
                0.904,
                0.257
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.595,
                0.265,
                0.92,
                0.297
            ],
            "angle": 0,
            "content": "图11 由度为3的顶点和连接它们的边所组成的 \\(G\\) 和 \\(H\\) 的子图"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.306,
                0.596,
                0.324
            ],
            "angle": 0,
            "content": "例11 判定图12所示的图 \\(G\\) 和 \\(H\\) 是否是同构的。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.329,
                0.538,
                0.44
            ],
            "angle": 0,
            "content": "解 \\(G\\) 和 \\(H\\) 都有6个顶点和7条边，都有4个度为2的顶点和2个度为3的顶点。还容易看出由度为2的顶点和连接它们的边所组成的\\(G\\) 和 \\(H\\) 的子图是同构的（读者应当验证它）。因为 \\(G\\) 和 \\(H\\) 对这些不变量来说是相同的，所以就有理由试着找出一个同构 \\(f\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.443,
                0.538,
                0.478
            ],
            "angle": 0,
            "content": "现在定义函数 \\(f\\) ，然后判定它是否同构。因为 \\(\\deg (u_1) = 2\\) 且 \\(u_{1}\\) 不与任何其他度为2的顶"
        },
        {
            "type": "image",
            "bbox": [
                0.55,
                0.331,
                0.955,
                0.445
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.68,
                0.453,
                0.825,
                0.467
            ],
            "angle": 0,
            "content": "图12 图 \\(G\\) 和 \\(H\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.482,
                0.954,
                0.6
            ],
            "angle": 0,
            "content": "点相邻，所以 \\(u_{1}\\) 的像必然是 \\(v_{4}\\) 或 \\(v_{6}\\)，它们是 \\(H\\) 中仅有的不与度为2的顶点相邻的度为2的顶点。任取 \\(f(u_{1}) = v_{6}\\)。（如果发现这个选择得不出同构，就接着试验 \\(f(u_{1}) = v_{4}\\)。）因为 \\(u_{2}\\) 与 \\(u_{1}\\) 相邻，所以 \\(u_{2}\\) 可能的像是 \\(v_{3}\\) 和 \\(v_{5}\\)。任取 \\(f(u_{2}) = v_{3}\\)。照这样继续下去，用顶点的相邻关系和度作为指引，令 \\(f(u_{3}) = v_{4}\\)，\\(f(u_{4}) = v_{5}\\)，\\(f(u_{5}) = v_{1}\\)，以及 \\(f(u_{6}) = v_{2}\\)。现在已经有了在 \\(G\\) 的顶点集与 \\(H\\) 的顶点集之间的一一对应，即 \\(f(u_{1}) = v_{6}\\)，\\(f(u_{2}) = v_{3}\\)，\\(f(u_{3}) = v_{4}\\)，\\(f(u_{4}) = v_{5}\\)，\\(f(u_{5}) = v_{1}\\)，以及 \\(f(u_{6}) = v_{2}\\)。为了查看 \\(f\\) 是否保持边，就检查 \\(G\\) 的邻接矩阵："
        },
        {
            "type": "equation",
            "bbox": [
                0.39,
                0.605,
                0.667,
                0.737
            ],
            "angle": 0,
            "content": "\\[\n\\boldsymbol {A} _ {G} = \\begin{array}{l} u _ {1} \\\\ u _ {2} \\\\ u _ {3} \\\\ u _ {4} \\\\ u _ {5} \\\\ u _ {6} \\end{array} \\left[ \\begin{array}{l l l l l l} 0 & 1 & 0 & 1 & 0 & 0 \\\\ 1 & 0 & 1 & 0 & 0 & 1 \\\\ 0 & 1 & 0 & 1 & 0 & 0 \\\\ 1 & 0 & 1 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 & 0 & 1 \\\\ 0 & 1 & 0 & 0 & 1 & 0 \\end{array} \\right]\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.741,
                0.668,
                0.759
            ],
            "angle": 0,
            "content": "和 \\(H\\) 的邻接矩阵，其中用 \\(G\\) 中的对应顶点的像来标记行和列："
        },
        {
            "type": "equation",
            "bbox": [
                0.39,
                0.764,
                0.667,
                0.896
            ],
            "angle": 0,
            "content": "\\[\n\\boldsymbol {A} _ {H} = \\begin{array}{l} v _ {6} \\\\ v _ {3} \\\\ v _ {4} \\\\ v _ {5} \\\\ v _ {1} \\\\ v _ {2} \\end{array} \\left[ \\begin{array}{l l l l l l} 0 & 1 & 0 & 1 & 0 & 0 \\\\ 1 & 0 & 1 & 0 & 0 & 1 \\\\ 0 & 1 & 0 & 1 & 0 & 0 \\\\ 1 & 0 & 1 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 & 0 & 1 \\\\ 0 & 1 & 0 & 0 & 1 & 0 \\end{array} \\right]\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.901,
                0.955,
                0.937
            ],
            "angle": 0,
            "content": "因为 \\(\\mathbf{A}_G = \\mathbf{A}_H\\) ，所以 \\(f\\) 是保持边的。由此得出 \\(f\\) 是同构，所以 \\(G\\) 与 \\(H\\) 是同构的。注意，若事实证明 \\(f\\) 不是同构，是无法得出 \\(G\\) 与 \\(H\\) 不是同构的，因为 \\(G\\) 和 \\(H\\) 中的顶点的另一个对应仍然可"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.777,
                0.038,
                0.884,
                0.053
            ],
            "angle": 0,
            "content": "图 593"
        },
        {
            "type": "text",
            "bbox": [
                0.068,
                0.094,
                0.159,
                0.109
            ],
            "angle": 0,
            "content": "以是同构。"
        },
        {
            "type": "text",
            "bbox": [
                0.066,
                0.112,
                0.914,
                0.265
            ],
            "angle": 0,
            "content": "图同构算法已知的最好的判定两个图是否同构的算法具有指数的最坏情形时间复杂度（对图的顶点数来说）。然而，2017年年初，Laszlo Babai宣布，他找到了一种用 \\( 2^{f(n)} \\) 时间来确定两个具有 \\( n \\) 个顶点的图是否同构的算法，其中 \\( f(n) \\) 是 \\( O((\\log n)^3) \\) 。这个大 \\( O \\) 估算意味着算法运行在准多项式时间，介于多项式时间和指数时间之间。Babai的这一发现还没有得到充分的同行评审，但能够缩小他在2015年发明的那种算法存在的严重差距。专家认为他现在的结果是正确的。尽管目前还没有找到解决这个问题的多项式时间算法，但可以通过线性平均情形时间复杂度的算法进行求解。能否找到判定两个图是否同构的多项式最坏情形时间复杂度的算法？对此，我们心存一丝希望，但也有些许怀疑。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.266,
                0.915,
                0.361
            ],
            "angle": 0,
            "content": "一种名为NAUTY的用于测试图同构的最佳实用算法，在现代个人计算机上可在1秒内判定具有100个顶点的两个图是否是同构的。可以在因特网上下载NAUTY软件并用它做实验。对于有严格限制的图，如顶点的最大度很小，存在着判断两个图是否同构的实用算法。判断任意两个图是否同构的问题是一个特别有趣的问题，因为这是少有的几个不知是理论可行的或NP完全的(见3.3节)NP问题之一(见练习72)。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.362,
                0.915,
                0.457
            ],
            "angle": 0,
            "content": "图同构的应用 图同构以及图同构中的函数源于图论在化学、电子电路设计以及其他的生物信息和计算机领域的应用。化学家用多图（已知的分子图），为化学成分建模。在这些图中，顶点表示原子，边表示这些原子之间的化学键。两个结构相同，具有相同分子式但不同原子键的分子，具有不同构的分子图。当分析出新的化学合成物时，就检查分子图数据库，以判断该化合物的分子图是否与已知的化合物相同。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.458,
                0.915,
                0.553
            ],
            "angle": 0,
            "content": "可以用图为电路图建模，其中顶点表示元件，边表示元件之间的连接。现代集成电路（即芯片）是混合的电路图，常常有上百万个晶体管及连接。由于现代芯片的复杂性，所以用自动化工具进行设计。图同构可用于验证由自动化工具设计的电路是否与最初的设计一致。图同构还可用于判断一个销售商的芯片与另一个销售商的芯片是否具有相同的知识产权。这可以通过寻找这些芯片的图模型中的最大同构子图来完成。"
        },
        {
            "type": "title",
            "bbox": [
                0.068,
                0.564,
                0.113,
                0.579
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.068,
                0.583,
                0.401,
                0.598
            ],
            "angle": 0,
            "content": "在练习 \\(1\\sim 4\\) 中，用邻接表表示给定的图。"
        },
        {
            "type": "image",
            "bbox": [
                0.067,
                0.601,
                0.206,
                0.699
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.289,
                0.601,
                0.531,
                0.699
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.614,
                0.6,
                0.78,
                0.695
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.067,
                0.706,
                0.315,
                0.804
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.812,
                0.322,
                0.828
            ],
            "angle": 0,
            "content": "5. 用邻接矩阵表示练习1的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.83,
                0.322,
                0.846
            ],
            "angle": 0,
            "content": "6. 用邻接矩阵表示练习2的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.849,
                0.322,
                0.864
            ],
            "angle": 0,
            "content": "7. 用邻接矩阵表示练习3的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.867,
                0.322,
                0.882
            ],
            "angle": 0,
            "content": "8. 用邻接矩阵表示练习4的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.886,
                0.341,
                0.901
            ],
            "angle": 0,
            "content": "9. 用邻接矩阵表示下列每一个图。"
        },
        {
            "type": "list",
            "bbox": [
                0.067,
                0.812,
                0.341,
                0.901
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.904,
                0.132,
                0.918
            ],
            "angle": 0,
            "content": "a) \\(K_{4}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.315,
                0.904,
                0.369,
                0.919
            ],
            "angle": 0,
            "content": "b) \\(K_{1,4}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.552,
                0.905,
                0.603,
                0.919
            ],
            "angle": 0,
            "content": "c) \\(K_{2,3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.923,
                0.13,
                0.936
            ],
            "angle": 0,
            "content": "d) \\(C_4\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.316,
                0.923,
                0.36,
                0.936
            ],
            "angle": 0,
            "content": "e) \\(W_{4}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.553,
                0.923,
                0.59,
                0.937
            ],
            "angle": 0,
            "content": "f) \\(Q_{3}\\)"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.127,
                0.037,
                0.164,
                0.05
            ],
            "angle": 0,
            "content": "594"
        },
        {
            "type": "header",
            "bbox": [
                0.209,
                0.035,
                0.284,
                0.05
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.092,
                0.492,
                0.106
            ],
            "angle": 0,
            "content": "在练习 \\(10\\sim 12\\) 中，画出给定邻接矩阵表示的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.112,
                0.223,
                0.17
            ],
            "angle": 0,
            "content": "0 1 0   \n1 0 1   \n0 1 0"
        },
        {
            "type": "text",
            "bbox": [
                0.357,
                0.111,
                0.507,
                0.176
            ],
            "angle": 0,
            "content": "0 1 1   \n11. 0 0 1 0 1 1 0"
        },
        {
            "type": "text",
            "bbox": [
                0.642,
                0.111,
                0.79,
                0.176
            ],
            "angle": 0,
            "content": "1 1 1 0   \n12. 0 0 1 0   \n1 0 1 0   \n1 1 1 0"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.181,
                0.472,
                0.195
            ],
            "angle": 0,
            "content": "在练习 \\(13\\sim 15\\) 中，用邻接矩阵表示给定的图。"
        },
        {
            "type": "image",
            "bbox": [
                0.101,
                0.199,
                0.255,
                0.293
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.358,
                0.199,
                0.504,
                0.293
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.642,
                0.199,
                0.815,
                0.31
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.314,
                0.546,
                0.328
            ],
            "angle": 0,
            "content": "在练习 \\(16\\sim 18\\) 中，画出给定邻接矩阵所表示的无向图。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.347,
                0.223,
                0.4
            ],
            "angle": 0,
            "content": "16. \\(\\begin{bmatrix} 1 & 3 & 2\\\\ 3 & 0 & 4\\\\ 2 & 4 & 0 \\end{bmatrix}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.358,
                0.341,
                0.507,
                0.406
            ],
            "angle": 0,
            "content": "17. \\(\\begin{bmatrix} 1 & 2 & 0 & 1 \\\\ 2 & 0 & 3 & 0 \\\\ 0 & 3 & 1 & 1 \\\\ 1 & 0 & 1 & 0 \\end{bmatrix}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.642,
                0.333,
                0.818,
                0.415
            ],
            "angle": 0,
            "content": "0 1 3 0 4   \n1 2 1 3 0   \n3 1 1 0 1   \n0 3 0 0 2   \n4 0 1 2 3"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.42,
                0.696,
                0.434
            ],
            "angle": 0,
            "content": "在练习 \\(19\\sim 21\\) 中，按照顶点的字典顺序，求给定有向多重图的邻接矩阵。"
        },
        {
            "type": "image",
            "bbox": [
                0.101,
                0.438,
                0.307,
                0.554
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.358,
                0.438,
                0.565,
                0.554
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.642,
                0.438,
                0.853,
                0.557
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.561,
                0.492,
                0.575
            ],
            "angle": 0,
            "content": "在练习 \\(22\\sim 24\\) 中，画出给定邻接矩阵表示的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.587,
                0.223,
                0.637
            ],
            "angle": 0,
            "content": "1 0 1   \n22. 0 0 1   \n1 1 1"
        },
        {
            "type": "text",
            "bbox": [
                0.358,
                0.588,
                0.48,
                0.637
            ],
            "angle": 0,
            "content": "1 2 1   \n2 0 0   \n0 2 2"
        },
        {
            "type": "text",
            "bbox": [
                0.642,
                0.58,
                0.79,
                0.643
            ],
            "angle": 0,
            "content": "0 2 3 0 1 2 2 1 2 1 1 0 1 0 0 2"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.65,
                0.943,
                0.665
            ],
            "angle": 0,
            "content": "无向图 \\(G\\) 的密度等于 \\(G\\) 中的边数除以含有 \\(\\left|G\\right|\\) 个顶点的无向图中可能的边数。因此， \\(G(V,E)\\) 的密度是"
        },
        {
            "type": "equation",
            "bbox": [
                0.463,
                0.669,
                0.589,
                0.702
            ],
            "angle": 0,
            "content": "\\[\n\\frac {2 | G |}{| V | (| V | - 1)}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.705,
                0.946,
                0.756
            ],
            "angle": 0,
            "content": "图族 \\(G_{n}\\) ， \\(n = 1\\) ，2，…是稀疏的，如果当 \\(n\\) 无约束增长时， \\(G_{n}\\) 的密度的极限为零；而如果此比例接近正实数，则为稠密的。如前文中所述，一张独立的图被称为稀疏图，如果它包含相对较少的边；而如果它包含许多边，则称为稠密图。这些术语可以根据具体情况进行精确定义，但不同的定义通常会不一致。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.759,
                0.293,
                0.773
            ],
            "angle": 0,
            "content": "25. 求下列各图的密度："
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.777,
                0.246,
                0.79
            ],
            "angle": 0,
            "content": "a)10.1节图1"
        },
        {
            "type": "text",
            "bbox": [
                0.393,
                0.777,
                0.506,
                0.79
            ],
            "angle": 0,
            "content": "b)10.1节图6"
        },
        {
            "type": "text",
            "bbox": [
                0.634,
                0.777,
                0.754,
                0.79
            ],
            "angle": 0,
            "content": "c)10.1节图12"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.795,
                0.293,
                0.809
            ],
            "angle": 0,
            "content": "26. 求下列各图的密度："
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.812,
                0.257,
                0.826
            ],
            "angle": 0,
            "content": "a)10.2节图12"
        },
        {
            "type": "text",
            "bbox": [
                0.393,
                0.813,
                0.515,
                0.826
            ],
            "angle": 0,
            "content": "b)10.2节图13"
        },
        {
            "type": "text",
            "bbox": [
                0.634,
                0.813,
                0.754,
                0.826
            ],
            "angle": 0,
            "content": "c)10.2节图14"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.83,
                0.946,
                0.862
            ],
            "angle": 0,
            "content": "27. (需要微积分知识) 对于每一个图族，判断该图族是稀疏的、稠密的或两者都不是。（参考10.2节练习37的结果。）"
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.867,
                0.177,
                0.88
            ],
            "angle": 0,
            "content": "a) \\(K_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.393,
                0.868,
                0.431,
                0.88
            ],
            "angle": 0,
            "content": "b) \\(C_n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.634,
                0.868,
                0.683,
                0.88
            ],
            "angle": 0,
            "content": "c) \\(K_{n,n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.134,
                0.885,
                0.175,
                0.897
            ],
            "angle": 0,
            "content": "d) \\(Q_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.393,
                0.885,
                0.434,
                0.897
            ],
            "angle": 0,
            "content": "e) \\(W_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.634,
                0.885,
                0.683,
                0.897
            ],
            "angle": 0,
            "content": "f) \\(K_{3,n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.902,
                0.848,
                0.916
            ],
            "angle": 0,
            "content": "28. 判断一个无向图是稀疏的、稠密的还是两者都不是，并解释你的答案。若此图用来建模："
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.92,
                0.47,
                0.934
            ],
            "angle": 0,
            "content": "a)城市中的街道网络（顶点为街道交叉口）"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.768,
                0.037,
                0.874,
                0.052
            ],
            "angle": 0,
            "content": "图 595"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.092,
                0.61,
                0.108
            ],
            "angle": 0,
            "content": "b)城市中的一座建筑物与另一座建筑物的距离是否在两英里以内"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.112,
                0.294,
                0.126
            ],
            "angle": 0,
            "content": "c)两个人是否是兄弟姐妹"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.13,
                0.351,
                0.145
            ],
            "angle": 0,
            "content": "d)两个人是否为同一家公司工作"
        },
        {
            "type": "list",
            "bbox": [
                0.085,
                0.092,
                0.61,
                0.145
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.149,
                0.657,
                0.163
            ],
            "angle": 0,
            "content": "29. 每一个对称的和对角线全为 0 的 0-1 方阵是否都是简单图的邻接矩阵？"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.168,
                0.415,
                0.182
            ],
            "angle": 0,
            "content": "30. 用关联矩阵表示练习1和练习2中的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.187,
                0.386,
                0.201
            ],
            "angle": 0,
            "content": "31. 用关联矩阵表示练习 \\(13\\sim 15\\) 中的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.205,
                0.62,
                0.22
            ],
            "angle": 0,
            "content": "* 32. 无向图的邻接矩阵的一行中的各项之和是什么？对有向图来说呢？"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.224,
                0.62,
                0.239
            ],
            "angle": 0,
            "content": "* 33. 无向图的邻接矩阵的一列中的各项之和是什么？对有向图来说呢？"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.243,
                0.473,
                0.257
            ],
            "angle": 0,
            "content": "34. 无向图的关联矩阵的一行中的各项之和是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.262,
                0.473,
                0.276
            ],
            "angle": 0,
            "content": "35. 无向图的关联矩阵的一列中的各项之和是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.28,
                0.303,
                0.295
            ],
            "angle": 0,
            "content": "* 36. 求下列每个图的邻接矩阵。"
        },
        {
            "type": "list",
            "bbox": [
                0.042,
                0.149,
                0.657,
                0.295
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.299,
                0.131,
                0.314
            ],
            "angle": 0,
            "content": "a) \\(K_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.203,
                0.299,
                0.242,
                0.314
            ],
            "angle": 0,
            "content": "b) \\(C_n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.315,
                0.299,
                0.357,
                0.314
            ],
            "angle": 0,
            "content": "c) \\(W_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.43,
                0.299,
                0.486,
                0.314
            ],
            "angle": 0,
            "content": "d) \\(K_{m,n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.559,
                0.299,
                0.597,
                0.314
            ],
            "angle": 0,
            "content": "e) \\(Q_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.319,
                0.368,
                0.333
            ],
            "angle": 0,
            "content": "* 37. 求练习 \\(32\\mathrm{a} \\sim \\mathrm{d}\\) 中的图的关联矩阵。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.337,
                0.903,
                0.37
            ],
            "angle": 0,
            "content": "在练习 \\(38\\sim 48\\) 中，判定所给定的一对图是否同构。构造一个同构或给出不存在同构的严格证明。关于这种类型的更多练习题，参见补充练习 \\(3\\sim 5\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.375,
                0.082,
                0.387
            ],
            "angle": 0,
            "content": "38."
        },
        {
            "type": "image",
            "bbox": [
                0.087,
                0.397,
                0.305,
                0.418
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.336,
                0.374,
                0.432,
                0.444
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.454,
                0.082,
                0.466
            ],
            "angle": 0,
            "content": "39."
        },
        {
            "type": "image",
            "bbox": [
                0.087,
                0.485,
                0.256,
                0.582
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.291,
                0.453,
                0.489,
                0.582
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.592,
                0.082,
                0.604
            ],
            "angle": 0,
            "content": "40."
        },
        {
            "type": "image",
            "bbox": [
                0.087,
                0.592,
                0.203,
                0.685
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.293,
                0.592,
                0.483,
                0.687
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.698,
                0.082,
                0.71
            ],
            "angle": 0,
            "content": "41."
        },
        {
            "type": "image",
            "bbox": [
                0.087,
                0.701,
                0.289,
                0.819
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.324,
                0.697,
                0.51,
                0.824
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.834,
                0.082,
                0.846
            ],
            "angle": 0,
            "content": "42."
        },
        {
            "type": "image",
            "bbox": [
                0.087,
                0.833,
                0.283,
                0.93
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.31,
                0.835,
                0.489,
                0.93
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.131,
                0.038,
                0.167,
                0.052
            ],
            "angle": 0,
            "content": "596"
        },
        {
            "type": "header",
            "bbox": [
                0.212,
                0.037,
                0.288,
                0.052
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.095,
                0.129,
                0.107
            ],
            "angle": 0,
            "content": "43."
        },
        {
            "type": "image",
            "bbox": [
                0.134,
                0.094,
                0.285,
                0.228
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.321,
                0.1,
                0.442,
                0.222
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.239,
                0.129,
                0.251
            ],
            "angle": 0,
            "content": "44."
        },
        {
            "type": "image",
            "bbox": [
                0.136,
                0.248,
                0.317,
                0.364
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.355,
                0.236,
                0.499,
                0.364
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.372,
                0.13,
                0.385
            ],
            "angle": 0,
            "content": "45."
        },
        {
            "type": "image",
            "bbox": [
                0.137,
                0.371,
                0.396,
                0.436
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.135,
                0.456,
                0.396,
                0.523
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.532,
                0.131,
                0.544
            ],
            "angle": 0,
            "content": "46."
        },
        {
            "type": "image",
            "bbox": [
                0.138,
                0.53,
                0.406,
                0.644
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.451,
                0.529,
                0.717,
                0.644
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.653,
                0.131,
                0.665
            ],
            "angle": 0,
            "content": "47."
        },
        {
            "type": "image",
            "bbox": [
                0.138,
                0.654,
                0.323,
                0.77
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.365,
                0.652,
                0.532,
                0.775
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.786,
                0.131,
                0.798
            ],
            "angle": 0,
            "content": "48."
        },
        {
            "type": "image",
            "bbox": [
                0.139,
                0.785,
                0.335,
                0.912
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.366,
                0.785,
                0.562,
                0.913
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.921,
                0.447,
                0.936
            ],
            "angle": 0,
            "content": "49. 证明：简单图的同构关系是等价关系。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.767,
                0.038,
                0.874,
                0.053
            ],
            "angle": 0,
            "content": "图 597"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.094,
                0.637,
                0.109
            ],
            "angle": 0,
            "content": "50. 设 \\(G\\) 和 \\(H\\) 是同构的简单图。证明：它们的补图 \\(\\overline{G}\\) 和 \\(\\overline{H}\\) 也是同构的。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.113,
                0.451,
                0.127
            ],
            "angle": 0,
            "content": "51. 描述对应于孤立点的图的邻接矩阵的行和列。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.131,
                0.414,
                0.145
            ],
            "angle": 0,
            "content": "52. 描述对应于孤立点的图的关联矩阵的行。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.148,
                0.886,
                0.162
            ],
            "angle": 0,
            "content": "53. 证明：可以对具有2个以上顶点的二分图的顶点排序，使得其邻接矩阵形如下图所示的四项都是矩形块。"
        },
        {
            "type": "list",
            "bbox": [
                0.053,
                0.094,
                0.886,
                0.162
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "equation",
            "bbox": [
                0.445,
                0.167,
                0.514,
                0.198
            ],
            "angle": 0,
            "content": "\\[\n\\left[ \\begin{array}{c c} 0 & A \\\\ B & 0 \\end{array} \\right]\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.201,
                0.428,
                0.216
            ],
            "angle": 0,
            "content": "若简单图 \\(G\\) 和 \\(\\overline{G}\\) 是同构的，则 \\(G\\) 称为自补图。"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.219,
                0.265,
                0.233
            ],
            "angle": 0,
            "content": "54. 证明：右图是自补图。"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.237,
                0.34,
                0.251
            ],
            "angle": 0,
            "content": "55. 求具有 5 个顶点的自补简单图。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.254,
                0.617,
                0.269
            ],
            "angle": 0,
            "content": "* 56. 证明：若 \\(G\\) 是具有 \\(v\\) 个顶点的自补简单图，则 \\(v \\equiv 0\\) 或 \\(1(\\mathrm{mod} 4)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.272,
                0.324,
                0.287
            ],
            "angle": 0,
            "content": "57. 对哪些整数 \\(n\\)，\\(C_n\\) 是自补图？"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.29,
                0.522,
                0.304
            ],
            "angle": 0,
            "content": "58. 具有 \\( n \\) 个顶点的非同构的简单图有多少个？其中 \\( n \\) 是"
        },
        {
            "type": "list",
            "bbox": [
                0.041,
                0.219,
                0.617,
                0.304
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.308,
                0.121,
                0.322
            ],
            "angle": 0,
            "content": "a)2"
        },
        {
            "type": "text",
            "bbox": [
                0.207,
                0.308,
                0.238,
                0.321
            ],
            "angle": 0,
            "content": "b)3"
        },
        {
            "type": "text",
            "bbox": [
                0.329,
                0.309,
                0.357,
                0.321
            ],
            "angle": 0,
            "content": "c)4"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.326,
                0.509,
                0.34
            ],
            "angle": 0,
            "content": "59. 具有 5 个顶点和 3 条边的非同构的简单图有多少个？"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.344,
                0.509,
                0.357
            ],
            "angle": 0,
            "content": "60. 具有 6 个顶点和 4 条边的非同构的简单图有多少个？"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.36,
                0.601,
                0.374
            ],
            "angle": 0,
            "content": "61. 具有 6 个顶点且每个顶点的度均为 3 的非同构简单图有多少个？"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.376,
                0.601,
                0.39
            ],
            "angle": 0,
            "content": "62. 具有 7 个顶点且每个顶点的度均为 2 的非同构简单图有多少个？"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.393,
                0.398,
                0.406
            ],
            "angle": 0,
            "content": "63. 具有下列邻接矩阵的简单图是否同构？"
        },
        {
            "type": "list",
            "bbox": [
                0.054,
                0.326,
                0.601,
                0.406
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.416,
                0.296,
                0.469
            ],
            "angle": 0,
            "content": "a) \\(\\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & 1 \\\\ 1 & 1 & 0 \\end{bmatrix}, \\begin{bmatrix} 0 & 1 & 1 \\\\ 1 & 0 & 0 \\\\ 1 & 0 & 0 \\end{bmatrix}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.332,
                0.41,
                0.597,
                0.475
            ],
            "angle": 0,
            "content": "0 1 0 1 b） \\(\\left[ \\begin{array}{lll}0 & 1 & 0 & 1\\\\ 1 & 0 & 0 & 1\\\\ 0 & 0 & 0 & 1\\\\ 1 & 1 & 1 & 0 \\end{array} \\right],\\left[ \\begin{array}{lll}0 & 1 & 1 & 1\\\\ 1 & 0 & 0 & 1\\\\ 1 & 0 & 0 & 1\\\\ 1 & 1 & 1 & 0 \\end{array} \\right]\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.633,
                0.41,
                0.893,
                0.474
            ],
            "angle": 0,
            "content": "0 1 1 0 0 1 0 1 0 1 0"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.478,
                0.434,
                0.492
            ],
            "angle": 0,
            "content": "64. 判定具有下列关联矩阵的无环图是否同构。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.502,
                0.311,
                0.555
            ],
            "angle": 0,
            "content": "a) \\(\\begin{bmatrix} 1 & 0 & 1 \\\\ 0 & 1 & 1 \\\\ 1 & 1 & 0 \\end{bmatrix}, \\quad \\begin{bmatrix} 1 & 1 & 0 \\\\ 1 & 0 & 1 \\\\ 0 & 1 & 1 \\end{bmatrix}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.383,
                0.495,
                0.712,
                0.56
            ],
            "angle": 0,
            "content": "b） \\(\\left[ \\begin{array}{ccccc}1 & 1 & 0 & 0 & 0\\\\ 1 & 0 & 1 & 0 & 1\\\\ 0 & 0 & 0 & 1 & 1\\\\ 0 & 1 & 1 & 1 & 0 \\end{array} \\right],\\quad \\left[ \\begin{array}{ccccc}0 & 1 & 0 & 0 & 1\\\\ 0 & 1 & 1 & 1 & 0\\\\ 1 & 0 & 0 & 1 & 0\\\\ 1 & 0 & 1 & 0 & 1 \\end{array} \\right]\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.564,
                0.533,
                0.578
            ],
            "angle": 0,
            "content": "65. 把简单图的同构定义推广到包含环和多重边的无向图。"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.58,
                0.254,
                0.594
            ],
            "angle": 0,
            "content": "66. 定义有向图的同构。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.596,
                0.623,
                0.61
            ],
            "angle": 0,
            "content": "在练习 \\(67\\sim 70\\) 中，判定所给定的一对有向图是否同构（参见练习66）。"
        },
        {
            "type": "image",
            "bbox": [
                0.064,
                0.613,
                0.238,
                0.714
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.296,
                0.619,
                0.436,
                0.719
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.468,
                0.613,
                0.621,
                0.707
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.693,
                0.611,
                0.815,
                0.707
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.064,
                0.727,
                0.231,
                0.824
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.293,
                0.727,
                0.426,
                0.824
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.064,
                0.831,
                0.337,
                0.936
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.417,
                0.831,
                0.688,
                0.936
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.122,
                0.041,
                0.159,
                0.054
            ],
            "angle": 0,
            "content": "598"
        },
        {
            "type": "header",
            "bbox": [
                0.204,
                0.04,
                0.28,
                0.054
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.096,
                0.94,
                0.129
            ],
            "angle": 0,
            "content": "71. 证明：若 \\(G\\) 和 \\(H\\) 是同构的有向图，则 \\(G\\) 和 \\(H\\) 的逆图（在10.2节练习69的前导文中定义）也是同构的。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.132,
                0.529,
                0.147
            ],
            "angle": 0,
            "content": "72. 证明：一个图是二分图这一属性是同构的不变量。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.15,
                0.94,
                0.182
            ],
            "angle": 0,
            "content": "73. 找出一对非同构的图，它们具有相同的度序列（在10.2节练习38的前导文中定义），但一个是二分图而另一个不是。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.185,
                0.539,
                0.2
            ],
            "angle": 0,
            "content": "74. 具有 \\(n\\) 个顶点的非同构有向图有多少个？其中 \\(n\\) 是"
        },
        {
            "type": "list",
            "bbox": [
                0.095,
                0.096,
                0.94,
                0.2
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.204,
                0.167,
                0.216
            ],
            "angle": 0,
            "content": "a)2?"
        },
        {
            "type": "text",
            "bbox": [
                0.284,
                0.204,
                0.323,
                0.216
            ],
            "angle": 0,
            "content": "b)3?"
        },
        {
            "type": "text",
            "bbox": [
                0.44,
                0.204,
                0.479,
                0.216
            ],
            "angle": 0,
            "content": "c)4?"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.22,
                0.476,
                0.235
            ],
            "angle": 0,
            "content": "* 75. 无向图的关联矩阵与它的转置之积是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.238,
                0.71,
                0.253
            ],
            "angle": 0,
            "content": "* 76. 表示具有 \\( n \\) 个顶点和 \\( m \\) 条边的简单图需要多少存储空间？其中分别利用"
        },
        {
            "type": "list",
            "bbox": [
                0.082,
                0.22,
                0.71,
                0.253
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.256,
                0.204,
                0.27
            ],
            "angle": 0,
            "content": "a)邻接表"
        },
        {
            "type": "text",
            "bbox": [
                0.349,
                0.256,
                0.443,
                0.27
            ],
            "angle": 0,
            "content": "b)邻接矩阵"
        },
        {
            "type": "text",
            "bbox": [
                0.59,
                0.257,
                0.683,
                0.27
            ],
            "angle": 0,
            "content": "c)关联矩阵"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.274,
                0.627,
                0.288
            ],
            "angle": 0,
            "content": "魔鬼对是一对不同构的图，但所谓的同构检验不能证明其不同构。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.291,
                0.94,
                0.324
            ],
            "angle": 0,
            "content": "77. 求一个用于检验的魔鬼对，该检验通过检查两个图的度序列（在10.2节练习38的前导文中定义）确定它们是相同的。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.327,
                0.94,
                0.359
            ],
            "angle": 0,
            "content": "78. 设从 \\(V_{1}\\) 到 \\(V_{2}\\) 的函数 \\(f\\) 是从图 \\(G_{1} = (V_{1}, E_{1})\\) 到 \\(G_{2} = (V_{2}, E_{2})\\) 的同构。证明：按图中顶点的个数，按所需要的比较次数，可以在多项式时间复杂度内进行验证。"
        },
        {
            "type": "list",
            "bbox": [
                0.095,
                0.291,
                0.94,
                0.359
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.099,
                0.374,
                0.257,
                0.393
            ],
            "angle": 0,
            "content": "10.4 连通性"
        },
        {
            "type": "title",
            "bbox": [
                0.099,
                0.401,
                0.233,
                0.418
            ],
            "angle": 0,
            "content": "10.4.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.421,
                0.94,
                0.476
            ],
            "angle": 0,
            "content": "许多问题可以用沿图的边前进所形成的通路来建模。例如，判定能否在两个计算机之间用中间连接传递消息的问题，就可以用图模型来研究。利用图模型中的通路，可以解决投递邮件、收取垃圾以及计算机网络诊断等有效规划路线的问题。"
        },
        {
            "type": "title",
            "bbox": [
                0.099,
                0.486,
                0.233,
                0.503
            ],
            "angle": 0,
            "content": "10.4.2 通路"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.506,
                0.94,
                0.542
            ],
            "angle": 0,
            "content": "非形式化地说，通路是边的序列，它从图的一个顶点开始沿着图中的边行经图中相邻的顶点。因为通路行经了边，所以沿着通路可以访问顶点，即这些边的端点。"
        },
        {
            "type": "text",
            "bbox": [
                0.137,
                0.544,
                0.518,
                0.561
            ],
            "angle": 0,
            "content": "定义1给出通路的形式化定义和相关术语。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.569,
                0.935,
                0.685
            ],
            "angle": 0,
            "content": "定义1 设 \\(n\\) 是非负整数且 \\(G\\) 是无向图。在 \\(G\\) 中从 \\(u\\) 到 \\(v\\) 的长度为 \\(n\\) 的通路是 \\(G\\) 的 \\(n\\) 条边 \\(e_1, \\cdots, e_n\\) 的序列，其中存在 \\(x_0 = u, x_1, \\cdots, x_n = v\\) 的顶点序列。使得对于 \\(i = 1, \\cdots, n\\)，\\(e_i\\) 以 \\(x_{i-1}\\) 和 \\(x_i\\) 作为端点。当这个图是简单图时，就用顶点序列 \\(x_0, x_1, \\cdots, x_n\\) 表示这条通路（因为列出这些顶点就唯一地确定了通路）。若一条通路在相同的顶点开始和结束，即 \\(u = v\\) 且长度大于 0，则它是一条回路。把通路或回路说成是经过顶点 \\(x_1, x_2, \\cdots, x_{n-1}\\) 或遍历边 \\(e_1, e_2, \\cdots, e_n\\)。若通路或回路不重复地包含相同的边，则它是简单的。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.694,
                0.94,
                0.768
            ],
            "angle": 0,
            "content": "当没有必要区分多重边时，就用顶点序列 \\(x_0, x_1, \\dots, x_n\\) 表示通路 \\(e_1, e_2, \\dots, e_n\\)，其中对于 \\(i = 1, 2, \\dots, n\\)，\\(f(e_i) = \\{x_{i-1}, x_i\\}\\)。这种记法仅仅指出通路所经过的顶点。当且仅当在这个序列中的一些相邻顶点之间有多条边时，才会有多条通路经过这个顶点序列，但它并没有指定唯一的通路。注意长度为 0 的通路由单个顶点组成。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.77,
                0.94,
                0.939
            ],
            "angle": 0,
            "content": "评注 关于定义1中的概念，有很多不同的术语。例如，在有些书中，使用路径（walk）而不是通路（path），这时路径被定义为图的顶点和边相互交替的序列，\\(v_0, e_1, v_1, e_2, \\cdots, v_{n-1}, e_n, v_n\\)，其中 \\(v_{i-1}\\) 和 \\(v_i\\) 是 \\(e_i\\) 的端点，\\(i = 1, 2, 3, \\cdots, n\\)。当使用“路径”这个术语时，就会使用闭合路径（closed walk）而不是回路（circuit）表示起始和终止于相同顶点的路径；使用路线（trail）表示没有重复边的路径（代替“简单通路”）。当使用路线这一术语时，术语通路（path）通常就会用来表示没有重复顶点的路线，这与定义1中的术语相冲突。由于这些术语的各种变体，所以当你在特定的书或者文章中阅读有关遍历图的边的内容时，需要弄清楚使用的是哪一组定义。文章[GrYe06]是一本关于本评注中提到的其他术语好的参考文献。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.772,
                0.037,
                0.877,
                0.052
            ],
            "angle": 0,
            "content": "图 599"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.094,
                0.661,
                0.21
            ],
            "angle": 0,
            "content": "例1如图1所示， \\(a\\) ， \\(d\\) ， \\(c\\) ， \\(f\\) ， \\(e\\) 是长度为4的简单通路，因为 \\(\\{a,d\\} ,\\{d,c\\} ,\\{c,f\\}\\) 和 \\(\\{f,e\\}\\) 都是边。但是 \\(d\\) ， \\(e\\) ， \\(c\\) ， \\(a\\) 不是通路，因为 \\(\\{e,c\\}\\) 不是边。注意 \\(b\\) ， \\(c\\) ， \\(f\\) ， \\(e\\) ， \\(b\\) 是长度为4的回路，因为 \\(\\{b,c\\} ,\\{c,f\\} ,\\{f,e\\}\\) 和 \\(\\{e,b\\}\\) 都是边，且这条通路在\\(b\\) 上开始和结束。长度为5的通路 \\(a\\) ， \\(b\\) ， \\(e\\) ， \\(d\\) ， \\(a\\) ， \\(b\\) 不是简单的，因为它包含边 \\(\\{a,b\\}\\) 两次。"
        },
        {
            "type": "image",
            "bbox": [
                0.676,
                0.096,
                0.89,
                0.194
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.736,
                0.202,
                0.846,
                0.217
            ],
            "angle": 0,
            "content": "图1 简单图"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.213,
                0.66,
                0.247
            ],
            "angle": 0,
            "content": "有向图中的通路和回路在第9章里介绍。现在给出更一般的定义。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.254,
                0.9,
                0.349
            ],
            "angle": 0,
            "content": "定义2 设 \\(n\\) 是非负整数且 \\(G\\) 是有向图。在 \\(G\\) 中从 \\(u\\) 到 \\(v\\) 的长度为 \\(n\\) 的通路是 \\(G\\) 的边的序列 \\(e_1, e_2, \\dots, e_n\\)，使得 \\(f(e_1) = (x_0, x_1)\\)，\\(f(e_2) = (x_1, x_2)\\)，\\(\\dots\\)，\\(f(e_n) = (x_{n-1}, x_n)\\)，其中 \\(x_0 = u\\)，\\(x_n = v\\)。当有向图中没有多重边时，就用顶点序列 \\(x_0, x_1, \\dots, x_n\\) 表示这条通路。把在相同的顶点上开始和结束的长度大于 0 的通路称为回路或圈。若一条通路或回路不重复地包含相同的边，则把它称为简单的。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.357,
                0.907,
                0.412
            ],
            "angle": 0,
            "content": "评注 经常用一些不是定义2给出的术语来表示其中描述的概念。特别地，使用路径（walk）、闭合路径（closed walk）、路线（trail）、通路（path）等术语（在定义1之后的评注中介绍过）描述有向图。详见[GrYe06]。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.414,
                0.907,
                0.489
            ],
            "angle": 0,
            "content": "注意通路上一条边的终点是这条通路上下一条边的起点。当没有必要区分多重边时，就用顶点序列 \\(x_0, x_1, \\dots, x_n\\) 表示通路 \\(e_1, e_2, \\dots, e_n\\)，其中对于 \\(i = 1, 2, \\dots, n\\)，\\(f(e_i) = (x_{i-1}, x_i)\\)。这种记法仅仅指出通路所经过的顶点。可以有多条通路经过这个顶点序列。当且仅当在这个序列中的一些相邻顶点之间有多条边时，才会有多条通路经过这个顶点序列。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.491,
                0.639,
                0.508
            ],
            "angle": 0,
            "content": "在许多图模型中，通路能表示有用的信息，如例 \\(2\\sim 4\\) 所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.512,
                0.909,
                0.628
            ],
            "angle": 0,
            "content": "例2 相识关系图中的通路 在相识关系图中，如果存在一条连接两个人的链，在该链中，相邻的两个人彼此认识，则在这两个人之间有一条通路。例如在10.1节的图6中，有一条连接Kamini和Ching的6个人的链。许多社会学家猜想，是否可以用只包含5个或更少的人的短链来连接世界上几乎每一对人。这意味着世界上所有人的相识关系图中，几乎每对顶点都可以通过长度不超过4的通路来连接。约翰·奎尔（JohnGuare）的六度分离（SixDegreesofSeparation)理论就是基于这个概念。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.632,
                0.909,
                0.768
            ],
            "angle": 0,
            "content": "例3 合作图中的通路 在合作图中，如果表示作者的两个顶点 \\(a\\) 和 \\(b\\) 之间有从 \\(a\\) 开始到 \\(b\\) 结束的一系列作者，使得每条边的端点所表示的两个作者写过一篇联名论文，则 \\(a\\) 和 \\(b\\) 就通过一条通路而连接。这里我们关注两个重要的合作图。首先，在所有数学家的学术合作图中，数学家 \\(m\\) 的埃德斯数（在第9章补充练习14中用关系术语定义过），就是在 \\(m\\) 和成果极其丰富的数学家保罗·埃德斯(1996年去世)之间的最短通路的长度。换句话说，一个数学家的埃德斯数就是从保罗·埃德斯开始到这个数学家结束的最短的数学家链的长度，其中每一对相邻的数学家都联名写过论文。根据“埃德斯数项目”，2006年具有不同埃德斯数的数学家的数目如表1所示。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.248,
                0.777,
                0.719,
                0.793
            ],
            "angle": 0,
            "content": "表 1 具有给定埃德斯数 (到 2006 年年初) 的数学家的数目"
        },
        {
            "type": "table",
            "bbox": [
                0.062,
                0.794,
                0.909,
                0.928
            ],
            "angle": 0,
            "content": "<table><tr><td>埃德斯数</td><td>人数</td><td>埃德斯数</td><td>人数</td></tr><tr><td>0</td><td>1</td><td>7</td><td>11 591</td></tr><tr><td>1</td><td>504</td><td>8</td><td>3146</td></tr><tr><td>2</td><td>6 593</td><td>9</td><td>819</td></tr><tr><td>3</td><td>33 605</td><td>10</td><td>244</td></tr><tr><td>4</td><td>83 642</td><td>11</td><td>68</td></tr><tr><td>5</td><td>87 760</td><td>12</td><td>23</td></tr><tr><td>6</td><td>40 014</td><td>13</td><td>5</td></tr></table>"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.124,
                0.038,
                0.159,
                0.05
            ],
            "angle": 0,
            "content": "600"
        },
        {
            "type": "header",
            "bbox": [
                0.205,
                0.036,
                0.281,
                0.051
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "image",
            "bbox": [
                0.041,
                0.096,
                0.081,
                0.108
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.092,
                0.943,
                0.262
            ],
            "angle": 0,
            "content": "在好莱坞图（参见10.1节例3）中，当存在连接两个顶点 \\(a\\) 和 \\(b\\) 的演员链，其中在这个链上每两个相邻的演员都出演过同一部电影时，\\(a\\) 和 \\(b\\) 就被连接。在好莱坞图中，演员 \\(c\\) 的培根数定义为连接 \\(c\\) 和著名演员凯文·培根的最短通路的长度。随着新电影（包括凯文·培根的新电影）的不断产生，演员的培根数也在不断地发生变化。表2显示的是从培根网站得到的到2017年8月，具有各个培根数的演员的数目。一个演员的培根数起源于1990年年初，凯文·培根标注了他在好莱坞合作的每一位演员或与他合作过的人。这使有些人发明了一个聚会游戏，要求参加者从指定的演员找到凯文·培根的一个电影系列。在网络诞生之前，你需要成为一名电影专家才能玩好这个游戏。现在，你只需要咨询培根的Oracle数据库。我们可以把表演学院的任意一个演员作为中心，找到一个类似于培根数的数。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.32,
                0.272,
                0.719,
                0.287
            ],
            "angle": 0,
            "content": "表 2 具有给定培根数 (到 2017 年年初) 的演员数"
        },
        {
            "type": "table",
            "bbox": [
                0.095,
                0.288,
                0.943,
                0.409
            ],
            "angle": 0,
            "content": "<table><tr><td>培根数</td><td>人数</td><td>培根数</td><td>人数</td></tr><tr><td>0</td><td>1</td><td>5</td><td>4388</td></tr><tr><td>1</td><td>3452</td><td>6</td><td>631</td></tr><tr><td>2</td><td>401 636</td><td>7</td><td>131</td></tr><tr><td>3</td><td>1 496 104</td><td>8</td><td>9</td></tr><tr><td>4</td><td>390 878</td><td>9</td><td>1</td></tr></table>"
        },
        {
            "type": "title",
            "bbox": [
                0.098,
                0.431,
                0.348,
                0.447
            ],
            "angle": 0,
            "content": "10.4.3 无向图的连通性"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.451,
                0.942,
                0.506
            ],
            "angle": 0,
            "content": "若消息可以通过一个或多个中间计算机来传递，则计算机网络何时具有每对计算机都可共享信息的性质？当利用图来表示这个计算机网络时，其中用顶点表示计算机而用边表示通信链路时，这个问题就变成：何时在图中任意两个顶点之间都存在通路？"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.514,
                0.936,
                0.569
            ],
            "angle": 0,
            "content": "定义3 若无向图中每一对不同的顶点之间都有通路，则该图称为连通的。不连通的无向图称为不连通的。当从图中删除顶点或边，或两者时，得到了不连通的子图，就称将图变成不连通的。"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.579,
                0.891,
                0.596
            ],
            "angle": 0,
            "content": "因此，在网络中的任何两个计算机之间都可以通信，当且仅当这个网络图是连通的。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.6,
                0.942,
                0.639
            ],
            "angle": 0,
            "content": "例4图2中的图 \\(G_{1}\\) 是连通的，因为在每一对不同的顶点之间都有通路（读者应当验证它）。但是图2中的图 \\(G_{2}\\) 不是连通的。例如，在顶点 \\(a\\) 和 \\(d\\) 之间没有通路。"
        },
        {
            "type": "image",
            "bbox": [
                0.351,
                0.646,
                0.692,
                0.806
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.457,
                0.813,
                0.604,
                0.828
            ],
            "angle": 0,
            "content": "图2 图 \\(G_{1}\\) 和 \\(G_{2}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.137,
                0.839,
                0.368,
                0.856
            ],
            "angle": 0,
            "content": "第11章将用到下述定理。"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.864,
                0.714,
                0.882
            ],
            "angle": 0,
            "content": "定理1 在连通无向图的每一对不同顶点之间都存在简单通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.891,
                0.945,
                0.927
            ],
            "angle": 0,
            "content": "证明 设 \\(u\\) 和 \\(v\\) 是连通无向图 \\(G = (V, E)\\) 的两个不同的顶点。因为 \\(G\\) 是连通的，所以 \\(u\\) 和 \\(v\\) 之间至少有1条通路。设 \\(x_0, x_1, \\dots, x_n\\) 是长度最短的通路的顶点序列，其中 \\(x_0 = u\\) 而"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.762,
                0.038,
                0.867,
                0.052
            ],
            "angle": 0,
            "content": "图 601"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.093,
                0.898,
                0.147
            ],
            "angle": 0,
            "content": "\\(x_{n} = v\\) 。这条长度最短的通路是简单的。为了看明白这一点，假设它不是简单的。则对满足 \\(0 \\leqslant i < j\\) 的某个 \\(i\\) 和 \\(j\\) 来说，有 \\(x_{i} = x_{j}\\) 。这意味着通过删除顶点序列 \\(x_{i}, \\cdots, x_{j-1}\\) 所对应的边，就得到带有顶点序列 \\(x_{0}, x_{1}, \\cdots, x_{i-1}, x_{j}, \\cdots, x_{n}\\) 的从 \\(u\\) 到 \\(v\\) 的更短的通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.15,
                0.898,
                0.168
            ],
            "angle": 0,
            "content": "连通分支 图 \\(G\\) 的连通分支是 \\(G\\) 的连通子图，且该子图不是图 \\(G\\) 的另一个连通子图的真"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.17,
                0.497,
                0.224
            ],
            "angle": 0,
            "content": "子图。也就是说，图 \\(G\\) 的连通分支是 \\(G\\) 的一个极大连通子图。不连通的图 \\(G\\) 具有2个或2个以上不相交的连通子图，并且 \\(G\\) 是这些连通子图的并。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.228,
                0.474,
                0.246
            ],
            "angle": 0,
            "content": "例5 图3所示的图 \\(H\\) 的连通分支是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.251,
                0.499,
                0.306
            ],
            "angle": 0,
            "content": "解如图3所示，图 \\(H\\) 是3个不相交的连通子图 \\(H_{1}\\) 、 \\(H_{2}\\) 和 \\(H_{3}\\) 的并。这3个子图是 \\(H\\) 的连通分支。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.311,
                0.499,
                0.35
            ],
            "angle": 0,
            "content": "例6 呼叫图的连通分支 当电话呼叫图（参见10.1节例4）中存在一系列从 \\(x\\) 开始到 \\(y\\) 结束的"
        },
        {
            "type": "image",
            "bbox": [
                0.512,
                0.174,
                0.9,
                0.322
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.529,
                0.327,
                0.882,
                0.343
            ],
            "angle": 0,
            "content": "图3 图 \\(H\\) 和它的连通分支 \\(H_{1}\\) 、 \\(H_{2}\\) 和 \\(H_{3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.353,
                0.898,
                0.464
            ],
            "angle": 0,
            "content": "电话呼叫时，两个顶点 \\(x\\) 和 \\(y\\) 就属于同一个连通分支。当分析AT&T网络中特定一天内发生的电话呼叫的呼叫图时，发现这个图具有53767087个顶点、超过1.7亿条边和超过370万个连通分支。这些连通分支大多数都很小，大约 \\(3/4\\) 是由表示只在彼此之间呼叫的一对电话号码的两个顶点所组成。这个图具有一个包含44989297个顶点（占总数的 \\(80\\%\\) ）的巨大的连通分支。另外，这个连通分支中的每个顶点都可以通过一条不超过20个顶点的链连接到任何其他顶点。"
        },
        {
            "type": "title",
            "bbox": [
                0.054,
                0.474,
                0.3,
                0.492
            ],
            "angle": 0,
            "content": "10.4.4 图是如何连通的"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.495,
                0.898,
                0.569
            ],
            "angle": 0,
            "content": "设有一个表示计算机网络的图。由该图是连通的可知，该网络中任意两台计算机之间都可以通信。然而，我们还想知道这个网络有多可靠。例如，当一个路由器或通信链路发生故障时，它是否还能保证所有计算机之间可以通信？为了回答这个以及类似的问题，我们介绍一些新的概念。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.571,
                0.898,
                0.664
            ],
            "angle": 0,
            "content": "有时删除图中的一个顶点和它所关联的边，就产生比原图具有更多连通分支的子图。把这样的顶点称为割点（或关节点）。从连通图里删除割点，就产生不连通的子图。同理，如果删除一条边，就产生比原图具有更多连通分支的子图，这条边就称为割边或桥。注意，在表示计算机网络的图中，割点和割边表示了最重要的路由器和最重要的链路，为了使所有的计算机可以通信，它们不能发生故障。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.669,
                0.478,
                0.686
            ],
            "angle": 0,
            "content": "例7 求出图4所示的图 \\(G_{1}\\) 的割点和割边。"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.692,
                0.898,
                0.727
            ],
            "angle": 0,
            "content": "解图 \\(G_{1}\\) 的割点是 \\(b\\) 、 \\(c\\) 和 \\(e\\) 。删除这些顶点中的一个（和它的邻边），就使得这个图不再是连通的。割边是 \\(\\{a,b\\}\\) 和 \\(\\{c,e\\}\\) 。删除这些边中的一条，就使得 \\(G\\) 不再是连通的。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.73,
                0.898,
                0.803
            ],
            "angle": 0,
            "content": "点连通性并不是所有的图都有割点。例如，完全图 \\(K_{n}\\)，其中 \\(n \\geq 3\\)，就没有割点。当从 \\(K_{n}\\) 中删除一个顶点及其相关联的边时，得到的子图是一个连通的完全图 \\(K_{n-1}\\)。不含割点的连通图称为不可分割图，它比有割点的连通图具有更好的连通性。我们可以扩展这个概念，基于使一个图不连通需要删除的最小的顶点数，定义一个与图的连通性相关的更大粒度的方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.805,
                0.898,
                0.879
            ],
            "angle": 0,
            "content": "若 \\(G - V^{\\prime}\\) 是不连通的，则称 \\(G = (V,E)\\) 的顶点集 \\(V\\) 的子集 \\(V^{\\prime}\\) 是点割集，或分割集。例如，在图1中，集合 \\(\\{b,c,e\\}\\) 是一个含有3个顶点的点割集，读者可自行验证。我们留给读者证明（练习51），除了完全图以外，每一个连通图都有一个点割集。我们定义非完全图的点连通度为点割集中最小的顶点数，记作 \\(\\kappa (G)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.882,
                0.898,
                0.937
            ],
            "angle": 0,
            "content": "当 \\(G\\) 是完全图时，它没有点割集，因为删除它顶点集合的任意子集及其所有相关联的边后它仍然是一个完全图。同时，当 \\(G\\) 是完全图时，我们不能把 \\(\\kappa(G)\\) 定义为点割集的最小顶点数。我们用 \\(\\kappa(K_n) = n - 1\\) 来替代，这是需要删除的顶点数，以便得到只含有一个顶点的图。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.13,
                0.037,
                0.167,
                0.051
            ],
            "angle": 0,
            "content": "602"
        },
        {
            "type": "header",
            "bbox": [
                0.211,
                0.036,
                0.288,
                0.051
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "image",
            "bbox": [
                0.169,
                0.095,
                0.509,
                0.278
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.557,
                0.095,
                0.892,
                0.278
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.168,
                0.287,
                0.5,
                0.405
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.568,
                0.287,
                0.892,
                0.412
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.164,
                0.414,
                0.498,
                0.548
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.443,
                0.56,
                0.612,
                0.575
            ],
            "angle": 0,
            "content": "图4 一些连通的图"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.586,
                0.951,
                0.641
            ],
            "angle": 0,
            "content": "因此，对于每一个图 \\(G\\) ， \\(\\kappa (G)\\) 是使 \\(G\\) 变成不连通的图或只含有一个顶点的图所需删除的最小的顶点数。若 \\(G\\) 含有 \\(n\\) 个顶点，则 \\(0\\leqslant \\kappa (G)\\leqslant n - 1\\) ， \\(\\kappa (G) = 0\\) 当且仅当 \\(G\\) 是不连通的或\\(G = K_{1}\\) ， \\(\\kappa (G) = n - 1\\) 当且仅当 \\(G\\) 是完全图[参见练习52a]。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.644,
                0.95,
                0.756
            ],
            "angle": 0,
            "content": "\\(\\kappa (G)\\) 越大，我们认为 \\(G\\) 的连通性越好。不连通的图和 \\(K_{1}\\) 具有 \\(\\kappa (G) = 0\\) ，含有点割集的连通图和 \\(K_{2}\\) 具有 \\(\\kappa (G) = 1\\) ，不含点割集的需要删除两个顶点才变成不连通的图和 \\(K_{3}\\) 具有\\(\\kappa (G) = 2\\) ，以此类推。若 \\(\\kappa (G)\\geqslant k\\) ，我们称图为 \\(k\\) 连通的(或 \\(k\\) 顶点-连通的)。若图是连通的且不是只含1个顶点的图，则称该图是1连通的；若图是不可分割的且至少含有3个顶点，则称该图为2连通的或双连通的。注意若 \\(G\\) 是一个 \\(k\\) 连通图，则对所有的 \\(j\\) ， \\(0\\leqslant j\\leqslant k\\) ， \\(G\\) 是一个 \\(j\\) 连通图。"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.761,
                0.481,
                0.779
            ],
            "angle": 0,
            "content": "例8 求出图4中每个图的点连通度。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.783,
                0.951,
                0.838
            ],
            "angle": 0,
            "content": "解图4中的5个图都是连通的且顶点数都大于1，所以每个图的点连通度都为正数。因为 \\(G_{1}\\) 是含1个割点的连通图，如例7所示，所以 \\(\\kappa (G) = 1\\) 。同理， \\(\\kappa (G_2) = 1\\) ，因为 \\(c\\) 是 \\(G_{2}\\) 的一个割点。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.841,
                0.95,
                0.896
            ],
            "angle": 0,
            "content": "读者可验证 \\(G_{3}\\) 没有割点，但是 \\(\\{b, g\\}\\) 是一个点割集。所以 \\(\\kappa(G_{3}) = 2\\) 。同理，\\(G_{4}\\) 没有割点，但是有一个含有两个元素 \\(\\{c, f\\}\\) 的点割集。由此可得，\\(\\kappa(G_{4}) = 2\\) 。读者可验证 \\(G_{5}\\) 没有含有两个元素的点割集，但 \\(\\{b, c, f\\}\\) 是 \\(G_{5}\\) 的一个点割集，所以 \\(\\kappa(G_{5}) = 3\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.899,
                0.951,
                0.935
            ],
            "angle": 0,
            "content": "边连通度 我们可以通过把连通图 \\(G = (V, E)\\) 变成不连通的所需要删除的最小边数，来度量连通图 \\(G\\) 的连通性。若一个图含有割边，那么我们只需删除该边就可以使 \\(G\\) 变成不连通"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.771,
                0.036,
                0.877,
                0.05
            ],
            "angle": 0,
            "content": "图 603"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.09,
                0.908,
                0.224
            ],
            "angle": 0,
            "content": "的。如果 \\(G\\) 不含有割边，那么我们寻找需要删除的最小的边割集，以使 \\(G\\) 变成不连通的。如果 \\(G - E'\\) 是不连通的，则称边集 \\(E'\\) 是图 \\(G\\) 的边割集。图 \\(G\\) 的边连通度，记作 \\(\\lambda(G)\\)，是图 \\(G\\) 的边割集中的最小的边数。这给出了顶点数大于1的所有连通图的 \\(\\lambda(G)\\) 的定义，因为把所有与图中某个顶点相关联的边都删除，就可以使该图变成不连通的。注意，若 \\(G\\) 是不连通的，则 \\(\\lambda(G) = 0\\)。若 \\(G\\) 是只含有1个顶点的图，我们也定义 \\(\\lambda(G) = 0\\)。由此可得，若 \\(G\\) 是含有 \\(n\\) 个顶点的图，则 \\(0 \\leqslant \\lambda(G) \\leqslant n - 1\\)。我们留给读者[练习52b]证明，\\(G\\) 是含有 \\(n\\) 个顶点的图，\\(\\lambda(G) = n - 1\\) 当且仅当 \\(G = K_n\\)，这等价于命题，若 \\(G\\) 不是完全图，则 \\(\\lambda(G) \\leqslant n - 2\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.228,
                0.414,
                0.246
            ],
            "angle": 0,
            "content": "例9 求图4中每个图的边连通度。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.25,
                0.908,
                0.286
            ],
            "angle": 0,
            "content": "解图4中的5个图都是连通的且顶点数都大于1，所以每个图的边连通度都为正数。如例7所示，因为 \\(G_{1}\\) 含1条割边，所以 \\(\\lambda (G_1) = 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.289,
                0.908,
                0.344
            ],
            "angle": 0,
            "content": "读者需要验证 \\(G_{2}\\) 没有割边，但是删除 \\(\\{a, b\\}\\) 和 \\(\\{a, c\\}\\) 两条边后，就可以使它变成不连通的。所以 \\(\\lambda(G_{2}) = 2\\) 。同理，\\(\\lambda(G_{3}) = 2\\) ，因为 \\(G_{3}\\) 没有割边，但是删除 \\(\\{b, c\\}\\) 和 \\(\\{f, g\\}\\) 两条边后，就可以使它变成不连通的。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.347,
                0.909,
                0.422
            ],
            "angle": 0,
            "content": "读者可以验证，删除任意两条边，都不能使 \\(G_{4}\\) 变成不连通的，但是删除 \\(\\{b,c\\} ,\\{a,f\\}\\) 和 \\(\\{f,g\\}\\) 三条边后，就可以使它变成不连通的。所以， \\(\\lambda (G_4) = 3\\) 。最后，读者需要验证\\(\\lambda (G_5) = 3\\) ，因为删除任意两条边，都不能使其变成不连通的，但是删除 \\(\\{a,b\\} ,\\{a,g\\}\\) 和 \\(\\{a,\\) \\(h\\}\\) 三条边后，就可以使它变成不连通的。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.424,
                0.909,
                0.502
            ],
            "angle": 0,
            "content": "一个与点连通度和边连通度相关的不等式 当 \\(G = (V, E)\\) 是一个至少含有 3 个顶点的非完全连通图时，图 \\(G\\) 中顶点的最小度是图 \\(G\\) 的点连通度和图 \\(G\\) 的边连通度的上界。即 \\(\\kappa(G) \\leqslant \\min_{v \\in V} \\deg(v)\\) 和 \\(\\lambda(G) \\leqslant \\min_{v \\in V} \\deg(v)\\) 。为了明白这一点，注意删除度最小的顶点的所有邻居，就使 \\(G\\) 变成不连通的；而且删除所有以度最小的顶点为端点的边，就使 \\(G\\) 变成不连通的。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.504,
                0.909,
                0.563
            ],
            "angle": 0,
            "content": "在练习55中，我们要求读者证明，若 \\(G\\) 是一个连通的非完全图，则 \\(\\kappa (G)\\leqslant \\lambda (G)\\) 。还要注意，若 \\(n\\) 是正整数，则 \\(\\kappa (K_n) = \\lambda (K_n) = \\min_{v\\in V}\\deg (v) = n - 1\\) ，而且，若 \\(G\\) 是不连通的图，则 \\(\\kappa (G) = \\lambda (G) = 0\\) 。将这些事实结合起来，对所有的图 \\(G\\) 有"
        },
        {
            "type": "equation",
            "bbox": [
                0.357,
                0.565,
                0.608,
                0.588
            ],
            "angle": 0,
            "content": "\\[\n\\kappa (G) \\leqslant \\lambda (G) \\leqslant \\min  _ {v \\in V} \\deg (v)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.588,
                0.91,
                0.701
            ],
            "angle": 0,
            "content": "点连通度和边连通度的应用 图的连通性对涉及网络可靠性的许多问题都很重要。例如，我们在介绍割点和割边时提到，可以用顶点表示路由器，用边表示它们之间的链路来为数据网络建模。图中的点连通度等于使网络不连通不能提供服务的最小的路由器数。若宕机的路由器少于这个数，那么还可以在任意两个路由器之间进行数据传输。边连通度表示使网络不连通时发生故障的最小光纤链路数。若发生故障的链路数少于这个数，那么还可以在任意两个路由器之间进行数据传输。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.703,
                0.91,
                0.798
            ],
            "angle": 0,
            "content": "我们可以使用顶点表示高速公路交叉点，边表示连接交叉点的公路为高速公路网建模。该图的点连通度表示，使任意两个交叉点不能通行，在某一时刻所需关闭的最少交叉点数。若少于这个数的交叉点关闭，则还可以在任意两个交叉点之间通行。边连通度表示使高速公路不连通，所需关闭的最少的公路数。如果少于这个数的高速公路关闭，则还可以在任意两个交叉点之间通行。显然，当设计公路维修计划时，这个信息对高速公路管理部门是很有用的。"
        },
        {
            "type": "title",
            "bbox": [
                0.064,
                0.807,
                0.314,
                0.825
            ],
            "angle": 0,
            "content": "10.4.5 有向图的连通性"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.827,
                0.612,
                0.845
            ],
            "angle": 0,
            "content": "根据是否考虑边的方向，在有向图中有两种连通性概念。"
        },
        {
            "type": "text",
            "bbox": [
                0.071,
                0.854,
                0.9,
                0.89
            ],
            "angle": 0,
            "content": "定义4 若对于有向图中的任意顶点 \\(a\\) 和 \\(b\\) ，都有从 \\(a\\) 到 \\(b\\) 和从 \\(b\\) 到 \\(a\\) 的通路，则该图是强连通的。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.899,
                0.91,
                0.937
            ],
            "angle": 0,
            "content": "对于一个强连通的有向图，在这个图中的任何一个顶点到任何另一个顶点之间一定存在有向边的序列。有向图可以不是强连通的，但还是“一整块”。定义5准确地说明了这个"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.117,
                0.036,
                0.154,
                0.05
            ],
            "angle": 0,
            "content": "604"
        },
        {
            "type": "header",
            "bbox": [
                0.199,
                0.035,
                0.275,
                0.05
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.092,
                0.143,
                0.106
            ],
            "angle": 0,
            "content": "概念。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.116,
                0.926,
                0.153
            ],
            "angle": 0,
            "content": "定义5 若在有向图的基本无向图中，任何两个顶点之间都有通路，则该有向图是弱连通的。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.162,
                0.574,
                0.217
            ],
            "angle": 0,
            "content": "也就是说，有向图是弱连通的，当且仅当在忽略边的方向时，任何两个顶点之间总是存在通路。显然，任何强连通有向图也是弱连通的。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.222,
                0.574,
                0.26
            ],
            "angle": 0,
            "content": "例10 图5所示的有向图 \\(G\\) 和 \\(H\\) 是否为强连通的？是否为弱连通的？"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.263,
                0.577,
                0.317
            ],
            "angle": 0,
            "content": "解 \\(G\\) 是强连通的，因为在这个有向图中，任何两个顶点之间都存在通路（读者应当验证它）。因此 \\(G\\) 也是弱连通的。图 \\(H\\) 不是强连通的。在这个图中，从"
        },
        {
            "type": "image",
            "bbox": [
                0.589,
                0.165,
                0.743,
                0.262
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.638,
                0.269,
                0.655,
                0.28
            ],
            "angle": 0,
            "content": "G"
        },
        {
            "type": "image",
            "bbox": [
                0.782,
                0.165,
                0.934,
                0.262
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.834,
                0.269,
                0.85,
                0.28
            ],
            "angle": 0,
            "content": "H"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.677,
                0.29,
                0.849,
                0.304
            ],
            "angle": 0,
            "content": "图5 有向图 \\(G\\) 和 \\(H\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.32,
                0.936,
                0.356
            ],
            "angle": 0,
            "content": "\\(a\\) 到 \\(b\\) 没有有向通路。但是 \\(H\\) 是弱连通的，因为在 \\(H\\) 的基本无向图中，任何两个顶点之间都有通路（读者应当验证它）。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.358,
                0.934,
                0.413
            ],
            "angle": 0,
            "content": "有向图的强连通分支 有向图 \\(G\\) 的子图是强连通的，但不包含在更大的强连通子图中，即极大强连通子图，可称为 \\(G\\) 的强连通分支或强分支。注意，若 \\(a\\) 和 \\(b\\) 是有向图中的两个顶点，它们的强连通分支或者相同或者不相交。（我们把这个事实的证明留在练习17中。）"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.418,
                0.934,
                0.456
            ],
            "angle": 0,
            "content": "例11图5中的图 \\(H\\) 有3个强连通分支，包括：顶点 \\(a\\)；顶点 \\(e\\)；由顶点 \\(b\\)、\\(c\\) 和 \\(d\\) 以及边 \\((b, c)\\)、\\((c, d)\\) 和 \\((d, b)\\) 所组成的子图。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.461,
                0.935,
                0.539
            ],
            "angle": 0,
            "content": "例12 网络图的强连通分支 10.1节例5中介绍的网络图用顶点表示网页而用有向边表示链路。该网络在1999年的快照产生了具有2亿个顶点和15亿条边的网络图。2010年，网络图估计至少有550亿个顶点和10000亿条边。从这些有限的数据可见（如果你近年来使用过网络，这很容易理解），网页数量有着较快的增长速度。（详情参见[Br00]及Web资源。）"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.541,
                0.936,
                0.749
            ],
            "angle": 0,
            "content": "1999年，该网络图的基本无向图不是连通的，但是有一个包含了这个图中大约 \\(90\\%\\) 的顶点的连通分支。与基本无向图中的这个连通分支所对应的原来有向图的子图（即具有相同的顶点以及连接这些顶点的所有有向边），有一个非常大的强连通分支和许多小的强连通分支。前者称为这个有向图的巨型强连通分支(GSCC)。从这个分支中的任何其他网页开始的链路都可到达这个分支中的某一个网页。已经发现，这项研究产生的网络图中的巨型强连通分支有超过5300万个顶点。这个无向图的大型连通分支中的其余顶点表示3种不同类型的网页：可以从巨型强连通分支中的网页到达的，但是不能通过一系列链路返回前面这些网页的网页；可以通过一系列链路返回巨型强连通分支中的网页，但是不能通过巨型强连通分支中网页上的链路到达的网页；既不能到达巨型强连通分支中的网页，也不能通过一系列链路从巨型强连通分支中的网页到达的网页。这项研究发现其余这三个集合中的每个都具有大约4400万个顶点（这三个集合都接近同样的规模，这是相当令人惊讶的）。"
        },
        {
            "type": "title",
            "bbox": [
                0.094,
                0.758,
                0.298,
                0.775
            ],
            "angle": 0,
            "content": "10.4.6 通路与同构"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.778,
                0.938,
                0.833
            ],
            "angle": 0,
            "content": "有多种方式可以利用通路和回路来帮助判定两个图是否同构。例如，特定长度简单回路的存在，就是一种可以用来证明两个图不同构的有用的不变量。另外，可以利用通路来构造可能的同构映射。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.835,
                0.938,
                0.89
            ],
            "angle": 0,
            "content": "前面提到过，简单图的一个有用的同构不变量是长度为 \\(k\\) 的简单回路的存在性，其中 \\(k\\) 是大于2的正整数（这是一个不变量的证明在本节练习60中）。例13说明如何用这个不变量来证明两个图是不同构的。"
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.895,
                0.571,
                0.912
            ],
            "angle": 0,
            "content": "例13 判定图6所示的图 \\(G\\) 和 \\(H\\) 是否是同构的。"
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.917,
                0.938,
                0.935
            ],
            "angle": 0,
            "content": "解 \\(G\\) 和 \\(H\\) 都具有6个顶点和8条边。各自具有4个度为3的顶点和2个度为2的顶点。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.77,
                0.037,
                0.874,
                0.051
            ],
            "angle": 0,
            "content": "图 605"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.092,
                0.906,
                0.166
            ],
            "angle": 0,
            "content": "所以对两个图来说，这3个不变量（顶点数、边数以及顶点度）都是相同的。但是 \\(H\\) 有长度为3的简单回路，即 \\(v_{1}, v_{2}, v_{6}, v_{1}\\)，而通过观察可以看到，\\(G\\) 没有长度为3的简单回路（\\(G\\) 中的所有简单回路的长度至少为4）。因为存在一条长度为3的简单回路是一个同构不变量，所以 \\(G\\) 和 \\(H\\) 是不同构的。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.169,
                0.905,
                0.204
            ],
            "angle": 0,
            "content": "我们已经说明了如何用某种类型的通路，即具有特定长度的简单回路，来证明两个图是不同构的。还可以用通路求出潜在的同构映射。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.208,
                0.535,
                0.226
            ],
            "angle": 0,
            "content": "例14 判定图7所示的图 \\(G\\) 和 \\(H\\) 是否是同构的。"
        },
        {
            "type": "image",
            "bbox": [
                0.091,
                0.233,
                0.25,
                0.374
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.163,
                0.381,
                0.18,
                0.391
            ],
            "angle": 0,
            "content": "G"
        },
        {
            "type": "image",
            "bbox": [
                0.278,
                0.234,
                0.437,
                0.374
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.351,
                0.381,
                0.367,
                0.391
            ],
            "angle": 0,
            "content": "H"
        },
        {
            "type": "image",
            "bbox": [
                0.524,
                0.288,
                0.677,
                0.376
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.595,
                0.383,
                0.61,
                0.392
            ],
            "angle": 0,
            "content": "G"
        },
        {
            "type": "image",
            "bbox": [
                0.72,
                0.289,
                0.871,
                0.376
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.79,
                0.383,
                0.807,
                0.392
            ],
            "angle": 0,
            "content": "H"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.195,
                0.4,
                0.331,
                0.415
            ],
            "angle": 0,
            "content": "图6 图 \\(G\\) 和 \\(H\\)"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.63,
                0.401,
                0.766,
                0.416
            ],
            "angle": 0,
            "content": "图7 图 \\(G\\) 和 \\(H\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.423,
                0.906,
                0.477
            ],
            "angle": 0,
            "content": "解 \\(G\\) 和 \\(H\\) 都具有5个顶点和6条边，都具有2个度为3的顶点和3个度为2顶点，而且都具有1个长度为3的简单回路，1个长度为4的简单回路，以及1个长度为5的简单回路。因为所有这些同构不变量都是相同的，所以 \\(G\\) 和 \\(H\\) 可能是同构的。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.48,
                0.908,
                0.611
            ],
            "angle": 0,
            "content": "为了求出可能的同构，沿着经过所有顶点并且使得两个图中的对应顶点的度都相同的通路前进。例如， \\(G\\) 中的通路 \\(u_{1}\\)，\\(u_{4}\\)，\\(u_{3}\\)，\\(u_{2}\\)，\\(u_{5}\\) 和 \\(H\\) 中的通路 \\(v_{3}\\)，\\(v_{2}\\)，\\(v_{1}\\)，\\(v_{5}\\)，\\(v_{4}\\) 都经过图中的每一个顶点，都从度为3的顶点开始，都分别经过度为2的顶点、度为3的顶点和度为2顶点并且在度为2的顶点结束。通过在图中沿着这些通路前进，定义映射 \\(f\\) 满足 \\(f(u_{1}) = v_{3}\\)，\\(f(u_{4}) = v_{2}\\)，\\(f(u_{3}) = v_{1}\\)，\\(f(u_{2}) = v_{5}\\) 和 \\(f(u_{5}) = v_{4}\\)。通过说明 \\(f\\) 保持边或者通过说明在顶点的适当顺序下 \\(G\\) 和 \\(H\\) 的邻接矩阵是相同的，读者就可以说明 \\(f\\) 是一个同构，所以 \\(G\\) 与 \\(H\\) 是同构的。"
        },
        {
            "type": "title",
            "bbox": [
                0.06,
                0.621,
                0.377,
                0.638
            ],
            "angle": 0,
            "content": "10.4.7 计算顶点之间的通路数"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.642,
                0.75,
                0.659
            ],
            "angle": 0,
            "content": "在一个图中两个顶点之间通路的数目，可以用这个图的邻接矩阵来确定。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.667,
                0.899,
                0.725
            ],
            "angle": 0,
            "content": "定理2 设 \\(G\\) 是一个图，该图的邻接矩阵 \\(\\mathbf{A}\\) 相对于图中的顶点顺序 \\(v_{1}, v_{2}, \\cdots, v_{n}\\) （允许带有无向或有向边、带有多重边和环）。从 \\(v_{i}\\) 到 \\(v_{j}\\) 长度为 \\(r\\) 的不同通路的数目等于 \\(\\mathbf{A}^{r}\\) 的第 \\((i, j)\\) 项，其中 \\(r\\) 是正整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.734,
                0.906,
                0.769
            ],
            "angle": 0,
            "content": "证明用数学归纳法证明。设 \\(G\\) 是带有邻接矩阵 \\(\\mathbf{A}\\) 的图（假设 \\(G\\) 的顶点具有顺序 \\(v_{1}, v_{2}, \\dots, v_{n}\\)）。从 \\(v_{i}\\) 到 \\(v_{j}\\) 长度为 1 的通路数是 \\(\\mathbf{A}\\) 的第 \\((i,j)\\) 项，因为该项是从 \\(v_{i}\\) 到 \\(v_{j}\\) 的边数。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.772,
                0.905,
                0.807
            ],
            "angle": 0,
            "content": "假设 \\(A^r\\) 的第 \\((i,j)\\) 项是从 \\(v_{i}\\) 到 \\(v_{j}\\) 长度为 \\(r\\) 的不同通路的个数。这是归纳假设。因为 \\(A^{r + 1} = A^r A\\) ，所以 \\(A^{r + 1}\\) 的第 \\((i,j)\\) 项等于"
        },
        {
            "type": "equation",
            "bbox": [
                0.366,
                0.811,
                0.597,
                0.828
            ],
            "angle": 0,
            "content": "\\[\nb _ {i 1} a _ {1 j} + b _ {i 2} a _ {2 j} + \\dots + b _ {i n} a _ {n j}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.83,
                0.77,
                0.846
            ],
            "angle": 0,
            "content": "其中 \\(b_{ik}\\) 是 \\(\\mathbf{A}^r\\) 的第 \\((i,k)\\) 项。根据归纳假设，\\(b_{ik}\\) 是从 \\(v_{i}\\) 到 \\(v_{k}\\) 长度为 \\(r\\) 的通路数。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.849,
                0.908,
                0.923
            ],
            "angle": 0,
            "content": "从 \\(v_{i}\\) 到 \\(v_{j}\\) 长度为 \\(r + 1\\) 的通路，包括从 \\(v_{i}\\) 到某个中间顶点 \\(v_{k}\\) 长度为 \\(r\\) 的通路以及从 \\(v_{k}\\) 到 \\(v_{j}\\) 的边。根据计数的乘积法则，这样的通路个数是从 \\(v_{i}\\) 到 \\(v_{k}\\) 长度为 \\(r\\) 的通路数（即 \\(b_{ik}\\)）与从 \\(v_{k}\\) 到 \\(v_{j}\\) 的边数（即 \\(a_{kj}\\)）积。当对所有可能的中间顶点 \\(v_{k}\\) 求这些乘积之和时，根据计数的求和法则，就可以得出所需要的结果。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.132,
                0.037,
                0.167,
                0.049
            ],
            "angle": 0,
            "content": "606"
        },
        {
            "type": "header",
            "bbox": [
                0.212,
                0.035,
                0.288,
                0.05
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "header",
            "bbox": [
                0.027,
                0.092,
                0.087,
                0.108
            ],
            "angle": 0,
            "content": "Extra Examples"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.094,
                0.78,
                0.111
            ],
            "angle": 0,
            "content": "例15 在图8所示的简单图 \\(G\\) 中，从 \\(a\\) 到 \\(d\\) 长度为4的通路有多少条？"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.116,
                0.56,
                0.132
            ],
            "angle": 0,
            "content": "解 \\(G\\) 的邻接矩阵（顶点顺序为 \\(a, b, c, d\\)）是"
        },
        {
            "type": "equation",
            "bbox": [
                0.374,
                0.136,
                0.55,
                0.207
            ],
            "angle": 0,
            "content": "\\[\n\\mathbf {A} = \\left[ \\begin{array}{l l l l} 0 & 1 & 1 & 0 \\\\ 1 & 0 & 0 & 1 \\\\ 1 & 0 & 0 & 1 \\\\ 0 & 1 & 1 & 0 \\end{array} \\right]\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.211,
                0.632,
                0.227
            ],
            "angle": 0,
            "content": "因此从 \\(a\\) 到 \\(d\\) 长度为4的通路数是 \\(\\mathbf{A}^4\\) 的第(1，4)项。因为"
        },
        {
            "type": "equation",
            "bbox": [
                0.371,
                0.23,
                0.556,
                0.302
            ],
            "angle": 0,
            "content": "\\[\n\\boldsymbol {A} ^ {4} = \\left[ \\begin{array}{l l l l} 8 & 0 & 0 & 8 \\\\ 0 & 8 & 8 & 0 \\\\ 0 & 8 & 8 & 0 \\\\ 8 & 0 & 0 & 8 \\end{array} \\right]\n\\]"
        },
        {
            "type": "image",
            "bbox": [
                0.839,
                0.123,
                0.951,
                0.218
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.85,
                0.226,
                0.942,
                0.241
            ],
            "angle": 0,
            "content": "图8 图 \\(G\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.307,
                0.951,
                0.361
            ],
            "angle": 0,
            "content": "所以恰好有8条从 \\(a\\) 到 \\(d\\) 长度为4的通路。通过观察这个图，我们看出 \\(a, b, a, b, d; a, b, a, c, d; a, b, d, b, d; a, b, d, c, d; a, c, a, b, d; a, c, a, c, d; a, c, d, b, d\\) 和 \\(a, c, d, c, d\\) 是8条从 \\(a\\) 到 \\(d\\) 的通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.364,
                0.95,
                0.4
            ],
            "angle": 0,
            "content": "定理2可以用来求出在图的两个顶点之间的最短通路的长度（见练习56），还可以用来判定图是否连通（见练习61和62）。"
        },
        {
            "type": "title",
            "bbox": [
                0.105,
                0.411,
                0.154,
                0.427
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.43,
                0.95,
                0.462
            ],
            "angle": 0,
            "content": "1. 下述每个顶点列表是否可以构成下图中的通路？哪些通路是简单的？哪些是回路？这些通路的长度是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.467,
                0.264,
                0.48
            ],
            "angle": 0,
            "content": "a) \\( a \\), \\( e \\), \\( b \\), \\( c \\), \\( b \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.482,
                0.467,
                0.676,
                0.48
            ],
            "angle": 0,
            "content": "b) \\(a, e, a, d, b, c, a\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.486,
                0.293,
                0.498
            ],
            "angle": 0,
            "content": "c)e，b，a，d，b，e"
        },
        {
            "type": "text",
            "bbox": [
                0.482,
                0.486,
                0.648,
                0.498
            ],
            "angle": 0,
            "content": "d)c，b，d，a，e，c"
        },
        {
            "type": "image",
            "bbox": [
                0.126,
                0.503,
                0.341,
                0.596
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.598,
                0.95,
                0.631
            ],
            "angle": 0,
            "content": "2.下述每个顶点列表是否可以构成下图中的通路？哪些通路是简单的？哪些是回路？这些通路的长度是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.636,
                0.267,
                0.649
            ],
            "angle": 0,
            "content": "a) \\( a \\), \\( b \\), \\( e \\), \\( c \\), \\( b \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.485,
                0.636,
                0.628,
                0.648
            ],
            "angle": 0,
            "content": "b) \\(a, d, a, d, a\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.129,
                0.655,
                0.268,
                0.666
            ],
            "angle": 0,
            "content": "c) \\(a, d, b, e, a\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.485,
                0.654,
                0.676,
                0.666
            ],
            "angle": 0,
            "content": "d) \\(a, b, e, c, b, d, a\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.129,
                0.671,
                0.35,
                0.764
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.767,
                0.481,
                0.781
            ],
            "angle": 0,
            "content": "在练习 \\(3\\sim 5\\) 中，判定所给的图是否是连通的。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.785,
                0.126,
                0.798
            ],
            "angle": 0,
            "content": "3."
        },
        {
            "type": "image",
            "bbox": [
                0.129,
                0.785,
                0.195,
                0.832
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.231,
                0.785,
                0.295,
                0.832
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.364,
                0.786,
                0.381,
                0.798
            ],
            "angle": 0,
            "content": "4."
        },
        {
            "type": "image",
            "bbox": [
                0.386,
                0.784,
                0.649,
                0.827
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.718,
                0.785,
                0.734,
                0.798
            ],
            "angle": 0,
            "content": "5."
        },
        {
            "type": "image",
            "bbox": [
                0.739,
                0.784,
                0.868,
                0.879
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.883,
                0.801,
                0.898
            ],
            "angle": 0,
            "content": "6. 在练习 \\(3\\sim 5\\) 中，每个图各自有多少个连通分支？对每个图求出它的每个连通分支。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.901,
                0.405,
                0.915
            ],
            "angle": 0,
            "content": "7. 相识关系图的连通分支表示什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.919,
                0.368,
                0.934
            ],
            "angle": 0,
            "content": "8. 合作图的连通分支表示什么？"
        },
        {
            "type": "list",
            "bbox": [
                0.105,
                0.883,
                0.801,
                0.934
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.763,
                0.038,
                0.87,
                0.053
            ],
            "angle": 0,
            "content": "图 607"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.094,
                0.898,
                0.127
            ],
            "angle": 0,
            "content": "9. 解释为什么在数学家的合作图中（参见10.1节例3），表示一个数学家的顶点与表示保罗·埃德斯的顶点是在同一个连通分支中，当且仅当这个数学家具有有穷的埃德斯数。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.13,
                0.898,
                0.163
            ],
            "angle": 0,
            "content": "10. 在好莱坞图中（参见10.1节例3），什么时候表示一个演员的顶点与表示凯文·培根的顶点是在同一个连通分支中？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.167,
                0.632,
                0.182
            ],
            "angle": 0,
            "content": "11. 判断下列各图是否是强连通的，如果不是，再判断是否是弱连通的。"
        },
        {
            "type": "list",
            "bbox": [
                0.051,
                0.094,
                0.898,
                0.182
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.082,
                0.187,
                0.316,
                0.28
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.389,
                0.187,
                0.627,
                0.28
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.699,
                0.187,
                0.874,
                0.279
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.284,
                0.632,
                0.299
            ],
            "angle": 0,
            "content": "12. 判断下列各图是否是强连通的，如果不是，再判断是否是弱连通的。"
        },
        {
            "type": "image",
            "bbox": [
                0.082,
                0.304,
                0.3,
                0.376
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.389,
                0.304,
                0.53,
                0.403
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.603,
                0.304,
                0.807,
                0.388
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.407,
                0.375,
                0.422
            ],
            "angle": 0,
            "content": "13. 电话呼叫图的强连通分支表示什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.426,
                0.3,
                0.44
            ],
            "angle": 0,
            "content": "14. 求下列各图的强连通分支。"
        },
        {
            "type": "list",
            "bbox": [
                0.051,
                0.407,
                0.375,
                0.44
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.082,
                0.445,
                0.311,
                0.539
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.417,
                0.445,
                0.651,
                0.54
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.085,
                0.543,
                0.51,
                0.638
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.642,
                0.299,
                0.657
            ],
            "angle": 0,
            "content": "15. 求下列各图的强连通分支。"
        },
        {
            "type": "image",
            "bbox": [
                0.082,
                0.661,
                0.278,
                0.742
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.401,
                0.661,
                0.673,
                0.742
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.085,
                0.747,
                0.437,
                0.827
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.832,
                0.898,
                0.864
            ],
            "angle": 0,
            "content": "设 \\(G = (V,E)\\) 是有向图。对于 \\(\\omega \\in V\\) 和 \\(v\\in V\\) ，若有一条从 \\(\\mathcal{V}\\) 到 \\(\\pmb{\\varpi}\\) 的有向通路，则称 \\(\\boldsymbol{\\varpi}\\) 是从 \\(\\pmb{v}\\) 可达的。若在图 \\(G\\) 中，有一条从 \\(\\pmb{v}\\) 到 \\(\\pmb{\\varpi}\\) 的有向通路和一条从 \\(\\pmb{\\varpi}\\) 到 \\(\\pmb{v}\\) 的有向通路，则称 \\(\\pmb{v}\\) 和 \\(\\pmb{\\varpi}\\) 是相互可达的。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.868,
                0.898,
                0.901
            ],
            "angle": 0,
            "content": "16. 证明：若 \\(G = (V, E)\\) 是有向图，\\(u\\)、\\(v\\) 和 \\(w\\) 都是 \\(V\\) 的顶点，且 \\(u\\) 和 \\(v\\) 是相互可达的，\\(v\\) 和 \\(w\\) 是相互可达的，则 \\(u\\) 和 \\(w\\) 也是相互可达的。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.905,
                0.898,
                0.937
            ],
            "angle": 0,
            "content": "17. 证明：若 \\(G = (V, E)\\) 是有向图，则 \\(V\\) 中的两个顶点 \\(u\\) 和 \\(v\\) 所在的强连通分支要么相同，要么不相交。[提示：使用练习16。]"
        },
        {
            "type": "list",
            "bbox": [
                0.051,
                0.868,
                0.898,
                0.937
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.13,
                0.038,
                0.167,
                0.052
            ],
            "angle": 0,
            "content": "608"
        },
        {
            "type": "header",
            "bbox": [
                0.211,
                0.037,
                0.288,
                0.053
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.094,
                0.945,
                0.126
            ],
            "angle": 0,
            "content": "18. 证明：连接有向图同一个强连通分支中两个顶点的有向通路所访问的所有顶点也都在这个强连通分支中。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.13,
                0.616,
                0.145
            ],
            "angle": 0,
            "content": "19. 求 \\( K_{4} \\) 中两个不同顶点之间长度为 \\( n \\) 的通路的数目，若 \\( n \\) 是"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.148,
                0.166,
                0.161
            ],
            "angle": 0,
            "content": "a)2"
        },
        {
            "type": "text",
            "bbox": [
                0.327,
                0.148,
                0.358,
                0.161
            ],
            "angle": 0,
            "content": "b)3"
        },
        {
            "type": "text",
            "bbox": [
                0.504,
                0.149,
                0.532,
                0.16
            ],
            "angle": 0,
            "content": "c)4"
        },
        {
            "type": "text",
            "bbox": [
                0.678,
                0.149,
                0.708,
                0.16
            ],
            "angle": 0,
            "content": "d)5"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.166,
                0.739,
                0.18
            ],
            "angle": 0,
            "content": "20. 运用通路要么证明这两个图不是同构的，要么找出这两图之间的一个同构。"
        },
        {
            "type": "image",
            "bbox": [
                0.136,
                0.187,
                0.264,
                0.279
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.19,
                0.284,
                0.205,
                0.294
            ],
            "angle": 0,
            "content": "G"
        },
        {
            "type": "image",
            "bbox": [
                0.329,
                0.187,
                0.455,
                0.279
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.383,
                0.284,
                0.398,
                0.295
            ],
            "angle": 0,
            "content": "H"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.301,
                0.74,
                0.316
            ],
            "angle": 0,
            "content": "21. 运用通路要么证明这两个图不是同构的，要么找出这两图之间的一个同构。"
        },
        {
            "type": "image",
            "bbox": [
                0.137,
                0.321,
                0.303,
                0.422
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.212,
                0.428,
                0.228,
                0.439
            ],
            "angle": 0,
            "content": "G"
        },
        {
            "type": "image",
            "bbox": [
                0.329,
                0.322,
                0.493,
                0.422
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.405,
                0.428,
                0.421,
                0.439
            ],
            "angle": 0,
            "content": "H"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.445,
                0.739,
                0.46
            ],
            "angle": 0,
            "content": "22. 运用通路要么证明这两个图不是同构的，要么找出这两图之间的一个同构。"
        },
        {
            "type": "image",
            "bbox": [
                0.136,
                0.464,
                0.301,
                0.566
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.212,
                0.573,
                0.228,
                0.583
            ],
            "angle": 0,
            "content": "G"
        },
        {
            "type": "image",
            "bbox": [
                0.329,
                0.464,
                0.493,
                0.566
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.405,
                0.573,
                0.421,
                0.583
            ],
            "angle": 0,
            "content": "H"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.588,
                0.74,
                0.603
            ],
            "angle": 0,
            "content": "23. 运用通路要么证明这两个图不是同构的，要么找出这两图之间的一个同构。"
        },
        {
            "type": "image",
            "bbox": [
                0.137,
                0.608,
                0.275,
                0.701
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.182,
                0.709,
                0.197,
                0.719
            ],
            "angle": 0,
            "content": "G"
        },
        {
            "type": "image",
            "bbox": [
                0.325,
                0.608,
                0.469,
                0.701
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.389,
                0.709,
                0.405,
                0.719
            ],
            "angle": 0,
            "content": "H"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.726,
                0.825,
                0.74
            ],
            "angle": 0,
            "content": "24. 对练习19中的 \\(n\\) 值来说，求出 \\(K_{3,3}\\) 中任意两个相邻顶点之间长度为 \\(n\\) 的通路的数目。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.744,
                0.842,
                0.758
            ],
            "angle": 0,
            "content": "25. 对练习19中的 \\(n\\) 值来说，求出 \\(K_{3,3}\\) 中任意两个不相邻顶点之间长度为 \\(n\\) 的通路的数目。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.762,
                0.573,
                0.775
            ],
            "angle": 0,
            "content": "26. 求出在图1中 \\(c\\) 和 \\(d\\) 之间具有如下长度的通路的数目："
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.78,
                0.167,
                0.792
            ],
            "angle": 0,
            "content": "a)2"
        },
        {
            "type": "text",
            "bbox": [
                0.33,
                0.78,
                0.361,
                0.792
            ],
            "angle": 0,
            "content": "b)3"
        },
        {
            "type": "text",
            "bbox": [
                0.507,
                0.78,
                0.535,
                0.792
            ],
            "angle": 0,
            "content": "c)4"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.797,
                0.167,
                0.809
            ],
            "angle": 0,
            "content": "d)5"
        },
        {
            "type": "text",
            "bbox": [
                0.331,
                0.797,
                0.359,
                0.809
            ],
            "angle": 0,
            "content": "e)6"
        },
        {
            "type": "text",
            "bbox": [
                0.507,
                0.797,
                0.534,
                0.809
            ],
            "angle": 0,
            "content": "f)7"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.815,
                0.664,
                0.829
            ],
            "angle": 0,
            "content": "27. 求出在练习 2 里的有向图中从 \\(a\\) 到 \\(e\\) 具有如下长度的通路的数目："
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.833,
                0.167,
                0.846
            ],
            "angle": 0,
            "content": "a)2"
        },
        {
            "type": "text",
            "bbox": [
                0.331,
                0.833,
                0.361,
                0.845
            ],
            "angle": 0,
            "content": "b)3"
        },
        {
            "type": "text",
            "bbox": [
                0.507,
                0.833,
                0.535,
                0.845
            ],
            "angle": 0,
            "content": "c)4"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.851,
                0.167,
                0.862
            ],
            "angle": 0,
            "content": "d)5"
        },
        {
            "type": "text",
            "bbox": [
                0.331,
                0.851,
                0.359,
                0.862
            ],
            "angle": 0,
            "content": "e)6"
        },
        {
            "type": "text",
            "bbox": [
                0.507,
                0.851,
                0.534,
                0.863
            ],
            "angle": 0,
            "content": "f)7"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.868,
                0.546,
                0.882
            ],
            "angle": 0,
            "content": "* 28. 证明：带有 \\( n \\) 个顶点的连通图至少具有 \\( n - 1 \\) 条边。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.886,
                0.948,
                0.918
            ],
            "angle": 0,
            "content": "29. 设 \\(G = (V, E)\\) 是简单图。设 \\(R\\) 是 \\(V\\) 上的关系，它是由顶点对 \\((u, v)\\) 所组成的，使得存在从 \\(u\\) 到 \\(v\\) 的通路或使得 \\(u = v\\) 。证明：\\(R\\) 是等价关系。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.922,
                0.851,
                0.936
            ],
            "angle": 0,
            "content": "* 30. 证明：在任何简单图中，任何度为奇数的顶点都与其他某些度为奇数的顶点之间有通路。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.766,
                0.038,
                0.87,
                0.052
            ],
            "angle": 0,
            "content": "图 609"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.094,
                0.389,
                0.108
            ],
            "angle": 0,
            "content": "在练习 \\(31\\sim 33\\) 中，求所给图的所有割点。"
        },
        {
            "type": "image",
            "bbox": [
                0.055,
                0.112,
                0.252,
                0.192
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.296,
                0.112,
                0.51,
                0.187
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.56,
                0.112,
                0.837,
                0.24
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.243,
                0.348,
                0.257
            ],
            "angle": 0,
            "content": "34. 求练习 \\(31 \\sim 33\\) 中图的所有割边。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.261,
                0.631,
                0.274
            ],
            "angle": 0,
            "content": "* 35. 假设 \\( v \\) 是一条割边的端点。证明: \\( v \\) 是割点当且仅当它不是悬挂点。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.279,
                0.9,
                0.311
            ],
            "angle": 0,
            "content": "* 36. 证明：在连通简单图 \\(G\\) 中，顶点 \\(c\\) 是割点当且仅当存在着与 \\(c\\) 不同的顶点 \\(u\\) 和 \\(v\\)，并且在 \\(u\\) 和 \\(v\\) 之间的每一条通路都经过 \\(c\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.315,
                0.617,
                0.328
            ],
            "angle": 0,
            "content": "* 37. 证明：在至少有 2 个顶点的简单图中，至少有 2 个顶点不是割点。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.333,
                0.709,
                0.346
            ],
            "angle": 0,
            "content": "* 38. 证明：简单图中的一条边是割边，当且仅当它不属于该图任何一条简单回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.351,
                0.901,
                0.383
            ],
            "angle": 0,
            "content": "39. 若网络中的通信链路故障会导致不能传送某些消息，则应当提供备份链路。对下面a和b所示的通信网络来说，确定哪些链路应该有备份链路。"
        },
        {
            "type": "image",
            "bbox": [
                0.086,
                0.387,
                0.513,
                0.482
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.087,
                0.485,
                0.483,
                0.616
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.62,
                0.901,
                0.652
            ],
            "angle": 0,
            "content": "有向图 \\(G\\) 的顶点基是 \\(G\\) 的最小顶点的集合 \\(B\\) ，使得对于 \\(G\\) 中任何一个不在 \\(B\\) 中的顶点 \\(\\mathcal{V}\\) ，都有从 \\(B\\) 中的一个顶点到 \\(\\mathcal{V}\\) 的一条通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.656,
                0.507,
                0.669
            ],
            "angle": 0,
            "content": "40. 对10.2节练习 \\(7\\sim 9\\) 中的每个有向图，求其顶点基。"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.674,
                0.812,
                0.687
            ],
            "angle": 0,
            "content": "41. 在影响图（在 10.1 节例 2 中描述）中顶点基的重要性是什么？找出该例中影响图的顶点基。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.692,
                0.775,
                0.705
            ],
            "angle": 0,
            "content": "42. 证明：若连通简单图 \\(G\\) 是图 \\(G_{1}\\) 和 \\(G_{2}\\) 的并图，则 \\(G_{1}\\) 和 \\(G_{2}\\) 至少具有1个公共的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.71,
                0.901,
                0.741
            ],
            "angle": 0,
            "content": "* 43. 证明：若简单图 \\(G\\) 有 \\(k\\) 个连通分支，而且这些分支分别具有 \\(n_1, n_2, \\dots, n_k\\) 个顶点，则 \\(G\\) 的边数不超过"
        },
        {
            "type": "equation",
            "bbox": [
                0.449,
                0.746,
                0.54,
                0.778
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {i = 1} ^ {k} C \\left(n _ {i}, 2\\right)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.781,
                0.901,
                0.812
            ],
            "angle": 0,
            "content": "* 44. 用练习 43 证明：带有 \\( n \\) 个顶点和 \\( k \\) 个连通分支的简单图最多有 \\( (n - k)(n - k + 1) / 2 \\) 条边。[提示：首先证明"
        },
        {
            "type": "equation",
            "bbox": [
                0.375,
                0.816,
                0.619,
                0.849
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {i = 1} ^ {k} n _ {i} ^ {2} \\leqslant n ^ {2} - (k - 1) (2 n - k)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.851,
                0.392,
                0.865
            ],
            "angle": 0,
            "content": "其中 \\(n_i\\) 是第 \\(i\\) 个连通分支的顶点数。]"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.869,
                0.756,
                0.883
            ],
            "angle": 0,
            "content": "* 45. 证明：若带有 \\( n \\) 个顶点的简单图 \\( G \\) 具有超过 \\( (n - 1)(n - 2) / 2 \\) 条边，则它是连通的。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.888,
                0.901,
                0.919
            ],
            "angle": 0,
            "content": "46. 当把图中的顶点都列出来，且每个连通分支中的顶点都连续地列出时，描述带有 \\( n \\) 个连通分支的图的邻接矩阵。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.923,
                0.639,
                0.937
            ],
            "angle": 0,
            "content": "47. 当 \\( n \\) 取如下值时，存在多少个不同构的带有 \\( n \\) 个顶点的连通简单图？"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.123,
                0.038,
                0.159,
                0.051
            ],
            "angle": 0,
            "content": "610"
        },
        {
            "type": "header",
            "bbox": [
                0.205,
                0.036,
                0.28,
                0.052
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.094,
                0.158,
                0.106
            ],
            "angle": 0,
            "content": "a)2"
        },
        {
            "type": "text",
            "bbox": [
                0.321,
                0.094,
                0.351,
                0.106
            ],
            "angle": 0,
            "content": "b)3"
        },
        {
            "type": "text",
            "bbox": [
                0.497,
                0.094,
                0.525,
                0.106
            ],
            "angle": 0,
            "content": "c)4"
        },
        {
            "type": "text",
            "bbox": [
                0.671,
                0.094,
                0.701,
                0.106
            ],
            "angle": 0,
            "content": "d)5"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.111,
                0.343,
                0.125
            ],
            "angle": 0,
            "content": "48. 证明下列各图都没有割点。"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.13,
                0.231,
                0.143
            ],
            "angle": 0,
            "content": "a) \\(C_n\\) ， \\(n\\geqslant 3\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.497,
                0.13,
                0.605,
                0.143
            ],
            "angle": 0,
            "content": "b) \\(W_{n}\\) ， \\(n\\geqslant 3\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.148,
                0.316,
                0.161
            ],
            "angle": 0,
            "content": "c) \\(K_{m,n}\\)，\\(m \\geqslant 2\\) 和 \\(n \\geqslant 2\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.497,
                0.149,
                0.602,
                0.161
            ],
            "angle": 0,
            "content": "d) \\(Q_{n}\\) ， \\(n\\geqslant 2\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.165,
                0.427,
                0.179
            ],
            "angle": 0,
            "content": "49. 证明练习48中的每个图都没有割边。"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.183,
                0.941,
                0.203
            ],
            "angle": 0,
            "content": "50. 对下列各图，求 \\(\\kappa(G)\\)、\\(\\lambda(G)\\) 和 \\(\\min_{v \\in V} \\deg(v)\\)，并判断 \\(\\kappa(G) \\leqslant \\lambda(G) \\leqslant \\min_{v \\in V} \\deg(v)\\) 中的两个不等式哪个更严格。"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.207,
                0.146,
                0.219
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "image",
            "bbox": [
                0.152,
                0.207,
                0.324,
                0.277
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.497,
                0.207,
                0.517,
                0.219
            ],
            "angle": 0,
            "content": "b）"
        },
        {
            "type": "image",
            "bbox": [
                0.524,
                0.206,
                0.778,
                0.28
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.292,
                0.146,
                0.303
            ],
            "angle": 0,
            "content": "c）"
        },
        {
            "type": "image",
            "bbox": [
                0.153,
                0.288,
                0.314,
                0.39
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.507,
                0.292,
                0.527,
                0.303
            ],
            "angle": 0,
            "content": "d）"
        },
        {
            "type": "image",
            "bbox": [
                0.532,
                0.291,
                0.648,
                0.376
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.396,
                0.816,
                0.411
            ],
            "angle": 0,
            "content": "51. 证明：若 \\(G\\) 是连通图，则有可能删除顶点使 \\(G\\) 变成不连通的当且仅当 \\(G\\) 不是完全图。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.414,
                0.469,
                0.428
            ],
            "angle": 0,
            "content": "52. 证明：若 \\(G\\) 是含有 \\(n\\) 个顶点的连通图，则"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.432,
                0.39,
                0.446
            ],
            "angle": 0,
            "content": "a) \\(\\kappa (G) = n - 1\\) 当且仅当 \\(G = K_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.45,
                0.39,
                0.464
            ],
            "angle": 0,
            "content": "b) \\(\\lambda (G) = n - 1\\) 当且仅当 \\(G = K_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.468,
                0.488,
                0.482
            ],
            "angle": 0,
            "content": "53. 求 \\(\\kappa(K_{m,n})\\) 和 \\(\\lambda(K_{m,n})\\)，其中 \\(m, n\\) 是正整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.486,
                0.579,
                0.506
            ],
            "angle": 0,
            "content": "54.构造一个图，使得 \\(\\kappa (G) = 1\\) ， \\(\\lambda (G) = 2\\) 和min \\(\\deg (v) = 3\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.508,
                0.444,
                0.522
            ],
            "angle": 0,
            "content": "* 55. 证明：若 \\(G\\) 是一个图。则 \\(\\kappa(G) < \\lambda(G)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.526,
                0.644,
                0.54
            ],
            "angle": 0,
            "content": "56. 解释如何用定理2求图中从顶点 \\( v \\) 到顶点 \\( w \\) 的最短通路的长度。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.544,
                0.513,
                0.558
            ],
            "angle": 0,
            "content": "57. 用定理2求图1中从 \\(a\\) 到 \\(f\\) 的最短通路的长度。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.562,
                0.601,
                0.576
            ],
            "angle": 0,
            "content": "58. 用定理2求练习2中的有向图从 \\(a\\) 到 \\(c\\) 的最短通路的长度。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.579,
                0.941,
                0.611
            ],
            "angle": 0,
            "content": "59. 设 \\(P_{1}\\) 和 \\(P_{2}\\) 是简单图 \\(G\\) 中顶点 \\(u\\) 和 \\(v\\) 之间的没有相同边集的两条简单通路。证明：在 \\(G\\) 中存在简单回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.615,
                0.824,
                0.629
            ],
            "angle": 0,
            "content": "60. 证明：长度为 \\(k\\) 的简单回路的存在性是一个图同构不变量，其中 \\(k\\) 是大于2的正整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.633,
                0.456,
                0.648
            ],
            "angle": 0,
            "content": "61. 解释如何用定理2判定图是否是连通的。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.651,
                0.634,
                0.665
            ],
            "angle": 0,
            "content": "62. 用练习61证明：图2中的图 \\(G_{1}\\) 是连通的而图 \\(G_{2}\\) 不是连通的。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.669,
                0.665,
                0.683
            ],
            "angle": 0,
            "content": "63. 证明：简单图 \\(G\\) 是二分图，当且仅当 \\(G\\) 没有包含奇数条边的回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.687,
                0.945,
                0.773
            ],
            "angle": 0,
            "content": "64. 在约克阿尔昆(735—804)提出的一个古老智力游戏中，一位农夫需要将一匹狼、一只山羊和一棵白菜带过河。农夫只有一只小船，小船每次只能载农夫和一件物品（一个动物或者一棵蔬菜）。农夫可以重复渡河，但如果农夫在河的另一边，那么狼会吃羊，类似地，羊会吃白菜。可以通过列出两岸各有什么来描述问题的每个状态。例如，可以用有序对(FG, WC)表示农夫和羊在一岸，而狼和白菜在另一岸的状态。[可用符号 \\(\\varnothing\\) 表示某边岸上什么也没有，这样问题的初始状态就是(FGWC, \\(\\varnothing\\))。]"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.776,
                0.941,
                0.809
            ],
            "angle": 0,
            "content": "a)找出这个游戏所有的允许状态，其中不能出现在没有农夫的情况下，让狼和羊，或者羊和白菜在同一岸上。"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.812,
                0.942,
                0.845
            ],
            "angle": 0,
            "content": "b)构造一个图，使得图中的每一个顶点表示一个允许的状态，如果可以通过一次船的运输从一个状态转换到另一个状态，那么相应的顶点之间用一条边相连。"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.848,
                0.942,
                0.881
            ],
            "angle": 0,
            "content": "e)解释为什么找到一条从表示(FGWC， \\(\\varnothing\\) )状态的顶点到表示 \\((\\emptyset ,FGWC)\\) 状态的顶点的通路，就能解决这个问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.885,
                0.586,
                0.899
            ],
            "angle": 0,
            "content": "d)找出这个游戏的两个不同解，每个解都使用7次渡河。"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.902,
                0.936,
                0.917
            ],
            "angle": 0,
            "content": "e)假设每次农夫携带一个动物过河都要付1元的过路费，那么农夫应当采用哪一个解以使过路费最少。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.92,
                0.944,
                0.935
            ],
            "angle": 0,
            "content": "* 65. 参考练习 64，运用图模型和图中的通路，求解吃醋丈夫问题。两对已婚夫妇想要过河，他们只能找"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.765,
                0.037,
                0.87,
                0.052
            ],
            "angle": 0,
            "content": "图 611"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.092,
                0.899,
                0.125
            ],
            "angle": 0,
            "content": "到一艘小船，小船一次只能运送一个或者两个人到对岸。每个丈夫都非常爱吃醋，不愿让自己的妻子和另外一位男士单独在船上或在岸上。这4个人要怎么做才能到达对岸？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.128,
                0.9,
                0.197
            ],
            "angle": 0,
            "content": "66. 假设你有一个3加仑的壶和一个5加仑的壶，可以用水将它们灌满。你可以倒空任何一个壶，也可以把水从一个壶倒往另一个壶。运用一个有向图模型来说明，你可以最终使一个壶里恰好装1加仑的水。[提示：用有序对 \\((a, b)\\) 表示每个壶里有多少水，然后用顶点来表示这个有序对。对可行的操作，在顶点之间添加相对应的边。]"
        },
        {
            "type": "title",
            "bbox": [
                0.055,
                0.21,
                0.4,
                0.23
            ],
            "angle": 0,
            "content": "10.5 欧拉通路与哈密顿通路"
        },
        {
            "type": "title",
            "bbox": [
                0.055,
                0.237,
                0.189,
                0.256
            ],
            "angle": 0,
            "content": "10.5.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.258,
                0.902,
                0.39
            ],
            "angle": 0,
            "content": "能否从一个顶点出发沿着图的边前进，恰好经过图的每条边一次并且回到这个顶点？同样，能否从一个顶点出发沿着图的边前进，恰好经过图的每个顶点一次并且回到这个顶点？虽然这两个问题有相似之处，但是对于所有的图来说，通过检查图中顶点的度，可以轻而易举地回答第一个关于是否具有欧拉回路(Euler Circuit)的问题，却非常难以解决第二个关于是否具有哈密顿回路(Hamilton Circuit)的问题。本节将研究这些问题并讨论求解这些问题的难点。虽然这两个问题在许多不同领域里都有实际应用，但是都来源于古老的智力题。下面将介绍这些古老的智力题以及现代的实际应用。"
        },
        {
            "type": "title",
            "bbox": [
                0.055,
                0.4,
                0.349,
                0.417
            ],
            "angle": 0,
            "content": "10.5.2 欧拉通路与欧拉回路"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.42,
                0.902,
                0.495
            ],
            "angle": 0,
            "content": "普鲁士的哥尼斯堡镇（现名为加里宁格勒，属于俄罗斯共和国）被普雷格尔河支流分成四部分。这四部分包括普雷格尔河两岸的两个区域、克奈普霍夫岛河中心岛以及普雷格尔河两条支流之间的部分区域。在18世纪，7座桥将这些区域连接起来。图1描述了这些区域和桥。"
        },
        {
            "type": "image",
            "bbox": [
                0.231,
                0.5,
                0.725,
                0.65
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.375,
                0.654,
                0.58,
                0.67
            ],
            "angle": 0,
            "content": "图1 哥尼斯堡的7座桥"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.675,
                0.616,
                0.731
            ],
            "angle": 0,
            "content": "镇上的人们在周日穿过镇子进行长距离的散步。他们想弄明白是否可能从镇里的某个位置出发不重复地经过所有桥并且返回出发点。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.733,
                0.616,
                0.807
            ],
            "angle": 0,
            "content": "瑞士数学家列昂哈德·欧拉解决了这个问题。他的解答发表在1736年，这也许是人们第一次使用图论（关于欧拉原始论文的译稿，参见[BiLlWi99]）。欧拉利用多重图来研究这个问题，其中用顶点表示这四部分，用边表示桥，如图2所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.809,
                0.616,
                0.864
            ],
            "angle": 0,
            "content": "不重复地经过每一座桥来旅行的问题可以利用这个模型来重新叙述。问题变成：在这个多重图中是否存在着包含每一条边的简单回路？"
        },
        {
            "type": "image",
            "bbox": [
                0.693,
                0.677,
                0.822,
                0.819
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.628,
                0.823,
                0.887,
                0.839
            ],
            "angle": 0,
            "content": "图2 哥尼斯堡镇的多重图模型"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.872,
                0.892,
                0.909
            ],
            "angle": 0,
            "content": "定义1 图 \\(G\\) 中的欧拉回路是包含 \\(G\\) 的每一条边的简单回路。图 \\(G\\) 中的欧拉通路是包含 \\(G\\) 的每一条边的简单通路。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.126,
                0.037,
                0.164,
                0.05
            ],
            "angle": 0,
            "content": "612"
        },
        {
            "type": "header",
            "bbox": [
                0.208,
                0.036,
                0.284,
                0.051
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.092,
                0.564,
                0.108
            ],
            "angle": 0,
            "content": "例1和例2解释了欧拉回路和欧拉通路的概念。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.114,
                0.945,
                0.153
            ],
            "angle": 0,
            "content": "例1 在图3中，哪些无向图有欧拉回路？在没有欧拉回路的那些图中，哪些具有欧拉通路？"
        },
        {
            "type": "image",
            "bbox": [
                0.248,
                0.158,
                0.371,
                0.256
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.297,
                0.264,
                0.321,
                0.279
            ],
            "angle": 0,
            "content": "\\(G_{1}\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.414,
                0.159,
                0.535,
                0.255
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.464,
                0.265,
                0.487,
                0.279
            ],
            "angle": 0,
            "content": "\\(G_{2}\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.578,
                0.159,
                0.797,
                0.255
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.679,
                0.266,
                0.701,
                0.278
            ],
            "angle": 0,
            "content": "G3"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.411,
                0.284,
                0.635,
                0.3
            ],
            "angle": 0,
            "content": "图3 无向图 \\(G_{1}\\) 、 \\(G_{2}\\) 和 \\(G_{3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.306,
                0.945,
                0.361
            ],
            "angle": 0,
            "content": "解图 \\(G_{1}\\) 具有欧拉回路，例如 \\(a\\) ， \\(e\\) ， \\(c\\) ， \\(d\\) ， \\(e\\) ， \\(b\\) ， \\(a\\) 。 \\(G_{2}\\) 和 \\(G_{3}\\) 都没有欧拉回路（读者应当验证它）。但是 \\(G_{3}\\) 具有欧拉通路，即 \\(a\\) ， \\(c\\) ， \\(d\\) ， \\(e\\) ， \\(b\\) ， \\(d\\) ， \\(a\\) ， \\(b\\) 。 \\(G_{2}\\) 没有欧拉通路（读者应当验证它）。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.366,
                0.945,
                0.404
            ],
            "angle": 0,
            "content": "例2 在图4中，哪些有向图有欧拉回路？在没有欧拉回路的那些图中，哪些具有欧拉通路？"
        },
        {
            "type": "image",
            "bbox": [
                0.316,
                0.411,
                0.414,
                0.504
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.352,
                0.513,
                0.374,
                0.526
            ],
            "angle": 0,
            "content": "H"
        },
        {
            "type": "image",
            "bbox": [
                0.438,
                0.411,
                0.613,
                0.509
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.515,
                0.513,
                0.537,
                0.525
            ],
            "angle": 0,
            "content": "\\(H_{2}\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.635,
                0.422,
                0.73,
                0.503
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.675,
                0.513,
                0.696,
                0.525
            ],
            "angle": 0,
            "content": "\\(H_{3}\\)"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.405,
                0.534,
                0.642,
                0.549
            ],
            "angle": 0,
            "content": "图4有向图 \\(H_{1}\\) ， \\(H_{2}\\) 和 \\(H_{3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.553,
                0.945,
                0.607
            ],
            "angle": 0,
            "content": "解图 \\(H_{2}\\) 有欧拉回路，例如 \\(a\\) ， \\(g\\) ， \\(c\\) ， \\(b\\) ， \\(g\\) ， \\(e\\) ， \\(d\\) ， \\(f\\) ， \\(a\\) 。 \\(H_{1}\\) 和 \\(H_{3}\\) 都没有欧拉回路（读者应当验证它）。 \\(H_{3}\\) 具有欧拉通路，即 \\(c\\) ， \\(a\\) ， \\(b\\) ， \\(c\\) ， \\(d\\) ， \\(b\\) ，但是 \\(H_{1}\\) 没有欧拉通路（读者应当验证它）。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.611,
                0.945,
                0.664
            ],
            "angle": 0,
            "content": "欧拉回路和欧拉通路的充要条件对判断多重图是否有欧拉回路和欧拉通路，存在着简单的标准。欧拉在解决著名的哥尼斯堡七桥问题时发现了它们。假设在本节讨论的所有图都有有穷个顶点和边。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.668,
                0.946,
                0.819
            ],
            "angle": 0,
            "content": "若一个连通多重图有欧拉回路，则它有什么性质呢？可以说明的是，每一个顶点都必有偶数条边。为此，首先注意一条欧拉回路从顶点 \\(a\\) 开始，接着是 \\(a\\) 关联的一条边，比方说 \\(\\{a, b\\}\\) 。边 \\(\\{a, b\\}\\) 为 \\(\\deg(a)\\) 贡献1度。这条回路每经过一个顶点就为该顶点的度贡献2度，因为这条回路从关联该顶点的一条边进入，又经过另一条这样的边离开该顶点。最后，这条回路在它开始的地方结束，为 \\(\\deg(a)\\) 贡献1度。因此 \\(\\deg(a)\\) 必为偶数，因为当回路开始时它贡献1度，当回路结束时它贡献1度，每次经过 \\(a\\) 都贡献2度（如果它又经过了 \\(a\\)）。除了 \\(a\\) 以外，其余顶点都有偶数度，因为每次回路经过一个顶点就为该顶点的度贡献2度。由此得出结论，若连通图有欧拉回路，则每一个顶点必有偶数度。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.821,
                0.945,
                0.857
            ],
            "angle": 0,
            "content": "欧拉回路存在性的这个必要条件是否也是充分的？即若在连通多重图中的所有顶点都有偶数度，则是否必有欧拉回路？这个问题可以通过构造来解决。"
        },
        {
            "type": "image",
            "bbox": [
                0.055,
                0.879,
                0.086,
                0.904
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.86,
                0.946,
                0.935
            ],
            "angle": 0,
            "content": "假设 \\(G\\) 是连通多重图且 \\(G\\) 的每一个顶点的度都是偶数。一条边一条边地构造从 \\(G\\) 的任意顶点 \\(a\\) 开始的简单回路。设 \\(x_0 = a\\) 。首先任意地选择一条关联 \\(a\\) 的边 \\(\\{x_0, x_1\\}\\)，因为 \\(G\\) 是连通的，所以这是可行的。通过一条一条地增加边来继续构造，建立尽量长的简单通路 \\(\\{x_0, x_1\\}, \\{x_1, x_2\\}, \\dots, \\{x_{n-1}, x_n\\}\\)，直到不能再向这条通路中增加边。当我们到达一个顶点，并且在"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.763,
                0.04,
                0.868,
                0.055
            ],
            "angle": 0,
            "content": "图 613"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.095,
                0.899,
                0.113
            ],
            "angle": 0,
            "content": "通路中已包含所有与该顶点相关联的边时，就会出现这种情况。例如，在图5的图 \\(G\\) 中，从 \\(a\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.116,
                0.492,
                0.149
            ],
            "angle": 0,
            "content": "开始且连续地选择边 \\(\\{a, f\\}\\) 、 \\(\\{f, c\\}\\) 、 \\(\\{c, b\\}\\) 和 \\(\\{b, a\\}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.153,
                0.495,
                0.303
            ],
            "angle": 0,
            "content": "这样的通路必然会结束，因为图的边数是有穷的，所以我们最终一定能到达一个顶点，对于该点，再也没有边可以增加到这条通路中。该通路在 \\(a\\) 上以形如 \\(\\{a, x\\}\\) 的边开始，现在证明其必然在 \\(a\\) 上以形如 \\(\\{y, a\\}\\) 的边结束。为了说明该通路一定结束于 \\(a\\) ，注意通路每经过一个度为偶数的顶点时，它只用1条边进入这个顶点，因为度数至少为2，所以通路中至少还剩下1条边离开"
        },
        {
            "type": "image",
            "bbox": [
                0.508,
                0.118,
                0.902,
                0.276
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.592,
                0.283,
                0.816,
                0.299
            ],
            "angle": 0,
            "content": "图5构造 \\(G\\) 中的欧拉回路"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.307,
                0.899,
                0.383
            ],
            "angle": 0,
            "content": "这个顶点。而且，每次进入和离开一个度数为偶数的顶点时，还有偶数条没在通路中的边与该点相关联。同时，在我们构造通路时，每次我们进入一个不同于 \\(a\\) 的顶点时，都可以从该点离开。这意味着，该通路只能结束于 \\(a\\) 。另外注意，我们构造的这条通路可能用完了所有的边或者当我们在用完所有的边之前回到了顶点 \\(a\\) ，也可能没用完所有的边。"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.385,
                0.9,
                0.441
            ],
            "angle": 0,
            "content": "若所有的边都已经用完，则欧拉回路已经构造好了。否则，考虑通过从 \\(G\\) 里删除已经用过的边和不关联任何剩余边的顶点所得到的子图 \\(H\\) 。当从图5的图中删除回路 \\(a, f, c, b, a\\) 时，就得到标记为 \\(H\\) 的子图。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.443,
                0.9,
                0.479
            ],
            "angle": 0,
            "content": "因为 \\(G\\) 是连通的，所以 \\(H\\) 与已经删除的回路至少有1个公共顶点。设 \\(\\omega\\) 是这样的顶点（此例中 \\(c\\) 是这个顶点）。"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.482,
                0.901,
                0.596
            ],
            "angle": 0,
            "content": "\\(H\\) 中的每一个顶点的度都是偶数。（因为 \\(G\\) 中的所有顶点的度都是偶数，对每个顶点来说，与这个顶点相关联的边都成对地删除了，以便形成 \\(H\\)。）注意 \\(H\\) 可能是不连通的。像在 \\(G\\) 中做过的那样，从 \\(\\varpi\\) 开始，通过尽可能地选择边来构造 \\(H\\) 的简单通路。这条通路必然在 \\(\\varpi\\) 结束。例如，在图5中，\\(c, d, e, c\\) 是 \\(H\\) 中的通路。下一步通过把 \\(H\\) 中的回路与 \\(G\\) 中原来的回路拼接起来形成 \\(G\\) 中的回路（这是可行的，因为 \\(\\varpi\\) 是这个回路的顶点之一）。当在图5的图中这样做时，就得到回路 \\(a, f, c, d, e, c, b, a\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.598,
                0.9,
                0.636
            ],
            "angle": 0,
            "content": "继续进行这个过程，直到已经用完了所有的边为止（这个过程必然结束，因为图中只有有穷的边数）。这样就产生了欧拉回路。这样的构造说明，若连通多重图的顶点的度都为偶数，"
        },
        {
            "type": "title",
            "bbox": [
                0.053,
                0.644,
                0.121,
                0.664
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.055,
                0.678,
                0.197,
                0.789
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.053,
                0.793,
                0.2,
                0.812
            ],
            "angle": 0,
            "content": "\\(\\odot\\) INTERFOTO/Alamy Stock Photo"
        },
        {
            "type": "text",
            "bbox": [
                0.212,
                0.677,
                0.901,
                0.799
            ],
            "angle": 0,
            "content": "列昂哈德·欧拉（Leonhard Euler，1707—1783）欧拉是瑞士巴塞尔附近一位加尔文教派牧师之子。他13岁进入巴塞尔大学，遵照父亲的意愿开始了他的神学生涯。在大学里，欧拉受到著名的伯努利家族中的数学家约翰·伯努利的指导。在他的指导下，欧拉发现了对数学浓厚的兴趣并熟练掌握了许多技巧，这使他放弃神学继而转向数学研究。欧拉16岁时取得了哲学硕士学位。1727年，彼得大帝邀请他来圣彼得堡学院学习。1741年，他来到柏林学院，在这里待了二十余年。直到1766年，他重新回到圣彼得堡，并在那里度过余生。"
        },
        {
            "type": "text",
            "bbox": [
                0.249,
                0.802,
                0.901,
                0.816
            ],
            "angle": 0,
            "content": "欧拉的一生硕果累累，在数学的许多领域都做出了贡献，包括数论、组合以及"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.818,
                0.901,
                0.941
            ],
            "angle": 0,
            "content": "分析，这些成果在音乐和造船学上也得到了应用。由他编写的书籍和论文多达1100余篇，仅他生前未来得及发表的著作就不计其数，以至于在他去世之后，用了47年才发表完他的全部著作。他写文章非常快，在世时总有一大摞文章等待发表。柏林学院总是先发表这一大摞最顶上的文章，以至于后来的研究的结果常常先于它们所依赖或取代的结果而发表。欧拉有13个孩子，当一两个孩子在他膝上玩耍时，他照样能够工作。在他生命最后的17年里，他失明了。但他本着惊人的记忆力，失明并没有影响他数学研究成果的推出。他著作全集的出版工作由瑞士自然科学协会负责，目前还在进行之中，预期将超过75卷。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.124,
                0.041,
                0.159,
                0.055
            ],
            "angle": 0,
            "content": "614"
        },
        {
            "type": "header",
            "bbox": [
                0.205,
                0.04,
                0.281,
                0.055
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.097,
                0.294,
                0.113
            ],
            "angle": 0,
            "content": "则该图具有欧拉回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.116,
                0.37,
                0.132
            ],
            "angle": 0,
            "content": "把这些结果总结成定理1。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.141,
                0.919,
                0.158
            ],
            "angle": 0,
            "content": "定理1 含有至少2个顶点的连通多重图具有欧拉回路当且仅当它的每个顶点的度都为偶数。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.167,
                0.941,
                0.221
            ],
            "angle": 0,
            "content": "现在可以解决哥尼斯堡七桥问题了。因为图2所示的表示这些桥的多重图具有4个度为奇数的顶点，所以它没有欧拉回路。从给定点开始，恰好经过每座桥一次并返回开始点的想法是无法实现的。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.224,
                0.942,
                0.28
            ],
            "angle": 0,
            "content": "算法1给出了在定理1之前所讨论的求欧拉回路的构造过程（因为这个过程中的回路是任意选择的，所以存在一些不确定性。我们不介意通过更精确地说明过程的步骤来消除这些不确定性）。"
        },
        {
            "type": "title",
            "bbox": [
                0.11,
                0.3,
                0.296,
                0.316
            ],
            "angle": 0,
            "content": "算法1 构造欧拉回路"
        },
        {
            "type": "code",
            "bbox": [
                0.109,
                0.318,
                0.767,
                0.457
            ],
            "angle": 0,
            "content": "procedure Euler(G：所有顶点的度都为偶数的连通多重图）  \ncircuit \\(\\coloneqq\\) 从 \\(G\\) 中任选的顶点开始，连续地加入边所形成的回到该顶点的回路  \n\\(H\\coloneqq\\) 删除这条回路的边之后的 \\(G\\)   \nwhile \\(H\\) 还有边subcircuit \\(\\coloneqq\\) 在既是 \\(H\\) 的顶点也是circuit的边的端点处开始的 \\(H\\) 的一条回路\\(H\\coloneqq\\) 删除subcircuit的边和所有孤立点之后的 \\(H\\) circuit \\(\\coloneqq\\) 在适当顶点上插入subcircuit之后的circuit  \nreturn circuit{circuit是欧拉回路}"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.482,
                0.941,
                0.518
            ],
            "angle": 0,
            "content": "算法1提供了一个在所有顶点的度都为偶数的连通多重图 \\(G\\) 中寻找欧拉回路的有效算法。我们留给读者证明(练习66)这个算法的最坏情形时间复杂度是 \\(O(m)\\)，其中 \\(m\\) 是 \\(G\\) 中的边数。"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.521,
                0.725,
                0.537
            ],
            "angle": 0,
            "content": "例3说明如何利用欧拉通路和欧拉回路来解决一种类型的智力题。"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.542,
                0.942,
                0.559
            ],
            "angle": 0,
            "content": "例3有许多智力题要求用铅笔连续移动，不离开纸面并且不重复地画出图形。可以利用"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.564,
                0.663,
                0.618
            ],
            "angle": 0,
            "content": "欧拉回路和欧拉通路来解决这样的智力题。例如，能否用这样的方法画出图6所示的穆罕默德短弯刀？其中，该画法在图形的同一个顶点上开始和结束。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.621,
                0.663,
                0.714
            ],
            "angle": 0,
            "content": "解可以解决这个问题，因为图6所示的图 \\(G\\) 具有欧拉回路。它具有这样的回路，因为它的所有顶点的度都为偶数。用算法1来构造欧拉回路。首先，形成回路 \\(a, b, d, c, b, e, i, f, e, a\\) 。通过删除这条回路的边并删除因此产生的孤立点，就得到子图 \\(H\\) 。然后形成 \\(H\\) 里的回路 \\(d, g, h, j, i, h, k,\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.677,
                0.568,
                0.947,
                0.678
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.719,
                0.686,
                0.903,
                0.701
            ],
            "angle": 0,
            "content": "图6 穆罕默德短弯刀"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.716,
                0.945,
                0.77
            ],
            "angle": 0,
            "content": "\\(g, f, d\\) 。形成这条回路后就用完了 \\(G\\) 中的所有边。在适当的地方将这条回路与第一条回路拼接，就产生了欧拉回路 \\(a, b, d, g, h, j, i, h, k, g, f, d, c, b, e, i, f, e, a\\) 。这条回路给出了铅笔不离开纸面且不重复地画出弯刀的方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.773,
                0.799,
                0.789
            ],
            "angle": 0,
            "content": "构造欧拉回路的另一个算法称为弗勒里算法，在练习50的前面描述了它。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.792,
                0.945,
                0.883
            ],
            "angle": 0,
            "content": "现在说明连通多重图具有欧拉通路（不是欧拉回路）当且仅当它恰有2个度为奇数的顶点。首先，假设连通多重图有一条从 \\(a\\) 到 \\(b\\) 的欧拉通路，但不是欧拉回路。该通路的第一条边为 \\(a\\) 的度贡献1度。通路每次经过 \\(a\\) 就为 \\(a\\) 的度贡献2度。通路的最后一条边为 \\(b\\) 的度贡献1度。通路每次经过 \\(b\\) 就为 \\(b\\) 的度贡献2度。所以 \\(a\\) 和 \\(b\\) 的度都是奇数。每一个其他顶点都具有偶数度，因为当通路经过一个顶点时，就为这个顶点的度贡献2度。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.886,
                0.945,
                0.941
            ],
            "angle": 0,
            "content": "现在反过来考虑。假设这个图恰有2个度为奇数的顶点，比方说 \\(a\\) 和 \\(b\\) 。考虑由原来的图和边 \\(\\{a, b\\}\\) 所组成的更大的图。这个更大的图的每一个顶点的度都为偶数，所以它具有欧拉回路。删除新边就产生原图的欧拉通路。定理2总结了这些结果。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.771,
                0.038,
                0.875,
                0.051
            ],
            "angle": 0,
            "content": "图 615"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.1,
                0.877,
                0.117
            ],
            "angle": 0,
            "content": "定理2 连通多重图具有欧拉通路但无欧拉回路当且仅当它恰有2个度为奇数的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.128,
                0.455,
                0.146
            ],
            "angle": 0,
            "content": "例4 图7所示的哪些图具有欧拉通路？"
        },
        {
            "type": "image",
            "bbox": [
                0.146,
                0.154,
                0.264,
                0.251
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.192,
                0.255,
                0.214,
                0.267
            ],
            "angle": 0,
            "content": "G"
        },
        {
            "type": "image",
            "bbox": [
                0.306,
                0.153,
                0.621,
                0.251
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.455,
                0.255,
                0.476,
                0.267
            ],
            "angle": 0,
            "content": "\\(G_{2}\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.669,
                0.153,
                0.817,
                0.25
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.734,
                0.255,
                0.754,
                0.266
            ],
            "angle": 0,
            "content": "G3"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.409,
                0.273,
                0.558,
                0.287
            ],
            "angle": 0,
            "content": "图7 三个无向图"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.299,
                0.907,
                0.374
            ],
            "angle": 0,
            "content": "解 \\(G_{1}\\) 恰有2个度为奇数的顶点，即 \\(b\\) 和 \\(d\\) 。因此它具有必须用 \\(b\\) 和 \\(d\\) 作为端点的欧拉通路。一条这样的欧拉通路是 \\(d\\) ， \\(a\\) ， \\(b\\) ， \\(c\\) ， \\(d\\) ， \\(b\\) 。同理， \\(G_{2}\\) 恰有2个度为奇数的顶点，即 \\(b\\) 和 \\(d\\) 。因此它具有必须用 \\(b\\) 和 \\(d\\) 作为端点的欧拉通路。一条这样的欧拉通路是 \\(b\\) ， \\(a\\) ， \\(g\\) ， \\(f\\) ， \\(e\\) ， \\(d\\) ， \\(c\\) ， \\(g\\) ， \\(b\\) ， \\(c\\) ， \\(f\\) ， \\(d\\) 。 \\(G_{3}\\) 没有欧拉通路，因为它具有6个度为奇数的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.377,
                0.907,
                0.432
            ],
            "angle": 0,
            "content": "回到18世纪的哥尼斯堡，是否有可能在镇里的某点开始，旅行经过所有的桥，在镇里的其他某点结束？通过判定表示哥尼斯堡七桥的多重图是否具有欧拉通路，就可以回答这个问题。因为这个多重图有4个度为奇数的顶点，没有欧拉通路，所以这样的旅行是不可能的。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.434,
                0.75,
                0.451
            ],
            "angle": 0,
            "content": "有向图中欧拉通路和欧拉回路的充要条件，在练习16和练习17中给出。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.453,
                0.909,
                0.604
            ],
            "angle": 0,
            "content": "欧拉通路和欧拉回路的应用可以用欧拉通路和欧拉回路解决许多实际问题。例如，许多应用都要求一条通路或回路，它要求恰好一次经过一个街区里的每条街道、一个交通网中的每条道路、一个高压输电网里的每个连接或者一个通信网络里的每条链路。求出适当的图模型中的欧拉通路或欧拉回路就可以解决这样的问题。例如，如果一个邮递员可以求出表示他所负责投递的街道图中的欧拉通路，则这条通路就产生恰好经过每条街道一次的投递路线。如果不存在欧拉通路，有些通路就必须经过多次。在图中找出一条回路，该回路以最少的边数至少遍历每一条边一次的问题称为中国邮递员问题，以纪念在1962年提出这个问题的中国科学家管梅谷。参看[MiRo91]以了解关于不存在欧拉通路时中国邮递员问题的解的更多信息。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.607,
                0.907,
                0.643
            ],
            "angle": 0,
            "content": "应用欧拉通路和欧拉回路的其他领域有：电路布线、网络组播和分子生物学，在分子生物学中欧拉通路用于DNA测序。"
        },
        {
            "type": "title",
            "bbox": [
                0.062,
                0.654,
                0.402,
                0.671
            ],
            "angle": 0,
            "content": "10.5.3 哈密顿通路与哈密顿回路"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.674,
                0.909,
                0.711
            ],
            "angle": 0,
            "content": "包含多重图每一条边恰好一次的通路和回路的存在性的充要条件已经得出。那么包含图中每一个顶点恰好一次的简单通路和回路的存在性的充要条件是否也能得出呢？"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.719,
                0.905,
                0.816
            ],
            "angle": 0,
            "content": "定义2 经过图 \\(G\\) 中每一个顶点恰好一次的简单通路称为哈密顿通路，经过图 \\(G\\) 中每一个顶点恰好一次的简单回路称为哈密顿回路。即，在图 \\(G = (V, E)\\) 中，若 \\(V = \\{x_0, x_1, \\dots, x_{n-1}, x_n\\}\\) 并且对 \\(0 \\leqslant i < j \\leqslant n\\) 来说有 \\(x_i \\neq x_j\\)，则图 \\(G\\) 中的简单通路 \\(x_0, x_1, \\dots, x_{n-1}, x_n\\) 称为哈密顿通路。在图 \\(G = (V, E)\\) 中，若 \\(x_0, x_1, \\dots, x_{n-1}, x_n\\) 是哈密顿通路，则 \\(x_0, x_1, \\dots, x_{n-1}, x_n, x_0\\) （其中 \\(n > 0\\)）称为哈密顿回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.824,
                0.909,
                0.919
            ],
            "angle": 0,
            "content": "这个术语来自爱尔兰数学家威廉·罗万·哈密顿爵士在1857年发明的智力题。哈密顿的智力题用到了木质十二面体（如图8a所示，十二面体有12个正五边形表面）、十二面体每个顶点上的钉子，以及细线。十二面体的20个顶点用世界上的不同城市标记。智力题要求从一个城市开始，沿十二面体的边旅行，访问其他19个城市，每个恰好一次，回到第一个城市结束。旅行经过的回路用钉子和细线来标记。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.921,
                0.909,
                0.938
            ],
            "angle": 0,
            "content": "因为作者不可能向每位读者提供带钉子和细线的木质十二面体，所以考虑一个等价的问"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.121,
                0.038,
                0.156,
                0.05
            ],
            "angle": 0,
            "content": "616"
        },
        {
            "type": "header",
            "bbox": [
                0.204,
                0.036,
                0.278,
                0.051
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.092,
                0.938,
                0.128
            ],
            "angle": 0,
            "content": "题：图8b中的图是否具有恰好经过每个顶点一次的回路？它就是对原题的解，因为该图同构于包含十二面体顶点和边的图。图9是哈密顿智力题的一个解。"
        },
        {
            "type": "image",
            "bbox": [
                0.14,
                0.137,
                0.322,
                0.249
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.224,
                0.254,
                0.24,
                0.263
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "image",
            "bbox": [
                0.369,
                0.135,
                0.554,
                0.251
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.456,
                0.254,
                0.472,
                0.263
            ],
            "angle": 0,
            "content": "b)"
        },
        {
            "type": "image",
            "bbox": [
                0.658,
                0.143,
                0.853,
                0.267
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.608,
                0.274,
                0.902,
                0.289
            ],
            "angle": 0,
            "content": "图9 “周游世界”智力题的一个解"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.199,
                0.274,
                0.495,
                0.289
            ],
            "angle": 0,
            "content": "图8 哈密顿的“周游世界”智力题"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.299,
                0.929,
                0.316
            ],
            "angle": 0,
            "content": "例5 在图10中，哪些简单图具有哈密顿回路？或者没有哈密顿回路但是有哈密顿通路？"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.321,
                0.941,
                0.394
            ],
            "angle": 0,
            "content": "解 \\(G_{1}\\) 有哈密顿回路：\\(a, b, c, d, e, a\\)。\\(G_{2}\\) 没有哈密顿回路（可以看出包含每一个顶点的任何回路必然两次包含边 \\(\\{a, b\\}\\)），但是 \\(G_{2}\\) 确实有哈密顿通路，即 \\(a, b, c, d\\)。\\(G_{3}\\) 既无哈密顿回路也无哈密顿通路，因为包含所有顶点的任何通路都必须多次包含边 \\(\\{a, b\\}, \\{e, f\\}\\) 和 \\(\\{c, d\\}\\) 其中之一。"
        },
        {
            "type": "image",
            "bbox": [
                0.191,
                0.399,
                0.327,
                0.519
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.255,
                0.519,
                0.267,
                0.528
            ],
            "angle": 0,
            "content": "d"
        },
        {
            "type": "image",
            "bbox": [
                0.365,
                0.399,
                0.484,
                0.496
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.415,
                0.501,
                0.434,
                0.513
            ],
            "angle": 0,
            "content": "\\(G_{2}\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.529,
                0.399,
                0.844,
                0.497
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.677,
                0.501,
                0.698,
                0.513
            ],
            "angle": 0,
            "content": "\\(G_{3}\\)"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.439,
                0.533,
                0.596,
                0.548
            ],
            "angle": 0,
            "content": "图10 三个简单图"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.559,
                0.942,
                0.652
            ],
            "angle": 0,
            "content": "哈密顿回路存在的条件 是否存在简单方式来判定一个图有无哈密顿回路或哈密顿通路？首先，似乎应当有判定这个问题的简单方式，因为存在简单方式来回答一个图有无欧拉回路这样的相似问题。令人吃惊的是，没有已知简单的充要条件来判定哈密顿回路的存在性。不过，已经有许多定理给出了哈密顿回路的存在性的充分条件。另外，也有某些性质可以用来证明一个图没有哈密顿回路。例如，带有度为1的顶点的图没有哈密顿回路，因为在哈密顿回路中每个"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.654,
                0.574,
                0.766
            ],
            "angle": 0,
            "content": "顶点都关联回路中的两条边。另外，若图中有度为2的顶点，则关联这个顶点的两条边属于任意一条哈密顿回路。此外注意，当构造哈密顿回路且该回路经过某一个顶点时，除了回路所用到的两条边以外，这个顶点所关联的其他所有边不用再考虑。而且，哈密顿回路不能包含更小的回路。"
        },
        {
            "type": "image",
            "bbox": [
                0.587,
                0.658,
                0.738,
                0.733
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.654,
                0.745,
                0.669,
                0.756
            ],
            "angle": 0,
            "content": "G"
        },
        {
            "type": "image",
            "bbox": [
                0.795,
                0.658,
                0.944,
                0.733
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.863,
                0.745,
                0.879,
                0.755
            ],
            "angle": 0,
            "content": "H"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.633,
                0.765,
                0.895,
                0.78
            ],
            "angle": 0,
            "content": "图11 两个没有哈密顿回路的图"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.795,
                0.944,
                0.85
            ],
            "angle": 0,
            "content": "解 \\(G\\) 没有哈密顿回路，因为 \\(G\\) 有度为1的顶点，即 \\(e\\) 。现在考虑 \\(H\\) 。因为顶点 \\(a, b, d\\) 和 \\(e\\) 的度都为2，所以与这些顶点关联的每一条边都必然属于任意一条哈密顿回路。现在容易看出 \\(H\\) 不存在哈密顿回路，因为任何这样的哈密顿回路都不得不包含4条关联 \\(c\\) 的边，这是不可能的。"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.856,
                0.529,
                0.873
            ],
            "angle": 0,
            "content": "例7 证明：当 \\(n \\geqslant 3\\) 时，\\(K_{n}\\) 有哈密顿回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.879,
                0.941,
                0.935
            ],
            "angle": 0,
            "content": "解 从 \\(K_{n}\\) 中的任意一个顶点开始来形成哈密顿回路。以所选择的任意顺序来访问顶点，只要求通路在同一个顶点开始和结束，而且对其他每个顶点恰好访问一次，就可以构造这样的回路。这样做是可能的，因为在 \\(K_{n}\\) 中任意两个顶点之间都有边。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.765,
                0.04,
                0.87,
                0.054
            ],
            "angle": 0,
            "content": "图 617"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.095,
                0.902,
                0.208
            ],
            "angle": 0,
            "content": "虽然还未发现任何有用的关于哈密顿回路存在性的充要条件，但很多充分条件已经被找到了。注意，一个图的边越多，这个图就越可能有哈密顿回路。另外，加入边（而不是顶点）到已经有哈密顿回路的图中，就产生有相同哈密顿回路的图。因此，当加入边到图中时，特别是当确保给每个顶点都加入边时，这个图存在哈密顿回路的可能性就更大了。因此，我们期望哈密顿回路存在性的充分条件取决于顶点的度足够大。这里叙述两个最重要的充分条件中。这些条件是加布里尔·A.狄拉克(Gabriel A. Dirac)在1952年和奥斯丁·欧尔(Oystein Ore)在1960年发现的。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.216,
                0.892,
                0.253
            ],
            "angle": 0,
            "content": "定理3 狄拉克定理 如果 \\(G\\) 是有 \\(n\\) 个顶点的简单图，其中 \\(n \\geqslant 3\\) ，并且 \\(G\\) 中每个顶点的度都至少为 \\(n / 2\\) ，则 \\(G\\) 有哈密顿回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.268,
                0.892,
                0.305
            ],
            "angle": 0,
            "content": "定理4 欧尔定理 如果 \\(G\\) 是有 \\(n\\) 个顶点的简单图，其中 \\(n \\geqslant 3\\) ，并且对于 \\(G\\) 中每一对不相邻的顶点 \\(u\\) 和 \\(v\\) 来说，都有 \\(\\deg(u) + \\deg(v) \\geqslant n\\) ，则 \\(G\\) 有哈密顿回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.314,
                0.898,
                0.349
            ],
            "angle": 0,
            "content": "本节练习65粗略介绍了欧尔定理的证明。狄拉克定理可以作为欧尔定理的推论来证明，因为狄拉克定理的条件蕴含了欧尔定理的条件。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.352,
                0.9,
                0.407
            ],
            "angle": 0,
            "content": "欧尔定理和狄拉克定理都给出了连通的简单图有哈密顿回路的充分条件。但是，这些定理没有给出哈密顿回路存在性的必要条件。例如，图 \\(C_5\\) 有哈密顿回路，但既不满足欧尔定理的假设也不满足狄拉克定理的假设，读者可以验证这一点。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.409,
                0.9,
                0.483
            ],
            "angle": 0,
            "content": "已知最好的求一个图哈密顿回路或判定这样的回路不存在的算法具有指数级的最坏情形时间复杂度（相对于图的顶点数来说）。找到具有多项式最坏情形时间复杂度的解决算法将具有重大意义，因为已经证明这个问题是 NP 完全的（见 3.3 节）。因此，它的发现将意味着其他许多理论上可解的问题都可以用具有多项式最坏情形时间复杂度的解决算法来解决。"
        },
        {
            "type": "image",
            "bbox": [
                0.053,
                0.496,
                0.12,
                0.52
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.059,
                0.532,
                0.199,
                0.642
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.054,
                0.645,
                0.157,
                0.664
            ],
            "angle": 0,
            "content": "Hilton-Deutsche Corbis/Getty Images"
        },
        {
            "type": "text",
            "bbox": [
                0.214,
                0.532,
                0.9,
                0.67
            ],
            "angle": 0,
            "content": "威廉·罗万·哈密顿（William Rowan Hamilton，1805—1865）哈密顿是爱尔兰最具名望的科学家，1805年出生于都柏林。他的父亲是一名成功的律师，母亲来自以智力超群而闻名的家族，而哈密顿本人更是个神童。3岁时，他在阅读方面就显示出了超群的能力并掌握了高等算术。因为他非凡的智商，哈密顿被送到身为著名语言学家的叔叔詹姆士那里生活。到哈密顿8岁时，他已经学会了拉丁语、希腊语和希伯来语；到10岁时，他又学会了意大利语和法语，并且开始学习东方语言，包括阿拉伯语、梵语和波斯语。那时，他以小小年纪却掌握多种语言而倍感自豪。17岁时，他不再学习新的语言，但是已经掌握了微积分和许多数学天文学知识，他开始了在"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.673,
                0.902,
                0.812
            ],
            "angle": 0,
            "content": "光学上的开创性工作，并发现了拉普拉斯的天体力学著作中的重大错误。在他18岁进入都柏林三一学院之前，哈密顿一直接受私人教育。在三一学院上学期间，他在科学和古典文学上都表现超群。在获得学位之前，他就因为过人的才华，从多位著名天文学家参与的竞争中脱颖而出，被任命为爱尔兰皇家天文学家。他终身担任这个职位，终其一生都在都柏林郊外的邓辛克(Dunsink)天文台生活和工作。哈密顿在光学、抽象代数和动力学领域做出了重要贡献。哈密顿发明了称为四元数的代数对象来作为非交换系统的例子。当他沿都柏林的运河散步时，他发现了四元数相乘的适当方式。狂喜之下，他把公式刻在了横跨运河的石桥上，直至今日还能看到该地立下的牌匾以做纪念。后来，哈密顿一直沉迷在四元数中，试图把它们应用到数学的其他领域，而不再涉足新的研究领域。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.815,
                0.902,
                0.866
            ],
            "angle": 0,
            "content": "1857年，哈密顿在自己非交换代数领域研究的基础上发明了“环游世界游戏”（The Icosian Game）。他把这个想法以25镑的价格出售给游戏和拼图益智题的经销商。（游戏的销路一直不好，事实证明这是经销商一次失败的投资。）本节所描述的拼图益智题“旅行者十二面体”，又称为“周游世界”，就是该游戏的变种。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.868,
                0.902,
                0.937
            ],
            "angle": 0,
            "content": "1833年，哈密顿第三次结婚，但他的婚姻很不幸，由于他的妻子是半残疾人，所以很多家务事都做不了，这无疑给哈密顿徒增了很多烦恼。在他生命的最后20年中，哈密顿过着酗酒和隐居的生活。1865年，他死于痛风，留下大量文稿，其中包含还未发表的研究结果。在这些文稿中，混杂着不少盘子，许多盘子里还盛着早已脱水的吃剩下的排骨。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.138,
                0.041,
                0.174,
                0.055
            ],
            "angle": 0,
            "content": "618"
        },
        {
            "type": "header",
            "bbox": [
                0.219,
                0.04,
                0.295,
                0.055
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "title",
            "bbox": [
                0.112,
                0.104,
                0.383,
                0.122
            ],
            "angle": 0,
            "content": "10.5.4 哈密顿回路的应用"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.125,
                0.957,
                0.199
            ],
            "angle": 0,
            "content": "可以用哈密顿通路和哈密顿回路来解决实际问题。例如，许多应用都要求一条通路或回路恰好访问一个城市的每个路口、一个设备网格的每个管道交汇处或者一个通信网络的每个节点一次。求出适当图模型中的哈密顿通路或哈密顿回路就可以解决这样的问题。著名的旅行商问题(TSP)要求一个旅行商为了访问一组城市所应当选取的最短路线。这个问题可归结为求完全"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.201,
                0.495,
                0.255
            ],
            "angle": 0,
            "content": "图的哈密顿回路，使这个回路的边的权的总和尽可能小。我们将在10.6节回到这个问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.258,
                0.495,
                0.293
            ],
            "angle": 0,
            "content": "现在给出哈密顿回路在编码上的一种相对不太显著的应用。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.298,
                0.497,
                0.394
            ],
            "angle": 0,
            "content": "例8 格雷码 旋转的指针的位置可以表示成数字的形式。一种方式是把圆周等分成 \\(2^{n}\\) 段弧并且用长度为 \\(n\\) 的比特串给每段弧赋值。图12显示出了用长度为3的比特串来这样做的两种方式。"
        },
        {
            "type": "image",
            "bbox": [
                0.512,
                0.203,
                0.695,
                0.324
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.597,
                0.326,
                0.615,
                0.337
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "image",
            "bbox": [
                0.778,
                0.203,
                0.957,
                0.324
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.864,
                0.326,
                0.882,
                0.336
            ],
            "angle": 0,
            "content": "b)"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.592,
                0.343,
                0.879,
                0.359
            ],
            "angle": 0,
            "content": "图12 把指针位置转换成数字形式"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.397,
                0.955,
                0.432
            ],
            "angle": 0,
            "content": "用 \\(n\\) 个接触点的集合来确定指针位置的数字表示。每个接触点用来读出位置的数字表示中的一位。图13对图12中的两种赋值进行了说明。"
        },
        {
            "type": "title",
            "bbox": [
                0.11,
                0.445,
                0.177,
                0.464
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.11,
                0.478,
                0.25,
                0.587
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.11,
                0.592,
                0.24,
                0.602
            ],
            "angle": 0,
            "content": "Courtesy of Gabriel Dirac"
        },
        {
            "type": "text",
            "bbox": [
                0.271,
                0.478,
                0.957,
                0.618
            ],
            "angle": 0,
            "content": "加布里尔·安德鲁·狄拉克(Gabriel Andrew Dirac，1925—1984）加布里尔出生于匈牙利的首都布达佩斯。1937年，他的母亲改嫁给了著名的物理学家诺贝尔奖获得者保罗·阿德里安·毛里斯·狄拉克，于是他跟随母亲来到了英国。1942年，狄拉克考入了剑桥大学，但是由于第二次世界大战期间航空工业的战时服务，狄拉克被迫中断学业。1951年，狄拉克在伦敦大学取得了数学专业的博士学位。后来，他先后在英国、加拿大、奥地利、德国和丹麦任教14年。在狄拉克事业的初期，他对图论有着浓厚的兴趣，他提升了图论研究的重要性，并在图论的诸多领域，例如图的着色和哈密尔顿回路等方面，做出了巨大的贡献。与此同时，狄拉克吸引了众多"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.62,
                0.549,
                0.635
            ],
            "angle": 0,
            "content": "学生参与图论的理论研究中，不失为一名出色的教师。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.638,
                0.957,
                0.689
            ],
            "angle": 0,
            "content": "狄拉克以他敏锐的洞察力而著称，他在政治和社会生活领域的很多问题上都有自己独到的见解。此外，狄拉克还有很多的兴趣爱好，其中美术是他的最爱。狄拉克和他的妻子罗斯玛丽养育了4个孩子，家庭生活十分幸福美满。"
        },
        {
            "type": "image",
            "bbox": [
                0.11,
                0.711,
                0.25,
                0.82
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.11,
                0.825,
                0.24,
                0.845
            ],
            "angle": 0,
            "content": "Courtesy of Museum of University History (MUV)"
        },
        {
            "type": "text",
            "bbox": [
                0.271,
                0.712,
                0.957,
                0.798
            ],
            "angle": 0,
            "content": "奥斯丁·欧尔（Oystein Ore，1899—1968）欧尔出生于克里斯蒂安尼亚（现称奥斯陆，挪威的首都）。1922年，他在克里斯蒂安尼亚大学取得学士学位，三年后获得数学系博士学位。1927年，他放弃了在克里斯蒂安尼亚大学的初级职称，来到了耶鲁大学任职。在耶鲁大学，他晋升得很快，仅用了两年的时间就升到了正教授的位置。1931年，他被选为斯特林讲座教授(Sterling Professor)，并一直任职至1968年。"
        },
        {
            "type": "text",
            "bbox": [
                0.271,
                0.8,
                0.957,
                0.851
            ],
            "angle": 0,
            "content": "欧尔对数论、环论、格论、图论和概率论的研究都做出了巨大的贡献。他是一个多产作者，发表了大量论文并编著了多部书籍。欧尔对数学史有着浓厚的兴趣，他编写的人物传记《亚伯和卡尔达诺》（Abel and Cardano）和教科书《数论及其历史》"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.853,
                0.957,
                0.886
            ],
            "angle": 0,
            "content": "(Number Theory and its History)中就充分说明了这一点。从1960年到1969年的十年间，欧尔编写了4本关于图论的书籍。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.889,
                0.957,
                0.94
            ],
            "angle": 0,
            "content": "第二次世界大战期间和第二次世界大战结束后，欧尔为保护他的祖国挪威，发挥了重大作用。1947年，挪威国王哈康七世授予他圣奥拉夫爵士的封号以表彰他为保护祖国做出的贡献。欧尔对绘画和雕塑颇有研究，此外，他也十分热衷收集古地图。欧尔已经结婚，并有两个孩子。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.78,
                0.035,
                0.885,
                0.049
            ],
            "angle": 0,
            "content": "图 619"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.09,
                0.916,
                0.204
            ],
            "angle": 0,
            "content": "当指针靠近两段弧的边界时，在读出指针位置时可能发生错误。这可能引起读出的比特串有一个大的错误。例如，在图12a的编码方案里，若在确定指针位置的过程中发生了一个小的错误，则读出的比特串是100而不是011。所有三位都是错的！为了把在确定指针位置的过程中的错误影响降到最低，用比特串对 \\(2^{n}\\) 段弧赋值，使相邻的弧所表示的比特串只相差一位。图12b的编码方案恰好就是这样。在确定指针位置的过程中一个错误使给出的比特串为010而不为011。只有一位是错的。"
        },
        {
            "type": "image",
            "bbox": [
                0.118,
                0.207,
                0.875,
                0.378
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.375,
                0.382,
                0.607,
                0.396
            ],
            "angle": 0,
            "content": "图13 指针位置的数字表示"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.402,
                0.916,
                0.418
            ],
            "angle": 0,
            "content": "格雷码是圆弧的一种标记，使得相邻的弧具有恰好相差一位的比特串标记。在图12b中的"
        },
        {
            "type": "text",
            "bbox": [
                0.069,
                0.421,
                0.64,
                0.552
            ],
            "angle": 0,
            "content": "赋值是一个格雷码。可以这样找出格雷码：以下述方式列出所有长度为 \\(n\\) 的比特串，使得每一个串与前一个串恰好相差一位，而且最后一个串与第一个串恰好相差一位。可以用 \\(n\\) 立方体 \\(Q_{n}\\) 来为这个问题建模。解决这个问题所需要的是 \\(Q_{n}\\) 中的一条哈密顿回路。这样的哈密顿回路容易求出。例如，\\(Q_{3}\\) 的一条哈密顿回路显示在图14中。这条哈密顿回路所产生的前后恰好相差一位的比特串序列是000，001，011，010，110，111，101，100。"
        },
        {
            "type": "text",
            "bbox": [
                0.069,
                0.555,
                0.638,
                0.609
            ],
            "angle": 0,
            "content": "格雷码是以弗兰克·格雷的名字来命名的。20世纪40年代，格雷在贝尔实验室研究如何把数字信号传送过程中错误的影响降到最低时发明了它们。"
        },
        {
            "type": "image",
            "bbox": [
                0.664,
                0.424,
                0.887,
                0.56
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.676,
                0.567,
                0.877,
                0.583
            ],
            "angle": 0,
            "content": "图14 \\(Q_{3}\\) 的哈密顿回路"
        },
        {
            "type": "title",
            "bbox": [
                0.07,
                0.623,
                0.117,
                0.639
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.071,
                0.644,
                0.916,
                0.678
            ],
            "angle": 0,
            "content": "在练习 \\(1\\sim 8\\) 中，判定给定的图是否具有欧拉回路。若存在，构造这样的回路；如果不存在，就确定这个图是否具有欧拉通路，若存在，则构造这样的通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.07,
                0.681,
                0.088,
                0.695
            ],
            "angle": 0,
            "content": "1."
        },
        {
            "type": "image",
            "bbox": [
                0.092,
                0.681,
                0.228,
                0.771
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.296,
                0.681,
                0.312,
                0.695
            ],
            "angle": 0,
            "content": "2."
        },
        {
            "type": "image",
            "bbox": [
                0.317,
                0.681,
                0.545,
                0.773
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.614,
                0.681,
                0.631,
                0.694
            ],
            "angle": 0,
            "content": "3."
        },
        {
            "type": "image",
            "bbox": [
                0.636,
                0.681,
                0.769,
                0.787
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.07,
                0.8,
                0.088,
                0.814
            ],
            "angle": 0,
            "content": "4."
        },
        {
            "type": "image",
            "bbox": [
                0.091,
                0.799,
                0.275,
                0.94
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.287,
                0.8,
                0.305,
                0.814
            ],
            "angle": 0,
            "content": "5."
        },
        {
            "type": "image",
            "bbox": [
                0.309,
                0.8,
                0.54,
                0.93
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.556,
                0.8,
                0.573,
                0.814
            ],
            "angle": 0,
            "content": "6."
        },
        {
            "type": "image",
            "bbox": [
                0.578,
                0.799,
                0.893,
                0.928
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.124,
                0.036,
                0.159,
                0.049
            ],
            "angle": 0,
            "content": "620"
        },
        {
            "type": "header",
            "bbox": [
                0.205,
                0.035,
                0.281,
                0.049
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.091,
                0.113,
                0.104
            ],
            "angle": 0,
            "content": "7."
        },
        {
            "type": "image",
            "bbox": [
                0.117,
                0.09,
                0.516,
                0.224
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.574,
                0.092,
                0.591,
                0.104
            ],
            "angle": 0,
            "content": "8."
        },
        {
            "type": "image",
            "bbox": [
                0.597,
                0.092,
                0.944,
                0.226
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.227,
                0.941,
                0.259
            ],
            "angle": 0,
            "content": "9. 设除了哥尼斯堡的7座桥之外（如图1所示），还有另外2座桥。这些新桥分别连接区域 \\(B\\) 和 \\(C\\) 以及区域 \\(B\\) 和 \\(D\\) 。是否有人能够经过这9座桥恰好一次并且回到出发点？"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.261,
                0.643,
                0.276
            ],
            "angle": 0,
            "content": "10. 是否有人能够经过下图所示的所有桥恰好一次并且回到出发点？"
        },
        {
            "type": "image",
            "bbox": [
                0.127,
                0.278,
                0.432,
                0.346
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.349,
                0.827,
                0.363
            ],
            "angle": 0,
            "content": "11. 何时可以画出一个城市街道的中心线而不重复经过街道（假设所有街道都是双向街道）？"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.366,
                0.659,
                0.38
            ],
            "angle": 0,
            "content": "12. 设计一个与算法 1 相似的过程，它能够在多重图里构造欧拉通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.383,
                0.894,
                0.397
            ],
            "angle": 0,
            "content": "在练习 \\(13\\sim 15\\) 中，判定是否可以用一支铅笔连续移动，不离开纸面并且不重复地画出所示的图形。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.4,
                0.122,
                0.413
            ],
            "angle": 0,
            "content": "13."
        },
        {
            "type": "image",
            "bbox": [
                0.127,
                0.4,
                0.251,
                0.492
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.339,
                0.4,
                0.365,
                0.413
            ],
            "angle": 0,
            "content": "14."
        },
        {
            "type": "image",
            "bbox": [
                0.368,
                0.4,
                0.493,
                0.529
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.582,
                0.4,
                0.607,
                0.413
            ],
            "angle": 0,
            "content": "15."
        },
        {
            "type": "image",
            "bbox": [
                0.615,
                0.402,
                0.743,
                0.511
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.531,
                0.941,
                0.562
            ],
            "angle": 0,
            "content": "* 16. 证明：不带有孤立点的有向多重图具有欧拉回路，当且仅当该图是弱连通的并且每个顶点的入度与出度都相等。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.565,
                0.942,
                0.613
            ],
            "angle": 0,
            "content": "* 17. 证明：不带有孤立点的有向多重图具有欧拉通路而没有欧拉回路，当且仅当该图是弱连通的并且存在两个顶点，一个顶点的入度比出度大1而另外一个顶点的出度比入度大1，其余每个顶点的入度与出度都相等。"
        },
        {
            "type": "list",
            "bbox": [
                0.081,
                0.531,
                0.942,
                0.613
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.615,
                0.941,
                0.647
            ],
            "angle": 0,
            "content": "在练习 \\(18\\sim 23\\) 中，判断所示的有向图是否具有欧拉回路。若存在欧拉回路，则构造一条欧拉回路。如果不存在欧拉回路，就判断这个有向图是否具有欧拉通路。若存在欧拉通路，则构造一条欧拉通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.65,
                0.123,
                0.663
            ],
            "angle": 0,
            "content": "18."
        },
        {
            "type": "image",
            "bbox": [
                0.128,
                0.65,
                0.271,
                0.757
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.324,
                0.65,
                0.348,
                0.663
            ],
            "angle": 0,
            "content": "19."
        },
        {
            "type": "image",
            "bbox": [
                0.352,
                0.65,
                0.497,
                0.757
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.567,
                0.65,
                0.592,
                0.663
            ],
            "angle": 0,
            "content": "20."
        },
        {
            "type": "image",
            "bbox": [
                0.596,
                0.65,
                0.848,
                0.757
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.76,
                0.123,
                0.772
            ],
            "angle": 0,
            "content": "21."
        },
        {
            "type": "image",
            "bbox": [
                0.128,
                0.76,
                0.378,
                0.869
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.401,
                0.76,
                0.427,
                0.772
            ],
            "angle": 0,
            "content": "22."
        },
        {
            "type": "image",
            "bbox": [
                0.431,
                0.76,
                0.657,
                0.862
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.679,
                0.76,
                0.704,
                0.772
            ],
            "angle": 0,
            "content": "23."
        },
        {
            "type": "image",
            "bbox": [
                0.709,
                0.76,
                0.896,
                0.934
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.77,
                0.036,
                0.874,
                0.051
            ],
            "angle": 0,
            "content": "图 621"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.091,
                0.416,
                0.106
            ],
            "angle": 0,
            "content": "* 24. 设计一个构造有向图中欧拉回路的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.109,
                0.416,
                0.124
            ],
            "angle": 0,
            "content": "25. 设计一个构造有向图中欧拉通路的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.127,
                0.416,
                0.142
            ],
            "angle": 0,
            "content": "26. 对哪些 \\(n\\) 值来说，下列图具有欧拉回路？"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.145,
                0.132,
                0.159
            ],
            "angle": 0,
            "content": "a) \\(K_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.282,
                0.146,
                0.322,
                0.159
            ],
            "angle": 0,
            "content": "b) \\(C_n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.459,
                0.146,
                0.501,
                0.159
            ],
            "angle": 0,
            "content": "c) \\(W_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.633,
                0.146,
                0.673,
                0.159
            ],
            "angle": 0,
            "content": "d) \\(Q_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.163,
                0.611,
                0.177
            ],
            "angle": 0,
            "content": "27. 对哪些 \\(n\\) 值来说，练习26中的图具有欧拉通路而没有欧拉回路？"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.181,
                0.45,
                0.195
            ],
            "angle": 0,
            "content": "28. 对哪些 \\(m\\) 和 \\(n\\) 值来说，完全二分图 \\(K_{m,n}\\) 具有"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.198,
                0.193,
                0.212
            ],
            "angle": 0,
            "content": "a)欧拉回路？"
        },
        {
            "type": "text",
            "bbox": [
                0.458,
                0.199,
                0.563,
                0.212
            ],
            "angle": 0,
            "content": "b)欧拉通路？"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.216,
                0.794,
                0.23
            ],
            "angle": 0,
            "content": "29. 当不重复任何部分地画出练习 \\(1 \\sim 7\\) 中的每个图时，求出铅笔必须离开纸面的最少次数。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.234,
                0.901,
                0.265
            ],
            "angle": 0,
            "content": "在练习 \\(30\\sim 36\\) 中，判断所给的图是否具有哈密顿回路。若有哈密顿回路，则求出这样一条回路。若没有哈密顿回路，则论证为什么不存在这样的回路。"
        },
        {
            "type": "image",
            "bbox": [
                0.057,
                0.269,
                0.375,
                0.364
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.584,
                0.269,
                0.788,
                0.364
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.057,
                0.367,
                0.271,
                0.463
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.587,
                0.367,
                0.874,
                0.463
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.057,
                0.467,
                0.353,
                0.639
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.385,
                0.467,
                0.537,
                0.564
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.586,
                0.467,
                0.894,
                0.578
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.643,
                0.868,
                0.657
            ],
            "angle": 0,
            "content": "37. 练习 30 中的图有哈密顿通路吗？如果有，找到它。如果没有，给出理由证明不存在这样的通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.66,
                0.868,
                0.675
            ],
            "angle": 0,
            "content": "38. 练习 31 中的图有哈密顿通路吗？如果有，找到它。如果没有，给出理由证明不存在这样的通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.678,
                0.868,
                0.693
            ],
            "angle": 0,
            "content": "39. 练习 32 中的图有哈密顿通路吗？如果有，找到它。如果没有，给出理由证明不存在这样的通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.696,
                0.868,
                0.711
            ],
            "angle": 0,
            "content": "40. 练习33中的图有哈密顿通路吗？如果有，找到它。如果没有，给出理由证明不存在这样的通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.714,
                0.868,
                0.729
            ],
            "angle": 0,
            "content": "* 41. 练习34中的图有哈密顿通路吗？如果有，找到它。如果没有，给出理由证明不存在这样的通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.732,
                0.868,
                0.747
            ],
            "angle": 0,
            "content": "42. 练习35中的图有哈密顿通路吗？如果有，找到它。如果没有，给出理由证明不存在这样的通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.749,
                0.661,
                0.781
            ],
            "angle": 0,
            "content": "43. 练习 36 中的图有哈密顿通路吗？如果有，找到它。如果没有，给出理由证明不存在这样的通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.785,
                0.5,
                0.799
            ],
            "angle": 0,
            "content": "44. 对哪些 \\( n \\) 值来说，练习26中的图具有哈密顿回路？"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.803,
                0.555,
                0.817
            ],
            "angle": 0,
            "content": "45. 对哪些 \\(m\\) 和 \\(n\\) 值来说，完全二分图 \\(K_{m,n}\\) 具有哈密顿回路？"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.82,
                0.662,
                0.852
            ],
            "angle": 0,
            "content": "* 46. 证明：右图所示的彼得森图没有哈密顿回路，但是通过删除一个顶点 \\( v \\) 和所有与 \\( v \\) 关联的边，得到的子图却有哈密顿回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.856,
                0.661,
                0.906
            ],
            "angle": 0,
            "content": "47. 对于下列各图确定：（i)能否用狄拉克定理来证明这个图有哈密顿回路；（ii)能否用欧尔定理来证明这个图有哈密顿回路；（iii)这个图是否有哈密顿回路。"
        },
        {
            "type": "image",
            "bbox": [
                0.677,
                0.752,
                0.907,
                0.901
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.132,
                0.035,
                0.169,
                0.049
            ],
            "angle": 0,
            "content": "622"
        },
        {
            "type": "header",
            "bbox": [
                0.212,
                0.034,
                0.29,
                0.049
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.135,
                0.091,
                0.156,
                0.104
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "image",
            "bbox": [
                0.153,
                0.09,
                0.268,
                0.199
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.335,
                0.091,
                0.355,
                0.104
            ],
            "angle": 0,
            "content": "b)"
        },
        {
            "type": "image",
            "bbox": [
                0.354,
                0.09,
                0.467,
                0.199
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.536,
                0.091,
                0.557,
                0.104
            ],
            "angle": 0,
            "content": "c)"
        },
        {
            "type": "image",
            "bbox": [
                0.558,
                0.09,
                0.664,
                0.166
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.734,
                0.091,
                0.754,
                0.104
            ],
            "angle": 0,
            "content": "d)"
        },
        {
            "type": "image",
            "bbox": [
                0.755,
                0.09,
                0.864,
                0.166
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.207,
                0.95,
                0.24
            ],
            "angle": 0,
            "content": "48. 能否找到一个带有 \\( n \\) 个顶点的简单图 \\((n \\geqslant 3)\\)，这个图没有哈密顿回路，但是这个图中每个顶点的度至少是 \\((n - 1) / 2\\)？"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.244,
                0.951,
                0.278
            ],
            "angle": 0,
            "content": "* 49. 证明：当 \\( n \\) 是正整数时，存在 \\( n \\) 阶格雷码，或者等价地证明：\\( n > 1 \\) 的 \\( n \\) 立方体 \\( Q_{n} \\) 总是具有哈密顿回路。[提示：用数学归纳法。证明如何从 \\( n - 1 \\) 阶格雷码产生 \\( n \\) 阶格雷码。]"
        },
        {
            "type": "list",
            "bbox": [
                0.087,
                0.207,
                0.951,
                0.278
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.28,
                0.951,
                0.334
            ],
            "angle": 0,
            "content": "构造欧拉回路的Fleury算法发表于1883年。该算法是从连通多重图的任意一个顶点开始，连续地选择边来形成一条回路。一旦选择了一条边，就删除这条边。连续地选择边，使得每条边从上一条边结束的地方开始，而且使得这条边不是一条割边，除非别无选择。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.337,
                0.51,
                0.352
            ],
            "angle": 0,
            "content": "50. 用Fleury算法找出在图5中图 \\(G\\) 的欧拉回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.355,
                0.356,
                0.37
            ],
            "angle": 0,
            "content": "* 51. 用伪代码表达 Fleury 算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.077,
                0.374,
                0.482,
                0.389
            ],
            "angle": 0,
            "content": "**52. 证明：Fleury 算法总是产生一条欧拉回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.393,
                0.468,
                0.407
            ],
            "angle": 0,
            "content": "* 53. 给出 Fleury 算法的变种以产生欧拉通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.411,
                0.713,
                0.463
            ],
            "angle": 0,
            "content": "54. 一个诊断消息可以在计算机网络上发出，以便在所有链路和所有设备上执行测试。为了测试所有的链路，应当使用什么类型的通路？为了测试所有的设备呢？"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.466,
                0.538,
                0.481
            ],
            "angle": 0,
            "content": "55. 证明：带有奇数个顶点的二分图没有哈密顿回路。"
        },
        {
            "type": "list",
            "bbox": [
                0.077,
                0.355,
                0.713,
                0.481
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.485,
                0.714,
                0.556
            ],
            "angle": 0,
            "content": "在国际象棋中马是这样一种棋子，它的移动可以是水平两格加垂直一格，或者是水平一格加垂直两格。即在 \\((x, y)\\) 格子的马可以移动到 8 个格子 \\((x \\pm 2, y \\pm 1)\\) 、\\((x \\pm 1, y \\pm 2)\\) 中的任何一个，只要这些格子是在棋盘上，如右图所示。"
        },
        {
            "type": "image",
            "bbox": [
                0.728,
                0.397,
                0.951,
                0.546
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.56,
                0.951,
                0.632
            ],
            "angle": 0,
            "content": "马的周游是马的合法移动的序列，马在某个格子上开始且访问每个格子恰好一次。若存在一种合法移动，让马从周游的最后一个格子回到周游开始的地方，则马的周游称为重返的。可以用图为马的周游建模，其中棋盘上每个格子都用一个顶点来表示，若马可以在两个顶点所表示的格子之间合法地移动，则用一条边连接这两个顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.636,
                0.492,
                0.651
            ],
            "angle": 0,
            "content": "56. 画出表示马在 \\(3 \\times 3\\) 棋盘上的合法移动的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.655,
                0.492,
                0.669
            ],
            "angle": 0,
            "content": "57. 画出表示马在 \\(3 \\times 4\\) 棋盘上的合法移动的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.673,
                0.868,
                0.688
            ],
            "angle": 0,
            "content": "58. a) 证明：求马在 \\(m \\times n\\) 棋盘上的周游等价于求表示马在该棋盘上合法移动的图的哈密顿通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.134,
                0.693,
                0.794,
                0.707
            ],
            "angle": 0,
            "content": "b) 证明：求马在 \\(m \\times n\\) 棋盘上的重返的周游等价于求所对应的图上的哈密顿回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.712,
                0.436,
                0.726
            ],
            "angle": 0,
            "content": "* 59. 证明：存在马在 \\(3 \\times 4\\) 棋盘上的周游。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.731,
                0.455,
                0.745
            ],
            "angle": 0,
            "content": "* 60. 证明：不存在马在 \\(3 \\times 3\\) 棋盘上的周游。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.75,
                0.455,
                0.764
            ],
            "angle": 0,
            "content": "*61. 证明：不存在马在 \\(4 \\times 4\\) 棋盘上的周游。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.769,
                0.798,
                0.783
            ],
            "angle": 0,
            "content": "62. 证明：当 \\(m\\) 和 \\(n\\) 都是正整数时，表示马在 \\(m \\times n\\) 棋盘上的合法移动的图是二分图。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.787,
                0.951,
                0.821
            ],
            "angle": 0,
            "content": "63. 证明：当 \\(m\\) 和 \\(n\\) 都是奇数时，不存在马在 \\(m \\times n\\) 棋盘上的重返的周游。[提示：利用练习55、练习58b和练习62。]"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.825,
                0.951,
                0.879
            ],
            "angle": 0,
            "content": "*64. 证明：存在马在 \\(8 \\times 8\\) 棋盘上的周游。[提示：你可以用沃恩斯道夫于1823年发明的下列方法来构造马的周游。从任意格子开始，然后总是移动到与最少数目的没有用过的格子连接的一个格子上。虽然这个方法不能总是产生马的周游，但是它确实很有效。]"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.882,
                0.951,
                0.915
            ],
            "angle": 0,
            "content": "65. 本练习粗略介绍欧尔定理的证明。假设 \\(G\\) 是带有 \\(n\\) 个顶点的简单图，\\(n \\geqslant 3\\)，并且当 \\(x\\) 和 \\(y\\) 是 \\(G\\) 中不相邻的顶点时，\\(\\deg(x) + \\deg(y) \\geqslant n\\)。欧尔定理称在这些条件下，\\(G\\) 有哈密顿回路。"
        },
        {
            "type": "list",
            "bbox": [
                0.09,
                0.712,
                0.951,
                0.915
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.134,
                0.918,
                0.951,
                0.933
            ],
            "angle": 0,
            "content": "a)证明：如果 \\(G\\) 没有哈密顿回路，则存在另一个带有与 \\(G\\) 相同顶点的图 \\(H\\) ，可以这样来构造 \\(H\\) ：加"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.767,
                0.038,
                0.873,
                0.053
            ],
            "angle": 0,
            "content": "图 623"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.093,
                0.901,
                0.127
            ],
            "angle": 0,
            "content": "入边到 \\(G\\) 使得加入一条边就产生 \\(H\\) 中的哈密顿回路。[提示：依次在 \\(G\\) 的每个顶点加入不产生哈密顿回路的尽可能多的边。]"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.13,
                0.364,
                0.144
            ],
            "angle": 0,
            "content": "b) 证明：在 \\(H\\) 中存在哈密顿通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.147,
                0.9,
                0.179
            ],
            "angle": 0,
            "content": "c) 设 \\( v_{1}, v_{2}, \\dots, v_{n} \\) 是 \\( H \\) 中的哈密顿通路。证明： \\( \\deg(v_{1}) + \\deg(v_{n}) \\geqslant n \\) 并且至多存在 \\( \\deg(v_{1}) \\) 个顶点不与 \\( v_{n} \\) 相邻（包括 \\( v_{n} \\) 在内）。"
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.182,
                0.896,
                0.198
            ],
            "angle": 0,
            "content": "d)设 \\(S\\) 是与哈密顿通路上与 \\(\\nu_{1}\\) 相邻的每个顶点前面的顶点的集合。证明 \\(S\\) 包含 \\(\\deg (v_1)\\) 个顶点并且 \\(\\nu_{n}\\notin S\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.2,
                0.697,
                0.232
            ],
            "angle": 0,
            "content": "e) 证明：\\(S\\) 包含与 \\(v_{n}\\) 相邻的顶点 \\(v_{k}\\)。这蕴含着存在连接 \\(v_{1}\\) 与 \\(v_{k+1}\\) 和 \\(v_{k}\\) 与 \\(v_{n}\\) 的边。"
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.236,
                0.697,
                0.268
            ],
            "angle": 0,
            "content": "f) 证明：e) 蕴含着 \\(v_{1}, v_{2}, \\cdots, v_{k-1}, v_{k}, v_{n}, v_{n-1}, \\cdots, v_{k+1}\\)，\\(v_{1}\\) 是 \\(G\\) 中的哈密顿回路。从这个矛盾得出欧尔定理成立。"
        },
        {
            "type": "list",
            "bbox": [
                0.084,
                0.13,
                0.9,
                0.268
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.271,
                0.699,
                0.304
            ],
            "angle": 0,
            "content": "66. 证明：求所有顶点度数都为偶数的连通图的欧拉回路的算法1的最坏情形计算复杂度是 \\(O(m)\\)，其中 \\(m\\) 是 \\(G\\) 中的边数。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.307,
                0.321,
                0.322
            ],
            "angle": 0,
            "content": "67. 证明右图不含有哈密顿回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.324,
                0.699,
                0.358
            ],
            "angle": 0,
            "content": "* 68. 证明：求所有顶点的度都为偶数的连通图的欧拉回路的算法1的最坏情形计算复杂度是 \\(O(m)\\)，其中 \\(m\\) 是 \\(G\\) 中的边数。"
        },
        {
            "type": "image",
            "bbox": [
                0.714,
                0.206,
                0.902,
                0.336
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.056,
                0.372,
                0.296,
                0.392
            ],
            "angle": 0,
            "content": "10.6 最短通路问题"
        },
        {
            "type": "title",
            "bbox": [
                0.056,
                0.399,
                0.192,
                0.416
            ],
            "angle": 0,
            "content": "10.6.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.419,
                0.905,
                0.513
            ],
            "angle": 0,
            "content": "许多问题可以用边上赋权的图来建模。作为说明，考虑航线系统如何建模。如果用顶点表示城市，用边表示航班，就可以得到基本的图模型。给边赋上城市之间的距离，就可以为涉及距离的问题建模；给边赋上飞行时间，就可以为涉及飞行时间的问题建模；给边赋上票价，就可以为涉及票价的问题建模。图1显示了给一个图的边赋权的三种不同方式，分别表示距离、飞行时间和票价。"
        },
        {
            "type": "title",
            "bbox": [
                0.055,
                0.548,
                0.123,
                0.568
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.058,
                0.582,
                0.199,
                0.695
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.056,
                0.698,
                0.195,
                0.719
            ],
            "angle": 0,
            "content": "\\(\\langle \\widehat{\\mathbb{C}}\\rangle\\) Paul Fearn/Alamy Stock Photo"
        },
        {
            "type": "text",
            "bbox": [
                0.213,
                0.582,
                0.905,
                0.721
            ],
            "angle": 0,
            "content": "朱理乌斯·彼得·克里西安·彼得森(Julius Peter Christian Petersen，1839—1910）彼得森出生在丹麦的索镇。他的父亲是一名染匠。1854年，他的父母再也负担不起他的学费，于是让他到叔叔的杂货店当学徒。他叔叔死的时候给彼得森留下足够的钱让他重新回到学校。毕业后，他在哥本哈根理工学院开始学习工程学，随后决定专攻数学。1858年，他出版了第一本书，一本关于对数的教科书。当继承的遗产用完之后，彼得森不得不靠教书来谋生。1859年到1871年间，彼得森在哥本哈根的一所私立贵族高中教书。他一边教书一边继续他的学业，并于1862年进入哥本哈根大学。同年，他与劳拉·伯特森结婚。他们育有3个孩子，两男一女。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.724,
                0.905,
                0.81
            ],
            "angle": 0,
            "content": "1866年，彼得森从哥本哈根大学获得数学学位，并于1871年从该校最终获得博士学位。得到博士学位后，他在理工与军事学院任教。1887年他被任命为哥本哈根大学的教授。在丹麦，彼得森因著有大量的高中和大学教科书而知名。其中《解决几何构造问题的方法和理论》（Methods and Theories for the Solution of Problems of Geometrical Construction)被译成8种语言，英文版最近的一次重印是在1960年，而法文版最近的一次重印是在1990年，距离初版已经超过了一个世纪。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.812,
                0.905,
                0.899
            ],
            "angle": 0,
            "content": "彼得森的研究领域很广泛，包括代数学、分析学、密码学、几何学、力学、数理经济学以及数论。他对图论的贡献，包括有关正则图的结果，最为著名。他以论述的清晰性、解决问题的技巧性和独创性、讲话的幽默感、充沛的精力以及擅长教学而闻名。彼得森不愿意读其他数学家的著作。所以，他经常证明一些已经被别人证明过的结果而常常陷于尴尬之中。不过，他却无法忍受其他的数学家不读他的作品。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.901,
                0.904,
                0.935
            ],
            "angle": 0,
            "content": "彼得森去世的消息曾刊登在哥本哈根报纸的头版。当时一家报纸把他誉为科学界的汉斯·克里西安·安徒生——在学术世界里做出巨大贡献的人民之子。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.134,
                0.038,
                0.168,
                0.051
            ],
            "angle": 0,
            "content": "624"
        },
        {
            "type": "header",
            "bbox": [
                0.215,
                0.036,
                0.29,
                0.051
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "image",
            "bbox": [
                0.234,
                0.095,
                0.825,
                0.272
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.235,
                0.288,
                0.825,
                0.468
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.237,
                0.488,
                0.825,
                0.664
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.405,
                0.673,
                0.66,
                0.688
            ],
            "angle": 0,
            "content": "图1 为航线系统建模的加权图"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.699,
                0.955,
                0.772
            ],
            "angle": 0,
            "content": "给每条边赋上一个数的图称为加权图。加权图用来为计算机网络建模。通信成本（比如租用电话线的月租费）、计算机在这些线路上的响应时间或计算机之间的距离等都可以用加权图来研究。图2显示三个加权图，它们表示给计算机网络图的边赋权的三种方式，分别对应于距离、响应时间和成本。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.775,
                0.955,
                0.925
            ],
            "angle": 0,
            "content": "与加权图有关的几种类型的问题经常出现。确定网络中两个顶点之间长度最短的通路就是一个这样的问题。说得更具体些，设加权图中一条通路的长度是这条通路上各条边的权的总和。（读者应当注意，对术语长度的这种用法，与表示不加权的图的通路中边数的长度的用法是不同的。）问题是：什么是最短通路，即什么是在两个给定顶点之间长度最短的通路？例如，在图1所示加权图表示的航线系统中，在波士顿与洛杉矶之间以空中距离计算的最短通路是什么？在波士顿与洛杉矶之间什么样的航班组合的总飞行时间（即在空中的总时间，不包括航班之间的时间）最短？在这两个城市之间的最低费用是多少？在图2所示的计算机网络中，连接旧金山的计算机与纽约的计算机所需要的最便宜的一组电话线是什么？哪一组电话线给出旧金"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.765,
                0.037,
                0.87,
                0.051
            ],
            "angle": 0,
            "content": "图 625"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.092,
                0.663,
                0.109
            ],
            "angle": 0,
            "content": "山与纽约之间通信的最快响应时间？哪一组电话线有最短的总距离？"
        },
        {
            "type": "image",
            "bbox": [
                0.207,
                0.114,
                0.749,
                0.277
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.206,
                0.285,
                0.75,
                0.474
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.206,
                0.496,
                0.75,
                0.669
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.342,
                0.674,
                0.618,
                0.689
            ],
            "angle": 0,
            "content": "图2 为计算机网络建模的加权图"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.7,
                0.905,
                0.755
            ],
            "angle": 0,
            "content": "与加权图有关的另外一个重要问题是：求访问完全图每个顶点恰好一次的、总长度最短的回路。这就是著名的旅行商问题，它求一位推销员应当以什么样的顺序来访问其路程上的每个城市恰好一次，使得他旅行的总距离最短。本节后面将讨论旅行商问题。"
        },
        {
            "type": "title",
            "bbox": [
                0.06,
                0.765,
                0.284,
                0.782
            ],
            "angle": 0,
            "content": "10.6.2 最短通路算法"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.783,
                0.903,
                0.799
            ],
            "angle": 0,
            "content": "求加权图中两个顶点之间的最短通路有多个不同的算法。下面将给出荷兰数学家E·迪克"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.802,
                0.599,
                0.856
            ],
            "angle": 0,
            "content": "斯特拉(Edsger Dijkstra)在1959年所发现的一个解决无向加权图中最短通路问题的算法，其中所有的权都是正数。可以很容易地将它修改来解决有向图里的最短通路问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.859,
                0.599,
                0.894
            ],
            "angle": 0,
            "content": "在给出这个算法的形式化表示之前，先给出一个启发性的例子。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.899,
                0.599,
                0.937
            ],
            "angle": 0,
            "content": "例1 在图3所示的加权图里， \\(a\\) 和 \\(z\\) 之间最短通路的长度是多少？"
        },
        {
            "type": "image",
            "bbox": [
                0.616,
                0.805,
                0.905,
                0.92
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.659,
                0.923,
                0.86,
                0.938
            ],
            "angle": 0,
            "content": "图3 一个加权的简单图"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.134,
                0.036,
                0.169,
                0.048
            ],
            "angle": 0,
            "content": "626"
        },
        {
            "type": "header",
            "bbox": [
                0.215,
                0.034,
                0.29,
                0.049
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.091,
                0.95,
                0.145
            ],
            "angle": 0,
            "content": "解 虽然通过观察可以很容易求出最短通路，但是需要一些有助于理解迪克斯特拉算法（Dijkstra's algorithm)的办法。解决这个问题的方法是：求出从 \\(a\\) 到各个后继顶点的最短通路，直到到达 \\(z\\) 为止。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.148,
                0.95,
                0.203
            ],
            "angle": 0,
            "content": "从 \\(a\\) 开始，不包含除 \\(a\\) 之外的顶点的唯一通路是增加一条以 \\(a\\) 为端点的边。这些通路仅有一条边，它们是长度分别为4和2的 \\(a, b\\) 和 \\(a, d\\) 。所以 \\(d\\) 是与 \\(a\\) 最靠近的顶点，从 \\(a\\) 到 \\(d\\) 的最短通路的长度是2。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.205,
                0.951,
                0.278
            ],
            "angle": 0,
            "content": "可以通过查看所有以 \\(a\\) 为起点到集合 \\(\\{a, d\\}\\) 中的顶点的最短通路，找到第二个最近的顶点，接着的边以 \\(\\{a, d\\}\\) 中的一个顶点为端点，另一个顶点不在该集合中。有两条这样的通路，\\(a, d, e\\) 长度为7，\\(a, b\\) 长度为4。所以，第二个与 \\(a\\) 最靠近的顶点是 \\(b\\)，从 \\(a\\) 到 \\(b\\) 的最短通路的长度是4。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.281,
                0.951,
                0.374
            ],
            "angle": 0,
            "content": "为了找出第三个与 \\(a\\) 最靠近的顶点，只需要检查那些以 \\(a\\) 为起点到集合 \\(\\{a, d, b\\}\\) 中的顶点的最短通路，接着的边以 \\(\\{a, d, b\\}\\) 中的一个顶点为端点，另一个顶点不在该集合中。有3条这样的通路：长度为7到 \\(c\\) 的通路，即 \\(a, b, c\\)；长度为7到 \\(e\\) 的通路，即 \\(a, b, e\\)；以及长度为5到 \\(e\\) 的通路，即 \\(a, d, e\\)。因为最短的通路是 \\(a, d, e\\)，所以 \\(e\\) 是第三个与 \\(a\\) 最靠近的顶点，而且从 \\(a\\) 到 \\(e\\) 的最短通路的长度为5。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.376,
                0.951,
                0.469
            ],
            "angle": 0,
            "content": "为了找出第四个与 \\(a\\) 最靠近的顶点，只需要检查那些以 \\(a\\) 为起点到集合 \\(\\{a, d, b, e\\}\\) 中的顶点的最短通路，接着的边以 \\(\\{a, d, b, e\\}\\) 中的一个顶点为端点，另一个顶点不在该集合中。有两条这样的通路：长度为7到 \\(c\\) 的通路，即 \\(a, b, c\\)；以及长度为6到 \\(z\\) 的通路，即 \\(a, d, e, z\\)。因为相对短的通路是 \\(a, d, e, z\\)，所以 \\(z\\) 是第四个与 \\(a\\) 最靠近的顶点，而且从 \\(a\\) 到 \\(z\\) 的最短通路的长度为6。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.471,
                0.95,
                0.526
            ],
            "angle": 0,
            "content": "例1说明了在迪克斯特拉算法中使用的一般原理。注意通过检查每条从 \\(a\\) 到 \\(z\\) 的通路就可以求出从 \\(a\\) 到 \\(z\\) 的最短通路。不过，无论对人还是对计算机来说，这种方法对于边数很多的图都是不切实际的。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.529,
                0.951,
                0.602
            ],
            "angle": 0,
            "content": "现在将考虑一般问题：在无向连通简单加权图中，求出 \\(a\\) 与 \\(z\\) 之间的最短通路的长度。迪克斯特拉算法如下进行：求出从 \\(a\\) 到第一个顶点的最短通路的长度，从 \\(a\\) 到第二个顶点的最短通路的长度，以此类推，直到求出从 \\(a\\) 到 \\(z\\) 的最短通路的长度为止。还有一个便利之处是，很容易扩展这个算法，求出从 \\(a\\) 到不只是 \\(z\\) 的所有顶点的最短通路的长度。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.604,
                0.951,
                0.678
            ],
            "angle": 0,
            "content": "这个算法依赖于一系列的迭代。通过在每次迭代中添加一个顶点来构造特殊顶点的集合。在每次迭代中完成一个标记过程。在这个标记过程中，用只包含特殊顶点集合中的顶点的从 \\(a\\) 到 \\(\\varpi\\) 的最短通路的长度来标记 \\(\\varpi\\) 。添加到特殊顶点集合中的顶点是尚在集合之外的那些顶点中带有最小标记的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.681,
                0.951,
                0.698
            ],
            "angle": 0,
            "content": "现在给出迪克斯特拉算法的细节。它首先用0标记 \\(a\\) 而用 \\(\\infty\\) 标记其余的顶点。用记号"
        },
        {
            "type": "title",
            "bbox": [
                0.106,
                0.706,
                0.175,
                0.727
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.108,
                0.74,
                0.25,
                0.853
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.107,
                0.858,
                0.248,
                0.867
            ],
            "angle": 0,
            "content": "Source: Hamilton Richards"
        },
        {
            "type": "text",
            "bbox": [
                0.267,
                0.74,
                0.951,
                0.843
            ],
            "angle": 0,
            "content": "爱德思葛·韦伯·迪克斯特拉（Edsger Wybe Dijkstra，1930—2002）迪克斯特拉出生在荷兰。20世纪50年代初期，当他在雷登大学学习理论物理时，他就开始编写计算机程序。1952年，当他意识到自己对程序设计比对物理学更感兴趣时，他迅速地完成了物理学课程的学习，转而开始程序员生涯，尽管当时程序设计还没有被认为是一种职业。（1957年，阿姆斯特丹当局拒绝接受他在结婚证上的工作一栏里把“程序设计”作为职业。无奈之下，他只好改成了“理论物理学家”。）"
        },
        {
            "type": "text",
            "bbox": [
                0.269,
                0.846,
                0.951,
                0.878
            ],
            "angle": 0,
            "content": "迪克斯特拉一直是把程序设计作为一个科学学科的最有力的倡导者之一。他在下述领域做出了奠基性的贡献：操作系统，其中包括死锁避免；程序设计语言，其"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.882,
                0.951,
                0.932
            ],
            "angle": 0,
            "content": "中包括结构化程序设计的概念；以及算法。1972年迪克斯特拉获得了计算机学会颁发的图灵奖，这是计算机科学里最具影响力的奖项之一。1973年迪克斯特拉，成为伯劳福斯研究员，1984年他被任命为得克萨斯大学奥斯丁分校的计算机科学教授。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.766,
                0.034,
                0.873,
                0.049
            ],
            "angle": 0,
            "content": "图 627"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.089,
                0.902,
                0.145
            ],
            "angle": 0,
            "content": "\\(L_{0}(a) = 0\\) 和 \\(L_{0}(v) = \\infty\\) 表示在没有发生任何迭代之前的这些标记（下标0表示“第0次”迭代）。这些标记是从 \\(a\\) 到这些顶点的最短通路的长度，其中这些通路只包含顶点 \\(a\\)。（因为不存在从 \\(a\\) 到其他顶点的这种通路，所以 \\(\\infty\\) 是 \\(a\\) 与这样的顶点之间的最短通路的长度。）"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.147,
                0.902,
                0.204
            ],
            "angle": 0,
            "content": "迪克斯特拉算法是通过形成特殊顶点的集合来进行的。设 \\(S_{k}\\) 表示在标记过程 \\(k\\) 次迭代之后的特殊顶点集。首先令 \\(S_0 = \\varnothing\\) 。集合 \\(S_{k}\\) 是通过把不属于 \\(S_{k - 1}\\) 的带最小标记的顶点 \\(u\\) 添加到\\(S_{k - 1}\\) 里形成的。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.205,
                0.902,
                0.281
            ],
            "angle": 0,
            "content": "一旦把 \\(u\\) 添加到 \\(S_{k}\\) 中，就更新所有不属于 \\(S_{k}\\) 的顶点的标记，使得顶点 \\(\\mathcal{V}\\) 在第 \\(k\\) 个阶段的标记 \\(L_{k}(v)\\) 是只包含 \\(S_{k}\\) 中顶点（即已有的特殊顶点再加上 \\(u\\)）的从 \\(a\\) 到 \\(v\\) 的最短通路的长度。注意，在每一步中选择添加到 \\(S_{k}\\) 中的顶点 \\(u\\)，都是一个最优选择，使之成为贪婪算法（我们将简要证明这个贪婪算法总是得到最优解）。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.282,
                0.902,
                0.359
            ],
            "angle": 0,
            "content": "设 \\(v\\) 是不属于 \\(S_{k}\\) 的一个顶点。更新 \\(v\\) 的标记，注意 \\(L_{k}(v)\\) 是只包含 \\(S_{k}\\) 中顶点的从 \\(a\\) 到 \\(v\\) 的最短通路的长度。当利用下面的观察结果时，就可以有效地完成这个更新：只包含 \\(S_{k}\\) 中顶点的从 \\(a\\) 到 \\(v\\) 的最短通路，要么是只包含 \\(S_{k-1}\\) 中顶点（即不包括 \\(u\\) 在内的特殊顶点）的从 \\(a\\) 到 \\(v\\) 的最短通路，要么是在第 \\(k-1\\) 阶段加上边 \\((u, v)\\) 的从 \\(a\\) 到 \\(u\\) 的最短通路。换句话说，"
        },
        {
            "type": "equation",
            "bbox": [
                0.261,
                0.361,
                0.697,
                0.378
            ],
            "angle": 0,
            "content": "\\[\nL _ {k} (a, v) = \\min  \\left\\{L _ {k - 1} (a, v), L _ {k - 1} (a, u) + w (u, v) \\right\\}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.38,
                0.902,
                0.435
            ],
            "angle": 0,
            "content": "其中，\\(w(u, v)\\) 是以 \\(u\\) 和 \\(v\\) 为端点的边的长度。这个过程这样迭代：依次添加顶点到特殊顶点集中，直到添加 \\(z\\) 为止。当把 \\(z\\) 添加到特殊顶点集中时，它的标记就是从 \\(a\\) 到 \\(z\\) 的最短通路的长度。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.437,
                0.902,
                0.474
            ],
            "angle": 0,
            "content": "算法1是迪克斯特拉算法。随后将证明这个算法的正确性。注意，当继续这个过程直到所有顶点都加入到特殊顶点集中时，就可以求出从 \\(a\\) 到图中所有其他顶点的最短通路的长度。"
        },
        {
            "type": "title",
            "bbox": [
                0.072,
                0.494,
                0.273,
                0.509
            ],
            "angle": 0,
            "content": "算法1 迪克斯特拉算法"
        },
        {
            "type": "code",
            "bbox": [
                0.071,
                0.512,
                0.867,
                0.759
            ],
            "angle": 0,
            "content": "procedure Dijkstra(G:所有权都为正数的带权连通简单图)  \n\\(\\{G\\) 带有顶点 \\(a = v_{0},v_{1},\\dots ,v_{n} = z\\) 和权 \\(\\omega (v_i,v_j)\\) ，其中若 \\(\\{v_i,v_j\\}\\) 不是 \\(G\\) 的边，则 \\(\\omega (v_i,v_j) = \\infty \\}\\)   \nfor \\(i\\coloneqq 1\\) to \\(n\\) （204  \n\\(L(v_{i}):= \\infty\\)   \n\\(L(a):= 0\\)   \n\\(S:= \\emptyset\\)   \n\\(\\{\\) 现在初始化标记，使得 \\(a\\) 的标记为0而所有其余标记为 \\(\\infty\\) ， \\(S\\) 是空集合\\(\\}\\)   \nwhile \\(z\\notin S\\) （20号  \n\\(u:= a\\) 不属于 \\(S\\) 的 \\(L(u)\\) 最小的一个顶点  \n\\(S:= S\\bigcup \\{u\\}\\)   \nfor所有不属于 \\(S\\) 的顶点 \\(v\\) （204 if \\(L(u) + w(u,v) <   L(v)\\) then \\(L(v):= L(u) + w(u,v)\\) （204  \n\\(\\{\\) 这样就给 \\(S\\) 中添加带最小标记的顶点，并且更新不在 \\(S\\) 中的顶点的标记\\(\\}\\)   \nreturn \\(L(z)\\{L(z)=\\) 从 \\(a\\) 到 \\(z\\) 的最短通路的长度\\(\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.776,
                0.902,
                0.814
            ],
            "angle": 0,
            "content": "例2 说明了迪克斯特拉算法是如何工作的。随后我们将证明这个算法总是产生加权图中两个顶点之间最短通路的长度。"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.818,
                0.829,
                0.836
            ],
            "angle": 0,
            "content": "例2用迪克斯特拉算法求图4a所示的加权图中顶点 \\(a\\) 与 \\(\\textbf{z}\\) 之间最短通路的长度。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.84,
                0.905,
                0.896
            ],
            "angle": 0,
            "content": "解图4显示了迪克斯特拉算法求 \\(a\\) 与 \\(z\\) 之间最短通路所用的步骤。在算法的每次迭代中，用圆圈圈起集合 \\(S_{k}\\) 中的顶点。每次迭代都只标明从 \\(a\\) 到 \\(S_{k}\\) 中的每个顶点的最短通路。当圆圈圈到 \\(z\\) 时，算法终止。找到从 \\(a\\) 到 \\(z\\) 的最短通路是 \\(a, c, b, d, e, z\\) ，长度为13。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.898,
                0.904,
                0.935
            ],
            "angle": 0,
            "content": "评注 在执行迪克斯特拉算法时，为了更便于在每步跟踪顶点的标记，有时可以用一个表来代替，而不再对每步都重新画出这个图。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.136,
                0.034,
                0.172,
                0.048
            ],
            "angle": 0,
            "content": "628"
        },
        {
            "type": "header",
            "bbox": [
                0.216,
                0.033,
                0.294,
                0.049
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "image",
            "bbox": [
                0.111,
                0.095,
                0.952,
                0.501
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.335,
                0.511,
                0.728,
                0.527
            ],
            "angle": 0,
            "content": "图4 用迪克斯特拉算法求从 \\(a\\) 到 \\(z\\) 的最短通路"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.537,
                0.953,
                0.572
            ],
            "angle": 0,
            "content": "下一步，用归纳论证来证明迪克斯特拉算法产生无向连通加权图中两个顶点 \\(a\\) 与 \\(z\\) 之间最短通路的长度。用下列断言作为归纳假设：在第 \\(k\\) 次迭代"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.575,
                0.752,
                0.59
            ],
            "angle": 0,
            "content": "(i) \\(S\\) 中的顶点 \\(v(v \\neq 0)\\) 的标记是从 \\(a\\) 到这个顶点的最短通路的长度。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.594,
                0.952,
                0.628
            ],
            "angle": 0,
            "content": "(ii) 不在 \\(S\\) 中的顶点的标记是（这个顶点自身除外）只包含 \\(S\\) 中顶点的从 \\(a\\) 到这个顶点的最短通路的长度。"
        },
        {
            "type": "list",
            "bbox": [
                0.106,
                0.575,
                0.952,
                0.628
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.632,
                0.953,
                0.667
            ],
            "angle": 0,
            "content": "当 \\(k = 0\\) 时，在没有执行任何迭代之前，\\(S = \\emptyset\\)，所以从 \\(a\\) 到除 \\(a\\) 外的顶点的最短通路的长度是 \\(\\infty\\)。所以基础步骤成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.67,
                0.955,
                0.724
            ],
            "angle": 0,
            "content": "假设对于第 \\(k\\) 次迭代，归纳假设成立。设 \\(\\mathcal{V}\\) 是在第 \\(k + 1\\) 次迭代时添加到 \\(S\\) 中的顶点，则 \\(\\mathcal{V}\\) 是在第 \\(k\\) 次迭代结束时带最小标记的不在 \\(S\\) 中的顶点（若有最小标记相同的顶点，可以采用带最小标记的任意顶点）。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.727,
                0.955,
                0.838
            ],
            "angle": 0,
            "content": "根据归纳假设，可以看出在第 \\(k + 1\\) 次迭代之前，\\(S\\) 中的顶点都用从 \\(a\\) 出发的最短通路的长度来标记。而且，\\(v\\) 也一定是用从 \\(a\\) 到 \\(v\\) 的最短通路的长度来标记。假如情况不是这样，那么在第 \\(k\\) 次迭代结束时，就可能存在包含不在 \\(S\\) 中的顶点长度小于 \\(L_{k}(v)\\) 的通路（因为 \\(L_{k}(v)\\) 是在第 \\(k\\) 次迭代后，只包含 \\(S\\) 中顶点的从 \\(a\\) 到 \\(v\\) 的最短通路的长度）。设 \\(u\\) 是在这样的通路中不属于 \\(S\\) 的第一个顶点。则存在一条只包含 \\(S\\) 中顶点的从 \\(a\\) 到 \\(u\\) 的长度小于 \\(L_{k}(v)\\) 的通路。这与 \\(v\\) 的选择相矛盾。因此，在第 \\(k + 1\\) 次迭代结束时 (i) 成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.841,
                0.955,
                0.933
            ],
            "angle": 0,
            "content": "设 \\(u\\) 是在第 \\(k + 1\\) 次迭代后不属于 \\(S\\) 的一个顶点。只包含 \\(S\\) 中顶点的从 \\(a\\) 到 \\(u\\) 的最短通路要么包含 \\(v\\) 要么不包含 \\(v\\) 。若它不包含 \\(v\\) ，则根据归纳假设，它的长度是 \\(L_{k}(u)\\) 。若它确实包含 \\(v\\) ，则它必然是这样组成的：一条只包含 \\(S\\) 中除 \\(v\\) 之外的顶点的从 \\(a\\) 到 \\(v\\) 的最短长度的通路，后面接着从 \\(v\\) 到 \\(u\\) 的边。这时，它的长度是 \\(L_{k}(v) + w(v,u)\\) 。这样就证明了(ii)为真，因为\\(L_{k + 1}(u) = \\min \\{L_k(u),L_k(v) + w(v,u)\\}\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.062,
                0.669,
                0.094,
                0.696
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.771,
                0.042,
                0.877,
                0.056
            ],
            "angle": 0,
            "content": "图 629"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.097,
                0.359,
                0.113
            ],
            "angle": 0,
            "content": "下面描述已经证明了的定理。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.123,
                0.856,
                0.14
            ],
            "angle": 0,
            "content": "定理1 迪克斯特拉算法求出连通简单无向加权图中两个顶点之间最短通路的长度。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.149,
                0.907,
                0.279
            ],
            "angle": 0,
            "content": "现在可以估计迪克斯特拉算法的计算复杂度（就加法和比较而言）。这个算法使用的迭代次数不超过 \\( n - 1 \\) 次，其中 \\( n \\) 是图中顶点的个数，因为在每次迭代时添加一个顶点到特殊顶点集中。若可以估计每次迭代所使用的运算次数，则大功告成。可以用不超过 \\( n - 1 \\) 次比较来找出不在 \\( S_{k} \\) 中的带最小标记的顶点。于是我们使用一次加法和一次比较来更新不在 \\( S_{k} \\) 中的每个顶点的标记，所以每次迭代的运算不超过 \\( 2(n - 1) \\) 次，因为每次迭代要更新的标记不超过 \\( n - 1 \\) 个。因为迭代次数不超过 \\( n - 1 \\) 次，每次迭代的运算次数不超过 \\( 2(n - 1) \\) 次，所以有定理2。"
        },
        {
            "type": "text",
            "bbox": [
                0.071,
                0.289,
                0.898,
                0.326
            ],
            "angle": 0,
            "content": "定理2 迪克斯特拉算法使用 \\(O(n^{2})\\) 次运算（加法和比较）求出含有 \\(n\\) 个顶点的连通简单无向加权图中两个顶点之间最短通路的长度。"
        },
        {
            "type": "title",
            "bbox": [
                0.062,
                0.343,
                0.265,
                0.36
            ],
            "angle": 0,
            "content": "10.6.3 旅行商问题"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.363,
                0.909,
                0.532
            ],
            "angle": 0,
            "content": "现在讨论与加权图有关的一个重要问题。考虑下面的问题：一位旅行商想要访问 \\( n \\) 个城市中每个城市恰好一次，并返回到出发点。例如，假定这个旅行商想要访问底特律、托莱多、萨吉诺、大急流域以及卡拉玛祖（见图5）。他应当以什么顺序访问这些城市以便旅行总距离最短？为了解决这个问题，可以假定旅行商从底特律出发（因为这个城市必须是回路的一部分），并且检查他访问其余4个城市然后返回底特律的所有可能方式（从别处出发将产生相同的回路）。这样的回路总共有24条，但是因为往返路程距离相同，所以在求最短总距离时，只需要考虑12条不同的回路即可。列出这12条不同回路和每条回路旅行的最短总距离。从下表可以看出，使用回路底特律-托莱多-卡拉玛祖格-大急流域-萨吉诺（或该回路的逆），对应458英里的最短总距离。"
        },
        {
            "type": "image",
            "bbox": [
                0.209,
                0.54,
                0.761,
                0.807
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.356,
                0.823,
                0.614,
                0.838
            ],
            "angle": 0,
            "content": "图5 显示5个城市间距离的图"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.849,
                0.909,
                0.904
            ],
            "angle": 0,
            "content": "上面描述了旅行商问题的一个实例。旅行商问题求加权完全无向图中访问每个顶点恰好一次并且返回出发点的总权值最小的回路。这等价于求完全图中总权值最小的哈密顿回路，因为在回路中访问每个顶点恰好一次。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.136,
                0.043,
                0.172,
                0.056
            ],
            "angle": 0,
            "content": "630"
        },
        {
            "type": "header",
            "bbox": [
                0.217,
                0.042,
                0.292,
                0.056
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "table",
            "bbox": [
                0.108,
                0.097,
                0.954,
                0.355
            ],
            "angle": 0,
            "content": "<table><tr><td>路 线</td><td>总距离(英里)</td></tr><tr><td>底特律-托莱多-大急流域-萨吉诺-卡拉玛祖-底特律</td><td>610</td></tr><tr><td>底特律-托莱多-大急流域-卡拉玛祖-萨吉诺-底特律</td><td>516</td></tr><tr><td>底特律-托莱多-卡拉玛祖-萨吉诺-大急流域-底特律</td><td>588</td></tr><tr><td>底特律-托莱多-卡拉玛祖-大急流域-萨吉诺-底特律</td><td>458</td></tr><tr><td>底特律-托莱多-萨吉诺-卡拉玛祖-大急流域-底特律</td><td>540</td></tr><tr><td>底特律-托莱多-萨吉诺-大急流域-卡拉玛祖-底特律</td><td>504</td></tr><tr><td>底特律-萨吉诺-托莱多-大急流域-卡拉玛祖-底特律</td><td>598</td></tr><tr><td>底特律-萨吉诺-托莱多-卡拉玛祖-大急流域-底特律</td><td>576</td></tr><tr><td>底特律-萨吉诺-卡拉玛祖-托莱多-大急流域-底特律</td><td>682</td></tr><tr><td>底特律-萨吉诺-大急流域-托莱多-卡拉玛祖-底特律</td><td>646</td></tr><tr><td>底特律-大急流域-萨吉诺-托莱多-卡拉玛祖-底特律</td><td>670</td></tr><tr><td>底特律-大急流域-托莱多-萨吉诺-卡拉玛祖-底特律</td><td>728</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.368,
                0.955,
                0.519
            ],
            "angle": 0,
            "content": "求解旅行商问题实例最直截了当的方式是检查所有可能的哈密顿回路，并选择总权值最小的一条回路。若在图中有 \\(n\\) 个城市，则为了求解这个问题，需要检查多少条回路？一旦选定了出发点，需要检查的不同的哈密顿回路就有 \\((n - 1)!\\) 条，因为第二个顶点有 \\(n - 1\\) 种选择，第三个顶点有 \\(n - 2\\) 种选择，以此类推。因为可以用相反顺序来经过一条哈密顿回路，所以只需要检查 \\((n - 1)! / 2\\) 条回路来求出答案。注意 \\((n - 1)! / 2\\) 增长得极快。当只有几十个顶点时，试图用这种方式来解决旅行商问题就是不切实际的。例如，假如有25个顶点，那么就不得不考虑总共 \\(24! / 2\\) （约为 \\(3.1\\times 10^{23}\\) )条不同的哈密顿回路。假定检查每条哈密顿回路只花费1纳秒\\((10^{-9}\\) 秒)，那么就需要大约1000万年才能求出这个图中长度最短的一条哈密顿回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.521,
                0.955,
                0.613
            ],
            "angle": 0,
            "content": "因为旅行商问题在实践和理论上都具有重要意义，所以已经投入了巨大的努力来设计解决它的有效算法。不过，还没有已知的解决这个问题的多项式最坏情形时间复杂度的算法。而且，假如这种算法找到了，那么许多其他难题（比如在第1章里讨论过的确定 \\(n\\) 个变元的命题公式是否重言式）也可以用多项式最坏情形时间复杂度的算法求解。这个结果是从NP完全性理论得出的（关于这个理论的更多信息请参考[GaJo79]）。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.616,
                0.955,
                0.748
            ],
            "angle": 0,
            "content": "当有许多需要访问的顶点时，解决旅行商问题的实际方法是使用近似算法。近似算法是这样的算法，它们不必产生问题的精确解，取而代之的是保证产生接近精确解的解。（参见第3章补充练习中练习46的前导文。）即它们可能产生带总权数 \\( W' \\) 的哈密顿回路，使得 \\( W \\leqslant W' \\leqslant cW \\)，其中 \\( W \\) 是精确解的总长度，而 \\( c \\) 是一个常数。例如，存在多项式最坏情形时间复杂度算法使得 \\( c = 3/2 \\) 。对于一般加权图和每个正实数 \\( k \\) 来说，总是产生最多 \\( k \\) 倍于最优解的解的算法还是未知的。假如这样的算法存在，那就可能证明P类等于NP类，这是关于算法复杂度的最著名的开放问题（参见3.3节）。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.75,
                0.955,
                0.824
            ],
            "angle": 0,
            "content": "在实际中，已经研究出这样的算法，它们可以只用几分钟的计算机时间，就可以解决多达1000个顶点的旅行商问题，误差在精确解的 \\(2\\%\\) 之内。关于旅行商问题的更多信息，包括历史、应用和算法等，见《离散数学的应用》（Applications of Discrete Mathematics）[MiRo91]中关于这个主题的那一章，也可以从这本书的网站获得。"
        },
        {
            "type": "title",
            "bbox": [
                0.11,
                0.835,
                0.156,
                0.85
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.854,
                0.795,
                0.869
            ],
            "angle": 0,
            "content": "1. 对下列关于地铁系统的每个问题，描述一个可以用来解决这个问题的加权图模型。"
        },
        {
            "type": "text",
            "bbox": [
                0.13,
                0.873,
                0.498,
                0.887
            ],
            "angle": 0,
            "content": "a)在两站之间旅行所需要的最短时间是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.13,
                0.89,
                0.534,
                0.904
            ],
            "angle": 0,
            "content": "b)从一站到达另外一站所经过的最短距离是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.908,
                0.737,
                0.94
            ],
            "angle": 0,
            "content": "c)若把各站之间的票价求和就得出总票价，则两站之间的最低票价是什么？在练习 \\(2\\sim 4\\) 中，求给定加权图在 \\(a\\) 与 \\(z\\) 之间的最短通路的长度。"
        },
        {
            "type": "list",
            "bbox": [
                0.107,
                0.873,
                0.737,
                0.94
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.77,
                0.034,
                0.874,
                0.048
            ],
            "angle": 0,
            "content": "图 631"
        },
        {
            "type": "image",
            "bbox": [
                0.059,
                0.089,
                0.38,
                0.205
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.39,
                0.089,
                0.838,
                0.188
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.059,
                0.207,
                0.504,
                0.322
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.324,
                0.599,
                0.339
            ],
            "angle": 0,
            "content": "5. 求在练习 \\(2 \\sim 4\\) 的每个加权图中，\\(a\\) 与 \\(z\\) 之间的最短通路是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.341,
                0.593,
                0.356
            ],
            "angle": 0,
            "content": "6. 在练习3的加权图中，求下列成对顶点之间的最短通路的长度。"
        },
        {
            "type": "list",
            "bbox": [
                0.057,
                0.324,
                0.599,
                0.356
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.359,
                0.151,
                0.373
            ],
            "angle": 0,
            "content": "a) \\( a \\) 和 \\( d \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.284,
                0.36,
                0.353,
                0.373
            ],
            "angle": 0,
            "content": "b) \\(a\\) 和 \\(f\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.46,
                0.36,
                0.525,
                0.373
            ],
            "angle": 0,
            "content": "c)c和f"
        },
        {
            "type": "text",
            "bbox": [
                0.635,
                0.36,
                0.7,
                0.373
            ],
            "angle": 0,
            "content": "d) \\(b\\) 和 \\(z\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.376,
                0.574,
                0.391
            ],
            "angle": 0,
            "content": "7. 在练习3的加权图中，求练习6的成对顶点之间的最短通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.394,
                0.686,
                0.409
            ],
            "angle": 0,
            "content": "8. 在图1所示的航线系统中，求下列每对城市之间的最短通路（以英里表示）。"
        },
        {
            "type": "list",
            "bbox": [
                0.057,
                0.376,
                0.686,
                0.409
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.411,
                0.214,
                0.425
            ],
            "angle": 0,
            "content": "a) 纽约与洛杉矶"
        },
        {
            "type": "text",
            "bbox": [
                0.285,
                0.412,
                0.434,
                0.425
            ],
            "angle": 0,
            "content": "b)波士顿与旧金山"
        },
        {
            "type": "text",
            "bbox": [
                0.461,
                0.412,
                0.59,
                0.425
            ],
            "angle": 0,
            "content": "c)迈阿密与丹佛"
        },
        {
            "type": "text",
            "bbox": [
                0.635,
                0.412,
                0.785,
                0.425
            ],
            "angle": 0,
            "content": "d)迈阿密与洛杉矶"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.429,
                0.796,
                0.443
            ],
            "angle": 0,
            "content": "9. 利用图1所示的飞行时间，求连接练习8中成对城市之间的总飞行时间最短的航班组合。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.446,
                0.713,
                0.461
            ],
            "angle": 0,
            "content": "10. 利用图1所示的票价，求连接练习8中成对城市之间的票价最低的航班组合。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.464,
                0.75,
                0.478
            ],
            "angle": 0,
            "content": "11. 在图2所示的通信网络里，求下列每对城市的计算机中心之间的(距离)最短路线。"
        },
        {
            "type": "list",
            "bbox": [
                0.057,
                0.429,
                0.796,
                0.478
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.481,
                0.242,
                0.496
            ],
            "angle": 0,
            "content": "a) 波士顿与洛杉矶"
        },
        {
            "type": "text",
            "bbox": [
                0.285,
                0.481,
                0.416,
                0.495
            ],
            "angle": 0,
            "content": "b)纽约与旧金山"
        },
        {
            "type": "text",
            "bbox": [
                0.461,
                0.482,
                0.608,
                0.495
            ],
            "angle": 0,
            "content": "c)达拉斯与旧金山"
        },
        {
            "type": "text",
            "bbox": [
                0.635,
                0.482,
                0.748,
                0.495
            ],
            "angle": 0,
            "content": "d)丹佛与纽约"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.499,
                0.814,
                0.514
            ],
            "angle": 0,
            "content": "12. 利用在图 2 给出的响应时间，求在练习 11 中成对的计算机中心之间响应时间最短的路线。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.517,
                0.778,
                0.531
            ],
            "angle": 0,
            "content": "13. 利用在图2给出的租费，求在练习11中成对的计算机中心之间月租费最便宜的路线。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.535,
                0.769,
                0.548
            ],
            "angle": 0,
            "content": "14. 解释把无向图中两个顶点之间边数最少的通路当作加权图中最短通路来求解的过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.552,
                0.903,
                0.583
            ],
            "angle": 0,
            "content": "15. 扩展求加权简单连通图中两个顶点之间最短通路的迪克斯特拉算法，以便求出顶点 \\(a\\) 与图中其余每个顶点之间的最短通路的长度。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.587,
                0.903,
                0.618
            ],
            "angle": 0,
            "content": "16. 扩展求带权简单连通图中两个顶点之间最短通路的迪克斯特拉算法，以便构造出在这些顶点之间的最短通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.621,
                0.903,
                0.653
            ],
            "angle": 0,
            "content": "17. 在下图中的加权图说明新泽西的一些主要道路。图a说明这些道路上的城市之间的距离；图b说明通行费。"
        },
        {
            "type": "list",
            "bbox": [
                0.058,
                0.499,
                0.903,
                0.653
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.09,
                0.655,
                0.481,
                0.877
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.289,
                0.886,
                0.309,
                0.897
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "image",
            "bbox": [
                0.513,
                0.655,
                0.905,
                0.877
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.719,
                0.887,
                0.74,
                0.897
            ],
            "angle": 0,
            "content": "b）"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.901,
                0.824,
                0.916
            ],
            "angle": 0,
            "content": "a)利用这些道路，求在纽华克与卡姆登之间，以及在纽华克与五月角之间距离最短的路线。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.919,
                0.75,
                0.934
            ],
            "angle": 0,
            "content": "b)利用给出的道路图，求在本题a中成对城市之间就总通行费而言最便宜的路线。"
        },
        {
            "type": "list",
            "bbox": [
                0.089,
                0.901,
                0.824,
                0.934
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.122,
                0.032,
                0.159,
                0.046
            ],
            "angle": 0,
            "content": "632"
        },
        {
            "type": "header",
            "bbox": [
                0.203,
                0.031,
                0.28,
                0.047
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.087,
                0.735,
                0.102
            ],
            "angle": 0,
            "content": "18. 若各边的权都是不同的，则在加权图中两个顶点之间的最短通路是否唯一？"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.106,
                0.661,
                0.121
            ],
            "angle": 0,
            "content": "19. 哪些应用必须求出加权图中两个顶点之间的最长简单通路的长度？"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.124,
                0.75,
                0.139
            ],
            "angle": 0,
            "content": "20. 什么是图4的加权图中 \\(a\\) 与 \\(z\\) 之间的最长简单通路的长度？在 \\(c\\) 与 \\(z\\) 之间呢？"
        },
        {
            "type": "list",
            "bbox": [
                0.093,
                0.087,
                0.75,
                0.139
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.142,
                0.938,
                0.175
            ],
            "angle": 0,
            "content": "弗洛伊德(Floyd)算法，如算法2所示，可以用来求出加权连通简单图中所有顶点对之间最短通路的长度。不过，不能用这个算法来构造最短通路（把无穷权值赋给任何一对不被图中的边所连接的顶点）。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.196,
                0.294,
                0.212
            ],
            "angle": 0,
            "content": "算法2 弗洛伊德算法"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.215,
                0.378,
                0.229
            ],
            "angle": 0,
            "content": "procedure Floyd(G: 带权简单图)"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.231,
                0.816,
                0.247
            ],
            "angle": 0,
            "content": "\\(\\{G\\) 有顶点 \\(v_{1}\\) ， \\(v_{2}\\) ，…， \\(v_{n}\\) 和权 \\(w(v_{i},v_{j})\\) ，其中若 \\((v_{i},\\bar{v}_{j})\\) 不是边，则 \\(w(v_{i},v_{j}) = \\infty \\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.251,
                0.227,
                0.264
            ],
            "angle": 0,
            "content": "for \\(i\\coloneqq 1\\) to \\(n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.269,
                0.256,
                0.282
            ],
            "angle": 0,
            "content": "for \\(j:=1\\) to \\(n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.166,
                0.286,
                0.359,
                0.301
            ],
            "angle": 0,
            "content": "\\(d(v_{i},v_{j}):= w(v_{i},v_{j})\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.305,
                0.227,
                0.318
            ],
            "angle": 0,
            "content": "for \\(i\\coloneqq 1\\) to \\(n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.323,
                0.256,
                0.336
            ],
            "angle": 0,
            "content": "for \\(j\\coloneqq 1\\) to \\(n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.166,
                0.34,
                0.284,
                0.353
            ],
            "angle": 0,
            "content": "for \\(k:=1\\) to \\(n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.193,
                0.357,
                0.489,
                0.372
            ],
            "angle": 0,
            "content": "if \\(d(v_{j},v_{i}) + d(v_{i},v_{k}) <   d(v_{j},v_{k})\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.212,
                0.375,
                0.541,
                0.39
            ],
            "angle": 0,
            "content": "then \\(d(v_{j},v_{k}):= d(v_{j},v_{i}) + d(v_{i},v_{k})\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.392,
                0.793,
                0.408
            ],
            "angle": 0,
            "content": "return \\(d(v_{i},v_{j})\\{d(v_{i},v_{j})\\) 是在 \\(\\boldsymbol{\\nu}_{i}\\) 与 \\(\\mathcal{V}_j\\) 之间的最短通路的长度， \\(1\\leqslant i\\leqslant n\\) ， \\(1\\leqslant j\\leqslant n\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.428,
                0.612,
                0.443
            ],
            "angle": 0,
            "content": "21. 用弗洛伊德算法求图4a中加权图中所有顶点对之间的距离。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.446,
                0.678,
                0.461
            ],
            "angle": 0,
            "content": "* 22. 证明：弗洛伊德算法确定加权简单图中所有顶点对之间的最短距离。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.464,
                0.942,
                0.498
            ],
            "angle": 0,
            "content": "* 23. 给出弗洛伊德算法为了确定在带有 \\( n \\) 个顶点的加权简单图中所有顶点对之间的最短距离而使用的运算（比较和加法）次数的大 \\( O \\) 估算。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.501,
                0.678,
                0.516
            ],
            "angle": 0,
            "content": "* 24. 证明：若边有负的权值，则迪克斯特拉算法或许不能给出正确答案。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.52,
                0.825,
                0.535
            ],
            "angle": 0,
            "content": "25. 通过求出所有哈密顿回路的总权值并确定总权值最小的回路来解决下图的旅行商问题。"
        },
        {
            "type": "list",
            "bbox": [
                0.081,
                0.428,
                0.942,
                0.535
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.127,
                0.538,
                0.268,
                0.618
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.62,
                0.827,
                0.635
            ],
            "angle": 0,
            "content": "26. 通过求出所有哈密顿回路的总权值并确定总权值最小的回路来解决下图的旅行商问题。"
        },
        {
            "type": "image",
            "bbox": [
                0.127,
                0.638,
                0.294,
                0.748
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.75,
                0.945,
                0.784
            ],
            "angle": 0,
            "content": "27. 求访问下图中每个城市的机票总价最低的路线，其中边上的权值是在这两个城市之间的航班所提供的最低票价。"
        },
        {
            "type": "image",
            "bbox": [
                0.127,
                0.786,
                0.586,
                0.894
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.896,
                0.945,
                0.93
            ],
            "angle": 0,
            "content": "28. 求访问下图中每个城市的机票总价最低的路线，其中边上的权值是在这两个城市之间的航班所提供的最低票价。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.759,
                0.038,
                0.865,
                0.053
            ],
            "angle": 0,
            "content": "图 633"
        },
        {
            "type": "image",
            "bbox": [
                0.078,
                0.093,
                0.491,
                0.199
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.201,
                0.893,
                0.234
            ],
            "angle": 0,
            "content": "29. 构造一个加权无向图，使得对于访问某些顶点超过一次的回路来说，访问每个顶点至少一次的回路的总权值是最小的。[提示：存在有3个顶点的例子。]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.236,
                0.894,
                0.287
            ],
            "angle": 0,
            "content": "30. 证明：求访问加权图每个顶点至少一次的总权值最小的回路问题，可以归约为求访问加权图每个顶点恰好一次的总权值最小的回路问题。这样做的方法是：构造一个新的加权图，它与原图有相同的顶点和边，但是连接顶点 \\(u\\) 和 \\(v\\) 的边的权却等于在原图中从 \\(u\\) 到 \\(v\\) 的通路的最小总权值数。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.29,
                0.893,
                0.324
            ],
            "angle": 0,
            "content": "31. 不含简单回路的加权有向图的最长通路问题是求图中的一个通路，该通路中边的权值之和是最大的。设计一个求解最长通路的算法。[提示：首先找到图中顶点的拓扑排序。]"
        },
        {
            "type": "list",
            "bbox": [
                0.047,
                0.201,
                0.894,
                0.324
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.049,
                0.338,
                0.208,
                0.357
            ],
            "angle": 0,
            "content": "10.7 平面图"
        },
        {
            "type": "title",
            "bbox": [
                0.049,
                0.365,
                0.184,
                0.382
            ],
            "angle": 0,
            "content": "10.7.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.385,
                0.44,
                0.516
            ],
            "angle": 0,
            "content": "考虑把三座房屋与三种设施的每种都连接起来的问题，如图1所示。是否有可能这样来连接这些房屋与设施，使得在这样的连接中不发生交叉？这个问题可以用完全二分图 \\(K_{3,3}\\) 来建模。原来的问题可以重新叙述为：能否在平面中画出 \\(K_{3,3}\\)，使得没有两条边发生交叉？"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.519,
                0.44,
                0.572
            ],
            "angle": 0,
            "content": "本节将研究能否在平面中让边不交叉地画出一个图的问题。特别是，将回答这个房屋与设施的问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.576,
                0.44,
                0.63
            ],
            "angle": 0,
            "content": "图的表示方式有许多种。何时有可能至少求出一种方式以便在平面中表示这个图而让边没有任何交叉？"
        },
        {
            "type": "image",
            "bbox": [
                0.457,
                0.387,
                0.877,
                0.608
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.563,
                0.615,
                0.788,
                0.63
            ],
            "angle": 0,
            "content": "图1 三座房屋与三种设施"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.639,
                0.885,
                0.694
            ],
            "angle": 0,
            "content": "定义1 若可以在平面中画出一个图而边没有任何交叉（其中边的交叉是表示边的直线或弧线在它们的公共端点以外的地方相交），则这个图是平面图。这种画法称为这个图的平面表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.704,
                0.894,
                0.739
            ],
            "angle": 0,
            "content": "即使通常交叉地画出了一个图，这个图也仍然可能是平面图，因为有可能以不同的方式不交叉地画出这个图。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.744,
                0.552,
                0.761
            ],
            "angle": 0,
            "content": "例1 \\(K_{4}\\) （如图2所示，有两条边交叉）是平面图吗？"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.766,
                0.643,
                0.782
            ],
            "angle": 0,
            "content": "解 \\(K_{4}\\) 是平面图，因为可以不带交叉地画出它，如图3所示。"
        },
        {
            "type": "image",
            "bbox": [
                0.19,
                0.802,
                0.321,
                0.89
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.204,
                0.895,
                0.304,
                0.91
            ],
            "angle": 0,
            "content": "图2 图 \\(K_{4}\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.611,
                0.786,
                0.771,
                0.891
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.592,
                0.895,
                0.785,
                0.91
            ],
            "angle": 0,
            "content": "图3 不带交叉的图 \\(K_{4}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.919,
                0.394,
                0.937
            ],
            "angle": 0,
            "content": "例2 图4所示的 \\(Q_{3}\\) 是平面图吗？"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.133,
                0.038,
                0.169,
                0.051
            ],
            "angle": 0,
            "content": "634"
        },
        {
            "type": "header",
            "bbox": [
                0.215,
                0.037,
                0.291,
                0.052
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.093,
                0.761,
                0.109
            ],
            "angle": 0,
            "content": "解 \\(Q_{3}\\) 是平面图，因为可以画出它而没有任何边交叉，如图5所示。"
        },
        {
            "type": "image",
            "bbox": [
                0.231,
                0.115,
                0.395,
                0.224
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.263,
                0.232,
                0.361,
                0.247
            ],
            "angle": 0,
            "content": "图4 图 \\(Q_{3}\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.666,
                0.116,
                0.828,
                0.224
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.643,
                0.232,
                0.851,
                0.247
            ],
            "angle": 0,
            "content": "图5 \\(Q_{3}\\) 的一种平面表示"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.254,
                0.951,
                0.308
            ],
            "angle": 0,
            "content": "可以通过显示一种平面表示来证明一个图是平面图。更难的是，证明一个图是非平面图。下面给出一个例子说明如何以一种特别的方法来做到这一点。后面将介绍一些可以使用的通用结论。"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.314,
                0.46,
                0.331
            ],
            "angle": 0,
            "content": "例3 图6所示的 \\(K_{3,3}\\) 是平面图吗？"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.335,
                0.953,
                0.424
            ],
            "angle": 0,
            "content": "解 任何在平面中画出 \\(K_{3,3}\\) 而没有边交叉的尝试都注定是失败的。现在说明这是为什么。在 \\(K_{3,3}\\) 的任何平面表示中，顶点 \\(v_{1}\\) 和 \\(v_{2}\\) 都必须同时与 \\(v_{4}\\) 和 \\(v_{5}\\) 连接。这四条边所形成的封闭曲线把平面分割成两个区域 \\(R_{1}\\) 和 \\(R_{2}\\)，如图7a所示。顶点 \\(v_{3}\\) 属于 \\(R_{1}\\) 或 \\(R_{2}\\)。当 \\(v_{3}\\) 属于闭曲线的内部 \\(R_{2}\\) 时，在 \\(v_{3}\\) 和 \\(v_{4}\\) 之间以及在 \\(v_{3}\\) 和 \\(v_{5}\\) 之间的边，把 \\(R_{2}\\) 分割成两个子区域 \\(R_{21}\\) 和 \\(R_{22}\\)，如图7b所示。"
        },
        {
            "type": "image",
            "bbox": [
                0.189,
                0.451,
                0.441,
                0.562
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.259,
                0.571,
                0.369,
                0.585
            ],
            "angle": 0,
            "content": "图6 图 \\(K_{3,3}\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.546,
                0.429,
                0.701,
                0.538
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.612,
                0.549,
                0.631,
                0.56
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "image",
            "bbox": [
                0.746,
                0.429,
                0.901,
                0.538
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.812,
                0.549,
                0.832,
                0.56
            ],
            "angle": 0,
            "content": "b）"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.614,
                0.57,
                0.836,
                0.585
            ],
            "angle": 0,
            "content": "图7 证明 \\(K_{3,3}\\) 是非平面图"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.591,
                0.953,
                0.644
            ],
            "angle": 0,
            "content": "下一步，已经没有办法不交叉地放置最后一个顶点 \\(v_{6}\\) 。因为若 \\(v_{6}\\) 属于 \\(R_{1}\\)，则不能不交叉地画出 \\(v_{6}\\) 和 \\(v_{3}\\) 之间的边。若 \\(v_{6}\\) 属于 \\(R_{21}\\)，则不能不交叉地画出 \\(v_{2}\\) 和 \\(v_{6}\\) 之间的边。若 \\(v_{6}\\) 属于 \\(R_{22}\\)，则不能不交叉地画出 \\(v_{1}\\) 和 \\(v_{6}\\) 之间的边。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.646,
                0.954,
                0.681
            ],
            "angle": 0,
            "content": "当 \\(v_{3}\\) 属于 \\(R_{1}\\) 时，可以使用类似的论证。请读者来完成这个论证（见本节练习10）。所以\\(K_{3,3}\\) 是非平面图。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.683,
                0.954,
                0.718
            ],
            "angle": 0,
            "content": "例3解决了在本节开头所描述的设施与房屋的问题。不能在平面中连接这三座房屋与三种设施而不发生交叉。可以用类似的论证来证明 \\(K_{5}\\) 是非平面图（见本节练习11）。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.721,
                0.955,
                0.832
            ],
            "angle": 0,
            "content": "平面图的应用 图的平面性在电子电路的设计中有重要作用。可以用图来为电路建立模型，用顶点表示电路的器件，用边表示器件之间的连接。如果表示一个电路的图是平面图，则可以把这个电路无交叉连接地印刷在单个电路板上。当这个图不是平面图时，就必须选择使用更高的成本。例如，可以把表示电路的图的顶点划分到平面子图。然后使用多层来构造这个电路（参见练习30的前导文来了解图的厚度）。当连接交叉时就可以用绝缘线来构造电路。在这种情况下，以尽可能少的交叉来画出这个图就很重要了（参见练习26的前导文来了解图的交叉数）。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.834,
                0.955,
                0.889
            ],
            "angle": 0,
            "content": "图的可平面性在公路网的设计中也很有用。假设我们要通过公路连接一组城市。我们可以使用简单图为连接这些城市的公路网建模，其中顶点表示城市，边表示连接城市的公路。若得到的图模型是平面图，那么在构造公路网时就不必使用地下通道或天桥。"
        },
        {
            "type": "title",
            "bbox": [
                0.112,
                0.899,
                0.292,
                0.916
            ],
            "angle": 0,
            "content": "10.7.2 欧拉公式"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.919,
                0.955,
                0.936
            ],
            "angle": 0,
            "content": "一个图的平面表示把平面分割成一些面(region)，包括一个无界的面。例如，图8所示的"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.771,
                0.036,
                0.877,
                0.051
            ],
            "angle": 0,
            "content": "图 635"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.092,
                0.905,
                0.128
            ],
            "angle": 0,
            "content": "图的平面表示把平面分割成6个面并加以标记。欧拉证明过一个图的所有平面表示都把平面分割成相同数目的面。他是通过求出平面图的面数、顶点数以及边数之间的关系进行证明的。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.136,
                0.896,
                0.173
            ],
            "angle": 0,
            "content": "定理1 欧拉公式 设 \\(G\\) 是带 \\(e\\) 条边和 \\(v\\) 个顶点的连通平面简单图。设 \\(r\\) 是 \\(G\\) 的平面图表示中的面数。则 \\(r = e - v + 2\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.182,
                0.906,
                0.294
            ],
            "angle": 0,
            "content": "证明首先规定 \\(G\\) 的平面图表示。将要这样证明定理：构造一系列子图 \\(G_{1}\\) ， \\(G_{2}\\) ，…，\\(G_{e} = G\\) ，依次在每个阶段添加一条边。用下面的归纳定义来这样做。任意地选择一条 \\(G\\) 的边来获得 \\(G_{1}\\) 。通过 \\(G_{n - 1}\\) 获得 \\(G_{n}\\) ：任意地添加一条与 \\(G_{n - 1}\\) 中顶点相关联的边，若与这条边关联的另一个顶点不在 \\(G_{n - 1}\\) 中，则添加这个顶点。这样的构造是可能的，因为 \\(G\\) 是连通的。在添加 \\(\\mathcal{e}\\) 条边之后就获得 \\(G\\) 。设 \\(r_n\\) 、 \\(e_n\\) 和 \\(\\upsilon_{n}\\) 分别表示由 \\(G\\) 的平面图表示所得到的 \\(G_{n}\\) 的平面图表示的面数、边数和顶点数。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.297,
                0.906,
                0.332
            ],
            "angle": 0,
            "content": "现在通过归纳来进行证明。对 \\(G_{1}\\) 来说，关系 \\(r_1 = e_1 - v_1 + 2\\) 为真，因为 \\(e_1 = 1\\) ， \\(v_{1} = 2\\) ，而\\(r_1 = 1\\) 。这种情形如图9所示。"
        },
        {
            "type": "image",
            "bbox": [
                0.13,
                0.338,
                0.401,
                0.426
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.18,
                0.434,
                0.348,
                0.448
            ],
            "angle": 0,
            "content": "图8 图的平面表示"
        },
        {
            "type": "image",
            "bbox": [
                0.631,
                0.388,
                0.77,
                0.426
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.569,
                0.434,
                0.829,
                0.448
            ],
            "angle": 0,
            "content": "图9 欧拉公式证明的基本情形"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.456,
                0.909,
                0.569
            ],
            "angle": 0,
            "content": "现在假定 \\(r_k = e_k - v_k + 2\\)。设 \\(\\{a_{k+1}, b_{k+1}\\}\\) 是为了获得 \\(G_{k+1}\\) 而添加到 \\(G_k\\) 上的边。有两种情形需要考虑。在第一种情形下，\\(a_{k+1}\\) 和 \\(b_{k+1}\\) 都已经在 \\(G_k\\) 中了。这两个顶点必然是在一个公共面 \\(R\\) 的边界上，否则就不可能把边 \\(\\{a_{k+1}, b_{k+1}\\}\\) 添加到 \\(G_k\\) 中而没有两条边相交叉（并且 \\(G_{k+1}\\) 是平面图）。这条新边的添加把 \\(R\\) 分割成两个面。所以，在这种情形下，\\(r_{k+1} = r_k + 1\\)，\\(e_{k+1} = e_k + 1\\)，\\(v_{k+1} = v_k\\)。因此，关系到面数、边数、顶点数的公式两边都恰好增加 1，所以这个公式仍然为真。换句话说，\\(r_{k+1} = e_{k+1} - v_{k+1} + 2\\)。在图 10a 里说明了这种情形。"
        },
        {
            "type": "image",
            "bbox": [
                0.148,
                0.575,
                0.455,
                0.737
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.282,
                0.749,
                0.303,
                0.761
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "image",
            "bbox": [
                0.514,
                0.574,
                0.818,
                0.732
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.642,
                0.749,
                0.664,
                0.761
            ],
            "angle": 0,
            "content": "b）"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.341,
                0.767,
                0.625,
                0.782
            ],
            "angle": 0,
            "content": "图10 添加一条边到 \\(G_{n}\\) 产生 \\(G_{n + 1}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.789,
                0.909,
                0.859
            ],
            "angle": 0,
            "content": "在第二种情形下，新边的两个顶点之一还不在 \\(G_{k}\\) 中。假定 \\(a_{k + 1}\\) 在 \\(G_{k}\\) 中但是 \\(b_{k + 1}\\) 不在 \\(G_{k}\\) 中。添加这条新边不产生任何新的面，因为 \\(b_{k + 1}\\) 必然是在边界上有 \\(a_{k + 1}\\) 的一个面中。所以，\\(r_{k + 1} = r_k\\)。另外，\\(e_{k + 1} = e_k + 1\\) 且 \\(v_{k + 1} = v_k + 1\\)。关系到面数、边数、顶点数的公式两边都保持相等，所以这个公式仍然为真。换句话说，\\(r_{k + 1} = e_{k + 1} - v_{k + 1} + 2\\)。在图10b里说明了这种情形。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.861,
                0.906,
                0.895
            ],
            "angle": 0,
            "content": "已经完成了归纳论证。因此，对所有的 \\(n\\) 来说，都有 \\(r_n = e_n - v_n + 2\\) 。因为原图是在添加了 \\(e\\) 条边之后所获得的图 \\(G_e\\) ，所以这个定理为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.898,
                0.299,
                0.914
            ],
            "angle": 0,
            "content": "例4解释了欧拉公式。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.919,
                0.909,
                0.936
            ],
            "angle": 0,
            "content": "例4假定连通平面简单图有20个顶点，每个顶点的度都为3。这个平面图的平面表示把"
        },
        {
            "type": "image",
            "bbox": [
                0.919,
                0.182,
                0.949,
                0.208
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.122,
                0.036,
                0.159,
                0.05
            ],
            "angle": 0,
            "content": "636"
        },
        {
            "type": "header",
            "bbox": [
                0.204,
                0.035,
                0.28,
                0.05
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.091,
                0.294,
                0.107
            ],
            "angle": 0,
            "content": "平面分割成多少个面？"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.11,
                0.938,
                0.145
            ],
            "angle": 0,
            "content": "解 这个图有20个顶点，每个顶点的度都为3，所以 \\(v = 20\\) 。因为这些顶点的度之和 \\(3v = 3 \\cdot 20 = 60\\) 等于边数的两倍 \\(2e\\) ，所以有 \\(2e = 60\\) 或 \\(e = 30\\) 。因此，根据欧拉公式，面数是"
        },
        {
            "type": "equation",
            "bbox": [
                0.391,
                0.149,
                0.648,
                0.163
            ],
            "angle": 0,
            "content": "\\[\nr = e - v + 2 = 3 0 - 2 0 + 2 = 1 2\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.167,
                0.938,
                0.203
            ],
            "angle": 0,
            "content": "可以用欧拉公式来建立平面图所必须满足的一些不等式。在下面的推论1中给出一个这样的不等式。"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.211,
                0.859,
                0.229
            ],
            "angle": 0,
            "content": "推论1 若 \\(G\\) 是 \\(e\\) 条边和 \\(v\\) 个顶点的连通平面简单图，其中 \\(v \\geqslant 3\\) ，则 \\(e \\leqslant 3v - 6\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.137,
                0.238,
                0.6,
                0.254
            ],
            "angle": 0,
            "content": "在证明推论1之前先用它证明下面这个有用的结论。"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.263,
                0.734,
                0.28
            ],
            "angle": 0,
            "content": "推论2 若 \\(G\\) 是连通平面简单图，则 \\(G\\) 中有度数不超过5的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.289,
                0.942,
                0.351
            ],
            "angle": 0,
            "content": "证明 如果 \\(G\\) 有1个或2个顶点，则结果为真。如果 \\(G\\) 至少有3个顶点，则根据推论1知道 \\(e \\leqslant 3v - 6\\) ，所以 \\(2e \\leqslant 6v - 12\\) 。假如每个顶点的度数至少是6，则由于 \\(2e = \\sum_{v \\in V} \\deg(v)\\) （根据握手定理），所以就有 \\(2e \\geqslant 6v\\) 。但是这与 \\(2e \\leqslant 6v - 12\\) 相矛盾。所以必定存在度数不超过5的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.353,
                0.942,
                0.37
            ],
            "angle": 0,
            "content": "推论1的证明是基于面的度的概念，它定义为这个面的边界上的边数。当一条边在边界上"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.372,
                0.651,
                0.427
            ],
            "angle": 0,
            "content": "出现两次（所以当描画边界时就描画它两次）时，它贡献的度是2。我们用 \\(\\deg(R)\\) 标记面 \\(R\\) 的度。图11显示了图中各面的度。"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.43,
                0.416,
                0.446
            ],
            "angle": 0,
            "content": "现在可以给出推论1的证明了。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.449,
                0.651,
                0.542
            ],
            "angle": 0,
            "content": "证明 在平面中连通平面简单图把平面分割成面，比如说 \\(r\\) 个面。每个面的度至少为3。（因为这里所讨论的图都是简单图，所以不允许带有可能产生度为2的面的多重边，或者可能产生度为1的面的环。）特别地，注意无界的面的度至少为3，因为在图中至少有3个顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.544,
                0.651,
                0.598
            ],
            "angle": 0,
            "content": "注意各面的度之和恰好是图中边数的两倍，因为每条边都在面的边界上出现两次（可能在两个不同面中，或者两次都在相同面中）。因为每个面的度都大于或等于3，所以有"
        },
        {
            "type": "equation",
            "bbox": [
                0.413,
                0.602,
                0.63,
                0.63
            ],
            "angle": 0,
            "content": "\\[\n2 e = \\sum_ {\\text {所 有 区 域} R} \\deg (R) \\geqslant 3 r\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.631,
                0.15,
                0.647
            ],
            "angle": 0,
            "content": "因此，"
        },
        {
            "type": "equation",
            "bbox": [
                0.472,
                0.65,
                0.574,
                0.665
            ],
            "angle": 0,
            "content": "\\[\n(2 / 3) e \\geqslant r\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.669,
                0.472,
                0.685
            ],
            "angle": 0,
            "content": "利用 \\(r = e - v + 2\\) （欧拉公式），就得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.435,
                0.688,
                0.609,
                0.703
            ],
            "angle": 0,
            "content": "\\[\ne - v + 2 \\leqslant (2 / 3) e\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.707,
                0.476,
                0.723
            ],
            "angle": 0,
            "content": "所以 \\(e / 3\\leqslant v - 2\\) 。这样就证明了 \\(e\\leqslant 3v - 6\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.726,
                0.493,
                0.742
            ],
            "angle": 0,
            "content": "可以用这个推论来证明 \\(K_{5}\\) 是非平面图。"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.748,
                0.48,
                0.764
            ],
            "angle": 0,
            "content": "例5 用推论1证明： \\(K_{5}\\) 是非平面图。"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.769,
                0.942,
                0.804
            ],
            "angle": 0,
            "content": "解 图 \\(K_{5}\\) 有5个顶点和10条边。不过，对这个图来说，不满足不等式 \\(e \\leqslant 3v - 6\\) ，因为 \\(e = 10\\) 和 \\(3v - 6 = 9\\) 。因此，\\(K_{5}\\) 不是平面图。"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.807,
                0.942,
                0.862
            ],
            "angle": 0,
            "content": "前面已经证明了 \\(K_{3,3}\\) 不是平面图。不过，注意这个图有6个顶点和9条边。这意味着满足不等式 \\(e = 9 \\leqslant 12 = 3 \\cdot 6 - 6\\) 。所以，满足不等式 \\(e \\leqslant 3v - 6\\) 并不意味着一个图是平面图。不过，可以利用下面定理1的推论来证明 \\(K_{3,3}\\) 不是平面图。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.871,
                0.936,
                0.907
            ],
            "angle": 0,
            "content": "推论3 若连通平面简单图有 \\(e\\) 条边和 \\(v\\) 个顶点，\\(v \\geqslant 3\\) 并且没有长度为3的回路，则 \\(e \\leqslant 2v - 4\\)。"
        },
        {
            "type": "image",
            "bbox": [
                0.668,
                0.375,
                0.945,
                0.559
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.746,
                0.564,
                0.865,
                0.579
            ],
            "angle": 0,
            "content": "图11 面的度"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.759,
                0.035,
                0.867,
                0.05
            ],
            "angle": 0,
            "content": "图 637"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.09,
                0.716,
                0.107
            ],
            "angle": 0,
            "content": "意味着面的度必然至少为4。把这个证明的细节留给读者（见本节练习15）。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.112,
                0.435,
                0.13
            ],
            "angle": 0,
            "content": "例6 用推论3证明： \\(K_{3,3}\\) 是非平面图。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.134,
                0.896,
                0.171
            ],
            "angle": 0,
            "content": "解因为 \\(K_{3,3}\\) 没有长度为3的回路(容易看出这一点，因为它是二分图)，所以可以使用推论3。\\(K_{3,3}\\) 有6个顶点和9条边。因为 \\(e = 9\\) 和 \\(2v - 4 = 8\\) ，所以由推论3可证明 \\(K_{3,3}\\) 是非平面图。"
        },
        {
            "type": "title",
            "bbox": [
                0.051,
                0.18,
                0.298,
                0.198
            ],
            "angle": 0,
            "content": "10.7.3 库拉图斯基定理"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.2,
                0.895,
                0.255
            ],
            "angle": 0,
            "content": "我们已经看到 \\(K_{3,3}\\) 和 \\(K_{5}\\) 都不是平面图。显然，若一个图包含这两个图之一作为子图，则它不是平面图。另外，所有非平面图必然包含一个从 \\(K_{3,3}\\) 或 \\(K_{5}\\) 利用某些允许的操作来获得的子图。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.258,
                0.895,
                0.314
            ],
            "angle": 0,
            "content": "若一个图是平面图，则通过删除一条边 \\(\\{u, v\\}\\) 并且添加一个新顶点 \\(w\\) 和两条边 \\(\\{u, w\\}\\) 与 \\(\\{w, v\\}\\) 获得的任何图也是平面图。这样的操作称为初等细分。若可以从相同的图通过一系列初等细分来获得图 \\(G_{1} = (V_{1}, E_{1})\\) 和图 \\(G_{2} = (V_{2}, E_{2})\\)，则称它们是同胚的。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.318,
                0.558,
                0.336
            ],
            "angle": 0,
            "content": "例7 证明：图12所示的图 \\(G_{1}\\) 、 \\(G_{2}\\) 和 \\(G_{3}\\) 是同胚的。"
        },
        {
            "type": "image",
            "bbox": [
                0.1,
                0.344,
                0.315,
                0.44
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.364,
                0.344,
                0.58,
                0.44
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.629,
                0.345,
                0.844,
                0.44
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.402,
                0.447,
                0.54,
                0.462
            ],
            "angle": 0,
            "content": "图12 同胚的图"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.474,
                0.895,
                0.512
            ],
            "angle": 0,
            "content": "解因为这三个图都可以从图 \\(G_{1}\\) 通过初等细分得到，所以它们是同胚的。 \\(G_{1}\\) 可以从它自身出发，通过一个空的初等细分序列而得到。要从 \\(G_{1}\\) 得到 \\(G_{2}\\) ，采用如下初等细分序列："
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.515,
                0.631,
                0.53
            ],
            "angle": 0,
            "content": "1)删掉边 \\(\\{a,c\\}\\) ，增加顶点 \\(f\\) ，然后添加边 \\(\\{a,f\\}\\) 和 \\(\\{f,c\\}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.534,
                0.628,
                0.55
            ],
            "angle": 0,
            "content": "2)删掉边 \\(\\{b,c\\}\\) ，增加顶点 \\(g\\) ，然后添加边 \\(\\{b,g\\}\\) 和 \\(\\{g,c\\}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.554,
                0.631,
                0.569
            ],
            "angle": 0,
            "content": "3)删掉边 \\(\\{b,g\\}\\) ，增加顶点 \\(h\\) ，然后添加边 \\(\\{g,h\\}\\) 和 \\(\\{h,b\\}\\) 。"
        },
        {
            "type": "list",
            "bbox": [
                0.086,
                0.515,
                0.631,
                0.569
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.573,
                0.558,
                0.589
            ],
            "angle": 0,
            "content": "把找出由 \\(G_{1}\\) 到 \\(G_{3}\\) 的初等细分序列的任务留给读者。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.592,
                0.896,
                0.628
            ],
            "angle": 0,
            "content": "波兰的数学家卡兹米尔兹·库拉图斯基在1930年建立了定理2，该定理利用图的同胚的概念刻画了平面图。"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.637,
                0.757,
                0.655
            ],
            "angle": 0,
            "content": "定理2 一个图是非平面图当且仅当它包含一个同胚于 \\(K_{3,3}\\) 或 \\(K_{5}\\) 的子图。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.665,
                0.895,
                0.683
            ],
            "angle": 0,
            "content": "显然，一个包含着同胚于 \\(K_{3,3}\\) 或 \\(K_{5}\\) 子图的图是非平面图。不过，相反方向的命题（即每个"
        },
        {
            "type": "image",
            "bbox": [
                0.049,
                0.69,
                0.117,
                0.712
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.052,
                0.726,
                0.191,
                0.836
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.05,
                0.84,
                0.187,
                0.86
            ],
            "angle": 0,
            "content": "©Archive PL/Alamy Stock Photo"
        },
        {
            "type": "text",
            "bbox": [
                0.206,
                0.725,
                0.897,
                0.864
            ],
            "angle": 0,
            "content": "卡兹米尔兹·库拉图斯基（Kazimierz Kuratowski，1896—1980）库拉图斯基是华沙一位著名律师的儿子。他在华沙上的中学，\\(1913\\sim 1914\\) 年，他在苏格兰的格拉斯哥学习，但第一次世界大战爆发后他无法返回那里继续学业。1915年，他考入华沙大学，继而投身于波兰学生爱国主义运动。1919年，他发表了第一篇论文，并且于1921年获得博士学位。他是华沙数学学派里的活跃分子，主要研究集合论和拓扑学的基础理论。他被勒沃理工大学聘为副教授，并在那里度过了7年的时光，并与当时在波兰举足轻重的数学家巴拿赫和乌拉姆合作。1930年，库拉图斯基还在勒沃任教时，他就完成了刻画可平面图的工作。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.867,
                0.897,
                0.936
            ],
            "angle": 0,
            "content": "1934年，他身为教授重返华沙大学。在那里，他一直积极从事研究和教学工作，直到第二次世界大战开始。在战争期间，为避免受到迫害，他起用化名来隐藏自己的身份，并且秘密地在华沙大学授课。战后，他帮助恢复波兰的数学研究工作，并担任波兰国家数学研究所主任。他写过180多篇论文，出过3本教科书，均受到广泛使用。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.145,
                0.034,
                0.182,
                0.048
            ],
            "angle": 0,
            "content": "638"
        },
        {
            "type": "header",
            "bbox": [
                0.226,
                0.033,
                0.304,
                0.049
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.089,
                0.962,
                0.125
            ],
            "angle": 0,
            "content": "非平面图都包含一个同胚于 \\(K_{3,3}\\) 或 \\(K_{5}\\) 的子图)，证明起来是很复杂的，因而不在这里给出。例8和例9说明了如何使用库拉图斯基定理。"
        },
        {
            "type": "text",
            "bbox": [
                0.157,
                0.13,
                0.546,
                0.148
            ],
            "angle": 0,
            "content": "例8 确定图13所示的图 \\(G\\) 是否是平面图。"
        },
        {
            "type": "image",
            "bbox": [
                0.182,
                0.156,
                0.385,
                0.29
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.274,
                0.295,
                0.29,
                0.305
            ],
            "angle": 0,
            "content": "G"
        },
        {
            "type": "image",
            "bbox": [
                0.443,
                0.156,
                0.641,
                0.289
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.534,
                0.295,
                0.55,
                0.305
            ],
            "angle": 0,
            "content": "H"
        },
        {
            "type": "image",
            "bbox": [
                0.702,
                0.156,
                0.9,
                0.289
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.791,
                0.295,
                0.812,
                0.306
            ],
            "angle": 0,
            "content": "K5"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.347,
                0.313,
                0.737,
                0.329
            ],
            "angle": 0,
            "content": "图13 无向图 \\(G\\) 、同胚于 \\(K_{5}\\) 的子图 \\(H\\) 以及 \\(K_{5}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.335,
                0.965,
                0.391
            ],
            "angle": 0,
            "content": "解 \\(G\\) 有同胚于 \\(K_{5}\\) 的子图 \\(H\\) 。 \\(H\\) 是这样获得的：删除 \\(h\\) 、 \\(j\\) 和 \\(k\\) 以及所有与这些顶点关联的边。 \\(H\\) 是同胚于 \\(K_{5}\\) 的，因为从 \\(K_{5}\\) （带有顶点 \\(a\\) 、 \\(b\\) 、 \\(c\\) 、 \\(g\\) 和 \\(i\\) ）通过一系列初等细分，添加顶点 \\(d\\) 、 \\(e\\) 和 \\(f\\) 就可以获得 \\(H\\) （读者应当构造出这样一系列初等细分）。因此， \\(G\\) 是非平面图。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.394,
                0.963,
                0.434
            ],
            "angle": 0,
            "content": "例9 在图14a中所示的彼得森图是平面图吗？（丹麦数学家朱利乌斯·彼得森在1891年研究过这个图；它常用来说明关于图的各种性质的理论。）"
        },
        {
            "type": "image",
            "bbox": [
                0.151,
                0.44,
                0.375,
                0.585
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.255,
                0.603,
                0.348,
                0.617
            ],
            "angle": 0,
            "content": "a）彼得森图"
        },
        {
            "type": "image",
            "bbox": [
                0.406,
                0.445,
                0.681,
                0.598
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.507,
                0.601,
                0.673,
                0.615
            ],
            "angle": 0,
            "content": "b）同胚于 \\(K_{3,3}\\) 的子图 \\(H\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.715,
                0.472,
                0.935,
                0.573
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.8,
                0.601,
                0.853,
                0.615
            ],
            "angle": 0,
            "content": "c) \\(K_{3,3}\\)"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.349,
                0.621,
                0.739,
                0.637
            ],
            "angle": 0,
            "content": "图14 彼得森图、同胚于 \\(K_{3,3}\\) 的子图 \\(H\\) 和 \\(K_{3,3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.643,
                0.967,
                0.718
            ],
            "angle": 0,
            "content": "解 彼得森图的子图 \\(H\\) 是这样获得的：删除 \\(b\\) 和以 \\(b\\) 为端点的3条边，如图14b所示，它同胚于带有顶点集合 \\(\\{f, d, j\\}\\) 和 \\(\\{e, i, h\\}\\) 的 \\(K_{3,3}\\)，因为可以通过一系列初等细分（删除 \\(\\{d, h\\}\\) 并添加 \\(\\{c, h\\}\\) 和 \\(\\{c, d\\}\\)，删除 \\(\\{e, f\\}\\) 并添加 \\(\\{a, e\\}\\) 和 \\(\\{a, f\\}\\)，删除 \\(\\{i, j\\}\\) 并添加 \\(\\{g, i\\}\\) 和 \\(\\{g, j\\}\\)）来获得它。因此，彼得森图不是平面图。"
        },
        {
            "type": "title",
            "bbox": [
                0.12,
                0.728,
                0.169,
                0.744
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.748,
                0.556,
                0.763
            ],
            "angle": 0,
            "content": "1.5座房屋能否不带连接交叉地与两种设施相连接吗？"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.766,
                0.55,
                0.78
            ],
            "angle": 0,
            "content": "在练习 \\(2\\sim 4\\) 中，不带任何交叉地画出给定的平面图。"
        },
        {
            "type": "image",
            "bbox": [
                0.12,
                0.783,
                0.354,
                0.86
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.404,
                0.783,
                0.634,
                0.859
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.683,
                0.783,
                0.884,
                0.894
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.897,
                0.829,
                0.912
            ],
            "angle": 0,
            "content": "在练习 \\(5\\sim 9\\) 中，判断所给的图是否是平面图。若是平面图，则画出它使得没有边交叉。"
        },
        {
            "type": "image",
            "bbox": [
                0.041,
                0.128,
                0.102,
                0.145
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.763,
                0.038,
                0.87,
                0.055
            ],
            "angle": 0,
            "content": "图 639"
        },
        {
            "type": "image",
            "bbox": [
                0.05,
                0.095,
                0.22,
                0.199
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.284,
                0.095,
                0.54,
                0.195
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.585,
                0.095,
                0.78,
                0.202
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.051,
                0.206,
                0.25,
                0.316
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.296,
                0.206,
                0.55,
                0.336
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.339,
                0.245,
                0.354
            ],
            "angle": 0,
            "content": "10. 完成例3中的论证。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.357,
                0.513,
                0.371
            ],
            "angle": 0,
            "content": "11. 用类似于例3中给出的论证来证明： \\( K_{5} \\) 是非平面图。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.374,
                0.889,
                0.389
            ],
            "angle": 0,
            "content": "12. 假定一个连通平面图有 8 个顶点，每个顶点的度都为 3。这个图的平面表示把平面分割成多少个面？"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.393,
                0.89,
                0.407
            ],
            "angle": 0,
            "content": "13. 假定一个连通平面图有 6 个顶点，每个顶点的度都为 4。这个图的平面表示把平面分割成多少个面？"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.411,
                0.897,
                0.443
            ],
            "angle": 0,
            "content": "14. 假定一个连通平面图有 30 条边。若这个图的平面表示把平面分割成 20 个面，则这个图有多少个顶点？"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.447,
                0.184,
                0.461
            ],
            "angle": 0,
            "content": "15. 证明推论3。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.465,
                0.767,
                0.479
            ],
            "angle": 0,
            "content": "16. 假定一个连通的平面简单二分图有 \\( e \\) 条边和 \\( v \\) 个顶点。证明：若 \\( v \\geqslant 3 \\)，则 \\( e \\leqslant 2v - 4 \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.483,
                0.899,
                0.516
            ],
            "angle": 0,
            "content": "* 17. 假定一个带有 \\( e \\) 条边和 \\( v \\) 个顶点的连通平面简单图不包含长度为 4 或更短的回路。证明：若 \\( v \\geqslant 4 \\)，则 \\( e \\leqslant (5 / 3)v - (10 / 3) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.519,
                0.899,
                0.552
            ],
            "angle": 0,
            "content": "18. 假定一个平面图有 \\(k\\) 个连通分支、\\(e\\) 条边和 \\(v\\) 个顶点。另外假定这个图的平面表示把平面分割成 \\(r\\) 个面。求用 \\(e\\)、\\(v\\) 和 \\(k\\) 所表示的 \\(r\\) 的公式。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.555,
                0.899,
                0.588
            ],
            "angle": 0,
            "content": "19. 下面的哪些非平面图具有这样的性质：删除任何一个顶点以及与这个顶点关联的所有边就产生一个平面图？"
        },
        {
            "type": "list",
            "bbox": [
                0.041,
                0.339,
                0.899,
                0.588
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.591,
                0.131,
                0.607
            ],
            "angle": 0,
            "content": "a) \\(K_{5}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.279,
                0.591,
                0.323,
                0.606
            ],
            "angle": 0,
            "content": "b) \\(K_{6}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.455,
                0.591,
                0.507,
                0.606
            ],
            "angle": 0,
            "content": "c) \\(K_{3,3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.629,
                0.591,
                0.683,
                0.606
            ],
            "angle": 0,
            "content": "d) \\(K_{3,4}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.609,
                0.465,
                0.624
            ],
            "angle": 0,
            "content": "在练习 \\(20\\sim 22\\) 中，判断给定的图是否同胚于 \\(K_{3,3}\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.053,
                0.628,
                0.42,
                0.764
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.467,
                0.628,
                0.808,
                0.746
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.053,
                0.767,
                0.292,
                0.92
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.924,
                0.651,
                0.939
            ],
            "angle": 0,
            "content": "在练习 \\(23\\sim 25\\) 中，用库拉图斯基定理来判断所给的图是不是平面图。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.14,
                0.042,
                0.175,
                0.054
            ],
            "angle": 0,
            "content": "640"
        },
        {
            "type": "header",
            "bbox": [
                0.221,
                0.04,
                0.296,
                0.054
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.111,
                0.097,
                0.137,
                0.11
            ],
            "angle": 0,
            "content": "23."
        },
        {
            "type": "image",
            "bbox": [
                0.141,
                0.096,
                0.455,
                0.192
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.506,
                0.098,
                0.531,
                0.11
            ],
            "angle": 0,
            "content": "24."
        },
        {
            "type": "image",
            "bbox": [
                0.536,
                0.095,
                0.758,
                0.259
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.113,
                0.263,
                0.138,
                0.275
            ],
            "angle": 0,
            "content": "25."
        },
        {
            "type": "image",
            "bbox": [
                0.144,
                0.262,
                0.38,
                0.406
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.057,
                0.411,
                0.098,
                0.424
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.409,
                0.956,
                0.44
            ],
            "angle": 0,
            "content": "一个简单图的交叉数是指，当在平面上画出这个图时，其中不允许任何3条表示边的弧线在同一个点交叉时，交叉的最少次数。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.444,
                0.352,
                0.458
            ],
            "angle": 0,
            "content": "26. 证明：\\(K_{3,3}\\) 的交叉数为1。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.462,
                0.398,
                0.476
            ],
            "angle": 0,
            "content": "**27. 求下面每个非平面图的交叉数。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.48,
                0.188,
                0.494
            ],
            "angle": 0,
            "content": "a) \\(K_{5}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.278,
                0.481,
                0.321,
                0.493
            ],
            "angle": 0,
            "content": "b) \\(K_{6}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.412,
                0.481,
                0.452,
                0.493
            ],
            "angle": 0,
            "content": "c) \\(K_{7}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.545,
                0.48,
                0.597,
                0.493
            ],
            "angle": 0,
            "content": "d) \\(K_{3,4}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.689,
                0.48,
                0.739,
                0.493
            ],
            "angle": 0,
            "content": "e) \\(K_{4,4}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.832,
                0.48,
                0.882,
                0.493
            ],
            "angle": 0,
            "content": "f) \\(K_{5,5}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.497,
                0.324,
                0.511
            ],
            "angle": 0,
            "content": "* 28. 求彼得森图的交叉数。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.515,
                0.957,
                0.581
            ],
            "angle": 0,
            "content": "**29. 证明：若 \\( m \\) 和 \\( n \\) 都是正偶数，则 \\( K_{m,n} \\) 的交叉数小于或等于 \\( mn(m - 2)(n - 2) / 16 \\)。[提示：沿着 \\( x \\) 轴放置 \\( m \\) 个顶点，使它们的间距相等且关于原点对称，再沿着 \\( y \\) 轴放置 \\( n \\) 个顶点，使它们的间距相等且关于原点对称。现在连接 \\( x \\) 轴上 \\( m \\) 个顶点中的每一个与 \\( y \\) 轴上 \\( n \\) 个顶点中的每一个，并计算交叉数。]简单图 \\( G \\) 的厚度是指，以 \\( G \\) 作为它们的并图的 \\( G \\) 的平面子图的最小个数。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.585,
                0.334,
                0.599
            ],
            "angle": 0,
            "content": "30. 证明：\\(K_{3,3}\\) 的厚度为2。"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.603,
                0.334,
                0.616
            ],
            "angle": 0,
            "content": "*31. 求练习27中图的厚度。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.62,
                0.95,
                0.634
            ],
            "angle": 0,
            "content": "32. 证明：若 \\(G\\) 是一个带有 \\(v\\) 个顶点和 \\(e\\) 条边的连通简单图，其中 \\(v \\geqslant 3\\) ，则 \\(G\\) 的厚度至少为 \\(\\left\\lceil e / 3v - 6 \\right\\rceil\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.638,
                0.694,
                0.652
            ],
            "angle": 0,
            "content": "*33. 利用练习32证明：当 \\(n\\) 是正整数时，\\(K_{n}\\) 的厚度至少为 \\(\\left\\lfloor (n + 7) / 6 \\right\\rfloor\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.655,
                0.956,
                0.687
            ],
            "angle": 0,
            "content": "34. 证明：若 \\(G\\) 是一个带有 \\(v\\) 个顶点和 \\(e\\) 条边且没有长度为 3 的回路的连通简单图，其中 \\(v \\geqslant 3\\)，则 \\(G\\) 的厚度至少为 \\(\\left\\lceil e / 2v - 4 \\right\\rceil\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.69,
                0.948,
                0.705
            ],
            "angle": 0,
            "content": "35. 利用练习 34 证明：当 \\( m \\) 和 \\( n \\) 都是正整数时，且 \\( m, n \\) 不同时为 1，\\( K_{m,n} \\) 的厚度至少是 \\( \\left\\lceil mn / (2m + 2n - 4) \\right\\rceil \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.71,
                0.525,
                0.724
            ],
            "angle": 0,
            "content": "*36. 在一个环面 \\(\\ominus\\) 上画出 \\(K_{5}\\)，使得没有边交叉。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.729,
                0.53,
                0.743
            ],
            "angle": 0,
            "content": "*37. 在一个环面上画出 \\(K_{3,3}\\)，使得没有边交叉。"
        },
        {
            "type": "list",
            "bbox": [
                0.086,
                0.515,
                0.957,
                0.743
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.116,
                0.759,
                0.276,
                0.778
            ],
            "angle": 0,
            "content": "10.8 图着色"
        },
        {
            "type": "title",
            "bbox": [
                0.116,
                0.786,
                0.252,
                0.802
            ],
            "angle": 0,
            "content": "10.8.1 引言"
        },
        {
            "type": "image",
            "bbox": [
                0.06,
                0.808,
                0.099,
                0.823
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.806,
                0.96,
                0.88
            ],
            "angle": 0,
            "content": "在图论中，有许多与地图区域（比如，世界各部分的地图）着色有关的理论成果。当为一幅地图 \\(\\text{念}\\) 着色时，具有公共边界的两个区域通常指定为不同的颜色。一种确保两个相邻的区域永远没有相同的颜色的方法是对每个区域都使用不同的颜色。不过，这种方法效率不高，而且在具有许多区域的地图上，可能难以区分相似的颜色。另一种方法是，应当尽可能地使用少数几"
        },
        {
            "type": "page_footnote",
            "bbox": [
                0.16,
                0.908,
                0.613,
                0.922
            ],
            "angle": 0,
            "content": "\\(\\ominus\\) 原文 torus，指自行车轮胎或救生圈这类形状。——译者注"
        },
        {
            "type": "page_footnote",
            "bbox": [
                0.16,
                0.925,
                0.825,
                0.939
            ],
            "angle": 0,
            "content": "假定地图中所有区域都是连通的。这样就消除了像密歇根这样的地理状况所引起的问题。"
        },
        {
            "type": "list",
            "bbox": [
                0.16,
                0.908,
                0.825,
                0.939
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.765,
                0.038,
                0.87,
                0.052
            ],
            "angle": 0,
            "content": "图 641"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.093,
                0.901,
                0.148
            ],
            "angle": 0,
            "content": "种颜色。考虑这样的问题：确定可以用来给一幅地图着色的颜色的最小数目，使得相邻的区域永远没有相同的颜色。例如，对图1左侧地图来说，4种颜色是足够的，但是3种颜色就不够（读者应当验证这一点）。对图1右侧地图来说，3种颜色是足够的（但是2种颜色就不够）。"
        },
        {
            "type": "image",
            "bbox": [
                0.216,
                0.154,
                0.741,
                0.262
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.413,
                0.271,
                0.543,
                0.286
            ],
            "angle": 0,
            "content": "图1 两幅地图"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.297,
                0.905,
                0.372
            ],
            "angle": 0,
            "content": "平面中的每幅地图都可以表示成一个图。为了建立这样的对应关系，地图的每个区域都表示成一个顶点。若两个顶点所表示的区域具有公共边界，则用边连接这两个顶点。只相交于一个点的两个区域不算是相邻的。这样所得到的图称为这个地图的对偶图。根据地图的对偶图的构造方式，显然在平面中的任何地图都具有可平面的对偶图。图2显示了对应于图1所示地图的对偶图。"
        },
        {
            "type": "image",
            "bbox": [
                0.202,
                0.378,
                0.758,
                0.496
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.359,
                0.504,
                0.598,
                0.519
            ],
            "angle": 0,
            "content": "图2 图1中的地图的对偶图"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.53,
                0.901,
                0.566
            ],
            "angle": 0,
            "content": "给地图的区域着色的问题等价于这样的问题：给对偶图的顶点着色，使得在对偶图中没有两个相邻的顶点具有相同的颜色。下面给出图着色的定义。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.574,
                0.893,
                0.611
            ],
            "angle": 0,
            "content": "定义1 简单图的着色是对该图的每个顶点都指定一种颜色，使得没有两个相邻的顶点颜色相同。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.619,
                0.901,
                0.656
            ],
            "angle": 0,
            "content": "通过对每个顶点都指定一种不同的颜色，就可以着色一个图。不过，对大多数图来说，可以找到所用颜色数少于图中顶点数的着色。什么是所需要的最少着色数？"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.668,
                0.893,
                0.708
            ],
            "angle": 0,
            "content": "定义2 图的着色数是着色这个图所需要的最少颜色数。图 \\(G\\) 的着色数记作 \\(\\chi(G)\\)（这里 \\(\\chi\\) 是希腊字母 chi）。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.716,
                0.905,
                0.753
            ],
            "angle": 0,
            "content": "注意，求平面图的着色数等于求平面地图着色所需要的最少颜色数，使得没有两个相邻的区域指定为相同的颜色。这个问题已经研究了100多年。数学中最著名的定理之一给出了它的答案。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.761,
                0.52,
                0.779
            ],
            "angle": 0,
            "content": "定理1 四色定理 平面图的着色数不超过4。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.787,
                0.905,
                0.862
            ],
            "angle": 0,
            "content": "四色定理最早是作为猜想在19世纪50年代提出的。美国数学家肯尼思·阿佩尔和沃尔夫冈·黑肯最终在1976年证明了它。在1976年之前，发表过许多不正确的证明，其中的错误常常难以发现。另外，还尝试过画出需要超过四色的地图来构造反例，而这样做是无效的。（证明五色定理就没有这样困难，参见练习36。）"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.863,
                0.906,
                0.939
            ],
            "angle": 0,
            "content": "也许迄今为止，在数学中最有名的错误证明就是伦敦律师和业余的数学家艾尔弗雷德·肯普在1879年所发表的四色定理证明。数学家一直认为他的证明是正确的，直到1890年珀西·希伍德发现了一处错误，才发现肯普的论证是不完全的。不过，事实证明，肯普的推理思路是阿佩尔和黑肯所给出的成功证明的基础。他们的证明依赖于计算机所完成的对各种情形的仔细"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.132,
                0.036,
                0.169,
                0.049
            ],
            "angle": 0,
            "content": "642"
        },
        {
            "type": "header",
            "bbox": [
                0.214,
                0.035,
                0.29,
                0.05
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.091,
                0.953,
                0.203
            ],
            "angle": 0,
            "content": "分析。他们证明，若四色定理为假，则在大约2000种不同类型中，一定存在一个反例，然后他们证明不存在这样的反例。在他们的证明中使用了1000多个小时的计算机时间。计算机在证明过程中起到如此重要的作用，由此引发了广泛的争论。例如，在计算机程序里有没有导致不正确结果的错误？假如论证是依赖于或许不可靠的计算机得出的，那么它是不是真正的证明？自从他们的证明出现之后，又出现了一些从检查更少的类型中检查的可能出现的反例的更为简单的证明，并且创建了使用自动证明系统的证明。但是仍然没有找到不依赖于计算机的证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.206,
                0.856,
                0.222
            ],
            "angle": 0,
            "content": "注意，四色定理只适用于平面图。例2将证明非平面图可以有任意大的着色数。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.224,
                0.951,
                0.279
            ],
            "angle": 0,
            "content": "证明一个图的着色数为 \\(n\\) 需要做两件事。首先必须证明：用 \\(n\\) 种颜色可以着色这个图。构造出这样的着色就可以完成这件事。其次证明：用少于 \\(n\\) 种颜色不能着色这个图。例 \\(1 \\sim 4\\) 说明如何求出着色数。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.284,
                0.553,
                0.302
            ],
            "angle": 0,
            "content": "例1 图3所示的图 \\(G\\) 和 \\(H\\) 的着色数是什么？"
        },
        {
            "type": "image",
            "bbox": [
                0.186,
                0.31,
                0.87,
                0.464
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.441,
                0.467,
                0.615,
                0.482
            ],
            "angle": 0,
            "content": "图3 简单图 \\(G\\) 和 \\(H\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.487,
                0.951,
                0.581
            ],
            "angle": 0,
            "content": "解 图 \\(G\\) 的色数至少为 3，因为顶点 \\(a\\)、\\(b\\) 和 \\(c\\) 必须为不同的颜色。为了看出是否可以用 3 种颜色来对 \\(G\\) 着色，指定 \\(a\\) 为红，\\(b\\) 为蓝，\\(c\\) 为绿。于是，可以（而且必须）令 \\(d\\) 为红，因为它与 \\(b\\) 和 \\(c\\) 相邻。另外，可以（而且必须）令 \\(e\\) 为绿，因为它只与红色和蓝色顶点相邻；可以（而且必须）令 \\(f\\) 为蓝，因为它只与红色和绿色顶点相邻。最后，可以（而且必须）令 \\(g\\) 为红，因为它只与蓝色和绿色的顶点相邻。这样就产生出恰好使用 3 种颜色的 \\(G\\) 的着色，如图 4 所示。"
        },
        {
            "type": "image",
            "bbox": [
                0.145,
                0.587,
                0.914,
                0.74
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.43,
                0.742,
                0.626,
                0.758
            ],
            "angle": 0,
            "content": "图4 图 \\(G\\) 和 \\(H\\) 的着色"
        },
        {
            "type": "title",
            "bbox": [
                0.105,
                0.762,
                0.177,
                0.785
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.108,
                0.797,
                0.25,
                0.909
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.106,
                0.912,
                0.218,
                0.933
            ],
            "angle": 0,
            "content": "Courtesy of London Mathematical Society"
        },
        {
            "type": "text",
            "bbox": [
                0.263,
                0.798,
                0.951,
                0.884
            ],
            "angle": 0,
            "content": "艾尔弗雷德·布雷·肯普（Alfred Bray Kempe，1849—1922）肯普是一名律师，同时也是教会法规的权威人士。不过，当他在剑桥大学学习了数学之后，他对数学的兴趣就从未减少，并且在以后的生活中对数学研究投入了大量的时间和精力。肯普对动力学（即数学中处理运动的一个分支）和逻辑学的发展做出了贡献。不过，肯普为人熟知主要还是因为他对四色定理的错误证明。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.752,
                0.035,
                0.859,
                0.051
            ],
            "angle": 0,
            "content": "图 643"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.091,
                0.888,
                0.166
            ],
            "angle": 0,
            "content": "图 \\(H\\) 是由图 \\(G\\) 和连接 \\(a\\) 与 \\(g\\) 的一条边所组成的。用3种颜色来着色 \\(H\\) 的任何尝试都必须遵循着色 \\(G\\) 时所用的同样的推理，不同之处是在最后阶段，当除了 \\(g\\) 以外的所有顶点都已经着色后，因为 \\(g\\) 与红色、蓝色和绿色顶点（在 \\(H\\) 里）相邻，所以需要使用第四种颜色，比如棕色。因此，\\(H\\) 的着色数为4。图4显示了 \\(H\\) 的一种着色。"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.17,
                0.322,
                0.188
            ],
            "angle": 0,
            "content": "例2 \\(K_{n}\\) 的着色数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.192,
                0.889,
                0.269
            ],
            "angle": 0,
            "content": "解 通过给每个顶点指定一种不同的颜色，用 \\(n\\) 种颜色可以构造 \\(K_{n}\\) 的着色。使用的颜色能否更少一些？答案是不能。没有两个顶点可以指定相同的颜色，因为这个图的每两个顶点都是相邻的。因此，\\(K_{n}\\) 的着色数 \\(= n\\) 。即 \\(\\chi(K_{n}) = n\\)。（回忆一下，当 \\(n \\geqslant 5\\) 时 \\(K_{n}\\) 不是平面图，所以这个结果与四色定理并不矛盾。）图5显示了使用5种颜色对 \\(K_{5}\\) 着色。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.274,
                0.669,
                0.292
            ],
            "angle": 0,
            "content": "例3 完全二分图 \\(K_{m,n}\\) 的着色数是什么？其中 \\(m\\) 和 \\(n\\) 都是正整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.297,
                0.889,
                0.374
            ],
            "angle": 0,
            "content": "解需要的颜色数似乎依赖于 \\(m\\) 和 \\(n\\) 。不过，由10.2节的定理4可知，仅仅需要两种颜色，因为 \\(K_{m,n}\\) 是二分图，所以 \\(\\chi (K_{m,n}) = 2\\) 。这意味着，可以用一种颜色为 \\(m\\) 个顶点着色，用另外一种颜色为 \\(n\\) 个顶点着色。因为边都只能连接 \\(m\\) 个顶点中的一个顶点与 \\(n\\) 个顶点中的一个顶点，所以没有相邻的顶点具有相同的颜色。图6显示了带有两种颜色的 \\(K_{3,4}\\) 的着色。"
        },
        {
            "type": "image",
            "bbox": [
                0.118,
                0.378,
                0.378,
                0.505
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.179,
                0.506,
                0.316,
                0.519
            ],
            "angle": 0,
            "content": "图5 \\(K_{5}\\) 的着色"
        },
        {
            "type": "image",
            "bbox": [
                0.509,
                0.409,
                0.855,
                0.506
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.612,
                0.506,
                0.754,
                0.519
            ],
            "angle": 0,
            "content": "图6 \\(K_{3,4}\\) 的着色"
        },
        {
            "type": "text",
            "bbox": [
                0.083,
                0.53,
                0.778,
                0.546
            ],
            "angle": 0,
            "content": "例4图 \\(C_n\\) 的着色数是什么 \\((n\\geqslant 3)\\) ？（回忆一下， \\(C_n\\) 是带有 \\(n\\) 个顶点的圈图。）"
        },
        {
            "type": "text",
            "bbox": [
                0.083,
                0.552,
                0.889,
                0.568
            ],
            "angle": 0,
            "content": "解 首先，考虑一些个别情形。设 \\(n = 6\\) 。挑选一个顶点并且把它着色成红色。在图7所示"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.571,
                0.484,
                0.702
            ],
            "angle": 0,
            "content": "的 \\(C_6\\) 的平面画法里顺时针前进。必须给到达的下一个顶点指定第二种颜色，比如蓝色。以顺时针方向继续下去，可以令第三个顶点为红色，第四个顶点为蓝色，第五个顶点为红色。最后，令第六个顶点为蓝色，它与第一个顶点是相邻的。因此，\\(C_6\\) 的着色数为2。图7显示了这样构造的着色。"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.706,
                0.484,
                0.74
            ],
            "angle": 0,
            "content": "其次，设 \\(n = 5\\) 并且考虑 \\(C_5\\) 。挑选一个顶点并且令它为红色。顺时针前进，必须给到达的下"
        },
        {
            "type": "image",
            "bbox": [
                0.502,
                0.574,
                0.695,
                0.716
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.706,
                0.574,
                0.891,
                0.715
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.605,
                0.72,
                0.786,
                0.734
            ],
            "angle": 0,
            "content": "图7 \\(C_5\\) 和 \\(C_6\\) 的着色"
        },
        {
            "type": "title",
            "bbox": [
                0.043,
                0.748,
                0.11,
                0.768
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.773,
                0.892,
                0.878
            ],
            "angle": 0,
            "content": "历史注解1852年，德·摩根从前的一个学生弗朗西斯·古特利注意到，用4种颜色可以给英格兰的郡着色，使得没有相邻的郡颜色相同。在此基础上，他猜想四色定理为真。弗朗西斯把这个问题告诉他的弟弟弗雷德里克，弗雷德里克当时是德·摩根的学生。弗雷德里克就哥哥的猜想询问了他的老师德·摩根。德·摩根对这个问题极其感兴趣，并且向数学界公布了它。事实上，在德·摩根给威廉·罗万·哈密顿爵士的信中第一次在书面上提到这个猜想。虽然德·摩根认为哈密顿可能对这个问题也感兴趣，但事实完全不是这样，因为它与四元数毫无关系。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.9,
                0.89,
                0.934
            ],
            "angle": 0,
            "content": "历史注解 虽然罗布森、桑得尔斯、西摩尔和托马斯在1996年找到了四色定理的简化证明，把证明的计算部分减少到检查633种格局，但是仍然没有找到不依赖于大量计算的证明。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.137,
                0.037,
                0.172,
                0.05
            ],
            "angle": 0,
            "content": "644"
        },
        {
            "type": "header",
            "bbox": [
                0.218,
                0.035,
                0.294,
                0.05
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.091,
                0.955,
                0.163
            ],
            "angle": 0,
            "content": "一个顶点指定第二种颜色，比如蓝色。以顺时针方向继续下去，可以令第三个顶点为红色，第四个顶点为蓝色。第五个顶点既不能为红色也不能为蓝色，因为它与第四个顶点和第一个顶点都相邻。所以，对这个顶点就需要第三种颜色。注意，假如以逆时针方向对顶点着色，同样需要三种颜色。因此，\\(C_5\\) 的着色数是3。用3种颜色对 \\(C_5\\) 着色见图7。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.166,
                0.955,
                0.238
            ],
            "angle": 0,
            "content": "在一般情形下，当 \\( n \\) 是偶数时，对 \\( C_n \\) 着色需要两种颜色。为了构造这样的着色，简单地挑选一个顶点并且令它为红色。然后（利用图的平面表示）以顺时针方向绕图前进，令第二个顶点为蓝色，第三个顶点为红色，以此类推。可以令第 \\( n \\) 个顶点为蓝色，因为与它相邻的两个顶点（即第 \\( n - 1 \\) 个顶点和第一个顶点）都是红色。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.241,
                0.955,
                0.294
            ],
            "angle": 0,
            "content": "当 \\(n\\) 是奇数且 \\(n > 1\\) 时，\\(C_n\\) 的着色数为3。为了看出这一点，挑选一个初始顶点。为了只用两种颜色，当以顺时针方向遍历这个图时，必须交替使用颜色。不过，所到达的第 \\(n\\) 个顶点与带不同颜色的两个顶点（第一个顶点和第 \\(n - 1\\) 个顶点）相邻。因此，必须使用第三种颜色。"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.3,
                0.918,
                0.316
            ],
            "angle": 0,
            "content": "我们已经证明了当 \\(n\\) 为正偶数且 \\(n \\geqslant 4\\) 时，\\(\\chi(C_n) = 2\\)，当 \\(n\\) 为正奇数且 \\(n \\geqslant 3\\) 时，\\(\\chi(C_n) = 3\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.319,
                0.955,
                0.391
            ],
            "angle": 0,
            "content": "已知最好的求图的着色数的算法（对图的顶点数来说）具有指数的最坏情形时间复杂度。即使求图的着色数的近似值也是很难的。已经证明，假如存在具有多项式最坏情形时间复杂度的可以达到2倍地近似图的着色数的算法（即构造出一个不超过图的着色数的两倍的界限），那么也存在具有多项式最坏情形时间复杂度的求图的着色数的算法。"
        },
        {
            "type": "title",
            "bbox": [
                0.11,
                0.401,
                0.339,
                0.418
            ],
            "angle": 0,
            "content": "10.8.2 图着色的应用"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.421,
                0.955,
                0.474
            ],
            "angle": 0,
            "content": "图着色在与调度和分配有关的问题中具有多种应用。（注意，由于不知道图着色的有效算法，所以这并不能得出调度和分配的有效算法。）这里将给出这样应用的例子。第一个应用是用来安排期末考试。"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.479,
                0.918,
                0.496
            ],
            "angle": 0,
            "content": "例5 安排期末考试 如何安排一所大学里的期末考试，使得没有学生同时要考两门？"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.501,
                0.655,
                0.574
            ],
            "angle": 0,
            "content": "解 这样的安排问题可以用图模型来解决，用顶点表示科目，若有学生要考两门，则在表示考试科目的两个顶点之间有边。用不同颜色来表示期末考试的每个时间段。考试的安排就对应于所关联的图的着色。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.577,
                0.655,
                0.688
            ],
            "angle": 0,
            "content": "例如，假定要安排七门期末考试。假定科目从1到7编号。假定下列各对科目的考试有学生要都参加：1和2，1和3，1和4，1和7，2和3，2和4，2和5，2和7，3和4，3和6，3和7，4和5，4和6，5和6，5和7，以及6和7。图8显示这组科目所关联的图。一种安排就是由这个图的一种着色来组成的。"
        },
        {
            "type": "image",
            "bbox": [
                0.679,
                0.507,
                0.929,
                0.676
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.683,
                0.691,
                0.924,
                0.706
            ],
            "angle": 0,
            "content": "图8表示期末考试安排的图"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.692,
                0.823,
                0.727
            ],
            "angle": 0,
            "content": "因为这个图的着色数为4（读者应当验证这一点），所以图8表示期末考需要4个时间段。图9显示使用了4种颜色的这个图的着色以及所关联的调度。"
        },
        {
            "type": "image",
            "bbox": [
                0.262,
                0.732,
                0.808,
                0.914
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.413,
                0.919,
                0.657,
                0.934
            ],
            "angle": 0,
            "content": "图9 用着色来安排期末考试"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.754,
                0.043,
                0.861,
                0.057
            ],
            "angle": 0,
            "content": "图 645"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.099,
                0.34,
                0.115
            ],
            "angle": 0,
            "content": "现在考虑对电视频道的分配。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.12,
                0.889,
                0.159
            ],
            "angle": 0,
            "content": "例6 频率分配 把频道2到13分配给在北美洲的电视台，要避免150英里之内的两家电视台在相同频道上播出。如何用图着色为频道分配建模？"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.161,
                0.889,
                0.198
            ],
            "angle": 0,
            "content": "解这样构造一个图：给每个电视台指定一个顶点。若两个电视台彼此位于150英里以内，则用边连接这两个顶点。频道分配就对应于这个图的着色，其中每种颜色表示一个不同的频道。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.199,
                0.424,
                0.216
            ],
            "angle": 0,
            "content": "图着色在编译器中的应用如例7所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.221,
                0.889,
                0.337
            ],
            "angle": 0,
            "content": "例7 变址寄存器 在有效的编译器中，当把频繁使用的变量暂时保存在中央处理单元的变址寄存器中，而不是保存在常规内存中时，可以加速循环的执行。对于给定的循环来说，需要多少个变址寄存器？可以用图着色模型来表示这个问题。为了建立这个模型，设图的每个顶点表示循环中的一个变量。若在循环执行期间两个顶点所表示的变量必须同时保存在变址寄存器中，则在这两个顶点之间有边。所以，这个图的着色数就给出了所需要的变址寄存器数，因为当表示变量的顶点在图中相邻时，就必须给这些变量分配不同的寄存器。"
        },
        {
            "type": "title",
            "bbox": [
                0.043,
                0.348,
                0.089,
                0.364
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.367,
                0.889,
                0.399
            ],
            "angle": 0,
            "content": "在练习 \\(1\\sim 4\\) 中，构造所示地图的对偶图。然后求给这个地图着色，使得相邻的两个区域都没有相同的颜色所需要的颜色数。"
        },
        {
            "type": "image",
            "bbox": [
                0.043,
                0.403,
                0.312,
                0.507
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.451,
                0.402,
                0.72,
                0.543
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.043,
                0.545,
                0.307,
                0.648
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.447,
                0.545,
                0.705,
                0.66
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.662,
                0.351,
                0.677
            ],
            "angle": 0,
            "content": "在练习 \\(5\\sim 11\\) 中，求给定图的着色数。"
        },
        {
            "type": "image",
            "bbox": [
                0.043,
                0.68,
                0.16,
                0.761
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.206,
                0.68,
                0.422,
                0.761
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.451,
                0.68,
                0.611,
                0.813
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.043,
                0.814,
                0.32,
                0.934
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.443,
                0.815,
                0.695,
                0.943
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.141,
                0.042,
                0.177,
                0.056
            ],
            "angle": 0,
            "content": "646"
        },
        {
            "type": "header",
            "bbox": [
                0.223,
                0.041,
                0.298,
                0.056
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.098,
                0.14,
                0.111
            ],
            "angle": 0,
            "content": "10."
        },
        {
            "type": "image",
            "bbox": [
                0.143,
                0.097,
                0.436,
                0.293
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.507,
                0.099,
                0.532,
                0.111
            ],
            "angle": 0,
            "content": "11."
        },
        {
            "type": "image",
            "bbox": [
                0.536,
                0.097,
                0.911,
                0.212
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.296,
                0.898,
                0.312
            ],
            "angle": 0,
            "content": "12. 对练习 \\(5 \\sim 11\\) 中的图，判定是否可能通过删除单个顶点和与所有与它关联的边来减少着色数。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.315,
                0.321,
                0.329
            ],
            "angle": 0,
            "content": "13. 哪些图的着色数为 1?"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.332,
                0.957,
                0.366
            ],
            "angle": 0,
            "content": "14. 为美国地图着色所需要的最少颜色数是什么？不要考虑只在一个尖角处相触的相邻州。假定密歇根是一个区域。把表示阿拉斯加和夏威夷的顶点当作孤立点。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.369,
                0.321,
                0.383
            ],
            "angle": 0,
            "content": "15. \\(W_{n}\\) 的着色数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.386,
                0.695,
                0.402
            ],
            "angle": 0,
            "content": "16. 证明：具有包含奇数个顶点的回路的简单图不能用两种颜色来着色。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.404,
                0.96,
                0.472
            ],
            "angle": 0,
            "content": "17. 假定除了科目 Math 115 与 CS 473, Math 116 与 CS 473, Math 195 与 CS 101, Math 195 与 CS 102, Math 115 与 Math 116, Math 115 与 Math 185, Math 185 与 Math 195 以外, 其他任意两种科目, 都有学生要参加这两种科目的考试, 请使用最少个数的不同时间段来为 Math 115、Math 116、Math 185、Math 195、CS 101、CS 102、CS 273 和 CS 473 安排期末考试日程表。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.476,
                0.957,
                0.509
            ],
            "angle": 0,
            "content": "18. 假定当两家电视台相距 150 英里以内时，它们就不能使用相同的频道，那么对相对距离如下表所示的 6 家电视台来说，需要多少个不同的频道？"
        },
        {
            "type": "table",
            "bbox": [
                0.113,
                0.519,
                0.96,
                0.658
            ],
            "angle": 0,
            "content": "<table><tr><td></td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td></tr><tr><td>1</td><td>-</td><td>85</td><td>175</td><td>200</td><td>50</td><td>100</td></tr><tr><td>2</td><td>85</td><td>-</td><td>125</td><td>175</td><td>100</td><td>160</td></tr><tr><td>3</td><td>175</td><td>125</td><td>-</td><td>100</td><td>200</td><td>250</td></tr><tr><td>4</td><td>200</td><td>175</td><td>100</td><td>-</td><td>210</td><td>220</td></tr><tr><td>5</td><td>50</td><td>100</td><td>200</td><td>210</td><td>-</td><td>100</td></tr><tr><td>6</td><td>100</td><td>160</td><td>250</td><td>220</td><td>100</td><td>-</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.67,
                0.957,
                0.739
            ],
            "angle": 0,
            "content": "19. 数学系有 6 个委员会，都是每月开一次会。假定委员会是 \\( C_1 = \\{ \\text{阿林豪斯，布兰德，沙斯拉夫斯基} \\} \\)、\\( C_2 = \\{ \\text{布兰德，李，罗森} \\} \\)、\\( C_3 = \\{ \\text{阿林豪斯，罗森，沙斯拉夫斯基} \\} \\)、\\( C_4 = \\{ \\text{李，罗森，沙斯拉夫斯基} \\} \\)、\\( C_5 = \\{ \\text{阿林豪斯，布兰德} \\} \\) 和 \\( C_6 = \\{ \\text{布兰德，罗森，沙斯拉夫斯基} \\} \\)，那么怎样安排才能确保没有人同时参加两个会议。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.742,
                0.957,
                0.775
            ],
            "angle": 0,
            "content": "20. 动物园想建立自然居住地，在里面展出动物。然而，有些动物一有机会就会吃掉另一些动物。如何用图模型和着色来确定所需要的不同居住地的数目，以及在这些居住地里的动物安排？"
        },
        {
            "type": "list",
            "bbox": [
                0.112,
                0.67,
                0.957,
                0.775
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.781,
                0.099,
                0.794
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.778,
                0.957,
                0.814
            ],
            "angle": 0,
            "content": "图的边着色是指对各边指定颜色，使得关联到相同顶点的边指定不同的颜色。图的边着色数是在该图的边着色里可以使用的最少颜色数。图 \\(G\\) 的边着色数记作 \\(\\chi^{\\prime}(G)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.817,
                0.417,
                0.832
            ],
            "angle": 0,
            "content": "21. 求练习 \\(5 \\sim 11\\) 中每个图的边色数。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.835,
                0.957,
                0.869
            ],
            "angle": 0,
            "content": "22. 设电路板上有 \\( n \\) 个器件，这些器件通过有色电线相连。要求连接同一器件的电线颜色不同，用表示电路板的图的边着色数来描述所需要的不同颜色的电线数。解释你的答案。"
        },
        {
            "type": "list",
            "bbox": [
                0.112,
                0.817,
                0.957,
                0.869
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.872,
                0.242,
                0.886
            ],
            "angle": 0,
            "content": "23. 求边着色数"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.889,
                0.291,
                0.904
            ],
            "angle": 0,
            "content": "a) \\(C_n\\) ，其中 \\(n \\geqslant 3\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.515,
                0.89,
                0.667,
                0.904
            ],
            "angle": 0,
            "content": "b) \\(W_{n}\\)，其中 \\(n \\geqslant 3\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.907,
                0.621,
                0.922
            ],
            "angle": 0,
            "content": "24. 证明：一个图的边着色数至少与该图的顶点的最大度一样。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.925,
                0.885,
                0.94
            ],
            "angle": 0,
            "content": "25. 证明：若 \\(G\\) 是含有 \\(n\\) 个顶点的图，在对 \\(G\\) 的边着色中，不超过 \\(n / 2\\) 的边可以着相同的颜色。"
        },
        {
            "type": "list",
            "bbox": [
                0.112,
                0.907,
                0.885,
                0.94
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.766,
                0.034,
                0.873,
                0.048
            ],
            "angle": 0,
            "content": "图 647"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.089,
                0.39,
                0.104
            ],
            "angle": 0,
            "content": "* 26. 当 \\( n \\) 是正整数时, 求 \\( K_{n} \\) 的边着色数。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.107,
                0.902,
                0.158
            ],
            "angle": 0,
            "content": "27. 7个变量出现在计算机程序的循环中。这些变量以及必须保存它们的计算步骤是： \\(t\\) ：步骤 \\(1\\sim 6\\) ； \\(u\\) ：步骤2； \\(v\\) ：步骤 \\(2\\sim 4\\) ； \\(\\omega\\) ：步骤1，3和5； \\(x\\) ：步骤1和6； \\(y\\) ：步骤 \\(3\\sim 6\\) ；以及 \\(z\\) ：步骤4和5。在执行期间需要多少个不同的变址寄存器来保存这些变量？"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.161,
                0.54,
                0.176
            ],
            "angle": 0,
            "content": "28. 关于一个以 \\(K_{n}\\) 作为子图的图的着色数能有些什么结论？"
        },
        {
            "type": "list",
            "bbox": [
                0.055,
                0.107,
                0.902,
                0.176
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.179,
                0.902,
                0.283
            ],
            "angle": 0,
            "content": "下面的算法可以用来为简单图着色。首先，以度递减的顺序列出顶点 \\(v_{1}, v_{2}, \\cdots, v_{n}\\)，使得 \\(\\deg(v_{1}) \\geqslant \\deg(v_{2}) \\geqslant \\cdots \\geqslant \\deg(v_{n})\\)。把颜色 1 指定给 \\(v_{1}\\) 和在表中不与 \\(v_{1}\\) 相邻的下一个顶点（若存在一个这样的顶点），并且继续指定给每一个在表中不与已经指定了颜色 1 的顶点相邻的顶点。然后把颜色 2 指定给表中还没有着色的第一个顶点。继续把颜色 2 指定给那些在表中还没有着色且不与指定了颜色 2 的顶点相邻的顶点。若还有未着色的顶点，则指定颜色 3 给表中还没有着色的第一个顶点，并且用颜色 3 继续对还没有着色且不与指定了颜色 3 的顶点相邻的那些顶点着色。继续这个过程直到所有顶点都着色为止。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.286,
                0.32,
                0.301
            ],
            "angle": 0,
            "content": "29. 用这个算法构造下图的着色。"
        },
        {
            "type": "image",
            "bbox": [
                0.086,
                0.304,
                0.514,
                0.422
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.425,
                0.32,
                0.439
            ],
            "angle": 0,
            "content": "* 30. 用伪代码描述这个着色算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.443,
                0.655,
                0.457
            ],
            "angle": 0,
            "content": "* 31. 证明：这个算法所产生的着色数可能比着色一个图所需的颜色数更多。"
        },
        {
            "type": "list",
            "bbox": [
                0.042,
                0.425,
                0.655,
                0.457
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.46,
                0.902,
                0.494
            ],
            "angle": 0,
            "content": "如果一个连通图 \\(G\\) 的着色数为 \\(k\\) ，但是对于 \\(G\\) 的任意一条边 \\(e\\) ，从 \\(G\\) 中删掉边 \\(e\\) 后得到的新图的着色数都是 \\(k - 1\\) ，则称 \\(G\\) 为着色 \\(k\\) 关键的。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.497,
                0.595,
                0.511
            ],
            "angle": 0,
            "content": "32. 证明：只要 \\( n \\) 是正的奇数且 \\( n \\geqslant 3 \\)，那么 \\( C_n \\) 就是着色 3 关键的。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.515,
                0.6,
                0.529
            ],
            "angle": 0,
            "content": "33. 证明：只要 \\( n \\) 是正的奇数且 \\( n \\geqslant 3 \\)，那么 \\( W_{n} \\) 就是着色4关键的。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.533,
                0.331,
                0.547
            ],
            "angle": 0,
            "content": "34. 证明：\\(W_{4}\\) 不是着色3关键的。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.551,
                0.682,
                0.565
            ],
            "angle": 0,
            "content": "35. 证明：如果图 \\(G\\) 为着色 \\(k\\) 关键的，那么 \\(G\\) 中的各个顶点的度至少是 \\(k - 1\\)。"
        },
        {
            "type": "list",
            "bbox": [
                0.055,
                0.497,
                0.682,
                0.565
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.571,
                0.902,
                0.661
            ],
            "angle": 0,
            "content": "图 \\(G\\) 的 \\(\\pmb{k}\\) 重着色是对 \\(G\\) 的顶点指定含有 \\(k\\) 种不同颜色的集合，使得相邻的顶点不具有相同的颜色。用 \\(\\chi_{k}(G)\\) 表示使 \\(G\\) 能用 \\(n\\) 种颜色进行 \\(k\\) 重着色的最小正整数 \\(n\\) 。例如，\\(\\chi_{2}(C_{4}) = 4\\) 。为了看出这一点，注意，如下图所示，只用4种颜色，就可以对 \\(C_4\\) 的每个顶点指定两种颜色，使得两个相邻顶点不具有相同的颜色。另外，少于4种颜色是不够的，因为顶点 \\(v_{1}\\) 和 \\(v_{2}\\) 每个都必须指定两种颜色，而且不能对 \\(v_{1}\\) 和 \\(v_{2}\\) 指定相同颜色。（关于 \\(k\\) 重着色的更多信息，见[MiRo91]。）"
        },
        {
            "type": "image",
            "bbox": [
                0.091,
                0.666,
                0.435,
                0.788
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.794,
                0.21,
                0.809
            ],
            "angle": 0,
            "content": "36. 求下列这些值："
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.814,
                0.171,
                0.831
            ],
            "angle": 0,
            "content": "a) \\(\\chi_{2}(K_{3})\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.282,
                0.814,
                0.364,
                0.83
            ],
            "angle": 0,
            "content": "b) \\(\\chi_{2}(K_{4})\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.456,
                0.814,
                0.54,
                0.83
            ],
            "angle": 0,
            "content": "c) \\(\\chi_{2}(W_{4})\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.836,
                0.167,
                0.851
            ],
            "angle": 0,
            "content": "d) \\(\\chi_{2}(C_{5})\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.282,
                0.836,
                0.372,
                0.851
            ],
            "angle": 0,
            "content": "e) \\(\\chi_{2}(K_{3,4})\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.456,
                0.836,
                0.537,
                0.851
            ],
            "angle": 0,
            "content": "f) \\(\\chi_{3}(K_{5})\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.075,
                0.857,
                0.166,
                0.872
            ],
            "angle": 0,
            "content": "\\(\\star \\mathbf{g})\\chi_{3}(C_{5})\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.282,
                0.857,
                0.374,
                0.872
            ],
            "angle": 0,
            "content": "h) \\(\\chi_{3}(K_{4,5})\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.875,
                0.361,
                0.89
            ],
            "angle": 0,
            "content": "* 37. 设 \\(G\\) 和 \\(H\\) 是如图3所示的图。求"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.896,
                0.16,
                0.912
            ],
            "angle": 0,
            "content": "a) \\(\\chi_{2}(G)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.282,
                0.896,
                0.357,
                0.912
            ],
            "angle": 0,
            "content": "b) \\(\\chi_{2}(H)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.456,
                0.896,
                0.527,
                0.912
            ],
            "angle": 0,
            "content": "c) \\(\\chi_{3}(G)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.631,
                0.896,
                0.708,
                0.912
            ],
            "angle": 0,
            "content": "d) \\(\\chi_{3}(H)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.917,
                0.473,
                0.932
            ],
            "angle": 0,
            "content": "38. 若 \\(G\\) 是二分图且 \\(k\\) 是正整数，则 \\(\\chi_{k}(G)\\) 是什么？"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.148,
                0.034,
                0.183,
                0.047
            ],
            "angle": 0,
            "content": "648"
        },
        {
            "type": "header",
            "bbox": [
                0.229,
                0.033,
                0.304,
                0.048
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.089,
                0.965,
                0.139
            ],
            "angle": 0,
            "content": "39. 移动广播（或蜂窝）电话的频率是按地段分配的。每个地段分配一组该地段中的设备所使用的频率。在产生干扰问题的地段中不能使用相同的频率。解释如何用 \\(k\\) 重着色来对一个区域里的每个移动广播地段分配 \\(k\\) 种频率。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.143,
                0.965,
                0.176
            ],
            "angle": 0,
            "content": "* 40. 证明：每个平面图 \\(G\\) 都可以用不超过6种颜色来着色。[提示：对图的顶点数用数学归纳法。应用10.7节推论2来求出满足 \\(\\deg(v) \\leqslant 5\\) 的顶点 \\(v\\)。考虑删除 \\(v\\) 和与其关联的所有边所获得的 \\(G\\) 的子图。]"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.179,
                0.845,
                0.194
            ],
            "angle": 0,
            "content": "**41. 证明：每个平面图 \\(G\\) 都可以用不超过5种颜色来着色。[提示：利用练习40的提示。]"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.197,
                0.965,
                0.32
            ],
            "angle": 0,
            "content": "著名的艺术馆问题是询问需要多少名保安才能看护到艺术馆的所有部分，这里艺术馆是一个 \\(n\\) 边形的边界及它所围的内部。为了更精确地描述这个问题，需要一些术语。如果线段 \\(xy\\) 上所有的点都在 \\(P\\) 边界上或 \\(P\\) 内部，则称简单多边形 \\(P\\) 边界上或 \\(P\\) 内部的点 \\(x\\) 覆盖或看见 \\(P\\) 边界上或 \\(P\\) 内部的点 \\(y\\) 。如果对于 \\(P\\) 边界上或 \\(P\\) 内部的每一个点 \\(y\\) ，都能够在一个点的集合中找到一个看见 \\(y\\) 的点 \\(x\\) ，就说这个点的集合是简单多边形的看守集。把看守简单多边形 \\(P\\) 所需的最少点数的看守集记为 \\(G(P)\\) 。艺术馆问题求的就是一个函数 \\(g(n)\\) ，它是所有 \\(n\\) 个顶点的简单多边形 \\(P\\) 的看守集 \\(G(P)\\) 的最大值 \\(\\Theta\\) 。也就是说，\\(g(n)\\) 是一个最小的正整数，使得一个 \\(n\\) 个顶点的简单多边形 \\(P\\) 保证可以被 \\(g(n)\\) 个或更少的保安看守。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.322,
                0.842,
                0.338
            ],
            "angle": 0,
            "content": "42. 通过证明所有的三角形和四边形都能够用一个点来看卫，证明： \\( g(3) = 1 \\) 和 \\( g(4) = 1 \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.34,
                0.965,
                0.373
            ],
            "angle": 0,
            "content": "* 43. 证明: \\( g(5) = 1 \\), 即所有的五边形都能够被一个点看卫。[提示: 先分出有 0 个、1 个、2 个顶点的内角大于 180 度, 然后再说明在各种情况下一个保安都足够了。]"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.376,
                0.965,
                0.409
            ],
            "angle": 0,
            "content": "* 44. 首先运用练习 42 和 43 的结果，以及 5.2 节的引理 1 证明 \\( g(6) \\leqslant 2 \\)，然后找出一个需要两名保安的六边形。最后证明 \\( g(6) = 2 \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.412,
                0.965,
                0.445
            ],
            "angle": 0,
            "content": "* 45. 证明: \\(g(n) \\geqslant \\lfloor n / 3 \\rfloor\\). [提示: 考虑具有 \\(3k\\) 个顶点和 \\(k\\) 个齿尖的梳子状的多边形, 如下图所示的 15 边形一样。]"
        },
        {
            "type": "list",
            "bbox": [
                0.104,
                0.34,
                0.965,
                0.445
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.151,
                0.447,
                0.577,
                0.524
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.527,
                0.969,
                0.615
            ],
            "angle": 0,
            "content": "* 46. 通过证明艺术馆定理，解决艺术馆问题。该定理说一个 \\(n\\) 个顶点的简单多边形最多需要 \\(\\lfloor n / 3\\rfloor\\) 个保安来守卫它的边界和内部。[提示：运用5.2节的定理1把这个简单多边形三角化为 \\(n - 2\\) 个三角形。然后说明只需要3种颜色就能够将三角形化后的简单多边形的顶点进行着色，使得相邻的顶点都具有不同的颜色。使用归纳方法和5.2节练习23，最后在所有红色的顶点上安置保安，这里红色是在顶点染色中用得最少的一种颜色。说明在这些点上安置保安就是所需要的全部保安。]"
        },
        {
            "type": "title",
            "bbox": [
                0.121,
                0.628,
                0.31,
                0.648
            ],
            "angle": 0,
            "content": "关键术语和结论"
        },
        {
            "type": "title",
            "bbox": [
                0.121,
                0.656,
                0.17,
                0.673
            ],
            "angle": 0,
            "content": "术语"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.676,
                0.717,
                0.692
            ],
            "angle": 0,
            "content": "无向边(undirected edge)：与集合 \\(\\{u, v\\}\\) 关联的边，其中 \\(u\\) 和 \\(v\\) 都是顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.694,
                0.717,
                0.71
            ],
            "angle": 0,
            "content": "有向边（directed edge）：与有序对 \\((u, v)\\) 关联的边，其中 \\(u\\) 和 \\(v\\) 都是顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.712,
                0.578,
                0.728
            ],
            "angle": 0,
            "content": "多重边(multiple edges)：连接同样一对顶点的不同的边。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.73,
                0.443,
                0.745
            ],
            "angle": 0,
            "content": "环（loop）：连接一个顶点与它自身的边。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.748,
                0.689,
                0.763
            ],
            "angle": 0,
            "content": "无向图(undirected graph)：一组顶点以及连接这些顶点的一组无向边。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.766,
                0.53,
                0.781
            ],
            "angle": 0,
            "content": "简单图（simple graph）：没有多重边和环的无向图。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.784,
                0.606,
                0.799
            ],
            "angle": 0,
            "content": "多重图(multigraph)：可能包含多重边但不包含环的无向图。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.802,
                0.545,
                0.817
            ],
            "angle": 0,
            "content": "伪图(pseudograph)：可能包含多重边和环的无向图。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.82,
                0.67,
                0.835
            ],
            "angle": 0,
            "content": "有向图（directed graph）：一组顶点以及连接这些顶点的一组有向边。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.838,
                0.655,
                0.853
            ],
            "angle": 0,
            "content": "有向多重图（directed multigraph）：可能包含多重有向边的有向图。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.856,
                0.633,
                0.871
            ],
            "angle": 0,
            "content": "简单有向图(simple directed graph)：不含环和多重边的有向图。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.874,
                0.585,
                0.889
            ],
            "angle": 0,
            "content": "相邻(adjacent)：若在两个顶点之间有边则它们是相邻的。"
        },
        {
            "type": "page_footnote",
            "bbox": [
                0.165,
                0.918,
                0.601,
                0.932
            ],
            "angle": 0,
            "content": "\\(\\ominus\\) 考虑 \\(n\\) 个顶点的简单多边形 \\(P\\) 的各种形态。——译者注"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.763,
                0.037,
                0.869,
                0.052
            ],
            "angle": 0,
            "content": "图 649"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.092,
                0.604,
                0.107
            ],
            "angle": 0,
            "content": "关联(incident)：若一个顶点是一条边的端点则那条边关联那个顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.11,
                0.898,
                0.142
            ],
            "angle": 0,
            "content": "\\(\\deg(v)\\) （无向图中顶点 \\(v\\) 的度，degree of the vertex \\(v\\) in an undirected graph）：与 \\(v\\) 关联的边的数目，环贡献2。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.145,
                0.898,
                0.178
            ],
            "angle": 0,
            "content": "\\(\\deg^{-}(\\pmb{v})\\) （带有向边的图中顶点 \\(\\pmb{v}\\) 的入度，the in-degree of the vertex \\(v\\) in a graph with directed edges）：以 \\(\\pmb{v}\\) 作为终点的边的数目。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.18,
                0.898,
                0.213
            ],
            "angle": 0,
            "content": "\\(\\deg^{+}(\\pmb{v})\\) （带有向边的图中顶点 \\(\\pmb{v}\\) 的出度，the out-degree of the vertex \\(\\pmb{v}\\) in a graph with directed edges）：以 \\(v\\) 作为起点的边的数目。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.215,
                0.898,
                0.248
            ],
            "angle": 0,
            "content": "带有向边的图的基本无向图(underlying undirected graph of a graph with directed edges)：通过忽略有向边的方向所获得的无向图。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.251,
                0.898,
                0.284
            ],
            "angle": 0,
            "content": "\\(\\pmb{K}_{n}\\) （\\(n\\) 个顶点的完全图，complete graph on n vertices）：带 \\(n\\) 个顶点的无向图，其中每对顶点都用一条边连接。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.286,
                0.898,
                0.319
            ],
            "angle": 0,
            "content": "二分图（bipartite graph）：顶点集划分成两个子集合 \\(V_{1}\\) 和 \\(V_{2}\\) 的图，使得每条边都连接 \\(V_{1}\\) 中的顶点和 \\(V_{2}\\) 中的顶点。序对 \\((V_{1}, V_{2})\\) 成为 \\(V\\) 的二部划分。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.321,
                0.898,
                0.355
            ],
            "angle": 0,
            "content": "\\(K_{m,n}\\) （完全二分图，complete bipartite graph）：顶点集划分成 \\(m\\) 个元素的子集和 \\(n\\) 个元素的子集，使得两个顶点被一条边所连接当且仅当一个顶点属于第一个子集而另外一个顶点属于第二个子集。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.357,
                0.898,
                0.39
            ],
            "angle": 0,
            "content": "\\(C_n\\) （大小为 \\(n\\) 的圈图，cycle of size \\(n\\) ， \\(n\\geqslant 3\\) ）：带有 \\(n\\) 个顶点 \\(v_{1}\\) ， \\(v_{2}\\) ，…， \\(v_{n}\\) 和边 \\(\\{v_{1},v_{2}\\}\\) ， \\(\\{v_{2},v_{3}\\}\\) ，…， \\(\\{v_{n - 1},v_n\\}\\) ， \\(\\{v_{n},v_{1}\\}\\) 的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.392,
                0.898,
                0.424
            ],
            "angle": 0,
            "content": "\\(W_{n}\\) （大小为 \\(n\\) 的轮图，whcfof size \\(n\\) ， \\(n\\geq 3\\) ）：通过向 \\(C_n\\) 添加一个顶点以及从这个顶点到 \\(C_n\\) 中原来每个顶点的一条边所获得的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.427,
                0.898,
                0.46
            ],
            "angle": 0,
            "content": "\\(Q_{n}\\) （ \\(n\\) 立方体图， \\(n\\) -cube， \\(n\\geqslant 1\\) ）：用 \\(2^{n}\\) 个长度为 \\(n\\) 的比特串作为顶点，边连接恰好相差一位的每对比特串的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.462,
                0.721,
                0.478
            ],
            "angle": 0,
            "content": "图 \\(G\\) 中的匹配（matching in a graph \\(G\\)）：一组边的集合且任意两边都没有公共端点。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.48,
                0.898,
                0.513
            ],
            "angle": 0,
            "content": "从 \\(V_{1}\\) 到 \\(V_{2}\\) 的完全匹配 \\(M\\) (complete matching \\(M\\) from \\(V_{1}\\) to \\(V_{2}\\)): \\(V_{1}\\) 中的每个顶点都是 \\(M\\) 中的边的端点的匹配。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.516,
                0.64,
                0.531
            ],
            "angle": 0,
            "content": "最大匹配（maximum matching）：在图中所有匹配中包含边数最多的匹配。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.534,
                0.378,
                0.548
            ],
            "angle": 0,
            "content": "孤立点(isolatedvertex)：度为0的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.551,
                0.38,
                0.566
            ],
            "angle": 0,
            "content": "悬挂点（pendantvertex）：度为1的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.568,
                0.482,
                0.584
            ],
            "angle": 0,
            "content": "正则图(regular graph)：所有顶点都有相同的度的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.586,
                0.898,
                0.618
            ],
            "angle": 0,
            "content": "图 \\(G = (V,E)\\) 的子图(subgraph of a graph \\(G = (V,E)\\) ）：图 \\((W,F)\\) ，其中 \\(W\\) 是 \\(V\\) 的子集而 \\(F\\) 是 \\(E\\) 的子集。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.62,
                0.898,
                0.654
            ],
            "angle": 0,
            "content": "\\(G_{1} \\cup G_{2}\\) (\\(G_{1}\\) 与 \\(G_{2}\\) 的并图) (\\(G_{1} \\cup G_{2}\\) (union of \\(G_{1}\\) and \\(G_{2}\\))：图 \\((V_{1} \\cup V_{2}, E_{1} \\cup E_{2})\\)，其中 \\(G_{1} = (V_{1}, E_{1})\\) 和 \\(G_{2} = (V_{2}, E_{2})\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.656,
                0.6,
                0.672
            ],
            "angle": 0,
            "content": "邻接矩阵(adjacency matrix)：利用顶点的相邻关系来表示图的矩阵。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.674,
                0.634,
                0.689
            ],
            "angle": 0,
            "content": "关联矩阵(incidence matrix)：利用边与顶点的关联关系来表示图的矩阵。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.691,
                0.898,
                0.742
            ],
            "angle": 0,
            "content": "同构的简单图(isomorphic simple graphs)：对简单图 \\(G_{1} = (V_{1},E_{1})\\) 和简单图 \\(G_{2} = (V_{2},E_{2})\\) 来说，若存在从 \\(V_{1}\\) 到 \\(V_{2}\\) 的一一对应 \\(f\\) ，使得对所有属于 \\(V_{1}\\) 的 \\(\\boldsymbol{v}_{1}\\) 和 \\(\\boldsymbol{v}_{2}\\) 来说， \\(\\{f(v_1),f(v_2)\\} \\in E_2\\) 当且仅当 \\(\\{v_{1},\\) \\(v_{2}\\} \\in E_{1}\\) ，则 \\(G_{1}\\) 与 \\(G_{2}\\) 是同构的。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.744,
                0.685,
                0.76
            ],
            "angle": 0,
            "content": "同构不变量(invariant for graph isomorphism)：同构的图都有或都没有的性质。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.762,
                0.898,
                0.795
            ],
            "angle": 0,
            "content": "无向图里从 \\(\\pmb{u}\\) 到 \\(\\pmb{\\nu}\\) 的通路（path from \\(u\\) to \\(v\\) in an undirected graph）：一条或多条边的序列 \\(e_1, e_2, \\dots, e_n\\)，其中对 \\(i = 0, 1, \\dots, n\\) 来说，\\(e_i\\) 关联着 \\(\\{x_i, x_{i+1}\\}\\)，其中 \\(x_0 = u\\) 而 \\(x_{n+1} = v\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.797,
                0.898,
                0.831
            ],
            "angle": 0,
            "content": "有向图中从 \\(\\pmb{u}\\) 到 \\(\\pmb{\\nu}\\) 的通路（path from \\(u\\) to \\(v\\) in a graph with directed edges）：一条或多条边的序列 \\(e_1, e_2, \\dots, e_n\\)，其中对 \\(i = 0, 1, \\dots, n\\) 来说，\\(e_i\\) 关联着 \\((x_i, x_{i+1})\\)，其中 \\(x_0 = u\\) 而 \\(x_{n+1} = v\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.833,
                0.468,
                0.848
            ],
            "angle": 0,
            "content": "简单通路（simple path）：不多次包含一条边的通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.85,
                0.578,
                0.865
            ],
            "angle": 0,
            "content": "回路(circuit)：在相同顶点处开始与结束的通路，通路长度 \\(n \\geqslant 1\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.868,
                0.596,
                0.884
            ],
            "angle": 0,
            "content": "连通图（connected graph）：在图中每对顶点之间都有通路的无向图。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.886,
                0.598,
                0.902
            ],
            "angle": 0,
            "content": "图 \\(G\\) 的割点（cutvertexof \\(G\\) ）：一个顶点 \\(\\pmb{v}\\) ，使得 \\(G - v\\) 是不连通的。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.904,
                0.563,
                0.919
            ],
            "angle": 0,
            "content": "图 \\(G\\) 的割边(cut edge of \\(G\\)): 一条边 \\(e\\), 使得 \\(G - e\\) 是不连通的。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.921,
                0.472,
                0.937
            ],
            "angle": 0,
            "content": "不可分割的图(nonseparable graph)：不含割点的图。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.132,
                0.038,
                0.167,
                0.051
            ],
            "angle": 0,
            "content": "650"
        },
        {
            "type": "header",
            "bbox": [
                0.212,
                0.036,
                0.29,
                0.052
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.093,
                0.762,
                0.109
            ],
            "angle": 0,
            "content": "图 \\(G\\) 的点割集(vertexcutof \\(G\\) ）：图 \\(G\\) 顶点集的子集 \\(V^{\\prime}\\) ，使得 \\(G - V^{\\prime}\\) 是不连通的。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.111,
                0.785,
                0.126
            ],
            "angle": 0,
            "content": "\\(\\kappa (G)\\) （图 \\(G\\) 的点连通度，thevertexconnectivityof \\(G\\) ）：图 \\(G\\) 中最小的点割集的大小。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.129,
                0.608,
                0.144
            ],
            "angle": 0,
            "content": "\\(k\\)-连通图（\\(k\\)-connected graph）：有一个点连通度不小于 \\(k\\) 的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.146,
                0.71,
                0.162
            ],
            "angle": 0,
            "content": "图 \\(G\\) 的边割集(edgecutof \\(G\\) ）：图 \\(G\\) 边的集合 \\(E^{\\prime}\\) ，使得 \\(G - E^{\\prime}\\) 是不连通的。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.164,
                0.773,
                0.179
            ],
            "angle": 0,
            "content": "\\(\\lambda (G)\\) （图 \\(G\\) 的边连通度，the edge connectivity of \\(G\\) ）：图 \\(G\\) 中最小的边割集的大小。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.182,
                0.724,
                0.197
            ],
            "angle": 0,
            "content": "图 \\(G\\) 的连通分支（connected component of a graph \\(G\\)）：图 \\(G\\) 的最大连通子图。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.2,
                0.914,
                0.215
            ],
            "angle": 0,
            "content": "强连通有向图(strongly connected directed graph)：从每个顶点到每个顶点都存在有向通路的有向图。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.218,
                0.911,
                0.233
            ],
            "angle": 0,
            "content": "有向图 \\(G\\) 的强连通分支(strongly connected component of a directed graph \\(G\\)): \\(G\\) 的最大强连通子图。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.235,
                0.568,
                0.25
            ],
            "angle": 0,
            "content": "欧拉通路(Euler path)：恰好包含图的每条边一次的通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.253,
                0.583,
                0.268
            ],
            "angle": 0,
            "content": "欧拉回路（Euler circuit）：恰好包含图的每条边一次的回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.271,
                0.636,
                0.286
            ],
            "angle": 0,
            "content": "哈密顿通路（Hamilton path）：恰好通过图的每个顶点一次的通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.289,
                0.65,
                0.304
            ],
            "angle": 0,
            "content": "哈密顿回路（Hamilton circuit）：恰好通过图的每个顶点一次的回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.306,
                0.495,
                0.321
            ],
            "angle": 0,
            "content": "加权图(weighted graph)：为各边指定数字的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.324,
                0.949,
                0.357
            ],
            "angle": 0,
            "content": "最短通路问题(shortest-path problem)：确定加权图中的通路以使得这条通路中的边的权之和在指定的顶点之间的所有通路上是最小值这样的问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.36,
                0.949,
                0.392
            ],
            "angle": 0,
            "content": "旅行商问题（traveling salesperson problem）：求访问图的每个顶点恰好一次的、总长度最短的回路的问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.395,
                0.585,
                0.41
            ],
            "angle": 0,
            "content": "平面图（planar graph）：可以画在平面上而没有边交叉的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.413,
                0.949,
                0.445
            ],
            "angle": 0,
            "content": "平面图的平面表示的面(regions of a representation of a planar graph)：该图的平面表示把平面所分割成的区域。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.448,
                0.922,
                0.464
            ],
            "angle": 0,
            "content": "初等细分（elementary subdivision）：删除无向图的边 \\(\\{u, v\\}\\) 而且添加新顶点 \\(w\\) 以及边 \\(\\{u, w\\}\\) 和边 \\(\\{w, v\\}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.466,
                0.914,
                0.482
            ],
            "angle": 0,
            "content": "同胚（homeomorphic）：若两个无向图是从同一个无向图通过一系列初等细分来获得的，则它们同胚。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.484,
                0.802,
                0.5
            ],
            "angle": 0,
            "content": "图着色（graph coloring）：给图的顶点指定颜色，使得相邻的两个顶点没有相同的颜色。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.502,
                0.625,
                0.517
            ],
            "angle": 0,
            "content": "着色数(chromatic number)：在图的着色中所需要的最少颜色数。"
        },
        {
            "type": "title",
            "bbox": [
                0.104,
                0.528,
                0.152,
                0.544
            ],
            "angle": 0,
            "content": "结论"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.548,
                0.883,
                0.575
            ],
            "angle": 0,
            "content": "握手定理(Thehandshakingtheorem)：设 \\(G = (V,E)\\) 是有 \\(m\\) 条边的无向图，则 \\(2m = \\sum_{v\\in V}\\deg (v)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.578,
                0.949,
                0.613
            ],
            "angle": 0,
            "content": "霍尔婚姻定理(Hall's marriage theorem)：带有二部划分 \\((V_{1}, V_{2})\\) 的二分图 \\(G = (V, E)\\) 中有一个从 \\(V_{1}\\) 到 \\(V_{2}\\) 的完全匹配当且仅当对于 \\(V_{1}\\) 的所有子集 \\(A\\)，有 \\(|N(A)| \\geqslant |A|\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.616,
                0.636,
                0.631
            ],
            "angle": 0,
            "content": "在连通多重图中存在欧拉回路当且仅当每个顶点的度数都为偶数。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.634,
                0.692,
                0.649
            ],
            "angle": 0,
            "content": "在连通多重图中存在欧拉通路当且仅当至多有两个度数都为奇数的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.651,
                0.914,
                0.667
            ],
            "angle": 0,
            "content": "迪克斯特拉算法(Dijkstra'salgorithm)：在加权图中求出两个顶点之间最短通路的过程(见10.6节)。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.669,
                0.949,
                0.702
            ],
            "angle": 0,
            "content": "欧拉公式(Euler's formula)： \\(r = e - v + 2\\) ，其中 \\(r\\) 、 \\(e\\) 和 \\(v\\) 分别是平面图的平面表示的面数、边数和顶点数。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.705,
                0.949,
                0.738
            ],
            "angle": 0,
            "content": "库拉图斯基定理(Kuratowski's theorem)：图是非平面图当且仅当它包含同胚于 \\(K_{3,3}\\) 或 \\(K_{5}\\) 的子图。（其证明超出本书范围。）"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.74,
                0.949,
                0.773
            ],
            "angle": 0,
            "content": "四色定理(The four color theorem)：每个平面图都可以用不超过4种颜色来着色。（其证明远远超出本书范围！）"
        },
        {
            "type": "title",
            "bbox": [
                0.104,
                0.788,
                0.187,
                0.806
            ],
            "angle": 0,
            "content": "复习题"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.814,
                0.584,
                0.829
            ],
            "angle": 0,
            "content": "1. a)定义：简单图、多重图、伪图、有向图、有向多重图。"
        },
        {
            "type": "text",
            "bbox": [
                0.122,
                0.832,
                0.949,
                0.864
            ],
            "angle": 0,
            "content": "b)用例子说明：如何用a中每种类型的图来建模。例如，解释如何为计算机网络或飞行航线的不同方面来建模。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.867,
                0.418,
                0.882
            ],
            "angle": 0,
            "content": "2. 给出如何用图建模的至少4个例子。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.885,
                0.843,
                0.9
            ],
            "angle": 0,
            "content": "3. 在无向图中，顶点度数之和与该图中边数之间的关系是什么？解释这个关系为什么成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.903,
                0.55,
                0.918
            ],
            "angle": 0,
            "content": "4. 为什么在无向图中一定有偶数个度数为奇数的顶点？"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.921,
                0.825,
                0.936
            ],
            "angle": 0,
            "content": "5. 在有向图中顶点的入度之和与出度之和之间的关系是什么？解释这个关系为什么成立。"
        },
        {
            "type": "list",
            "bbox": [
                0.101,
                0.814,
                0.949,
                0.936
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.77,
                0.037,
                0.874,
                0.052
            ],
            "angle": 0,
            "content": "图 651"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.093,
                0.203,
                0.106
            ],
            "angle": 0,
            "content": "6. 描述下列图族。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.11,
                0.336,
                0.124
            ],
            "angle": 0,
            "content": "a) \\( K_{n} \\)，在 \\( n \\) 个顶点上的完全图。"
        },
        {
            "type": "text",
            "bbox": [
                0.458,
                0.11,
                0.806,
                0.124
            ],
            "angle": 0,
            "content": "b) \\(K_{m,n}\\)，在 \\(m\\) 和 \\(n\\) 个顶点上的完全二分图。"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.127,
                0.296,
                0.141
            ],
            "angle": 0,
            "content": "c) \\(C_{n}\\)，带 \\(n\\) 个顶点的圈图。"
        },
        {
            "type": "text",
            "bbox": [
                0.459,
                0.127,
                0.661,
                0.141
            ],
            "angle": 0,
            "content": "d) \\(W_{n}\\)，大小为 \\(n\\) 的轮图。"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.145,
                0.217,
                0.158
            ],
            "angle": 0,
            "content": "e) \\(Q_{n}\\) ， \\(n\\) 立方体。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.161,
                0.521,
                0.174
            ],
            "angle": 0,
            "content": "7. 在练习6的图族中，每个图有多少个顶点和多少条边？"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.178,
                0.223,
                0.191
            ],
            "angle": 0,
            "content": "8. a) 什么是二分图？"
        },
        {
            "type": "text",
            "bbox": [
                0.459,
                0.178,
                0.76,
                0.191
            ],
            "angle": 0,
            "content": "b) 图 \\(K_{n}\\) 、 \\(C_{n}\\) 和 \\(W_{n}\\) 中哪些是二分图？"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.195,
                0.371,
                0.208
            ],
            "angle": 0,
            "content": "c)你如何确定无向图是否为二分图？"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.211,
                0.37,
                0.224
            ],
            "angle": 0,
            "content": "9. a)描述用来表示图的3种不同方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.228,
                0.799,
                0.241
            ],
            "angle": 0,
            "content": "b) 画出至少带 5 个顶点和 8 条边的简单图。说明如何用你在 a) 中所描述的方法来表示它。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.245,
                0.38,
                0.258
            ],
            "angle": 0,
            "content": "10. a)两个简单图是同构的是什么意思？"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.261,
                0.767,
                0.275
            ],
            "angle": 0,
            "content": "b)对于简单图的同构来说，不变量是什么意思？给出至少5个这样的不变量的例子。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.278,
                0.694,
                0.292
            ],
            "angle": 0,
            "content": "c)给出带有相同的顶点数、边数和顶点度数但不同构的两个简单图的例子。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.296,
                0.661,
                0.309
            ],
            "angle": 0,
            "content": "d)是否有一组已知的不变量可以用来有效地确定两个简单图是否同构？"
        },
        {
            "type": "list",
            "bbox": [
                0.088,
                0.261,
                0.767,
                0.309
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.313,
                0.307,
                0.326
            ],
            "angle": 0,
            "content": "11. a) 图是连通的是什么意思？"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.33,
                0.289,
                0.343
            ],
            "angle": 0,
            "content": "b) 什么是图的连通分支？"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.346,
                0.361,
                0.359
            ],
            "angle": 0,
            "content": "12. a) 解释如何用邻接矩阵来表示图。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.363,
                0.744,
                0.376
            ],
            "angle": 0,
            "content": "b)如何用邻接矩阵来确定从图 \\(G\\) 的顶点集到图 \\(H\\) 的顶点集的函数是否是同构的？"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.38,
                0.801,
                0.393
            ],
            "angle": 0,
            "content": "c)如何用图的邻接矩阵来确定在图的两个顶点之间长度为 \\(r\\) 的通路数？其中 \\(r\\) 是正整数。"
        },
        {
            "type": "list",
            "bbox": [
                0.088,
                0.363,
                0.801,
                0.393
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.396,
                0.417,
                0.41
            ],
            "angle": 0,
            "content": "13. a) 定义无向图中的欧拉回路和欧拉通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.413,
                0.713,
                0.427
            ],
            "angle": 0,
            "content": "b)描述著名的哥尼斯堡七桥问题，并且解释如何利用欧拉回路来重新叙述它。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.43,
                0.399,
                0.444
            ],
            "angle": 0,
            "content": "c)如何确定无向图是否具有欧拉通路？"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.447,
                0.4,
                0.46
            ],
            "angle": 0,
            "content": "d)如何确定无向图是否具有欧拉回路？"
        },
        {
            "type": "list",
            "bbox": [
                0.088,
                0.413,
                0.713,
                0.46
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.464,
                0.343,
                0.477
            ],
            "angle": 0,
            "content": "14. a)定义简单图中的哈密顿回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.48,
                0.565,
                0.494
            ],
            "angle": 0,
            "content": "b)给出一些性质，这些性质蕴含着简单图没有哈密顿回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.497,
                0.64,
                0.511
            ],
            "angle": 0,
            "content": "15. 给出至少两个可以通过求出加权图中最短通路来解决的问题的例子。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.515,
                0.602,
                0.528
            ],
            "angle": 0,
            "content": "16. a) 描述求在加权图两个顶点之间的最短通路的迪克斯特拉算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.531,
                0.905,
                0.561
            ],
            "angle": 0,
            "content": "b) 画出至少带 10 个顶点和 20 条边的加权图。用迪克斯特拉算法求出在图中你所选择的两个顶点之间的最短通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.564,
                0.308,
                0.578
            ],
            "angle": 0,
            "content": "17. a) 图是平面图是什么意思？"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.581,
                0.343,
                0.595
            ],
            "angle": 0,
            "content": "b)给出非平面图简单图的例子。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.598,
                0.363,
                0.611
            ],
            "angle": 0,
            "content": "18. a) 连通平面图的欧拉公式是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.614,
                0.568,
                0.628
            ],
            "angle": 0,
            "content": "b)如何用平面图的欧拉公式来证明一个简单图是非平面图？"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.631,
                0.751,
                0.645
            ],
            "angle": 0,
            "content": "19.叙述关于图的平面性的库拉图斯基定理，并且解释它如何刻画了哪些图是平面图。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.649,
                0.249,
                0.662
            ],
            "angle": 0,
            "content": "20. a)定义图的着色数。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.665,
                0.451,
                0.679
            ],
            "angle": 0,
            "content": "b)当 \\(n\\) 是正整数时，图 \\(K_{n}\\) 的着色数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.682,
                0.52,
                0.696
            ],
            "angle": 0,
            "content": "c)当 \\(n\\) 是大于2的正整数时，图 \\(C_n\\) 的着色数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.699,
                0.52,
                0.713
            ],
            "angle": 0,
            "content": "d)当 \\(m\\) 和 \\(n\\) 都是正整数时，图 \\(K_{m,n}\\) 的着色数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.716,
                0.512,
                0.73
            ],
            "angle": 0,
            "content": "21.叙述四色定理。有没有不能用4种颜色来着色的图？"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.733,
                0.566,
                0.746
            ],
            "angle": 0,
            "content": "22. 解释在建模里如何使用图的着色。至少举两个不同的例子。"
        },
        {
            "type": "title",
            "bbox": [
                0.06,
                0.761,
                0.167,
                0.779
            ],
            "angle": 0,
            "content": "补充练习"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.787,
                0.439,
                0.801
            ],
            "angle": 0,
            "content": "1. 一个带 100 个顶点的 50-正则图有多少条边？"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.804,
                0.304,
                0.818
            ],
            "angle": 0,
            "content": "2. \\(K_{3}\\) 有多少种非同构的子图？"
        },
        {
            "type": "list",
            "bbox": [
                0.059,
                0.787,
                0.439,
                0.818
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.821,
                0.489,
                0.835
            ],
            "angle": 0,
            "content": "在练习 \\(3\\sim 5\\) 中，判断所给的成对的图是否是同构的。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.839,
                0.073,
                0.85
            ],
            "angle": 0,
            "content": "3"
        },
        {
            "type": "image",
            "bbox": [
                0.08,
                0.839,
                0.397,
                0.936
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.455,
                0.838,
                0.639,
                0.937
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.131,
                0.038,
                0.167,
                0.051
            ],
            "angle": 0,
            "content": "652"
        },
        {
            "type": "header",
            "bbox": [
                0.212,
                0.037,
                0.288,
                0.052
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.095,
                0.12,
                0.107
            ],
            "angle": 0,
            "content": "4."
        },
        {
            "type": "image",
            "bbox": [
                0.125,
                0.093,
                0.37,
                0.252
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.445,
                0.094,
                0.687,
                0.252
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.126,
                0.256,
                0.367,
                0.432
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.438,
                0.26,
                0.7,
                0.43
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.435,
                0.951,
                0.469
            ],
            "angle": 0,
            "content": "完全 \\(m\\) 部图 \\(K_{n_1,n_2,\\dots ,n_m}\\) 的顶点划分成 \\(m\\) 个子集合，各有 \\(n_1\\) ， \\(n_2\\) ，…， \\(n_m\\) 个元素，而且顶点相邻当且仅当它们属于这个划分的不同子集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.473,
                0.232,
                0.486
            ],
            "angle": 0,
            "content": "6. 画出下列图。"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.491,
                0.191,
                0.505
            ],
            "angle": 0,
            "content": "a) \\(K_{1,2,3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.331,
                0.491,
                0.394,
                0.504
            ],
            "angle": 0,
            "content": "b) \\(K_{2,2,2}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.507,
                0.491,
                0.578,
                0.504
            ],
            "angle": 0,
            "content": "c) \\(K_{1,2,3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.508,
                0.536,
                0.525
            ],
            "angle": 0,
            "content": "* 7. 完全 \\( m \\) 部图 \\( {K}_{{n}_{1},{n}_{2},\\cdots ,{n}_{m}} \\) 有多少个顶点和多少条边?"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.527,
                0.788,
                0.541
            ],
            "angle": 0,
            "content": "8. 证明或反证：在至少有两个顶点的有穷多重图中，总是存在两个度数相同的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.545,
                0.581,
                0.558
            ],
            "angle": 0,
            "content": "9. 设 \\(G = (V, E)\\) 是无向图，并且令 \\(A \\subseteq V\\) 和 \\(B \\subseteq V\\)，证明："
        },
        {
            "type": "text",
            "bbox": [
                0.125,
                0.562,
                0.367,
                0.576
            ],
            "angle": 0,
            "content": "a) \\(N(A \\cup B) = N(A) \\cup N(B)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.125,
                0.58,
                0.729,
                0.594
            ],
            "angle": 0,
            "content": "b) \\(N(A \\cap B) \\subseteq N(A) \\cap N(B)\\)，并且给出 \\(N(A \\cap B) \\neq N(A) \\cap N(B)\\) 的例子。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.598,
                0.395,
                0.611
            ],
            "angle": 0,
            "content": "10. 设 \\(G = (V, E)\\) 是无向图，证明："
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.616,
                0.464,
                0.631
            ],
            "angle": 0,
            "content": "a)对于所有的 \\(v\\in V\\) ， \\(\\left|N(v)\\right|\\leqslant \\deg (v)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.134,
                0.636,
                0.672,
                0.651
            ],
            "angle": 0,
            "content": "b)对于所有的 \\(v\\in V\\) ， \\(\\left|N(v)\\right| = \\deg (v)\\) 当且仅当 \\(G\\) 是一个简单图。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.655,
                0.951,
                0.687
            ],
            "angle": 0,
            "content": "设 \\(n\\) 是正整数，\\(S_{1}\\)，\\(S_{2}\\)，\\(\\cdots\\)，\\(S_{n}\\) 是集合 \\(S\\) 的子集构成的集合族，这个族的不同代表系统(SDR)是一个有序的 \\(n\\) 元组 \\((a_{1}, a_{2}, \\cdots, a_{n})\\)，其中，对 \\(i = 1, 2, \\cdots, n\\)，有 \\(a_{i} \\in S_{i}\\) 且对于所有的 \\(i \\neq j\\)，有 \\(a_{i} \\neq a_{j}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.691,
                0.951,
                0.723
            ],
            "angle": 0,
            "content": "11. 求集合 \\( S_{1} = \\{a, c, m, e\\} \\)，\\( S_{2} = \\{m, a, c, e\\} \\)，\\( S_{3} = \\{a, p, e, x\\} \\)，\\( S_{4} = \\{x, e, n, a\\} \\)，\\( S_{5} = \\{n, a, m, e\\} \\) 和 \\( S_{6} = \\{e, x, a, m\\} \\) 的SDR。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.726,
                0.951,
                0.773
            ],
            "angle": 0,
            "content": "12. 使用霍尔婚姻定理证明：集合 \\(S\\) 的有穷子集 \\(S_{1}\\)，\\(S_{2}\\)，…，\\(S_{n}\\) 有 \\(\\mathrm{SDR}(a_{1}, a_{2}, \\dots, a_{n})\\) 当且仅当对于 \\(\\{1, 2, \\dots, n\\}\\) 的所有子集 \\(I\\) 有 \\(\\left|\\bigcup_{i \\in I} S_{i}\\right| \\geqslant |I|\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.778,
                0.951,
                0.811
            ],
            "angle": 0,
            "content": "13. a)使用练习12证明： \\(S_{1} = \\{a,b,c\\}\\) ， \\(S_{2} = \\{b,c,d\\}\\) ， \\(S_{3} = \\{a,b,d\\}\\) ， \\(S_{4} = \\{b,c,d\\}\\) 构成的集合族有一个SDR，不允许直接求出一个。"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.814,
                0.355,
                0.828
            ],
            "angle": 0,
            "content": "b)求出a中集合族的SDR。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.832,
                0.951,
                0.864
            ],
            "angle": 0,
            "content": "14. 使用练习 12 证明: \\( S_{1} = \\{a, b, c\\} \\), \\( S_{2} = \\{a, c\\} \\), \\( S_{3} = \\{c, d, e\\} \\), \\( S_{4} = \\{b, c\\} \\), \\( S_{5} = \\{d, e, f\\} \\), \\( S_{6} = \\{a, c, e\\} \\) 和 \\( S_{7} = \\{a, b\\} \\) 构成的集合族没有 SDR。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.868,
                0.951,
                0.899
            ],
            "angle": 0,
            "content": "设 \\(u\\) 、 \\(\\mathcal{V}\\) 和 \\(\\pmb{\\varpi}\\) 是一个简单图的3个顶点，简单图 \\(G\\) 的簇系数 \\(C(G)\\) 是当 \\(\\textit{\\textbf{u}}\\) 和 \\(\\boldsymbol{\\upsilon}\\) 是邻居且 \\(\\mathcal{V}\\) 和 \\(\\pmb{\\varpi}\\) 是邻居时，\\(u\\) 和 \\(\\pmb{\\omega}\\) 是邻居的概率。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.903,
                0.951,
                0.935
            ],
            "angle": 0,
            "content": "15. 设 \\( u \\) 、 \\( v \\) 和 \\( w \\) 是一个简单图的3个顶点，当这些顶点构成的所有3对顶点之间都有边相连时，这3个顶点构成一个三角形。求用图中三角形个数以及图中长度为2的通路的条数表示的 \\( C(G) \\) 的公式。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.764,
                0.035,
                0.87,
                0.051
            ],
            "angle": 0,
            "content": "图 653"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.091,
                0.634,
                0.106
            ],
            "angle": 0,
            "content": "[提示：按照形成三角形的顶点的顺序计算图中的每个三角形一次。]"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.11,
                0.391,
                0.124
            ],
            "angle": 0,
            "content": "16. 求 10.2 节练习 20 中每个图的簇系数。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.128,
                0.356,
                0.143
            ],
            "angle": 0,
            "content": "17. 解释下列各图中簇系数表示什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.147,
                0.177,
                0.16
            ],
            "angle": 0,
            "content": "a)好莱坞图"
        },
        {
            "type": "text",
            "bbox": [
                0.454,
                0.147,
                0.64,
                0.16
            ],
            "angle": 0,
            "content": "b）“人脸”中的朋友图"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.165,
                0.268,
                0.178
            ],
            "angle": 0,
            "content": "c)图论中的学术合作图"
        },
        {
            "type": "text",
            "bbox": [
                0.454,
                0.166,
                0.695,
                0.178
            ],
            "angle": 0,
            "content": "d)人类细胞中的蛋白质作用图"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.183,
                0.436,
                0.197
            ],
            "angle": 0,
            "content": "e)表示构成万维网的路由器和通信链路的图"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.201,
                0.82,
                0.216
            ],
            "angle": 0,
            "content": "18. 对练习 17 中的每一个图，解释是否可以期望其簇系数接近 0.01 或 0.10，并且解释为什么。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.22,
                0.951,
                0.252
            ],
            "angle": 0,
            "content": "简单无向图的团是一个完全子图，它不包含在任何更大的完全子图中。在练习 \\(19\\sim 21\\) 中，求所给图的所有团。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.257,
                0.077,
                0.269
            ],
            "angle": 0,
            "content": "19."
        },
        {
            "type": "image",
            "bbox": [
                0.082,
                0.257,
                0.325,
                0.362
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.339,
                0.257,
                0.363,
                0.269
            ],
            "angle": 0,
            "content": "20."
        },
        {
            "type": "image",
            "bbox": [
                0.369,
                0.257,
                0.586,
                0.4
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.601,
                0.257,
                0.626,
                0.269
            ],
            "angle": 0,
            "content": "21."
        },
        {
            "type": "image",
            "bbox": [
                0.633,
                0.257,
                0.862,
                0.466
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.47,
                0.898,
                0.503
            ],
            "angle": 0,
            "content": "简单图中顶点的支配集是顶点的一个集合，使得其他每个顶点都与这个集合中至少一个顶点是相邻的。带最少顶点数的支配集称为最小支配集。在练习 \\(22\\sim 24\\) 中，求所给的图的最小支配集。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.507,
                0.077,
                0.519
            ],
            "angle": 0,
            "content": "22."
        },
        {
            "type": "image",
            "bbox": [
                0.083,
                0.507,
                0.23,
                0.622
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.28,
                0.507,
                0.305,
                0.519
            ],
            "angle": 0,
            "content": "23."
        },
        {
            "type": "image",
            "bbox": [
                0.311,
                0.507,
                0.519,
                0.621
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.57,
                0.508,
                0.595,
                0.519
            ],
            "angle": 0,
            "content": "24."
        },
        {
            "type": "image",
            "bbox": [
                0.602,
                0.508,
                0.822,
                0.623
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.628,
                0.9,
                0.698
            ],
            "angle": 0,
            "content": "简单图可用来确定在棋盘上控制整个棋盘的最少皇后数。一个 \\(n \\times n\\) 的棋盘具有 \\(n^2\\) 个格子。如下图所示，在所给位置上的皇后控制着同行、同列以及包含这个格子的两条斜线上的所有格子。与此对应的简单图具有 \\(n^2\\) 个顶点，每个顶点表示一个格子，而且若一个顶点所表示的格子上的皇后控制着另外一个顶点所表示的格子，则这两个顶点是相邻的。"
        },
        {
            "type": "image",
            "bbox": [
                0.091,
                0.702,
                0.358,
                0.88
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.386,
                0.841,
                0.455,
                0.855
            ],
            "angle": 0,
            "content": "皇后所控"
        },
        {
            "type": "text",
            "bbox": [
                0.387,
                0.856,
                0.454,
                0.868
            ],
            "angle": 0,
            "content": "制的格子"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.884,
                0.617,
                0.899
            ],
            "angle": 0,
            "content": "25.构造表示 \\(n\\times n\\) 棋盘的简单图，用边表示皇后对格子的控制，其中"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.903,
                0.143,
                0.914
            ],
            "angle": 0,
            "content": "a) \\(n = 3\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.281,
                0.903,
                0.337,
                0.914
            ],
            "angle": 0,
            "content": "b) \\(n = 4\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.92,
                0.736,
                0.935
            ],
            "angle": 0,
            "content": "26. 解释一下最小支配集的概念如何应用到确定控制 \\(n \\times n\\) 棋盘的最少皇后数的问题。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.146,
                0.034,
                0.182,
                0.048
            ],
            "angle": 0,
            "content": "654"
        },
        {
            "type": "header",
            "bbox": [
                0.227,
                0.034,
                0.303,
                0.049
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.09,
                0.461,
                0.105
            ],
            "angle": 0,
            "content": "**27. 求控制 \\(n \\times n\\) 棋盘的最少皇后数，其中"
        },
        {
            "type": "text",
            "bbox": [
                0.149,
                0.109,
                0.209,
                0.122
            ],
            "angle": 0,
            "content": "a) \\(n = 3\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.344,
                0.109,
                0.403,
                0.122
            ],
            "angle": 0,
            "content": "b) \\(n = 4\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.52,
                0.109,
                0.577,
                0.122
            ],
            "angle": 0,
            "content": "c) \\(n = 5\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.126,
                0.928,
                0.141
            ],
            "angle": 0,
            "content": "28. 假定 \\(G_{1}\\) 和 \\(H_{1}\\) 是同构的，而且 \\(G_{2}\\) 和 \\(H_{2}\\) 是同构的。证明或反证：\\(G_{1} \\cup G_{2}\\) 和 \\(H_{1} \\cup H_{2}\\) 是同构的。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.144,
                0.609,
                0.158
            ],
            "angle": 0,
            "content": "29. 证明：下列性质是同构的简单图都有或都没有的不变量。"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.162,
                0.227,
                0.176
            ],
            "angle": 0,
            "content": "a)连通性"
        },
        {
            "type": "text",
            "bbox": [
                0.344,
                0.162,
                0.532,
                0.176
            ],
            "angle": 0,
            "content": "b)哈密顿回路的存在性"
        },
        {
            "type": "text",
            "bbox": [
                0.695,
                0.162,
                0.862,
                0.176
            ],
            "angle": 0,
            "content": "c)欧拉回路的存在性"
        },
        {
            "type": "text",
            "bbox": [
                0.149,
                0.18,
                0.265,
                0.193
            ],
            "angle": 0,
            "content": "d)有交叉数 \\(C\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.344,
                0.18,
                0.493,
                0.193
            ],
            "angle": 0,
            "content": "e)有 \\(n\\) 个孤立顶点"
        },
        {
            "type": "text",
            "bbox": [
                0.695,
                0.18,
                0.786,
                0.194
            ],
            "angle": 0,
            "content": "f)是二分图"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.197,
                0.616,
                0.211
            ],
            "angle": 0,
            "content": "30. 如何从 \\(G\\) 的邻接矩阵求 \\(\\overline{G}\\) 的邻接矩阵？其中 \\(G\\) 是简单图。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.215,
                0.572,
                0.228
            ],
            "angle": 0,
            "content": "31. 有多少种非同构的带有 4 个顶点的连通简单二分图？"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.233,
                0.562,
                0.246
            ],
            "angle": 0,
            "content": "* 32. 有多少种非同构的带有 5 个顶点简单连通图，并且"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.25,
                0.38,
                0.264
            ],
            "angle": 0,
            "content": "a)没有任何顶点的度超过2？"
        },
        {
            "type": "text",
            "bbox": [
                0.519,
                0.251,
                0.657,
                0.265
            ],
            "angle": 0,
            "content": "b)着色数等于4？"
        },
        {
            "type": "text",
            "bbox": [
                0.695,
                0.251,
                0.796,
                0.265
            ],
            "angle": 0,
            "content": "c)非平面图？"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.268,
                0.445,
                0.282
            ],
            "angle": 0,
            "content": "若有向图与它的逆同构，则它是自逆的。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.286,
                0.367,
                0.301
            ],
            "angle": 0,
            "content": "33. 确定下列图是否为自逆的。"
        },
        {
            "type": "text",
            "bbox": [
                0.149,
                0.304,
                0.169,
                0.317
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "image",
            "bbox": [
                0.167,
                0.304,
                0.439,
                0.409
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.526,
                0.304,
                0.546,
                0.317
            ],
            "angle": 0,
            "content": "b)"
        },
        {
            "type": "image",
            "bbox": [
                0.544,
                0.304,
                0.788,
                0.425
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.428,
                0.777,
                0.443
            ],
            "angle": 0,
            "content": "34. 证明：若有向图 \\(G\\) 是自逆的而且 \\(H\\) 是同构于 \\(G\\) 的有向图，则 \\(H\\) 也是自逆的。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.446,
                0.964,
                0.478
            ],
            "angle": 0,
            "content": "无向简单图的定向就是指定它的各边的方向，使得所得到的有向图是强连通的。当无向图有定向时，这个图称为可定向的。在练习 \\(35\\sim 37\\) 中，确定给定的图是否是可定向的。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.482,
                0.143,
                0.495
            ],
            "angle": 0,
            "content": "35."
        },
        {
            "type": "image",
            "bbox": [
                0.147,
                0.482,
                0.365,
                0.579
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.371,
                0.482,
                0.397,
                0.495
            ],
            "angle": 0,
            "content": "36."
        },
        {
            "type": "image",
            "bbox": [
                0.399,
                0.482,
                0.714,
                0.579
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.72,
                0.482,
                0.746,
                0.495
            ],
            "angle": 0,
            "content": "37."
        },
        {
            "type": "image",
            "bbox": [
                0.748,
                0.482,
                0.964,
                0.643
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.646,
                0.964,
                0.679
            ],
            "angle": 0,
            "content": "38. 因为在城市中心区交通流量正在增长，所以交通工程师正在计划把目前所有双行街道都变成单行街道。解释如何为这个问题建模。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.682,
                0.533,
                0.696
            ],
            "angle": 0,
            "content": "* 39. 证明：若一个图具有割边，则它不是可定向的。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.7,
                0.943,
                0.715
            ],
            "angle": 0,
            "content": "竞赛图是简单有向图，使得若 \\(u\\) 和 \\(v\\) 是图中不同的顶点，则 \\((u, v)\\) 和 \\((v, u)\\) 中恰好有一个是图中的边。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.718,
                0.461,
                0.732
            ],
            "angle": 0,
            "content": "40. 有多少种不同的带 \\( n \\) 个顶点的竞赛图？"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.736,
                0.535,
                0.75
            ],
            "angle": 0,
            "content": "41. 在竞赛图中一个顶点的入度与出度之和是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.753,
                0.441,
                0.767
            ],
            "angle": 0,
            "content": "* 42. 证明：每个竞赛图都有哈密顿通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.771,
                0.964,
                0.803
            ],
            "angle": 0,
            "content": "43. 给定鸡群里的两只鸡，其中一只占优势。这样就定义了这个鸡群的啄食次序。如何用竞赛图来为啄食次序建模？"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.806,
                0.792,
                0.821
            ],
            "angle": 0,
            "content": "44. 设连通图 \\(G\\) 有 \\(n\\) 个顶点且点连通度 \\(\\kappa(G) = k\\)。证明：图 \\(G\\) 至少含有 \\(\\lceil kn / 2 \\rceil\\) 条边。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.824,
                0.938,
                0.845
            ],
            "angle": 0,
            "content": "若 \\(\\kappa (G) = \\lambda (G) = \\min_{v\\in V}\\deg v = 2m / n\\) ，则称含有 \\(n\\) 个顶点和 \\(m\\) 条边的连通图 \\(G = (V,E)\\) 具有最优连通度。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.846,
                0.533,
                0.861
            ],
            "angle": 0,
            "content": "45. 证明：具有最优连通度的连通图一定是正则图。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.864,
                0.403,
                0.878
            ],
            "angle": 0,
            "content": "46. 证明下列各图具有最优连通度。"
        },
        {
            "type": "text",
            "bbox": [
                0.149,
                0.882,
                0.246,
                0.896
            ],
            "angle": 0,
            "content": "a) \\(C_{n}\\) ， \\(n\\geqslant 3\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.344,
                0.882,
                0.443,
                0.896
            ],
            "angle": 0,
            "content": "b) \\(K_{n}\\) ， \\(n\\geqslant 3\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.521,
                0.882,
                0.626,
                0.896
            ],
            "angle": 0,
            "content": "c) \\(K_{r,r}\\) ， \\(r\\geqslant 2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.899,
                0.696,
                0.914
            ],
            "angle": 0,
            "content": "* 47. 求 2 个带有 6 个顶点, 9 条边, 具有最优连通度的非同构的简单图。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.917,
                0.964,
                0.933
            ],
            "angle": 0,
            "content": "48. 假定 \\(G\\) 是带 \\(2k\\) 个度为奇数的顶点的连通多重图。证明：存在 \\(k\\) 个子图，它们的并图是 \\(G\\) ，其中每个"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.757,
                0.04,
                0.863,
                0.054
            ],
            "angle": 0,
            "content": "图 655"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.096,
                0.892,
                0.129
            ],
            "angle": 0,
            "content": "子图都有欧拉通路并且任何两个子图都没有公共边。[提示：向该图添加 \\(k\\) 条连接成对的度为奇数的顶点，并且利用这个变大了的图的欧拉回路。]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.131,
                0.894,
                0.201
            ],
            "angle": 0,
            "content": "在练习49和50中，我们讨论一个由佩特科维奇(petkovic)在[Pe09]中提出的一个智力题(基于[Avch80]中的问题)。设亚瑟王召集 \\(2n\\) 个骑士开一个重要的圆桌会议。其中任意两个人要么是朋友，要么是敌人，并且每个人在其余 \\(2n - 1\\) 个人中最多有不超过 \\(n - 1\\) 个敌人。问亚瑟王是否可以安排他的骑士在圆桌就座，使得每个人都和他的两个朋友为邻座。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.203,
                0.892,
                0.236
            ],
            "angle": 0,
            "content": "49. a) 证明：用顶点表示骑士，若两个骑士是朋友，则在图中用边连接这两人。该题可以化简为判断图中是否存在哈密顿回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.239,
                0.611,
                0.255
            ],
            "angle": 0,
            "content": "b)解答在上面智力题中的提出的问题。[提示：利用狄拉克定理。]"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.257,
                0.894,
                0.345
            ],
            "angle": 0,
            "content": "50. 假设有 8 个骑士，Alynore、Bedivere、De-gore、Gareth、Kay、Lancelot、Perceval 和 Tristan 用每个人的名字的第一个字母表示该骑士，并在该字母后面列出他的敌人列表。他们的敌人列表是：\\( A(D, G, P) \\)、\\( B(K, P, T) \\)、\\( D(A, G, L) \\)、\\( G(A, D, T) \\)、\\( K(B, L, P) \\)、\\( L(D, K, T) \\)、\\( P(A, B, K) \\)、\\( T(B, G, L) \\)。画出表示这 8 个骑士和他们的朋友的图，并且求出安排方式使得每一个骑士都挨着他的两个朋友坐。"
        },
        {
            "type": "text",
            "bbox": [
                0.033,
                0.348,
                0.892,
                0.4
            ],
            "angle": 0,
            "content": "* 51. 设 \\(G\\) 是带有 \\(n\\) 个顶点的简单图。\\(G\\) 的带宽表示成 \\(B(G)\\)，它是 \\(\\max \\{|i - j| | a_i\\) 与 \\(a_j\\) 是相邻的\\} 在 \\(G\\) 的顶点 \\(a_1, a_2, \\dots, a_n\\) 的所有排列上所取的最小值。即带宽是赋给相邻顶点的下标的最大差值在顶点的所有列表上所取的最小值。求下列图的带宽。"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.403,
                0.122,
                0.418
            ],
            "angle": 0,
            "content": "a) \\(K_{5}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.271,
                0.403,
                0.326,
                0.418
            ],
            "angle": 0,
            "content": "b) \\(K_{1,3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.446,
                0.403,
                0.5,
                0.418
            ],
            "angle": 0,
            "content": "c) \\(K_{2,3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.621,
                0.403,
                0.675,
                0.418
            ],
            "angle": 0,
            "content": "d) \\(K_{3,3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.422,
                0.12,
                0.435
            ],
            "angle": 0,
            "content": "e) \\(Q_{3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.271,
                0.422,
                0.309,
                0.435
            ],
            "angle": 0,
            "content": "f) \\(C_5\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.033,
                0.438,
                0.894,
                0.49
            ],
            "angle": 0,
            "content": "* 52. 连通简单图的两个不同顶点 \\( v_{1} \\) 和 \\( v_{2} \\) 之间的距离是在 \\( v_{1} \\) 和 \\( v_{2} \\) 之间的最短通路的长度（边数）。图的半径是从顶点 \\( v \\) 到其他顶点的最大距离在所有顶点 \\( v \\) 上所取的最小值。图的直径是在两个不同顶点之间的最大距离。求下列图的半径和直径。"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.493,
                0.122,
                0.508
            ],
            "angle": 0,
            "content": "a) \\(K_{6}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.271,
                0.493,
                0.326,
                0.508
            ],
            "angle": 0,
            "content": "b) \\(K_{4,5}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.446,
                0.493,
                0.487,
                0.508
            ],
            "angle": 0,
            "content": "c) \\(Q_{3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.621,
                0.493,
                0.663,
                0.508
            ],
            "angle": 0,
            "content": "d) \\(C_6\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.033,
                0.512,
                0.643,
                0.528
            ],
            "angle": 0,
            "content": "* 53. a) 证明：若简单图 \\(G\\) 的直径至少为4，则它的补图 \\(\\overline{G}\\) 的直径不超过2。"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.53,
                0.643,
                0.546
            ],
            "angle": 0,
            "content": "b) 证明：若简单图 \\(G\\) 的直径至少为3，则它的补图 \\(\\overline{G}\\) 的直径不超过3。"
        },
        {
            "type": "text",
            "bbox": [
                0.033,
                0.548,
                0.894,
                0.581
            ],
            "angle": 0,
            "content": "* 54. 假定一个多重图有 \\(2m\\) 个度为奇数的顶点。证明：任何包含该图中每条边的回路，必然至少包含 \\(m\\) 条边超过一次。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.584,
                0.488,
                0.599
            ],
            "angle": 0,
            "content": "55. 求 10.6 节图 3 中在顶点 \\(a\\) 与 \\(z\\) 之间的次最短通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.602,
                0.628,
                0.617
            ],
            "angle": 0,
            "content": "56. 设计一个算法，求在简单连通加权图中两个顶点之间的次最短通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.62,
                0.675,
                0.636
            ],
            "angle": 0,
            "content": "57. 求 10.6 节练习 3 的加权图中，在顶点 \\(a\\) 与 \\(z\\) 之间经过顶点 \\(f\\) 的最短通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.638,
                0.775,
                0.653
            ],
            "angle": 0,
            "content": "58. 设计一个算法，求在简单连通加权图中两个顶点之间经过第三个指定顶点的最短通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.033,
                0.655,
                0.696,
                0.671
            ],
            "angle": 0,
            "content": "* 59. 证明：若 \\(G\\) 是至少带11个顶点的简单图，则 \\(G\\) 或 \\(\\overline{G}(G)\\) 的补图）不是平面图。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.674,
                0.894,
                0.707
            ],
            "angle": 0,
            "content": "若图的一组顶点集合中的任何两个顶点都不相邻，则这个顶点集合称为独立的。图的独立数是该图的独立顶点集中的最大顶点个数。"
        },
        {
            "type": "text",
            "bbox": [
                0.033,
                0.71,
                0.279,
                0.725
            ],
            "angle": 0,
            "content": "* 60. 下列图的独立数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.728,
                0.122,
                0.743
            ],
            "angle": 0,
            "content": "a) \\(K_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.271,
                0.728,
                0.313,
                0.743
            ],
            "angle": 0,
            "content": "b) \\(C_n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.446,
                0.728,
                0.488,
                0.743
            ],
            "angle": 0,
            "content": "c) \\(Q_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.621,
                0.728,
                0.679,
                0.743
            ],
            "angle": 0,
            "content": "d) \\(K_{m,n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.746,
                0.666,
                0.761
            ],
            "angle": 0,
            "content": "61. 证明：一个简单图中的顶点数小于或等于这个图的独立数与着色数之积。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.764,
                0.835,
                0.779
            ],
            "angle": 0,
            "content": "62. 证明：一个图的着色数小于或等于 \\( n - i + 1 \\)，其中 \\( n \\) 是这个图的顶点数，\\( i \\) 是这个图的独立数。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.781,
                0.894,
                0.833
            ],
            "angle": 0,
            "content": "63. 假定为了生成带有 \\( n \\) 个顶点的随机简单图，首先选择满足 \\( 0 \\leqslant p \\leqslant 1 \\) 的实数 \\( p \\)。对 \\( C(n, 2) \\) 对不同顶点中的每一对，都生成一个在 \\( 0 \\sim 1 \\) 之间的随机数 \\( x \\)。若 \\( 0 \\leqslant x \\leqslant p \\)，则用一条边连接这两个顶点；否则就不连接这两个顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.836,
                0.578,
                0.851
            ],
            "angle": 0,
            "content": "a)生成带有 \\(m\\) 条边的图的概率是什么？其中 \\(0\\leqslant m\\leqslant C(n,2)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.853,
                0.83,
                0.869
            ],
            "angle": 0,
            "content": "b)若包含每一条边的概率为 \\(p\\) ，则在随机生成的带有 \\(n\\) 个顶点的图中，边数的期望值是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.872,
                0.634,
                0.887
            ],
            "angle": 0,
            "content": "c) 证明：若 \\( p = 1 / 2 \\)，则每一个带 \\( n \\) 个顶点的简单图是等概率生成的。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.89,
                0.894,
                0.922
            ],
            "angle": 0,
            "content": "当向简单图添加更多的边（不添加顶点）时，都还保持的性质称为单调递增的，当从简单图删除边（不删除顶点）时，都还保持的性质称为单调递减的。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.925,
                0.721,
                0.94
            ],
            "angle": 0,
            "content": "64. 对下列每个性质来说，判断它是否为单调递增的，并判断它是否为单调递减的。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.132,
                0.04,
                0.169,
                0.054
            ],
            "angle": 0,
            "content": "656"
        },
        {
            "type": "header",
            "bbox": [
                0.213,
                0.039,
                0.29,
                0.054
            ],
            "angle": 0,
            "content": "第10章"
        },
        {
            "type": "text",
            "bbox": [
                0.134,
                0.095,
                0.273,
                0.11
            ],
            "angle": 0,
            "content": "a)图 \\(G\\) 是连通的"
        },
        {
            "type": "text",
            "bbox": [
                0.329,
                0.095,
                0.484,
                0.11
            ],
            "angle": 0,
            "content": "b) 图 \\(G\\) 不是连通的"
        },
        {
            "type": "text",
            "bbox": [
                0.507,
                0.095,
                0.657,
                0.11
            ],
            "angle": 0,
            "content": "c)图 \\(G\\) 有欧拉回路"
        },
        {
            "type": "text",
            "bbox": [
                0.679,
                0.095,
                0.852,
                0.11
            ],
            "angle": 0,
            "content": "d) 图 \\(G\\) 有哈密顿回路"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.114,
                0.271,
                0.128
            ],
            "angle": 0,
            "content": "e)图 \\(G\\) 是平面图"
        },
        {
            "type": "text",
            "bbox": [
                0.329,
                0.114,
                0.497,
                0.128
            ],
            "angle": 0,
            "content": "f)图 \\(G\\) 的着色数为4"
        },
        {
            "type": "text",
            "bbox": [
                0.507,
                0.114,
                0.655,
                0.128
            ],
            "angle": 0,
            "content": "g)图 \\(G\\) 的半径为3"
        },
        {
            "type": "text",
            "bbox": [
                0.679,
                0.114,
                0.831,
                0.127
            ],
            "angle": 0,
            "content": "h)图 \\(G\\) 的直径为3"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.131,
                0.95,
                0.164
            ],
            "angle": 0,
            "content": "65. 证明：图的性质 \\(P\\) 是单调递增的当且仅当图的性质 \\(Q\\) 是单调递减的，其中 \\(Q\\) 是不具有性质 \\(P\\) 的性质。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.167,
                0.951,
                0.2
            ],
            "angle": 0,
            "content": "** 66. 假定 \\(P\\) 是简单图的单调递增的性质。证明：带 \\(n\\) 个顶点的随机图有性质 \\(P\\) 的概率是 \\(p\\) 的单调非递减函数，其中 \\(p\\) 是一条边被挑选到该图的概率。"
        },
        {
            "type": "title",
            "bbox": [
                0.105,
                0.214,
                0.242,
                0.234
            ],
            "angle": 0,
            "content": "计算机课题"
        },
        {
            "type": "title",
            "bbox": [
                0.104,
                0.241,
                0.36,
                0.256
            ],
            "angle": 0,
            "content": "按给定的输入和输出写出程序。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.259,
                0.586,
                0.273
            ],
            "angle": 0,
            "content": "1. 给定无向图的各边所关联的顶点对，确定每个顶点的度。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.277,
                0.696,
                0.291
            ],
            "angle": 0,
            "content": "2. 给定有向图的各边所关联的有序顶点对，确定每个顶点的入度和出度。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.295,
                0.53,
                0.309
            ],
            "angle": 0,
            "content": "3. 给定简单图的边列表，确定这个图是否为二分图。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.313,
                0.951,
                0.345
            ],
            "angle": 0,
            "content": "4. 给定图的各边所关联的顶点对，构造这个图的邻接矩阵。（要求当存在环、多重边或有向边时仍起作用。）"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.348,
                0.696,
                0.362
            ],
            "angle": 0,
            "content": "5. 给定图的邻接矩阵，列出这个图的各边，并且给出每条边出现的次数。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.366,
                0.806,
                0.38
            ],
            "angle": 0,
            "content": "6. 给定无向图各边所关联的顶点对，以及每条边出现的次数，构造这个图的关联矩阵。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.384,
                0.696,
                0.398
            ],
            "angle": 0,
            "content": "7. 给定无向图的关联矩阵，列出它的各边，并且给出每条边出现的次数。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.401,
                0.951,
                0.434
            ],
            "angle": 0,
            "content": "8. 给定正整数 \\( n \\)，通过产生图的邻接矩阵来生成含有 \\( n \\) 个顶点的无向图，使得以相等的概率生成所有含有 \\( n \\) 个顶点的简单图。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.437,
                0.951,
                0.47
            ],
            "angle": 0,
            "content": "9. 给定正整数 \\( n \\)，通过产生图的邻接矩阵来生成含有 \\( n \\) 个顶点的有向图，使得以相等的概率生成所有含有 \\( n \\) 个顶点的有向图。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.473,
                0.78,
                0.487
            ],
            "angle": 0,
            "content": "10. 给定两个都带不超过 6 个顶点的简单图的边列表，确定这两个图是否是同构的。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.491,
                0.951,
                0.524
            ],
            "angle": 0,
            "content": "11. 给定图的邻接矩阵和正整数 \\( n \\)，求两个顶点之间长度为 \\( n \\) 的通路数（产生对有向图和无向图来说都能起作用的程序）。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.527,
                0.725,
                0.541
            ],
            "angle": 0,
            "content": "* 12. 给定简单图的边列表，确定它是否连通，若它不连通，则求连通分支数。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.545,
                0.951,
                0.577
            ],
            "angle": 0,
            "content": "13. 给定多重图的各边所关联的顶点对，确定它是否有欧拉回路，若没有欧拉回路，则确定它是否有欧拉通路。若存在欧拉通路或欧拉回路，则构造这样的通路或回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.58,
                0.951,
                0.613
            ],
            "angle": 0,
            "content": "* 14. 给定有向多重图的各边所关联的有序顶点对，若存在欧拉通路或欧拉回路，则构造这样的通路或回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.616,
                0.763,
                0.631
            ],
            "angle": 0,
            "content": "**15. 给定简单图的边列表，产生一条哈密顿回路，或者确定该图没有这样的回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.635,
                0.763,
                0.649
            ],
            "angle": 0,
            "content": "**16. 给定简单图的边列表，产生一条哈密顿通路，或者确定该图没有这样的通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.652,
                0.951,
                0.685
            ],
            "angle": 0,
            "content": "17. 给定加权连通简单图的边及其权的列表，以及该图中的两个顶点，用迪克斯特拉算法求这两点间最短通路的长度。另外，求出这条通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.688,
                0.679,
                0.703
            ],
            "angle": 0,
            "content": "18. 给定无向图的边的表，用 10.8 节练习所给的算法求这个图的着色。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.707,
                0.56,
                0.721
            ],
            "angle": 0,
            "content": "19. 给定学生及其注册课程的表，构造期末考试日程表。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.724,
                0.818,
                0.738
            ],
            "angle": 0,
            "content": "20. 给定各对电视台之间的距离以及它们之间允许的最短距离，为这些电视台分配频率。"
        },
        {
            "type": "list",
            "bbox": [
                0.081,
                0.259,
                0.951,
                0.738
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.108,
                0.754,
                0.245,
                0.773
            ],
            "angle": 0,
            "content": "计算和探索"
        },
        {
            "type": "title",
            "bbox": [
                0.107,
                0.78,
                0.529,
                0.795
            ],
            "angle": 0,
            "content": "用一个计算程序或你自己编写的程序做下面的练习。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.798,
                0.384,
                0.812
            ],
            "angle": 0,
            "content": "1. 显示带4个顶点的所有简单图。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.816,
                0.458,
                0.83
            ],
            "angle": 0,
            "content": "2. 显示带6个顶点的所有非同构的简单图。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.834,
                0.513,
                0.848
            ],
            "angle": 0,
            "content": "3. 显示全套的带4个顶点的所有非同构的有向图。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.852,
                0.937,
                0.866
            ],
            "angle": 0,
            "content": "4.随机地生成10个不同的简单图，每个带20个顶点，使得每个这样的图都是以相等的概率来生成的。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.87,
                0.551,
                0.884
            ],
            "angle": 0,
            "content": "5.构造一种格雷码，其中码字都是长度为6的比特串。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.888,
                0.458,
                0.902
            ],
            "angle": 0,
            "content": "6.构造马在不同大小的棋盘上的周游路线。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.905,
                0.951,
                0.937
            ],
            "angle": 0,
            "content": "7. 确定你在本组练习的练习4中生成的每个图是否为平面图。若你可以做到，则确定每个非平面图的厚度。"
        },
        {
            "type": "list",
            "bbox": [
                0.106,
                0.798,
                0.951,
                0.937
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.77,
                0.038,
                0.876,
                0.053
            ],
            "angle": 0,
            "content": "图 657"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.094,
                0.904,
                0.126
            ],
            "angle": 0,
            "content": "8. 确定你在本组练习的练习4中生成的每个图是否连通。若有一个图不连通，则确定这个图的连通分支数。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.13,
                0.904,
                0.162
            ],
            "angle": 0,
            "content": "9.随机地生成带10个顶点的简单图。当你生成了一个带欧拉回路的图时停止。显示这个图的一个欧拉回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.166,
                0.904,
                0.197
            ],
            "angle": 0,
            "content": "10. 随机地生成带 10 个顶点的简单图。当你生成了一个带哈密顿回路的图时停止。显示这个图的一个哈密顿回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.201,
                0.529,
                0.216
            ],
            "angle": 0,
            "content": "11. 求你在本组练习的练习4中所生成的每个图的着色数。"
        },
        {
            "type": "text",
            "bbox": [
                0.034,
                0.219,
                0.853,
                0.234
            ],
            "angle": 0,
            "content": "**12. 求旅行推销员访问美国50个州的每个首府所能采取的最短路线，在各城市之间坐直飞的航班。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.237,
                0.905,
                0.269
            ],
            "angle": 0,
            "content": "* 13. 对每个不超过 10 的正整数 \\( n \\) 来说，估计随机生成的带 \\( n \\) 个顶点的简单图连通的概率，方法是生成一组随机简单图并且确定每个图是否连通。"
        },
        {
            "type": "text",
            "bbox": [
                0.034,
                0.272,
                0.821,
                0.288
            ],
            "angle": 0,
            "content": "**14. 研究这个问题：确定 \\( K_{7,7} \\) 的交叉数是否为 77、79 或 81。已知它等于这三个数当中的一个。"
        },
        {
            "type": "list",
            "bbox": [
                0.034,
                0.094,
                0.905,
                0.288
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.06,
                0.303,
                0.167,
                0.321
            ],
            "angle": 0,
            "content": "写作课题"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.329,
                0.423,
                0.344
            ],
            "angle": 0,
            "content": "用本教材以外的资料，按下列要求写成论文。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.347,
                0.398,
                0.362
            ],
            "angle": 0,
            "content": "1. 描述在 1900 年以前图论的起源和发展。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.365,
                0.372,
                0.379
            ],
            "angle": 0,
            "content": "2. 讨论图论在生态系统研究中的应用。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.382,
                0.39,
                0.396
            ],
            "angle": 0,
            "content": "3. 讨论图论在社会学和心理学中的应用。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.4,
                0.446,
                0.414
            ],
            "angle": 0,
            "content": "4. 讨论通过研究网络图的性质可以了解到什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.417,
                0.904,
                0.45
            ],
            "angle": 0,
            "content": "5. 解释在表示网络的图中，如社交网络、计算机网络、信息网络或生物学网络，社团结构是什么？定义在这些图中的社团是什么？并且解释在表示所列的网络类型的图中，社团表示了什么。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.453,
                0.65,
                0.467
            ],
            "angle": 0,
            "content": "6. 描述一些用于在表示第 5 题中所列网络类型的图中，社团发现的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.471,
                0.905,
                0.503
            ],
            "angle": 0,
            "content": "7. 描述给定一个图的顶点和边，在纸面或屏幕上画出这个图的算法。在画图中需要考虑什么，使得其最好地显示了该图的属性。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.506,
                0.724,
                0.521
            ],
            "angle": 0,
            "content": "8. 通过学习相关的社交网络和通信网络，解释图论如何帮助发现犯罪或恐怖网络。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.524,
                0.892,
                0.539
            ],
            "angle": 0,
            "content": "9. 一个输入、显示和操纵各种图的软件工具应当具有什么功能？现有的工具都具有这些功能中的哪些？"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.541,
                0.905,
                0.574
            ],
            "angle": 0,
            "content": "10. 描述确定两个图是否是同构的一些可用算法和这些算法的计算复杂度。目前已知最有效的算法是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.577,
                0.864,
                0.592
            ],
            "angle": 0,
            "content": "11. 什么是子图同构问题及其在化学、生态学、电子电路设计和计算机视图等方面有哪些重要应用？"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.595,
                0.751,
                0.609
            ],
            "angle": 0,
            "content": "12. 解释什么是图挖掘（它是数据挖掘的重要领域），并说明图挖掘中的一些基本技术。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.612,
                0.451,
                0.627
            ],
            "angle": 0,
            "content": "13. 描述如何用欧拉通路来帮助确定 DNA 序列。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.63,
                0.862,
                0.645
            ],
            "angle": 0,
            "content": "14. 定义德布鲁因序列并且讨论它们如何出现在应用中。解释如何用欧拉回路来构造德布鲁因序列。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.648,
                0.492,
                0.663
            ],
            "angle": 0,
            "content": "15. 描述中国邮递员问题并且解释如何解决这个问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.666,
                0.456,
                0.68
            ],
            "angle": 0,
            "content": "16. 描述表明图具有哈密顿回路的一些不同条件。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.684,
                0.53,
                0.698
            ],
            "angle": 0,
            "content": "17. 描述用来解决旅行推销员问题的几个不同策略和算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.701,
                0.717,
                0.716
            ],
            "angle": 0,
            "content": "18. 描述判定一个图是否是平面图几个不同算法。每个算法的计算复杂度是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.719,
                0.905,
                0.751
            ],
            "angle": 0,
            "content": "19. 在建模中，有时把超大规模集成电路(VLSI)图嵌入到一本书中，让顶点都在书脊上而边都在不同的书页上。定义图的书页数 \\(\\ominus\\) 并对 \\(n = 3\\) ，4，5和6求包括 \\(K_{n}\\) 在内的各种图的书页数。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.754,
                0.27,
                0.769
            ],
            "angle": 0,
            "content": "20. 描述四色定理的历史。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.772,
                0.827,
                0.787
            ],
            "angle": 0,
            "content": "21. 描述在四色定理的证明中计算机所扮演的角色。如何肯定一个依赖计算机的证明是正确的？"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.79,
                0.77,
                0.805
            ],
            "angle": 0,
            "content": "22. 就是否产生最少颜色的着色以及复杂度而言，描述并比较给图着色的几个不同算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.808,
                0.474,
                0.823
            ],
            "angle": 0,
            "content": "23. 解释在各种不同模型中如何使用图的多重着色。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.826,
                0.251,
                0.84
            ],
            "angle": 0,
            "content": "24. 描述边着色的应用。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.843,
                0.678,
                0.858
            ],
            "angle": 0,
            "content": "25. 解释如何将随机图理论应用在带特定性质的图的非构造性存在性证明中。"
        },
        {
            "type": "list",
            "bbox": [
                0.058,
                0.329,
                0.905,
                0.858
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "footer",
            "bbox": [
                0.106,
                0.924,
                0.454,
                0.939
            ],
            "angle": 0,
            "content": "即上述做法所需要的最少页数。——译者注"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.117,
                0.095,
                0.206,
                0.113
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "header",
            "bbox": [
                0.116,
                0.118,
                0.406,
                0.129
            ],
            "angle": 0,
            "content": "Discrete Mathematics and Its Applications, 8E"
        },
        {
            "type": "title",
            "bbox": [
                0.106,
                0.139,
                0.145,
                0.164
            ],
            "angle": 0,
            "content": "树"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.216,
                0.951,
                0.251
            ],
            "angle": 0,
            "content": "不包含简单回路的连通图称为树。早在1857年，英国数学家亚瑟·凯莱就用树计数某些类型的化合物。本章中的例子将说明从那时起，树已经被用来解决各种学科分支中的问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.254,
                0.953,
                0.347
            ],
            "angle": 0,
            "content": "树在计算机科学中特别有用，尤其是在算法中。例如，用树构造求元素在表中位置的有效算法。可以将树用于算法，构造节省数据存储和传输成本的有效编码，比如哈夫曼编码；可以用树来研究诸如跳棋和象棋这样的博弈，并且可以帮助确定进行这些博弈的取胜策略；可以用树来为通过一系列决策而完成的过程建立模型。构造这些模型可以帮助确定排序算法等基于一系列决策的算法的计算复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.349,
                0.951,
                0.404
            ],
            "angle": 0,
            "content": "通过深度优先搜索或宽度优先搜索，可以系统地遍历图的顶点，构造出一棵包括每个顶点的树。通过深度优先搜索来探索图的顶点，也称为回溯，允许系统地搜索各种问题的解，比如确定在棋盘上如何放置8个王后使得这些王后不能互相攻击。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.406,
                0.951,
                0.442
            ],
            "angle": 0,
            "content": "可以给树的边赋权值来为许多问题建立模型。例如，用加权树可以开发出构造网络的算法，使得这些网络含有最便宜的连接不同网络节点的电话线集合。"
        },
        {
            "type": "title",
            "bbox": [
                0.106,
                0.456,
                0.295,
                0.475
            ],
            "angle": 0,
            "content": "11.1 树的概述"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.482,
                0.951,
                0.557
            ],
            "angle": 0,
            "content": "第10章说明了如何用图来建立模型和解决许多问题。本章将集中讨论称为树的一种特殊类型的图，之所以这样命名是因为这样的图就像是树。例如，家族树是表示族谱图的图。家族树用顶点表示家族成员并且用边表示父子关系。图1显示了瑞士数学世家伯努利家族男性成员的家族树。表示家族树（限制成员为一种性别，并且没有近亲结婚）的无向图是树的一个例子。"
        },
        {
            "type": "image",
            "bbox": [
                0.178,
                0.561,
                0.887,
                0.791
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.437,
                0.796,
                0.625,
                0.811
            ],
            "angle": 0,
            "content": "图1 伯努利数学世家"
        },
        {
            "type": "text",
            "bbox": [
                0.157,
                0.829,
                0.536,
                0.846
            ],
            "angle": 0,
            "content": "定义1 树是没有简单回路的连通无向图。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.855,
                0.838,
                0.872
            ],
            "angle": 0,
            "content": "因为树没有简单回路，所以树不含多重边或环。因此任何树都必然是简单图。"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.877,
                0.503,
                0.894
            ],
            "angle": 0,
            "content": "例1 在图2所示的图中，哪些图是树？"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.899,
                0.951,
                0.934
            ],
            "angle": 0,
            "content": "解 \\(G_{1}\\) 和 \\(G_{2}\\) 是树，因为都是没有简单回路的连通图。 \\(G_{3}\\) 不是树，因为 \\(e\\) ， \\(b\\) ， \\(a\\) ， \\(d\\) ， \\(e\\) 是这个图中的简单回路。最后， \\(G_{4}\\) 不是树，因为它不连通。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.77,
                0.038,
                0.876,
                0.052
            ],
            "angle": 0,
            "content": "树 659"
        },
        {
            "type": "image",
            "bbox": [
                0.139,
                0.096,
                0.28,
                0.305
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.318,
                0.097,
                0.479,
                0.305
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.496,
                0.097,
                0.654,
                0.305
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.685,
                0.097,
                0.828,
                0.305
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.36,
                0.314,
                0.604,
                0.328
            ],
            "angle": 0,
            "content": "图2 树和不是树的图的例子"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.34,
                0.908,
                0.395
            ],
            "angle": 0,
            "content": "任何一个不包含简单回路的连通图都是树。不含简单回路但不一定连通的图是什么？这些图称为森林，而且具有这样的性质：它们的每个连通分支都是树。图3显示了一个森林。注意，图2中的 \\(G_{4}\\) 也是森林。图3中的图是具有3棵树的森林，图2中的 \\(G_{4}\\) 是具有2棵树的森林。"
        },
        {
            "type": "image",
            "bbox": [
                0.191,
                0.401,
                0.778,
                0.584
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.407,
                0.591,
                0.556,
                0.606
            ],
            "angle": 0,
            "content": "图3 森林的例子"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.617,
                0.908,
                0.654
            ],
            "angle": 0,
            "content": "通常把树定义成具有在每对顶点之间存在唯一简单通路性质的无向图。定理1说明这个变换的定义与原来的定义是等价的。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.661,
                0.776,
                0.679
            ],
            "angle": 0,
            "content": "定理1 一个无向图是树当且仅当在它的每对顶点之间存在唯一简单通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.687,
                0.909,
                0.779
            ],
            "angle": 0,
            "content": "证明 首先假定 \\(T\\) 是树。则 \\(T\\) 是没有简单回路的连通图。设 \\(x\\) 和 \\(y\\) 是 \\(T\\) 的两个顶点。因为 \\(T\\) 是连通的，所以根据10.4节定理1，在 \\(x\\) 和 \\(y\\) 之间存在一条简单通路。而且，这条通路必然是唯一的，因为假如存在第二条这样的通路，那么从 \\(x\\) 到 \\(y\\) 的第一条通路以及将第二条通路逆转后所得到的从 \\(y\\) 到 \\(x\\) 的通路，将组合起来形成回路。利用10.4节练习59，这蕴含着在 \\(T\\) 中存在简单回路。因此，在树的任何两个顶点之间存在唯一简单通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.782,
                0.91,
                0.856
            ],
            "angle": 0,
            "content": "现在假定在图 \\(T\\) 的任何两个顶点之间存在唯一简单通路。则 \\(T\\) 是连通的，因为在它的任何两个顶点之间存在通路。另外，\\(T\\) 没有简单回路。为了看出这是真命题，假定 \\(T\\) 有包含顶点 \\(x\\) 和 \\(y\\) 的简单回路。则在 \\(x\\) 和 \\(y\\) 之间就有两条简单通路，因为这条简单回路包含一条从 \\(x\\) 到 \\(y\\) 的简单通路和一条从 \\(y\\) 到 \\(x\\) 的简单通路。因此，在任何两个顶点之间存在唯一简单通路的图是树。"
        },
        {
            "type": "title",
            "bbox": [
                0.061,
                0.865,
                0.222,
                0.882
            ],
            "angle": 0,
            "content": "11.1.1 有根树"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.886,
                0.908,
                0.939
            ],
            "angle": 0,
            "content": "在树的许多应用中，指定树的一个特殊顶点作为根。一旦规定了根，就可以给每条边指定方向。因为从根到图中每个顶点存在唯一通路（根据定理1），所以指定每条边是离开根的方向。因此，树与它的根一起产生一个有向图，称为有根树。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.13,
                0.04,
                0.164,
                0.053
            ],
            "angle": 0,
            "content": "660"
        },
        {
            "type": "header",
            "bbox": [
                0.211,
                0.038,
                0.287,
                0.053
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.101,
                0.799,
                0.118
            ],
            "angle": 0,
            "content": "定义2 有根树是指定一个顶点作为根并且每条边的方向都离开根的树。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.127,
                0.95,
                0.201
            ],
            "angle": 0,
            "content": "也可以递归地定义有根树。参考5.3节来了解如何这样做。通过选择任何一个顶点来作为根，就可以把非有根树变成有根树。注意对根的不同选择会导致产生不同的有根树。例如，图4显示通过在树 \\(T\\) 中分别指定 \\(a\\) 和 \\(c\\) 作为根所形成的有根树。通常在画有根树时把根画在图的顶端。指示有根树中边的方向的箭头可以省略，因为对根的选择确定了边的方向。"
        },
        {
            "type": "image",
            "bbox": [
                0.216,
                0.207,
                0.837,
                0.347
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.342,
                0.35,
                0.713,
                0.365
            ],
            "angle": 0,
            "content": "图4一棵树以及指定两个根所形成的有根树"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.369,
                0.951,
                0.48
            ],
            "angle": 0,
            "content": "树这个术语起源于植物学和族谱学。假定 \\(T\\) 是有根树。若 \\(\\mathcal{V}\\) 是 \\(T\\) 中的非根顶点，则 \\(\\mathcal{V}\\) 的父母是从 \\(\\pmb{u}\\) 到 \\(\\mathcal{V}\\) 存在有向边的唯一的顶点 \\(\\pmb{u}\\) （读者应当证明这样的顶点 \\(\\pmb{u}\\) 是唯一的）。当 \\(\\pmb{u}\\) 是 \\(\\mathcal{V}\\) 的父母时，\\(\\mathcal{V}\\) 称为 \\(\\pmb{u}\\) 的孩子。具有相同父母的顶点称为兄弟。非根顶点的祖先是从根到该顶点通路上的顶点，不包括该顶点自身但包括根（即该顶点的父母，该顶点的父母的父母等，一直到根）。顶点 \\(\\mathcal{V}\\) 的后代是以 \\(\\mathcal{V}\\) 作为祖先的顶点。树的顶点若没有孩子则称为树叶。有孩子的顶点称为内点。根是内点，除非它是图中唯一的顶点，在这种情况下，它是树叶。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.482,
                0.95,
                0.518
            ],
            "angle": 0,
            "content": "若 \\(a\\) 是树中的顶点，则以 \\(a\\) 为根的子树是由 \\(a\\) 和 \\(a\\) 的后代以及这些顶点所关联的边所组成的该树的子图。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.522,
                0.949,
                0.56
            ],
            "angle": 0,
            "content": "例2 在图5所示的有根树中（根为 \\(a\\)），求 \\(c\\) 的父母，\\(g\\) 的孩子，\\(h\\) 的兄弟，\\(e\\) 的所有祖先，\\(b\\) 的所有后代，所有内点以及所有树叶。什么是以 \\(g\\) 为根的子树？"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.562,
                0.95,
                0.599
            ],
            "angle": 0,
            "content": "解 \\(c\\) 的父母是 \\(b\\) 。 \\(g\\) 的孩子是 \\(h\\) 、 \\(i\\) 和 \\(j\\) 。 \\(h\\) 的兄弟是 \\(i\\) 和 \\(j\\) 。 \\(e\\) 的祖先是 \\(c\\) 、 \\(b\\) 和 \\(a\\) 。 \\(b\\) 的后代是 \\(c\\) 、 \\(d\\) 和 \\(e\\) 。内点是 \\(a\\) 、 \\(b\\) 、 \\(c\\) 、 \\(g\\) 、 \\(h\\) 和 \\(j\\) 。树叶是 \\(d\\) 、 \\(e\\) 、 \\(f\\) 、 \\(i\\) 、 \\(k\\) 、 \\(l\\) 和 \\(m\\) 。以 \\(g\\) 为根的子树如图6所示。"
        },
        {
            "type": "image",
            "bbox": [
                0.161,
                0.619,
                0.87,
                0.829
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.277,
                0.831,
                0.407,
                0.846
            ],
            "angle": 0,
            "content": "图5 有根树 \\(T\\)"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.693,
                0.831,
                0.859,
                0.846
            ],
            "angle": 0,
            "content": "图6 根在 \\(g\\) 的子树"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.852,
                0.95,
                0.888
            ],
            "angle": 0,
            "content": "在许多不同的应用中都用到具有下面性质的有根树：它们的所有内点都有相同个数的孩子。在本章后面将用这样的树去研究涉及搜索、排序和编码的问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.896,
                0.942,
                0.932
            ],
            "angle": 0,
            "content": "定义3 若有根树的每个内点都有不超过 \\(m\\) 个孩子，则称它为 \\(m\\) 叉树。若该树的每个内点都恰好有 \\(m\\) 个孩子，则称它为满 \\(m\\) 叉树。把 \\(m = 2\\) 的 \\(m\\) 叉树称为二叉树。"
        },
        {
            "type": "footer",
            "bbox": [
                0.027,
                0.903,
                0.092,
                0.915
            ],
            "angle": 0,
            "content": "Links"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.763,
                0.043,
                0.87,
                0.057
            ],
            "angle": 0,
            "content": "树 661"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.1,
                0.685,
                0.118
            ],
            "angle": 0,
            "content": "例3 在图7中的有根树，对某个正整数 \\(m\\) 来说是否为满 \\(m\\) 叉树？"
        },
        {
            "type": "image",
            "bbox": [
                0.235,
                0.125,
                0.716,
                0.379
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.405,
                0.385,
                0.548,
                0.4
            ],
            "angle": 0,
            "content": "图74个有根树"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.406,
                0.902,
                0.46
            ],
            "angle": 0,
            "content": "解 \\(T_{1}\\) 是满二叉树，因为它的每个内点都有2个孩子。 \\(T_{2}\\) 是满三叉树，因为它的每个内点都有3个孩子。在 \\(T_{3}\\) 中每个内点都有5个孩子，所以它是满五叉树。对任何 \\(m\\) 来说， \\(T_{4}\\) 都不是满 \\(m\\) 叉树，因为它的有些内点有2个孩子而有些内点有3个孩子。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.463,
                0.902,
                0.518
            ],
            "angle": 0,
            "content": "有序根树 有序根树是把每个内点的孩子都排序的有根树。画有序根树时，以从左向右的顺序来显示每个内点的孩子。注意在常规方式下有根树的表示将确定它的边的一种顺序。我们将在画图时使用边的这种顺序，但不明确地指出有根树是有序的。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.521,
                0.902,
                0.594
            ],
            "angle": 0,
            "content": "在有序二叉树(通常只称为二叉树)中，若一个内点有2个孩子，则第一个孩子称为左子而第二个孩子称为右子。以一个顶点的左子为根的树称为该顶点的左子树，而以一个顶点的右子为根的树称为该顶点的右子树。读者应当注意，对某些应用来说，二叉树的每个非根顶点都指定为其父母的右子或左子。即使当某些顶点仅有一个孩子也这样做。具体指定方式视需要而定。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.597,
                0.884,
                0.613
            ],
            "angle": 0,
            "content": "可以递归地定义有序根树。5.3节以这种方式定义了二叉树，它是有序根树的一种类型。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.618,
                0.902,
                0.657
            ],
            "angle": 0,
            "content": "例4 在图8a所示二叉树 \\(T\\) 中，\\(d\\) 的左子和右子是什么（其中顺序是画法所蕴含的）？\\(c\\) 的左子树和右子树是什么？"
        },
        {
            "type": "image",
            "bbox": [
                0.225,
                0.662,
                0.731,
                0.841
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.301,
                0.845,
                0.655,
                0.86
            ],
            "angle": 0,
            "content": "图8 二叉树 \\(T\\) 和顶点 \\(c\\) 的左子树和右子树"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.868,
                0.833,
                0.884
            ],
            "angle": 0,
            "content": "解 \\(d\\) 的左子是 \\(f\\) ，而右子是 \\(g\\) 。在图8b和图8c中分别显示 \\(c\\) 的左子树和右子树。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.888,
                0.902,
                0.942
            ],
            "angle": 0,
            "content": "与图的情形恰好一样，不存在用来描述树、有根树、有序根树和二叉树等的标准术语。出现这种非标准的术语是因为在计算机科学里大量地使用树，而计算机科学还是相对年轻的领域。当碰到关于树的术语时，读者就应当仔细地核对这些术语所表示的意思。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.14,
                0.044,
                0.178,
                0.057
            ],
            "angle": 0,
            "content": "662"
        },
        {
            "type": "header",
            "bbox": [
                0.222,
                0.043,
                0.298,
                0.058
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "title",
            "bbox": [
                0.113,
                0.108,
                0.319,
                0.124
            ],
            "angle": 0,
            "content": "11.1.2 树作为模型"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.128,
                0.959,
                0.163
            ],
            "angle": 0,
            "content": "以树为模型的应用领域非常广泛，比如计算机科学、化学、地理学、植物学和心理学等。下面将描述基于树的各种模型。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.168,
                0.959,
                0.244
            ],
            "angle": 0,
            "content": "例5 饱和碳氢化合物与树 图可以用来表示分子，其中用顶点表示原子，用边表示原子之间的化学键。英国数学家亚瑟·凯莱在1857年发现了树，当时他正在试图列举形如 \\(\\mathrm{C}_n\\mathrm{H}_{2n + 2}\\) 的化合物的同分异构体，它们都被称为饱和碳氢化合物。（同分异构体代表具有相同化学式但不同化学性质的化合物。）"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.247,
                0.96,
                0.283
            ],
            "angle": 0,
            "content": "在饱和碳氢化合物的图模型中，用度为4的顶点表示每个碳原子，用度为1的顶点表示每个氢原子。在形如 \\(\\mathrm{C}_n\\mathrm{H}_{2n + 2}\\) 的化合物的表示图中有 \\(3n + 2\\) 个顶点。在这个图中，边数是顶点度"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.286,
                0.605,
                0.339
            ],
            "angle": 0,
            "content": "数之和的一半。因此，在这个图中有 \\((4n + 2n + 2) / 2 = 3n + 1\\) 条边。因为这个图是连通的，而且边数比顶点数少1，所以它必然是树（见本节练习15）。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.343,
                0.607,
                0.455
            ],
            "angle": 0,
            "content": "带有 \\(n\\) 个度为4的顶点和 \\(2n + 2\\) 个度为1的顶点的非同构的树表示了形如 \\(\\mathrm{C}_n\\mathrm{H}_{2n + 2}\\) 的不同的同分异构体。例如，当 \\(n = 4\\) 时，恰好存在2个这种类型的不同的同分异构体（读者需要验证）。所以恰好有2个 \\(\\mathrm{C_4H_{10}}\\) 的同分异构体。它们的结构如图9所示。这两种同分异构体称为丁烷和异丁烷。（也称为i-丁烷或甲基丙烷）"
        },
        {
            "type": "image",
            "bbox": [
                0.619,
                0.289,
                0.961,
                0.452
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.669,
                0.454,
                0.911,
                0.469
            ],
            "angle": 0,
            "content": "图9 丁烷的两种同分异构体"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.46,
                0.607,
                0.476
            ],
            "angle": 0,
            "content": "例6 表示组织机构 大的组织机构的结构可以用"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.482,
                0.96,
                0.537
            ],
            "angle": 0,
            "content": "有根树来建模。在这个树中每个顶点表示机构里的一个职务。从一个顶点到另外一个顶点的边的起点所表示的人是终点所表示的人的(直接)上司。图10就是这样的树。在这个树所表示的组织机构里，硬件开发主任直接为研发副总经理工作。这个树的根是表示这个组织的总经理的顶点。"
        },
        {
            "type": "image",
            "bbox": [
                0.123,
                0.543,
                0.951,
                0.709
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.382,
                0.716,
                0.69,
                0.731
            ],
            "angle": 0,
            "content": "图10 一家计算机公司的组织机构图"
        },
        {
            "type": "title",
            "bbox": [
                0.111,
                0.732,
                0.182,
                0.755
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.115,
                0.767,
                0.256,
                0.877
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.111,
                0.882,
                0.25,
                0.901
            ],
            "angle": 0,
            "content": "\\(\\odot\\) Paul Fearn/Alamy Stock Photo"
        },
        {
            "type": "text",
            "bbox": [
                0.27,
                0.767,
                0.959,
                0.907
            ],
            "angle": 0,
            "content": "亚瑟·凯莱（Arthur Cayley，1821—1895）凯莱是一个商人的儿子。他在年纪很小时就在数字计算方面显示出他的数学天分。凯莱在17岁时来到剑桥的三一学院学习。上学期间，他酷爱阅读小说，在校表现也极为优秀，被选举为任期3年的三一学院的研究员和助教。在这期间，凯莱开始了对 \\(n\\) 维几何学的研究，对几何学和分析学做出了巨大贡献。学习之余，他渐渐喜欢上了登山，尤其是在瑞士度假时登山的愉快经历让他难以忘怀。由于在剑桥大学没有合适的数学家职位提供给他，凯莱离开了剑桥，转行学习法律并且在1849年获取律师资格。尽管凯莱在从事法律工作的同时还继续着数学研究，但他依然在法律界享有盛誉。在他的律师生涯中，凯莱写"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.909,
                0.957,
                0.942
            ],
            "angle": 0,
            "content": "出了三百多篇关于数学研究的论文。1863年，剑桥大学专门设立了一个新的数学类的职位并把它给了凯莱。尽管薪酬低于律师的收入，凯莱还是欣然接受了这份工作。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.773,
                0.035,
                0.88,
                0.049
            ],
            "angle": 0,
            "content": "树 663"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.093,
                0.909,
                0.171
            ],
            "angle": 0,
            "content": "例7 计算机文件系统 计算机存储器中的文件可以组织成目录。目录可以包含文件和子目录。根目录包含整个文件系统。因此，文件系统可以表示成有根树，其中根表示根目录，内点表示子目录，树叶表示文件或空目录。在图11中显示了一个这样的文件系统。在该系统中，文件khr属于目录rje。（注意文件的链接，同一个文件有多个路径名，会导致计算机文件系统中有回路。）"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.175,
                0.911,
                0.312
            ],
            "angle": 0,
            "content": "例8 树形连接并行处理系统 在10.2节例17中描述了多种并行处理的互联网络。树形连接网络是把处理器互相连接的另外一种重要方式。表示这样的网络的图是完全二叉树，即一个每个树叶都在同一层上的满二叉树。这样的网络把 \\( n = 2^k - 1 \\) 个处理器互连起来，其中 \\( k \\) 是正整数。一个非根也非树叶的顶点 \\( v \\) 所表示的处理器具有三个双向连接，一个连接通向 \\( v \\) 的父母所表示的处理器，两个连接通向 \\( v \\) 的两个孩子所表示的处理器。根所表示的处理器具有两个双向连接，分别通向 \\( v \\) 的两个孩子所表示的处理器。树叶所表示的处理器具有一个双向连接，通向 \\( v \\) 的父母。图12显示了一个带7个处理器的树形连接网络。"
        },
        {
            "type": "image",
            "bbox": [
                0.073,
                0.319,
                0.532,
                0.557
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.185,
                0.565,
                0.418,
                0.58
            ],
            "angle": 0,
            "content": "图11 一个计算机文件系统"
        },
        {
            "type": "image",
            "bbox": [
                0.635,
                0.451,
                0.817,
                0.557
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.571,
                0.565,
                0.876,
                0.58
            ],
            "angle": 0,
            "content": "图12 带7个处理器的树形连接网络"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.587,
                0.911,
                0.682
            ],
            "angle": 0,
            "content": "下面说明并行计算是如何使用树形连接网络的。具体地说，说明图12中的处理器如何用3步来完成8个数的相加。第一步，用 \\(P_{4}\\) 将 \\(x_{1}\\) 和 \\(x_{2}\\) 相加、用 \\(P_{5}\\) 将 \\(x_{3}\\) 和 \\(x_{4}\\) 相加、用 \\(P_{6}\\) 将 \\(x_{5}\\) 和 \\(x_{6}\\) 相加、用 \\(P_{7}\\) 将 \\(x_{7}\\) 和 \\(x_{8}\\) 相加。第二步，用 \\(P_{2}\\) 将 \\(x_{1} + x_{2}\\) 和 \\(x_{3} + x_{4}\\) 相加、用 \\(P_{3}\\) 将 \\(x_{5} + x_{6}\\) 和 \\(x_{7} + x_{8}\\) 相加。第三步，用 \\(P_{1}\\) 将 \\(x_{1} + x_{2} + x_{3} + x_{4}\\) 和 \\(x_{5} + x_{6} + x_{7} + x_{8}\\) 相加。这种方法要优于串行地将8个数相加所需要的7步，串行的步骤是依次把一个数与表中前面各数之和相加。"
        },
        {
            "type": "title",
            "bbox": [
                0.064,
                0.692,
                0.248,
                0.709
            ],
            "angle": 0,
            "content": "11.1.3 树的性质"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.713,
                0.591,
                0.729
            ],
            "angle": 0,
            "content": "我们常常需要知道树中各种边和顶点数目之间的联系。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.738,
                0.503,
                0.755
            ],
            "angle": 0,
            "content": "定理2 带有 \\(n\\) 个顶点的树含有 \\(n - 1\\) 条边。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.764,
                0.91,
                0.8
            ],
            "angle": 0,
            "content": "证明 将用数学归纳法来证明这个定理。注意对于所有的树来说，这里可以选择一个树根并且认为这个树是有根树。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.803,
                0.864,
                0.819
            ],
            "angle": 0,
            "content": "基础步骤：当 \\(n = 1\\) 时，有 \\(n = 1\\) 个顶点的树没有边。所有对于 \\(n = 1\\) 来说，定理为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.822,
                0.911,
                0.914
            ],
            "angle": 0,
            "content": "归纳步骤：归纳假设有 \\(k\\) 个顶点的每棵树都有 \\(k - 1\\) 条边，其中 \\(k\\) 是正整数。假设树 \\(T\\) 有 \\(k + 1\\) 个顶点并且 \\(v\\) 是 \\(T\\) 的树叶（\\(v\\) 必定存在，因为树是有穷的），设 \\(w\\) 是 \\(v\\) 的父母，从 \\(T\\) 中删除顶点 \\(v\\) 以及连接 \\(w\\) 和 \\(v\\) 的边，就产生有 \\(k\\) 个顶点的树 \\(T'\\)，因为所得出的图还是连通的并且没有简单回路。根据归纳假设，\\(T'\\) 有 \\(k - 1\\) 条边。所以 \\(T\\) 有 \\(k\\) 条边，因为 \\(T\\) 比 \\(T'\\) 多 1 条边，即连接 \\(v\\) 和 \\(w\\) 的边。这样就完成了归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.918,
                0.911,
                0.935
            ],
            "angle": 0,
            "content": "树是一个不带简单回路的连通无向图。所以，当 \\(G\\) 是一个含有 \\(n\\) 个顶点的无向图时，由定"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.13,
                0.036,
                0.167,
                0.049
            ],
            "angle": 0,
            "content": "664"
        },
        {
            "type": "header",
            "bbox": [
                0.211,
                0.034,
                0.288,
                0.049
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.09,
                0.951,
                0.203
            ],
            "angle": 0,
            "content": "理2可知，两个条件：条件1， \\(G\\) 是连通的；条件2， \\(G\\) 没有简单回路。这两个条件蕴含条件3， \\(G\\) 有 \\(n - 1\\) 条边。同时，当条件1和条件3成立时，条件2也一定成立；当条件2和条件3成立时，条件1也一定成立。也就是说，若 \\(G\\) 是连通的， \\(G\\) 有 \\(n - 1\\) 条边，则 \\(G\\) 没有简单回路，所以 \\(G\\) 是一棵树(见练习15a)，并且若 \\(G\\) 没有简单回路，并且 \\(G\\) 有 \\(n - 1\\) 条边，则 \\(G\\) 是连通的，所以 \\(G\\) 是一棵树(见练习15b)。同理，当条件1、2、3中的两个成立时，第三个也一定成立，而且 \\(G\\) 一定是一棵树。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.205,
                0.949,
                0.24
            ],
            "angle": 0,
            "content": "计算满 \\(m\\) 叉树中的顶点数如定理3所示，带有指定内点数的满 \\(m\\) 叉树的顶点数是确定的。与定理2一样，用 \\(n\\) 来表示树中的顶点数。"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.249,
                0.668,
                0.266
            ],
            "angle": 0,
            "content": "定理3 带有 \\(i\\) 个内点的满 \\(m\\) 叉树含有 \\(n = mi + 1\\) 个顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.275,
                0.949,
                0.311
            ],
            "angle": 0,
            "content": "证明除了根之外的每个顶点都是内点的孩子。因为每个内点有 \\(m\\) 个孩子，所以在树中除了根之外还有 \\(mi\\) 个顶点。因此，该树含有 \\(n = mi + 1\\) 个顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.314,
                0.949,
                0.349
            ],
            "angle": 0,
            "content": "假定 \\(T\\) 是满 \\(m\\) 叉树。设 \\(i\\) 是该树的内点数，\\(l\\) 是树叶数。一旦 \\(n\\)、\\(i\\) 和 \\(l\\) 中的一个已知，另外的两个量就随之确定了。定理4解释了如何从已知的一个量求出其他两个量。"
        },
        {
            "type": "text",
            "bbox": [
                0.152,
                0.359,
                0.424,
                0.374
            ],
            "angle": 0,
            "content": "定理4 一个满 \\(m\\) 叉树若有"
        },
        {
            "type": "text",
            "bbox": [
                0.152,
                0.378,
                0.788,
                0.393
            ],
            "angle": 0,
            "content": "(i) \\(n\\) 个顶点，则有 \\(i = (n - 1) / m\\) 个内点和 \\(l = [(m - 1)n + 1] / m\\) 个树叶；"
        },
        {
            "type": "text",
            "bbox": [
                0.152,
                0.397,
                0.713,
                0.412
            ],
            "angle": 0,
            "content": "(ii) \\(i\\) 个内点，则有 \\(n = m i + 1\\) 个顶点和 \\(l = (m - 1)i + 1\\) 个树叶；"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.416,
                0.833,
                0.431
            ],
            "angle": 0,
            "content": "(iii) \\(l\\) 个树叶，则有 \\(n = (ml - 1) / (m - 1)\\) 个顶点和 \\(i = (l - 1) / (m - 1)\\) 个内点。"
        },
        {
            "type": "list",
            "bbox": [
                0.151,
                0.378,
                0.833,
                0.431
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.442,
                0.95,
                0.496
            ],
            "angle": 0,
            "content": "证明 设 \\(n\\) 表示顶点数，\\(i\\) 表示内点数，\\(l\\) 表示树叶数。利用定理3中的等式，即 \\(n = mi + 1\\)，以及等式 \\(n = l + i\\)（这个等式为真，因为每一个顶点要么是树叶要么是内点），就可以证明本定理的所有三个部分。这里证明(i)。（ii)和(iii)的证明留给读者作为练习。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.499,
                0.949,
                0.534
            ],
            "angle": 0,
            "content": "在 \\(n = mi + 1\\) 中求解 \\(i\\) 得出 \\(i = (n - 1) / m\\) 。然后把 \\(i\\) 的这个表达式代入等式 \\(n = l + i\\) ，就证明 \\(l = n - i = n - (n - 1) / m = [(m - 1)n + 1] / m.\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.537,
                0.378,
                0.553
            ],
            "angle": 0,
            "content": "例9说明如何使用定理4。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.558,
                0.951,
                0.616
            ],
            "angle": 0,
            "content": "例9 假定某人寄出一封连环信。要求收到信的每个人再把它寄给另外4个人。有些人这样做了，但是其他人则没有寄出信。若没有人收到超过一封的信，而且若读过信但是不寄出它的人数超过100个后，连环信就终止了，那么包括第一个人在内，有多少人看过信？有多少人寄出过信？"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.619,
                0.951,
                0.692
            ],
            "angle": 0,
            "content": "解可以用4叉树表示连环信。内点对应于寄出信的人，而树叶对应于不寄出信的人。因为有100个人不寄出信，所以在这个有根树中，树叶数是 \\( l = 100 \\) 。因此，由定理4的(iii)说明，已经看过信的人数是 \\( n = (4 \\cdot 100 - 1) / (4 - 1) = 133 \\) 。另外，内点数是 \\( 133 - 100 = 33 \\)，所以33个人寄出过信。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.695,
                0.95,
                0.789
            ],
            "angle": 0,
            "content": "平衡的 \\(m\\) 叉树经常需要使用这样的有根树，它们是“平衡的”，所以在每个顶点的子树都包含大约相同长度的通路。下面的一些定义将解释这个概念。在有根树中顶点 \\(v\\) 的层是从根到这个顶点的唯一通路的长度。根的层定义为0。有根树的高度就是顶点层数的最大值。换句话说，有根树的层数是从根到任意顶点的最长通路的长度。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.792,
                0.734,
                0.831
            ],
            "angle": 0,
            "content": "例10 求图13所示的有根树中每个顶点的层数。这棵树的高度是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.834,
                0.734,
                0.888
            ],
            "angle": 0,
            "content": "解 根 \\(a\\) 在0层上。顶点 \\(b\\)、\\(j\\) 和 \\(k\\) 都在1层上。顶点 \\(c\\)、\\(e\\)、\\(f\\) 和 \\(l\\) 都在2层上。顶点 \\(d\\)、\\(g\\)、\\(i\\)、\\(m\\) 和 \\(n\\) 都在3层上。最后，顶点 \\(h\\) 在4层上。因为任意顶点的最大层数是4，所以这棵树的高度为4。"
        },
        {
            "type": "image",
            "bbox": [
                0.749,
                0.715,
                0.934,
                0.863
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.763,
                0.865,
                0.918,
                0.88
            ],
            "angle": 0,
            "content": "图13 一棵有根树"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.892,
                0.851,
                0.907
            ],
            "angle": 0,
            "content": "若一棵高度为 \\(h\\) 的 \\(m\\) 叉树的所有树叶都在 \\(h\\) 层或 \\(h - 1\\) 层，则这棵树是平衡的。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.914,
                0.687,
                0.93
            ],
            "angle": 0,
            "content": "例11 在图14所示的一些有根树中，哪些有根树是平衡的？"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.76,
                0.038,
                0.866,
                0.052
            ],
            "angle": 0,
            "content": "树 665"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.094,
                0.893,
                0.128
            ],
            "angle": 0,
            "content": "解 \\(T_{1}\\) 是平衡的，因为它所有的树叶都在3层和4层上。然而，\\(T_{2}\\) 不是平衡的，因为它有树叶在2层、3层和4层上。最后，\\(T_{3}\\) 是平衡的，因为它所有的树叶都在3层上。"
        },
        {
            "type": "image",
            "bbox": [
                0.209,
                0.135,
                0.51,
                0.249
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.341,
                0.255,
                0.359,
                0.269
            ],
            "angle": 0,
            "content": "\\(T_{1}\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.535,
                0.136,
                0.737,
                0.248
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.649,
                0.256,
                0.667,
                0.269
            ],
            "angle": 0,
            "content": "\\(T_{2}\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.325,
                0.276,
                0.707,
                0.366
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.506,
                0.372,
                0.525,
                0.384
            ],
            "angle": 0,
            "content": "\\(T_{3}\\)"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.393,
                0.387,
                0.551,
                0.402
            ],
            "angle": 0,
            "content": "图14 一些有根树"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.413,
                0.895,
                0.448
            ],
            "angle": 0,
            "content": "在 \\(m\\) 叉树中树叶数的界 常常用到 \\(m\\) 叉树中树叶数的上界。定理5用 \\(m\\) 叉树的高度给出了一个这样的界。"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.458,
                0.559,
                0.475
            ],
            "angle": 0,
            "content": "定理5 在高度为 \\(h\\) 的 \\(m\\) 叉树中至多有 \\(m^k\\) 个树叶。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.484,
                0.895,
                0.539
            ],
            "angle": 0,
            "content": "证明 本证明对高度使用数学归纳法。首先，考虑高度为1的 \\(m\\) 叉树。这些树都是由一个根和不超过 \\(m\\) 个孩子所组成的，每个孩子都是树叶。因此在高度为1的 \\(m\\) 叉树中有不超过\\(m^1 = m\\) 个树叶。这是归纳论证的基础步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.542,
                0.895,
                0.595
            ],
            "angle": 0,
            "content": "现在假定对高度小于 \\(h\\) 的所有 \\(m\\) 叉树来说，这个结果都为真。这是归纳假设。设 \\(T\\) 是高度为 \\(h\\) 的 \\(m\\) 叉树。\\(T\\) 的树叶都是通过删除从根到每个在1层的顶点的边所获得的 \\(T\\) 的子树的树叶，如图15所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.599,
                0.895,
                0.654
            ],
            "angle": 0,
            "content": "这些子树的高度都小于或等于 \\(h - 1\\) 。所以根据归纳假设，每个这样的有根树都至多有 \\(m^{h - 1}\\) 个树叶。因为最多有 \\(m\\) 棵这样的子树，每个子树最多有 \\(m^{h - 1}\\) 个树叶，所以在这个有根树中最多有 \\(m \\cdot m^{h - 1} = m^h\\) 个树叶。这样就完成了归纳论证。"
        },
        {
            "type": "image",
            "bbox": [
                0.122,
                0.66,
                0.826,
                0.803
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.375,
                0.806,
                0.571,
                0.82
            ],
            "angle": 0,
            "content": "图15 证明的归纳步骤"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.832,
                0.895,
                0.865
            ],
            "angle": 0,
            "content": "推论1 若一棵高度为 \\(h\\) 的 \\(m\\) 叉树带有 \\(l\\) 个树叶，则 \\(h \\geqslant \\lceil \\log_m l \\rceil\\) 。若这棵 \\(m\\) 叉树是满的和平衡的，则 \\(h = \\lceil \\log_m l \\rceil\\) （这里使用向上取整函数。 \\(\\lceil x \\rceil\\) 是大于或等于 \\(x\\) 的最小整数）。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.868,
                0.897,
                0.939
            ],
            "angle": 0,
            "content": "证明 从定理5知道 \\(l \\leqslant m^{h}\\) 。取以 \\(m\\) 为底的对数就证明 \\(\\log_{m} l \\leqslant h\\) 。因为 \\(h\\) 是整数，所以有 \\(h \\geqslant \\lceil \\log_{m} l \\rceil\\) 。现在假定这棵树是平衡的。于是每个树叶都在 \\(h\\) 层或 \\(h - 1\\) 层上，而且因为树的高度为 \\(h\\) ，所以在 \\(h\\) 层至少有一个树叶。所以必然有超过 \\(m^{h - 1}\\) 个树叶（见本节练习30）。因为 \\(l \\leqslant m^{h}\\) ，所以 \\(m^{h - 1} < l \\leqslant m^{h}\\) 。在这个不等式中取以 \\(m\\) 为底的对数就得出 \\(h - 1 < \\log_{m} l \\leqslant h\\) 。因此 \\(h = \\lceil \\log_{m} l \\rceil\\) 。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.145,
                0.038,
                0.18,
                0.051
            ],
            "angle": 0,
            "content": "666"
        },
        {
            "type": "header",
            "bbox": [
                0.227,
                0.037,
                0.301,
                0.052
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "title",
            "bbox": [
                0.117,
                0.101,
                0.165,
                0.118
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.121,
                0.283,
                0.136
            ],
            "angle": 0,
            "content": "1. 下面哪些图是树？"
        },
        {
            "type": "image",
            "bbox": [
                0.139,
                0.139,
                0.315,
                0.192
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.437,
                0.138,
                0.614,
                0.192
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.698,
                0.139,
                0.821,
                0.191
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.139,
                0.211,
                0.315,
                0.266
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.438,
                0.211,
                0.543,
                0.271
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.704,
                0.192,
                0.875,
                0.251
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.272,
                0.283,
                0.287
            ],
            "angle": 0,
            "content": "2. 下面哪些图是树？"
        },
        {
            "type": "image",
            "bbox": [
                0.139,
                0.289,
                0.393,
                0.455
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.434,
                0.289,
                0.617,
                0.408
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.698,
                0.289,
                0.915,
                0.456
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.457,
                0.467,
                0.472
            ],
            "angle": 0,
            "content": "3. 回答下列关于图中所示的有根树的问题。"
        },
        {
            "type": "image",
            "bbox": [
                0.139,
                0.475,
                0.455,
                0.68
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.683,
                0.283,
                0.697
            ],
            "angle": 0,
            "content": "a)哪个顶点是根？"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.7,
                0.338,
                0.714
            ],
            "angle": 0,
            "content": "d)哪些顶点是 \\(j\\) 的孩子？"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.718,
                0.342,
                0.731
            ],
            "angle": 0,
            "content": "g)哪些顶点是 \\(m\\) 的祖先？"
        },
        {
            "type": "text",
            "bbox": [
                0.399,
                0.683,
                0.56,
                0.697
            ],
            "angle": 0,
            "content": "b)哪些顶点是内点？"
        },
        {
            "type": "text",
            "bbox": [
                0.399,
                0.7,
                0.596,
                0.714
            ],
            "angle": 0,
            "content": "e)哪些顶点是 \\(h\\) 的父母？"
        },
        {
            "type": "text",
            "bbox": [
                0.399,
                0.718,
                0.596,
                0.731
            ],
            "angle": 0,
            "content": "h)哪些顶点是 \\(b\\) 的后代？"
        },
        {
            "type": "text",
            "bbox": [
                0.64,
                0.683,
                0.798,
                0.697
            ],
            "angle": 0,
            "content": "c)哪些顶点是树叶？"
        },
        {
            "type": "text",
            "bbox": [
                0.64,
                0.7,
                0.834,
                0.714
            ],
            "angle": 0,
            "content": "f)哪些顶点是 \\(o\\) 的兄弟？"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.734,
                0.597,
                0.749
            ],
            "angle": 0,
            "content": "4. 对于下图所示的有根树，回答练习3所列出的相同问题。"
        },
        {
            "type": "image",
            "bbox": [
                0.139,
                0.752,
                0.448,
                0.936
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.77,
                0.036,
                0.879,
                0.051
            ],
            "angle": 0,
            "content": "树 667"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.092,
                0.566,
                0.105
            ],
            "angle": 0,
            "content": "5. 练习3中的有根树对某个正整数 \\(m\\) 来说，是否是满 \\(m\\) 叉树？"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.11,
                0.566,
                0.123
            ],
            "angle": 0,
            "content": "6. 练习4中的有根树对某个正整数 \\(m\\) 来说，是否是满 \\(m\\) 叉树？"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.128,
                0.447,
                0.141
            ],
            "angle": 0,
            "content": "7. 练习3中的有根树的每个顶点的层数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.145,
                0.446,
                0.159
            ],
            "angle": 0,
            "content": "8. 练习4中的有根树的每个顶点的层数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.163,
                0.427,
                0.176
            ],
            "angle": 0,
            "content": "9. 画出练习3中的树以下列顶点为根的子树。"
        },
        {
            "type": "list",
            "bbox": [
                0.056,
                0.092,
                0.566,
                0.176
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.182,
                0.127,
                0.194
            ],
            "angle": 0,
            "content": "a) \\( a \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.34,
                0.182,
                0.371,
                0.194
            ],
            "angle": 0,
            "content": "b)c"
        },
        {
            "type": "text",
            "bbox": [
                0.582,
                0.183,
                0.609,
                0.194
            ],
            "angle": 0,
            "content": "c)e"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.198,
                0.436,
                0.211
            ],
            "angle": 0,
            "content": "10. 画出练习4中的树以下列顶点为根的子树。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.217,
                0.122,
                0.228
            ],
            "angle": 0,
            "content": "a) \\( a \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.341,
                0.217,
                0.37,
                0.228
            ],
            "angle": 0,
            "content": "b)c"
        },
        {
            "type": "text",
            "bbox": [
                0.582,
                0.218,
                0.609,
                0.228
            ],
            "angle": 0,
            "content": "c)e"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.234,
                0.456,
                0.246
            ],
            "angle": 0,
            "content": "11. a) 有多少种非同构的带有 3 个顶点的无根树？"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.251,
                0.622,
                0.263
            ],
            "angle": 0,
            "content": "b)有多少种非同构的带有3个顶点的有根树(使用有向图的同构)?"
        },
        {
            "type": "list",
            "bbox": [
                0.06,
                0.234,
                0.622,
                0.263
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.269,
                0.456,
                0.281
            ],
            "angle": 0,
            "content": "* 12. a)有多少种非同构的带有 4 个顶点的无根树？"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.286,
                0.622,
                0.298
            ],
            "angle": 0,
            "content": "b)有多少种非同构的带有4个顶点的有根树（使用有向图的同构）？"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.304,
                0.456,
                0.316
            ],
            "angle": 0,
            "content": "* 13. a)有多少种非同构的带有 5 个顶点的无根树?"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.321,
                0.622,
                0.334
            ],
            "angle": 0,
            "content": "b)有多少种非同构的带有5个顶点的有根树(使用有向图的同构)?"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.339,
                0.787,
                0.352
            ],
            "angle": 0,
            "content": "* 14. 证明：简单图是树当且仅当它是连通的，但是删除它的任何一条边就产生不连通的图。"
        },
        {
            "type": "list",
            "bbox": [
                0.045,
                0.269,
                0.787,
                0.352
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.017,
                0.357,
                0.402,
                0.37
            ],
            "angle": 0,
            "content": "\\(\\text{空} * 15\\) 设 \\(G\\) 是带有 \\(n\\) 个顶点的简单图。证明："
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.375,
                0.483,
                0.387
            ],
            "angle": 0,
            "content": "a) \\(G\\) 是树当且仅当 \\(G\\) 是连通的并且有 \\(n - 1\\) 条边。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.392,
                0.904,
                0.423
            ],
            "angle": 0,
            "content": "b) \\(G\\) 是树当且仅当 \\(G\\) 没有简单回路并且有 \\(n - 1\\) 条边。[提示：为了证明当 \\(G\\) 没有简单回路并且有 \\(n - 1\\) 条边时 \\(G\\) 是连通的，证明 \\(G\\) 不能有多于1个的连通分部。]"
        },
        {
            "type": "list",
            "bbox": [
                0.09,
                0.375,
                0.904,
                0.423
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.427,
                0.521,
                0.44
            ],
            "angle": 0,
            "content": "16. 哪些完全二分图 \\(K_{m,n}\\) 是树，其中 \\(m\\) 和 \\(n\\) 都是正整数？"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.445,
                0.388,
                0.457
            ],
            "angle": 0,
            "content": "17. 带有 10000 个顶点的树有多少条边？"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.463,
                0.438,
                0.475
            ],
            "angle": 0,
            "content": "18. 带有 100 个内点的满 5 叉树有多少个顶点？"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.481,
                0.43,
                0.493
            ],
            "angle": 0,
            "content": "19. 带有 1000 个内点的满二叉树有多少条边？"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.498,
                0.438,
                0.51
            ],
            "angle": 0,
            "content": "20. 带有 100 个顶点的满 3 叉树有多少个树叶？"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.516,
                0.906,
                0.546
            ],
            "angle": 0,
            "content": "21. 假定 1000 个人参加象棋巡回赛。若一个选手输掉一盘就遭到淘汰，而且比赛进行到只有一位参加者还没有输过为止，则利用这个巡回赛的有根树模型来确定为了决出冠军必须下多少盘棋(假定没有平局)。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.551,
                0.906,
                0.598
            ],
            "angle": 0,
            "content": "22. 一封连环信开始时有一个人寄出一封信给其他5个人。收到此信的每个人要么寄出信给从来没有收到过此信的其他5个人，要么不把它寄给任何人。假定在这个连环终止以前有10000个人寄出过此信，并且没有人收到超过一封信。有多少人收到过信？又有多少人收到过信但是没有寄出它？"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.603,
                0.906,
                0.687
            ],
            "angle": 0,
            "content": "23. 一封连环信开始时一个人寄出一封信给其他10个人。要求每个人寄出此信给其他10个人，而且每封信都包含该连环中前面6个人的列表。除非表中不足6个名字，否则每个人都寄一美元给表中的第一个人，从表中删除这个人的名字，把其他5个人的名字向上移动一位，并且把他自己的名字插入到表的末尾。若没有人中断这个连环，并且每人至多收到一封信，则这个连环中的一个人最终将收到多少钱？"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.691,
                0.863,
                0.704
            ],
            "angle": 0,
            "content": "*24. 要么画出带有 76 个树叶且高度为 3 的满 \\( m \\) 叉树,其中 \\( m \\) 是正整数,要么证明这样的树不存在。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.71,
                0.863,
                0.722
            ],
            "angle": 0,
            "content": "* 25. 要么画出带有 84 个树叶且高度为 3 的满 \\( m \\) 叉树,其中 \\( m \\) 是正整数,要么证明这样的树不存在。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.728,
                0.45,
                0.739
            ],
            "angle": 0,
            "content": "* 26.一棵满 \\(m\\) 叉树 \\(T\\) 有81个树叶并且高度为4。"
        },
        {
            "type": "list",
            "bbox": [
                0.045,
                0.691,
                0.863,
                0.739
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.745,
                0.295,
                0.757
            ],
            "angle": 0,
            "content": "a)给出 \\(m\\) 的上界和下界。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.762,
                0.374,
                0.774
            ],
            "angle": 0,
            "content": "b) 若 \\(T\\) 也是平衡的, 则 \\(m\\) 是多少?"
        },
        {
            "type": "list",
            "bbox": [
                0.091,
                0.745,
                0.374,
                0.774
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.78,
                0.544,
                0.793
            ],
            "angle": 0,
            "content": "一棵完全 \\(m\\) 叉树是其中每个树叶都在同一层上的满 \\(m\\) 叉树。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.798,
                0.531,
                0.81
            ],
            "angle": 0,
            "content": "27.构造高度为4的完全二叉树和高度为3的完全3叉树。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.815,
                0.537,
                0.828
            ],
            "angle": 0,
            "content": "28. 高度为 \\(h\\) 的完全 \\(m\\) 叉树具有多少个顶点和多少个树叶？"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.833,
                0.141,
                0.845
            ],
            "angle": 0,
            "content": "29. 证明："
        },
        {
            "type": "list",
            "bbox": [
                0.06,
                0.798,
                0.537,
                0.845
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.85,
                0.204,
                0.864
            ],
            "angle": 0,
            "content": "a)定理4的ii"
        },
        {
            "type": "text",
            "bbox": [
                0.342,
                0.851,
                0.459,
                0.864
            ],
            "angle": 0,
            "content": "b)定理4的iii"
        },
        {
            "type": "text",
            "bbox": [
                0.029,
                0.868,
                0.541,
                0.881
            ],
            "angle": 0,
            "content": "30. 证明：高度为 \\(h\\) 的满 \\(m\\) 叉平衡树具有超过 \\(m^{h-1}\\) 个树叶。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.886,
                0.512,
                0.898
            ],
            "angle": 0,
            "content": "31. 在包含总共 \\( n \\) 个顶点的 \\( t \\) 棵树的森林中有多少条边？"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.904,
                0.623,
                0.916
            ],
            "angle": 0,
            "content": "32. 解释如何用树来表示由章、章中节、节中小节组成的书的目录表。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.921,
                0.514,
                0.933
            ],
            "angle": 0,
            "content": "33. 下面的饱和碳氢化合物有多少种不同的同分异构体？"
        },
        {
            "type": "list",
            "bbox": [
                0.029,
                0.868,
                0.623,
                0.933
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.133,
                0.038,
                0.171,
                0.051
            ],
            "angle": 0,
            "content": "668"
        },
        {
            "type": "header",
            "bbox": [
                0.215,
                0.036,
                0.291,
                0.052
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.094,
                0.207,
                0.107
            ],
            "angle": 0,
            "content": "a) \\(\\mathrm{C}_3\\mathrm{H}_8\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.387,
                0.094,
                0.455,
                0.107
            ],
            "angle": 0,
            "content": "b) \\(\\mathrm{C}_5\\mathrm{H}_{12}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.628,
                0.094,
                0.694,
                0.107
            ],
            "angle": 0,
            "content": "c) \\(\\mathrm{C_6H_{14}}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.111,
                0.504,
                0.125
            ],
            "angle": 0,
            "content": "34. 在组织机构树中下述对象分别表示什么内容？"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.129,
                0.288,
                0.143
            ],
            "angle": 0,
            "content": "a)一个顶点的父母"
        },
        {
            "type": "text",
            "bbox": [
                0.387,
                0.13,
                0.537,
                0.143
            ],
            "angle": 0,
            "content": "b)一个顶点的孩子"
        },
        {
            "type": "text",
            "bbox": [
                0.628,
                0.13,
                0.776,
                0.143
            ],
            "angle": 0,
            "content": "c)一个顶点的兄弟"
        },
        {
            "type": "text",
            "bbox": [
                0.137,
                0.147,
                0.289,
                0.161
            ],
            "angle": 0,
            "content": "d)一个顶点的祖先"
        },
        {
            "type": "text",
            "bbox": [
                0.387,
                0.148,
                0.537,
                0.16
            ],
            "angle": 0,
            "content": "e)一个顶点的后代"
        },
        {
            "type": "text",
            "bbox": [
                0.628,
                0.148,
                0.776,
                0.16
            ],
            "angle": 0,
            "content": "f)一个顶点的层数"
        },
        {
            "type": "text",
            "bbox": [
                0.137,
                0.165,
                0.27,
                0.179
            ],
            "angle": 0,
            "content": "g)一棵树的高度"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.182,
                0.732,
                0.197
            ],
            "angle": 0,
            "content": "35. 对表示计算机文件系统的有根树，回答与练习 34 所给的那些相同的问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.2,
                0.704,
                0.214
            ],
            "angle": 0,
            "content": "36. a) 画出表示 15 个处理器的树形连接网络的有 15 个顶点的完全二叉树。"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.218,
                0.592,
                0.232
            ],
            "angle": 0,
            "content": "b)说明如何用a中的15个处理器分四步求16个数之和。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.235,
                0.873,
                0.25
            ],
            "angle": 0,
            "content": "37. 设 \\( n \\) 是 2 的幂。证明：可以用 \\( n - 1 \\) 个处理器的树形连接网络在 \\( \\log n \\) 步中求出 \\( n \\) 个数之和。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.253,
                0.951,
                0.305
            ],
            "angle": 0,
            "content": "*38. 标记树是其中每个顶点都指定了标记的树。当在两个标记树之间存在保持顶点标记的同构时，就把这两个标记树当作同构的。用集合{1，2，3}中3个不同的数来标记3个顶点的、非同构的标记树有多少种？用集合{1，2，3，4}里4个不同的数来标记四个顶点的、非同构的标记树有多少种？"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.307,
                0.951,
                0.34
            ],
            "angle": 0,
            "content": "无根树中顶点的离心度是从这个顶点开始的最长的简单通路的长度。若在树中没有其他顶点比一个顶点的离心度更小，则这个顶点就称为中心。在练习 \\(39\\sim 41\\) 中，求每一个所给树的中心。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.342,
                0.133,
                0.356
            ],
            "angle": 0,
            "content": "39."
        },
        {
            "type": "image",
            "bbox": [
                0.136,
                0.342,
                0.315,
                0.481
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.327,
                0.343,
                0.54,
                0.432
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.552,
                0.343,
                0.917,
                0.416
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.484,
                0.724,
                0.499
            ],
            "angle": 0,
            "content": "42. 证明：为了从无根树产生高度最小的有根树，就应当选择中心来作为根。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.502,
                0.466,
                0.516
            ],
            "angle": 0,
            "content": "* 43. 证明：树有一个中心或两个相邻的中心。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.52,
                0.484,
                0.534
            ],
            "angle": 0,
            "content": "44. 证明：每一棵树都可以用两种颜色来着色。"
        },
        {
            "type": "list",
            "bbox": [
                0.103,
                0.502,
                0.484,
                0.534
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.537,
                0.951,
                0.57
            ],
            "angle": 0,
            "content": "有根的斐波那契树 \\(T_{n}\\) 是以下面的方式递归地定义的。 \\(T_{1}\\) 和 \\(T_{2}\\) 都是包含单个顶点的有根树，而对 \\(n = 3\\) 4，…来说，都是由一个根以及以 \\(T_{n - 1}\\) 作为其左子树并且以 \\(T_{n - 2}\\) 作为其右子树来构造出的有根树 \\(T_{n}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.573,
                0.392,
                0.587
            ],
            "angle": 0,
            "content": "45. 画出前7个有根的斐波那契树。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.591,
                0.848,
                0.605
            ],
            "angle": 0,
            "content": "* 46. 有根的斐波那契树 \\(T_{n}\\) 有多少个顶点、树叶和内点？其中 \\(n\\) 是正整数。它的高度是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.608,
                0.951,
                0.677
            ],
            "angle": 0,
            "content": "47. 下面这个使用数学归纳法的“证明”错在什么地方？命题：有 \\(n\\) 个顶点的每棵树都有长度为 \\(n - 1\\) 的通路。基础步骤：有1个顶点的每棵树显然有长度为0的通路。归纳步骤：假设有 \\(n\\) 个顶点的树有长度为 \\(n - 1\\) 的通路，且这个通路以 \\(u\\) 作为终点。加入顶点 \\(v\\) 和从 \\(u\\) 到 \\(v\\) 的边。所得出的树有 \\(n + 1\\) 个顶点并且有长度为 \\(n\\) 的通路。这样就完成了归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.68,
                0.627,
                0.695
            ],
            "angle": 0,
            "content": "\\(\\mathbb{S}^{*}\\) 48.证明：有 \\(n\\) 个顶点的二叉树中，树叶的平均深度是 \\(\\Omega (\\log n)\\)"
        },
        {
            "type": "title",
            "bbox": [
                0.107,
                0.71,
                0.293,
                0.729
            ],
            "angle": 0,
            "content": "11.2 树的应用"
        },
        {
            "type": "title",
            "bbox": [
                0.107,
                0.737,
                0.245,
                0.754
            ],
            "angle": 0,
            "content": "11.2.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.757,
                0.951,
                0.831
            ],
            "angle": 0,
            "content": "下面将要运用树来讨论三个问题。第一个问题是：应当如何对列表里的元素进行排序，以便可以容易地找到元素的位置？第二个问题是：为了在某种类型的一组对象里找出带有某种性质的对象，应当做出一系列什么样的决策？第三个问题是：应当如何用比特串来有效地编码一组字符？"
        },
        {
            "type": "title",
            "bbox": [
                0.107,
                0.842,
                0.313,
                0.859
            ],
            "angle": 0,
            "content": "11.2.2 二叉搜索树"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.865,
                0.094,
                0.877
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.862,
                0.951,
                0.936
            ],
            "angle": 0,
            "content": "在列表里搜索一些元素，是计算机科学的一项重要任务。主要目标是实现一个搜索算法，当元素都完全排序时，这个算法能有效地找出元素。这个任务可以通过使用二叉搜索树来完成，二叉搜索树是一种二叉树，其中任何顶点的每个孩子都指定为右子或左子，没有顶点有超过一个的右子或左子，而且每个顶点都用一个关键字来标记，这个关键字是各元素中的一个。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.763,
                0.034,
                0.87,
                0.048
            ],
            "angle": 0,
            "content": "树 669"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.089,
                0.9,
                0.126
            ],
            "angle": 0,
            "content": "另外，这样指定顶点的关键字，使得顶点的关键字不仅大于它的左子树里的所有顶点的关键字，而且小于它的右子树里的所有顶点的关键字。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.128,
                0.902,
                0.279
            ],
            "angle": 0,
            "content": "这个递归过程用来形成元素列表的二叉搜索树。从只包含一个顶点（即根）的树开始。指定列表中第一个元素作为这个根的关键字。为了添加新的元素，首先比较它与已经在树中的顶点的关键字，从根开始，若这个元素小于所比较顶点的关键字而且这个顶点有左子，则向左移动，若这个元素大于所比较顶点的关键字而且这个顶点有右子，则向右移动。当这个元素小于所比较顶点的关键字而且这个顶点没有左子时，就插入以这个元素作为关键字的一个新顶点，并把新顶点作为这个顶点的左子。同理，当这个元素大于所比较顶点的关键字而且这个顶点没有右子时，就插入以这个元素作为关键字的一个新顶点，并把新顶点作为这个顶点的右子。用例1来说明这个过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.283,
                0.9,
                0.322
            ],
            "angle": 0,
            "content": "例1 构造下面这些单词的二叉搜索树（用字母顺序）：mathematics、physics、geography、zoology、meteorology、geology、psychology和chemistry。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.324,
                0.902,
                0.475
            ],
            "angle": 0,
            "content": "解图1显示了构造这个二叉搜索树所用的步骤。单词mathematics是根的关键字。因为physics是在mathematics之后（按照字母顺序），所以给根添加带关键字physics的右子。因为geography是在mathematics之前，所以给根添加带关键字geography的左子。下一步，给带关键字physics的顶点添加右子，并且给其指定关键字zoology，因为zoology是在mathematics之后且在physics之后。同理，给带关键字physics的顶点添加左子，并且给其指定关键字meteorology。给带关键字geography的顶点添加右子，并且给其指定关键字geology。给带关键字zoology的顶点添加左子，并且给其指定关键字psychology。给带关键字geography的顶点添加左子，并且给其指定关键字chemistry（读者应当完成在每步上所需的所有比较）。"
        },
        {
            "type": "image",
            "bbox": [
                0.054,
                0.482,
                0.902,
                0.775
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.386,
                0.785,
                0.571,
                0.801
            ],
            "angle": 0,
            "content": "图1构造二叉搜索树"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.81,
                0.905,
                0.925
            ],
            "angle": 0,
            "content": "一旦建立了二叉搜索树，就需要一种在二叉搜索树中查找元素的方法，以及添加新元素的方法。算法1是插入算法，尽管看上去它只是在二叉搜索树上添加新顶点，但实际上它可以完成上面提到的两个任务。也就是说，如果元素 \\(x\\) 存在，算法1可以在二叉搜索树中查找该元素\\(x\\)；如果元素 \\(x\\) 不存在，也可以添加该元素 \\(x\\)。在下面的伪代码中，\\(v\\) 是当前正在查看的顶点，\\(\\operatorname{label}(v)\\) 是该顶点的关键字。算法从根开始查看。如果 \\(v\\) 的关键字等于 \\(x\\)，那么算法就找到了 \\(x\\) 的位置并结束；如果 \\(x\\) 比 \\(v\\) 的关键字小，就向 \\(v\\) 的左子顶点移动并重复这个过程；如果 \\(x\\) 比 \\(v\\)"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.125,
                0.036,
                0.161,
                0.049
            ],
            "angle": 0,
            "content": "670"
        },
        {
            "type": "header",
            "bbox": [
                0.206,
                0.035,
                0.282,
                0.05
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.091,
                0.941,
                0.146
            ],
            "angle": 0,
            "content": "的关键字大，就向 \\(v\\) 的右子顶点移动并重复这个过程。如果在任何一步，要移动到的子顶点并不存在，那么就知道在这棵二叉搜索树中没有 \\(x\\) ，然后就添加一个以 \\(x\\) 为关键字的顶点作为这个子顶点。"
        },
        {
            "type": "code",
            "bbox": [
                0.107,
                0.165,
                0.596,
                0.413
            ],
            "angle": 0,
            "content": "算法1在二叉搜索树中查找或添加一个元素  \nprocedure insertion(T：二叉搜索树， \\(x\\) ：元素）  \n\\(v:=T\\) 的根  \n{一个不在 \\(T\\) 中具有值null的顶点}  \nwhile \\(v\\neq\\) null并且 \\(\\mathrm{label}(v)\\neq x\\) if \\(x <   \\mathrm{label}(v)\\) then if \\(v\\) 的左子 \\(\\neq\\) nullthen \\(v:=v\\) 的左子else添加新顶点作为 \\(v\\) 的左子并且设置 \\(v:=\\) nullelseif \\(v\\) 的右子 \\(\\neq\\) nullthen \\(v:=v\\) 的右子else给 \\(T\\) 添加新顶点作为 \\(v\\) 的右子并且设置 \\(v:=\\) nullif \\(T\\) 的根 \\(\\equiv\\) nullthen给树添加顶点 \\(v\\) 并且用 \\(x\\) 标记它  \nelseif \\(v\\) 为null或 \\(\\mathrm{label}(v)\\neq x\\) then用 \\(x\\) 标记新顶点 \\(v\\)   \nreturn \\(v\\{v = x\\) 的位置}"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.432,
                0.682,
                0.447
            ],
            "angle": 0,
            "content": "例2 说明了如何使用算法1在二叉搜索树中插入一个新元素。"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.454,
                0.737,
                0.47
            ],
            "angle": 0,
            "content": "例2运用算法1在例1的二叉搜索树中插入oceanography这个词。"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.477,
                0.94,
                0.492
            ],
            "angle": 0,
            "content": "解算法1从 \\(v\\) 开始， \\(v\\) 等于 \\(T\\) 的根顶点，是当前查看的顶点。因此 \\(\\mathrm{label}(v) = \\mathrm{mathematics}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.496,
                0.941,
                0.627
            ],
            "angle": 0,
            "content": "因为 \\(v \\neq\\) null，且 \\(\\text{label}(v) = \\text{mathematics} < \\text{oceanography}\\)，所以接下来就查看根的右子顶点。右子存在，因此置当前查看的顶点 \\(v\\) 等于这个右子。这一步，有 \\(v \\neq\\) null，且 \\(\\text{label}(v) = \\text{physics} > \\text{oceanography}\\)，所以要查看 \\(v\\) 的左子。左子存在，因此置当前查看的顶点 \\(v\\) 等于这个左子。在这一步，有 \\(v \\neq\\) null，且 \\(\\text{label}(v) = \\text{metereology} < \\text{oceanography}\\)，所以试图查看 \\(v\\) 的右子。但是，这个右子并不存在，所以添加一个新的顶点作为 \\(v\\) 的右子（此时就是关键字为 oceanography 的顶点），然后置 \\(v := \\text{null}\\)。因为 \\(v = \\text{null}\\)，所以现在跳出了 while 循环。因为 \\(T\\) 的根不是 null 而 \\(v = \\text{null}\\)，所以使用算法结束处的 else if 语句让新顶点以 oceanography 为关键字。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.631,
                0.94,
                0.703
            ],
            "angle": 0,
            "content": "现在我们来确定这个过程的计算复杂度。假定有 \\(n\\) 个元素的列表的二叉搜索树 \\(T\\) 。可以从 \\(T\\) 这样构造一个满二叉树 \\(U\\) ：在必要时添加无标记的顶点，使得每个带关键字的顶点都有两个孩子。这个做法在图2里说明。一旦这样做了，就容易找出新元素的位置，或者添加新元素作为关键字而不添加顶点。"
        },
        {
            "type": "image",
            "bbox": [
                0.179,
                0.705,
                0.857,
                0.907
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.326,
                0.916,
                0.714,
                0.931
            ],
            "angle": 0,
            "content": "图2 添加无标记顶点以得到一个满二叉搜索树"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.762,
                0.038,
                0.868,
                0.053
            ],
            "angle": 0,
            "content": "树 671"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.094,
                0.901,
                0.264
            ],
            "angle": 0,
            "content": "添加一个新元素所需要的最多比较次数，等于在 \\(U\\) 中从根到树叶的最长通路的长度。\\(U\\) 的内点都是 \\(T\\) 的顶点。所以 \\(U\\) 有 \\(n\\) 个内点。现在可以利用11.1节定理4的部分ii)来得出 \\(U\\) 有 \\(n + 1\\) 个树叶。利用11.1节的推论1，可以看出 \\(U\\) 的高度大于或等于 \\(h = \\lceil \\log (n + 1)\\rceil\\) 。所以，为了添加某个元素，必须至少执行 \\(\\lceil \\log (n + 1)\\rceil\\) 次比较。注意若 \\(U\\) 是平衡的，则它的高度是\\(\\lceil \\log (n + 1)\\rceil\\) （根据11.1节的推论1）。因此，若二叉搜索树是平衡的，则确定一个元素的位置或者添加一个元素所需要的比较次数不超过 \\(\\lceil \\log (n + 1)\\rceil\\) 次。当给二叉搜索树添加一些元素时，该树可能变得不平衡。因为平衡的二叉搜索树给出二叉搜索的最优的最坏情形复杂度，所以添加元素时重新平衡二叉搜索树的算法已经设计出来。感兴趣的读者可以查阅关于数据结构的参考文献来了解这些算法。"
        },
        {
            "type": "title",
            "bbox": [
                0.055,
                0.274,
                0.212,
                0.291
            ],
            "angle": 0,
            "content": "11.2.3 决策树"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.294,
                0.901,
                0.387
            ],
            "angle": 0,
            "content": "有根树可以用来为一系列决策求解问题建立模型。例如，二叉搜索树可以用来基于一系列比较来找出元素的位置，其中每次比较都说明是否已经找到了元素的位置，或者是否应当向右或向左进入子树。其中每个内点都对应着一次决策，这些顶点的子树都对应着该决策的每种可能结果，这样的有根树称为决策树。问题的可能解对应着这个有根树中通向树叶的通路。例3 说明了决策树的一个应用。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.392,
                0.9,
                0.431
            ],
            "angle": 0,
            "content": "例3 假定有重量相同的7枚硬币和重量较轻的一枚伪币。为了用一架天平确定这8枚硬币中哪个是伪币，需要多少次称重？给出找出这个伪币的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.433,
                0.901,
                0.526
            ],
            "angle": 0,
            "content": "解 在天平上每次称重结果有三种可能性。分别是：两个托盘有相同的重量，第一个托盘较重，或第二个托盘较重。所以，称重序列的决策树是3元树。在决策树中至少有8个树叶，因为有8种可能的结果（因为每枚硬币都可能是较轻的伪币），而且每种可能的结果必须至少用一个树叶来表示。确定伪币所需要的最大称重次数是决策树的高度。从11.1节的推论1得出决策树的高度至少是 \\(\\lceil \\log_38\\rceil = 2\\) 。因此，至少需要两次称重。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.529,
                0.743,
                0.546
            ],
            "angle": 0,
            "content": "用两次称重来确定伪币是可行的。说明如何这样做的决策树如图3所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.548,
                0.901,
                0.602
            ],
            "angle": 0,
            "content": "基于比较的排序算法的复杂度已经开发了许多不同的排序算法。为了确定一个具体的排序算法是否有效，就要确定这个算法的复杂度。用决策树作为模型，可以求出基于二元比较的排序算法的最坏情形复杂度的下界。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.605,
                0.901,
                0.699
            ],
            "angle": 0,
            "content": "可以用决策树为排序算法建立模型并且确定对这些算法的最坏情形复杂度的估计。注意给定 \\( n \\) 个元素，这些元素有 \\( n! \\) 种可能的排序，因为这些元素的 \\( n! \\) 种排列中的每一个都可以是正确的顺序。本书研究的排序算法以及最常用的排序算法都基于二元比较，即一次比较两个元素。每次这样的比较都缩小了可能的顺序集合。而且，基于二元比较的排序算法可以表示成二叉决策树，其中每个内点表示两个元素的一次比较。每个树叶表示 \\( n \\) 个元素的 \\( n! \\) 种排列中的一种。"
        },
        {
            "type": "image",
            "bbox": [
                0.053,
                0.703,
                0.902,
                0.884
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.218,
                0.888,
                0.737,
                0.904
            ],
            "angle": 0,
            "content": "图3找出伪币位置的决策树。每种最终结果的下面一行是伪币"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.918,
                0.607,
                0.936
            ],
            "angle": 0,
            "content": "例4图4显示了给列表 \\(a\\) 、 \\(b\\) 、 \\(c\\) 里的元素排序的决策树。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.132,
                0.04,
                0.169,
                0.054
            ],
            "angle": 0,
            "content": "672"
        },
        {
            "type": "header",
            "bbox": [
                0.213,
                0.039,
                0.29,
                0.054
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "image",
            "bbox": [
                0.29,
                0.098,
                0.77,
                0.323
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.36,
                0.331,
                0.696,
                0.346
            ],
            "angle": 0,
            "content": "图4对3个不同元素进行排序的决策树"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.357,
                0.951,
                0.449
            ],
            "angle": 0,
            "content": "基于二元比较的排序的复杂度是用二元比较的次数来度量的。排序有 \\(n\\) 个元素的列表所需要的最多比较次数就给出了这个算法的最坏情形复杂度。所用的最多比较次数等于表示这个排序过程的决策树里的最长通路长度。换句话说，所需要的最多比较次数等于这个决策树的高度。因为带 \\(n!\\) 个树叶的二叉树的高度至少是 \\(\\lceil \\log n! \\rceil\\) （利用11.1节推论1），所以如定理1所说，至少需要 \\(\\lceil \\log n! \\rceil\\) 次比较。"
        },
        {
            "type": "text",
            "bbox": [
                0.154,
                0.458,
                0.71,
                0.476
            ],
            "angle": 0,
            "content": "定理1 基于二元比较的排序算法至少需要 \\(\\lceil \\log n!\\rceil\\) 次比较。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.485,
                0.95,
                0.54
            ],
            "angle": 0,
            "content": "可以用定理1给出基于二元比较的排序算法所用比较次数的大 \\(O\\) 估计。只需要根据3.2节练习72注意到 \\(\\lceil \\log n! \\rceil\\) 是 \\(\\Theta(n \\log n)\\)，这是算法的计算复杂度经常使用的一个参照函数。推论1是这个估计的结果。"
        },
        {
            "type": "text",
            "bbox": [
                0.154,
                0.548,
                0.878,
                0.566
            ],
            "angle": 0,
            "content": "引理1 基于二元比较的排序算法排序 \\(n\\) 个元素所用的比较次数是 \\(\\Omega (n\\log n)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.574,
                0.951,
                0.629
            ],
            "angle": 0,
            "content": "推论1的一个结论是，基于二元比较的排序算法在最坏情形下使用 \\(\\Theta (n\\log n)\\) 次比较来排序 \\(n\\) 个元素，其他这类算法都没有更好的最坏情形复杂度，在这个意义下，基于二元比较的排序算法是最优的。注意根据5.4节定理1可以看出，在这个意义下归并排序算法是最优的。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.631,
                0.95,
                0.706
            ],
            "angle": 0,
            "content": "对于排序算法的平均情形复杂度也可以证明类似的结果。基于二元比较的排序算法所用的平均比较次数是表示这个排序算法的决策树中的平均树叶深度。根据11.1节练习48知道，有 \\(N\\) 个顶点的二叉树的平均树叶深度是 \\(\\Omega (\\log N)\\) 。当令 \\(N = n!\\) 并且注意因为 \\(\\log n!\\) 是\\(\\Theta (n\\log n)\\) ，所以是 \\(\\Omega (\\log n!)\\) 的函数也是 \\(\\Omega (n\\log n)\\) 时，就会得出下面的估计。"
        },
        {
            "type": "text",
            "bbox": [
                0.154,
                0.714,
                0.922,
                0.732
            ],
            "angle": 0,
            "content": "定理2 基于二元比较的排序算法排序 \\(n\\) 个元素所用的平均比较次数是 \\(\\Omega (n\\log n)\\) 。"
        },
        {
            "type": "title",
            "bbox": [
                0.107,
                0.749,
                0.269,
                0.765
            ],
            "angle": 0,
            "content": "11.2.4 前缀码"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.768,
                0.953,
                0.862
            ],
            "angle": 0,
            "content": "考虑这样的问题：用比特串来编码英语字母表里的字母（其中不区分小写和大写字母）。可以用长度为5的比特串来表示每个字母，因为只有26个字母而且有32个长度为5的比特串。当每个字母都用5位来编码时，用来编码数据的总位数是5乘以文本中的字符数。有没有可能找出这些字母的编码方案，使得在编码数据时使用的位数更少？若可能，那么就可以节省存储空间而且缩短传输时间。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.864,
                0.953,
                0.937
            ],
            "angle": 0,
            "content": "考虑用不同长度的比特串来编码字母。较短的比特串用来编码出现较频繁的字母，较长的比特串用来编码不经常出现的字母。当用可变长的位数来给字母编码时，就必须用某种方法来确定每个字母的在何处开始和结束。例如，若把e编码成0，把a编码成1，而把t编码成01，则比特串0101可能对应着eat、tea、eaea或tt。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.771,
                0.04,
                0.794,
                0.054
            ],
            "angle": 0,
            "content": "树"
        },
        {
            "type": "page_number",
            "bbox": [
                0.842,
                0.041,
                0.876,
                0.053
            ],
            "angle": 0,
            "content": "673"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.095,
                0.908,
                0.15
            ],
            "angle": 0,
            "content": "为了保证没有比特串对应着多个字母的序列，可以令一个字母的比特串永远不出现在另一个字母的比特串的开头部分。具有这个性质的编码称为前缀码。例如，把e编码成0、把a编码成10、而把t编码成11的编码就是前缀码。从编码一个单词的字母的唯一比特串可以恢复"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.152,
                0.695,
                0.226
            ],
            "angle": 0,
            "content": "这个单词。例如，串10110是ate的编码。为了看明白这一点，注意开始的1不表示一个字符，但是10表示a（并且它不可能是另一个字母的比特串的开始部分）。然后，下一个1不表示一个字符，但是11表示t。最后一位0表示e。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.228,
                0.695,
                0.322
            ],
            "angle": 0,
            "content": "前缀码可以用二叉树来表示，其中字符是树中树叶的标记。树的边也被标记，使得通向左子的边标记为0而通向右子的边标记为1。用来编码一个字符的比特串是在从根到以这个字符作为标记的树叶的唯一通路上标记的序列。例如，图5中的树表示把e编码成0，把a编码成10，把t编码成110，把n编码成1110和把s编码成1111。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.324,
                0.695,
                0.379
            ],
            "angle": 0,
            "content": "表示编码的树可以用来解码比特串。例如，考虑一个用图5中的编码编成11111011100的单词。这个比特串可以这样解码：从根开始，用比特序列来形成一条到树叶为止的通路。每个0都使得通路向下到"
        },
        {
            "type": "image",
            "bbox": [
                0.711,
                0.156,
                0.887,
                0.336
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.726,
                0.342,
                0.874,
                0.373
            ],
            "angle": 0,
            "content": "图5 表示前缀码的二叉树"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.383,
                0.906,
                0.477
            ],
            "angle": 0,
            "content": "达通向通路中最后一个顶点的左子的边，而每个1都对应到最后一个顶点的右子。所以，开头的1111对应这样的通路：从根开始，向右前进四次，到达以s作为标记的树叶，因为1111是s的编码。从第五位继续进行，在向右再向左之后，就到达下一个树叶，这时访问到以a作为标记的顶点，它的编码是10。从第七位开始，在向右三次然后向左之后，访问到了标记为n，编码为1110的顶点。最后，末位0指向用e标记的树叶。因此，原来的单词是sane。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.479,
                0.906,
                0.516
            ],
            "angle": 0,
            "content": "可以从任何二叉树来构造一个前缀码，其中每个内点的左边都用0标记，而右边都用1标记，树叶都用字符标记。字符都用从根到这个树叶的唯一通路中的边的标记所组成的比特串来编码。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.518,
                0.908,
                0.652
            ],
            "angle": 0,
            "content": "哈夫曼编码 现在介绍一种算法，这种算法用一个字符串中符号的出现频率（即出现概率）作为输入，并产生编码这个字符串的一个前缀码作为输出，在这些符号的所有可能的二叉前缀码中，这个编码使用最少的位。这个所谓哈夫曼编码的算法是大卫·哈夫曼于1951年做麻省理工学院的研究生时发表在一篇学期论文中的。（注意，这个算法假定已知字符串中每个符号出现多少次，所以可以计算每个符号的出现频率，方法是用这个符号出现的次数除以这个字符串的长度。)哈夫曼编码是数据压缩中的基本算法，数据压缩的目的在于减少表示信息所需要的位数。哈夫曼编码广泛用于压缩表示文本的比特串，并且在压缩视频和图像文件方面也起到重要作用。"
        },
        {
            "type": "title",
            "bbox": [
                0.059,
                0.661,
                0.127,
                0.678
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.062,
                0.694,
                0.201,
                0.804
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.06,
                0.808,
                0.203,
                0.829
            ],
            "angle": 0,
            "content": "Courtesy of California State University"
        },
        {
            "type": "text",
            "bbox": [
                0.218,
                0.693,
                0.908,
                0.833
            ],
            "angle": 0,
            "content": "大卫·哈夫曼（David A. Huffman，1925—1999）哈夫曼在俄亥俄州长大。他18岁时毕业于俄亥俄州立大学并获得电机工程学士学位。此后，他在美国海军服役，在一艘驱逐舰上担任雷达维护官，该驱逐舰在第二次世界大战后主要负责在亚洲水域执行扫雷任务。后来，他从俄亥俄州立大学获得硕士学位并从麻省理工学院获得电机工程的博士学位。1953年，哈夫曼成为麻省理工学院的一名教员，并在那任教多年，直到1967年他创建了加州大学桑塔·克鲁茨分校计算机科学系才离开。他在该系的发展中起到了举足轻重的作用，并在那里度过了最后的职业生涯，直到1994年才退休。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.835,
                0.908,
                0.904
            ],
            "angle": 0,
            "content": "哈夫曼在信息论与编码、雷达与通信的信号设计、异步逻辑电路的设计过程等方面的卓越贡献而为世人所知。哈夫曼在零曲率表面上的工作使得他开发出把纸和乙烯基塑料折叠成非同寻常的形状的独创技术。这些形状被许多人当作艺术品并且在多个展览中公开展出。但是，让哈夫曼一举成名的，还是他在麻省理工学院读研期间所写的一篇学期论文中开发出的哈夫曼编码。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.906,
                0.907,
                0.939
            ],
            "angle": 0,
            "content": "哈夫曼喜爱户外探险，经常远足和旅游。当他年近60岁高龄时，他还获得了水肺潜水员的资格。他饲养毒蛇作为宠物。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.143,
                0.036,
                0.181,
                0.051
            ],
            "angle": 0,
            "content": "674"
        },
        {
            "type": "header",
            "bbox": [
                0.225,
                0.035,
                0.304,
                0.051
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.095,
                0.102,
                0.108
            ],
            "angle": 0,
            "content": "Demo"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.092,
                0.965,
                0.224
            ],
            "angle": 0,
            "content": "算法2给出了哈夫曼编码算法。给定符号及其频率，目标是构造一个有根的二叉树，其中符号是树叶的标记。算法从只含有一个顶点的一些树构成的森林开始，其中每个顶点有一个符号作为标记，并且这个顶点的权就等于所标记符号的频率。在每一步，都把具有最小总权值的两个树组合成一个单独的树，方法是引入一个新的根，把具有较大的权的树作为左子树，把具有较小的权的树作为右子树。另外，把这个树的两个子树的权之和作为这个树的总权值。（虽然可以规定在具有相同的权的树之间进行选择以打破平局的过程，但是这里将不具体指定这样的过程。）当构造出了一个树，即森林缩小为单个树时，算法就停止。"
        },
        {
            "type": "title",
            "bbox": [
                0.13,
                0.244,
                0.298,
                0.259
            ],
            "angle": 0,
            "content": "算法2 哈夫曼编码"
        },
        {
            "type": "text",
            "bbox": [
                0.13,
                0.262,
                0.654,
                0.277
            ],
            "angle": 0,
            "content": "procedureHuffman(C：具有频率 \\(\\omega_{i}\\) 的符号 \\(a_{i}\\) ， \\(i = 1\\) ，2，…，n）"
        },
        {
            "type": "text",
            "bbox": [
                0.13,
                0.28,
                0.684,
                0.295
            ],
            "angle": 0,
            "content": "\\(F:=n\\) 个有根树的森林，每个有根树由单个顶点 \\(a_{i}\\) 组成并且赋权 \\(\\boldsymbol{w}_{i}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.299,
                0.253,
                0.313
            ],
            "angle": 0,
            "content": "while \\(F\\) 不是树"
        },
        {
            "type": "text",
            "bbox": [
                0.157,
                0.316,
                0.803,
                0.331
            ],
            "angle": 0,
            "content": "把 \\(F\\) 中满足 \\(\\varpi (T)\\geqslant \\varpi (T^{\\prime})\\) 的权最小的有根树 \\(T\\) 和 \\(T^{\\prime}\\) 换成具有新树根的一个树，"
        },
        {
            "type": "text",
            "bbox": [
                0.158,
                0.334,
                0.552,
                0.348
            ],
            "angle": 0,
            "content": "这个树根以 \\(T\\) 作为左子树并且以 \\(T^{\\prime}\\) 作为右子树。"
        },
        {
            "type": "text",
            "bbox": [
                0.157,
                0.351,
                0.642,
                0.366
            ],
            "angle": 0,
            "content": "用0标记树根到 \\(T\\) 的新边，并且用1标记树根到 \\(T^{\\prime}\\) 的新边。"
        },
        {
            "type": "text",
            "bbox": [
                0.158,
                0.369,
                0.421,
                0.383
            ],
            "angle": 0,
            "content": "把 \\(w(T) + w(T^{\\prime})\\) 作为新树的权。"
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.386,
                0.701,
                0.402
            ],
            "angle": 0,
            "content": "{符号 \\(a_{i}\\) 的哈夫曼编码是从树根到 \\(a_{i}\\) 的唯一通路上的边的标记的连接}"
        },
        {
            "type": "text",
            "bbox": [
                0.04,
                0.421,
                0.102,
                0.439
            ],
            "angle": 0,
            "content": "Extra Examples"
        },
        {
            "type": "text",
            "bbox": [
                0.156,
                0.422,
                0.581,
                0.438
            ],
            "angle": 0,
            "content": "例5说明如何用算法2来对6个符号进行编码。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.444,
                0.958,
                0.482
            ],
            "angle": 0,
            "content": "例5 用哈夫曼编码来编码下列符号，这些符号具有下列频率：A:0.08，B:0.10，C:0.12，D:0.15，E:0.20，F:0.35。编码一个字符串所需要的平均位数是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.486,
                0.963,
                0.521
            ],
            "angle": 0,
            "content": "解图6表示了编码这些符号所用的步骤。所产生的编码为：A是111，B是110，C是011，D是010，E是10，F是00。使用这种编码来编码一个符号所用的平均位数是"
        },
        {
            "type": "equation",
            "bbox": [
                0.24,
                0.524,
                0.84,
                0.539
            ],
            "angle": 0,
            "content": "\\[\n3 \\cdot 0. 0 8 + 3 \\cdot 0. 1 0 + 3 \\cdot 0. 1 2 + 3 \\cdot 0. 1 5 + 2 \\cdot 0. 2 0 + 2 \\cdot 0. 3 5 = 2. 4 5\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.543,
                0.964,
                0.597
            ],
            "angle": 0,
            "content": "注意哈夫曼编码是贪心算法。在每一步替换具有最小权值的两棵树，在没有任何二叉前缀码能使用更少的比特来编码这些符号的情况下，这样做就导出了最优编码。在本节末把哈夫曼编码是最优的证明留作练习32。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.601,
                0.964,
                0.695
            ],
            "angle": 0,
            "content": "哈夫曼编码有许多变种。例如，不编码单个符号，可以编码指定长度的符号块，比如两个符号的块。这样做有可能减少编码这个字符串所需要的位数（参看本节练习30）。也可以用两个以上的符号来编码这个符号串中的原始符号（参看本节练习28的前导文）。另外，当事先不知道一个字符串中每个符号的频率时，可以使用一种变种，即所谓的自适应哈夫曼编码（参见[Sa00]），使得在读这个字符串的同时来进行编码。"
        },
        {
            "type": "title",
            "bbox": [
                0.119,
                0.706,
                0.28,
                0.722
            ],
            "angle": 0,
            "content": "11.2.5 博弈树"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.726,
                0.965,
                0.896
            ],
            "angle": 0,
            "content": "可以用树来分析某些类型的游戏，比如井字游戏、取石子游戏、跳棋和象棋。在每一种游戏中，两个选手轮流进行移动。每个选手知道另一个选手的移动并且游戏不存在偶然因素。使用博弈树为这样的游戏建立模型，这些树的顶点表示当游戏进行时游戏所处的局面，边表示在这些局面之间合乎规则的移动。由于博弈树常常很大，所以通过用同一个顶点表示所有对称的局面来简化博弈树。但是，如果一个游戏的不同移动序列导致同一个局面，则可以用不同的顶点来表示这个局面。根表示起始的局面。通常的约定是用方框表示偶数层的顶点并且用圆圈表示奇数层的顶点。当游戏处在偶数层顶点所表示的局面时，就轮到第一个选手移动。当游戏处在奇数层顶点所表示的局面时，就轮到第二个选手移动。博弈树所表示的游戏可以永远不结束，比如进入了无穷循环，因此博弈树可以是无穷的，但是对于大多数游戏来说，都存在一些规则导致有穷的博弈树。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.899,
                0.964,
                0.935
            ],
            "angle": 0,
            "content": "博弈树的树叶表示游戏的终局。给每个树叶指定一个值，表示游戏在这个树叶所代表的局面终止时第一个选手的得分。对于非胜即负的游戏，用1来标记圆圈所表示的终结顶点以表示"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.76,
                0.04,
                0.866,
                0.054
            ],
            "angle": 0,
            "content": "树 675"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.096,
                0.893,
                0.15
            ],
            "angle": 0,
            "content": "第一个选手获胜，用-1来标记方框所表示的终结顶点以表示第二个选手获胜。对于允许平局的游戏，用0来标记平局所对应的终结顶点。注意，对于非胜即负的游戏，为终结顶点指定值，这个值越高，第一个选手的结局就越好。"
        },
        {
            "type": "image",
            "bbox": [
                0.099,
                0.154,
                0.847,
                0.702
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.341,
                0.705,
                0.604,
                0.72
            ],
            "angle": 0,
            "content": "图6例5中符号的哈夫曼编码"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.726,
                0.637,
                0.742
            ],
            "angle": 0,
            "content": "例6展示了一个非常著名的和经过深入研究的游戏的博弈树。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.748,
                0.902,
                0.941
            ],
            "angle": 0,
            "content": "例6 取石子游戏 取石子游戏是这样的，在游戏的开始，有几堆石子。两个选手轮流移动石子，合法的移动包括从其中一堆取走一块或多块石子，而不去移动其余的所有石子。不能进行合法移动的选手告负。（也可以规定取走最后一块石子的选手告负，因为不允许没有石子堆的局面。）图7所示的博弈树表示了这种形式的给定开局的取石子游戏，其中有3堆石子，分别包含2块、2块和1块石子。用不同堆中石子数的无序表来表示每个局面（堆的顺序无关紧要）。第一个选手的初始移动可以导致3种可能的局面，因为这个选手可以从有2块石子的堆中取走1块石子（留下包含1块、1块和2块石子的3堆），可以从包含2块石子的堆中取走2块石子（留下包含2块和1块石子的2堆），或者从包含1块石子的堆中取走1块石子（留下包含2块石子的2堆）。当只剩下包含1块石子的1堆时，就不可能进行合法移动了，所以这样的局面就是终局。由于取石子游戏是非胜即负的游戏，所以用 \\(+1\\) 标记表示第一个选手获胜的终结"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.134,
                0.041,
                0.171,
                0.055
            ],
            "angle": 0,
            "content": "676"
        },
        {
            "type": "header",
            "bbox": [
                0.215,
                0.04,
                0.291,
                0.055
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.096,
                0.566,
                0.113
            ],
            "angle": 0,
            "content": "顶点，用一1标记表示第二个选手获胜的终结顶点。"
        },
        {
            "type": "image",
            "bbox": [
                0.159,
                0.12,
                0.904,
                0.429
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.418,
                0.434,
                0.643,
                0.448
            ],
            "angle": 0,
            "content": "图7 取石子游戏的博弈树"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.462,
                0.955,
                0.54
            ],
            "angle": 0,
            "content": "例7 井字游戏 井字游戏的博弈树非常大，这里不能画出，尽管计算机能轻而易举地构造出这样的树。图8a显示了井字游戏的博弈树的一部分。注意，由于对称的局面是等价的，所以只需要考虑图8a所示的3种可能的初始移动。在图8b中，还显示了这个博弈树的一个导致终局的子树，其中一个能够获胜的选手进行了制胜的移动。"
        },
        {
            "type": "image",
            "bbox": [
                0.105,
                0.544,
                0.957,
                0.89
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.41,
                0.894,
                0.655,
                0.909
            ],
            "angle": 0,
            "content": "图8 井字游戏的部分博弈树"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.919,
                0.955,
                0.937
            ],
            "angle": 0,
            "content": "可以用某种方式递归地定义博弈树中所有顶点的值，使得可以确定当两个选手都遵循最优"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.762,
                0.043,
                0.868,
                0.057
            ],
            "angle": 0,
            "content": "树 677"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.097,
                0.898,
                0.153
            ],
            "angle": 0,
            "content": "策略时这个游戏的结果。所谓策略，就意味着一组规则，这些规则说明一个选手如何移动来赢得游戏。第一个选手的最优策略就是把这个选手的得分最大化的策略，第二个选手的最优策略就是把这个得分最小化的策略。现在递归地定义顶点的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.162,
                0.477,
                0.178
            ],
            "angle": 0,
            "content": "定义1 博弈树中顶点的值递归地定义为："
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.182,
                0.806,
                0.198
            ],
            "angle": 0,
            "content": "i)一个树叶的值是当游戏在这个树叶所表示的局面里终止时第一个选手的得分。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.201,
                0.886,
                0.235
            ],
            "angle": 0,
            "content": "ii) 偶数层内点的值是这个内点的孩子的最大值，奇数层内点的值是这个内点的孩子的最小值。"
        },
        {
            "type": "list",
            "bbox": [
                0.064,
                0.182,
                0.886,
                0.235
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.244,
                0.898,
                0.3
            ],
            "angle": 0,
            "content": "使第一个选手移动到具有最大值的孩子所表示的局面并且第二个选手移动到具有最小值的孩子所表示的局面的策略称为最小最大策略。当两个选手都遵循最小最大策略时，通过计算树根的值就可以确定谁将赢得游戏，这个值称为树的值。这是定理3的结论。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.307,
                0.89,
                0.345
            ],
            "angle": 0,
            "content": "定理3 博弈树顶点的值说明，如果两个选手都遵循最小最大策略并且从博弈树的某一个顶点所表示的局面开始进行游戏，则这个顶点的值表明第一个选手的得分。"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.353,
                0.412,
                0.37
            ],
            "angle": 0,
            "content": "证明 将用归纳法来证明这个定理。"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.372,
                0.864,
                0.389
            ],
            "angle": 0,
            "content": "基础步骤：如果这个顶点是树叶，则通过定义指定给这个顶点的值就是第一个选手的得分。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.391,
                0.898,
                0.426
            ],
            "angle": 0,
            "content": "归纳步骤：归纳假设一个顶点的孩子的值就是第一个选手的得分，假定从这些顶点所表示的每一个局面中开始进行游戏。需要考虑两种情形，即当轮到第一个选手时和当轮到第二个选手时。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.428,
                0.899,
                0.502
            ],
            "angle": 0,
            "content": "当轮到第一个选手时，这个选手遵循最小最大策略并且移动到具有最大值的孩子所表示的局面。根据归纳假设，当从这个孩子所表示的局面开始游戏并且遵循最小最大策略时，这个值就是第一个选手的得分。根据偶数层内点的值的定义的递归步骤（作为其孩子的最大值），当从这个顶点所表示的局面开始游戏时，这个顶点的值就是这个得分。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.504,
                0.899,
                0.578
            ],
            "angle": 0,
            "content": "当轮到第二个选手时，这个选手遵循最小最大策略并且移动到具有最小值的孩子所表示的局面。根据归纳假设，当从这个孩子所表示的局面开始游戏并且遵循最小最大策略时，这个值就是第一个选手的得分。根据把奇数层内点的值作为其孩子的最小值的递归定义，当从这个顶点所表示的局面开始游戏时，这个顶点的值就是这个得分。"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.58,
                0.884,
                0.597
            ],
            "angle": 0,
            "content": "评注 通过扩展定理3的证明，可以证明对于两个选手来说最小最大策略都是最优策略。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.599,
                0.899,
                0.673
            ],
            "angle": 0,
            "content": "例8解释最小最大过程如何工作。它显示了为例6的博弈树中的内点所指定的值。注意可以缩短所需要的计算，注意对于非胜即负游戏来说，一旦找到方框顶点具有 \\(+1\\) 值的一个孩子，则方框顶点的值也是 \\(+1\\) ，因为 \\(+1\\) 是最大可能的得分。同样，一旦找到圆圈顶点具有 \\(-1\\) 值的一个孩子，则这个值也是这个圆圈顶点的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.677,
                0.899,
                0.773
            ],
            "angle": 0,
            "content": "例8 例6构造了具有包含2块、2块和1块的3堆石子的开局的取石子游戏的博弈树。图9说明了这个博弈树的顶点的值。这些顶点的值是这样计算的：使用树叶的值并且每次向上计算1层。这个图的右边空白处说明究竟使用孩子的最大值还是最小值来求出每层内点的值。例如，一旦求出了树根的3个孩子的值，1、-1和-1，则这样求出树根的值：计算 \\(\\max (1, -1, -1) = 1\\) 。由于根的值是1，所以得出当两个选手都遵循最小最大策略时第一个选手获胜。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.774,
                0.9,
                0.943
            ],
            "angle": 0,
            "content": "有些著名游戏的博弈树可能非同寻常地大，因为这些游戏有多种移动选择。例如，据估计象棋的博弈树有多达 \\(10^{100}\\) 个顶点！由于博弈树规模的原因，也许不可能直接使用定理3来研究这样的游戏，所以设计了各种方法来帮助确定好的策略以及确定游戏的结果。一种被称为 \\(\\alpha-\\beta\\) 剪枝的有用技巧减少了许多计算，它剪掉不能影响祖先顶点的值的那部分博弈树（关于 \\(\\alpha-\\beta\\) 剪枝的信息，参考[Gr90]）。另一种有用的方法是使用求值函数，当精确地计算博弈树中内点值不可行时，它就估计这些值。例如，在井字游戏中，可以使用不含圈O(O用来表示第二个选手的移动)的直行(行、列、对角线)数减去不含叉X(X用来表示第一个选手的移动)的直行数来作为一个局面的求值函数。这个求值函数给出了关于哪个选手在游戏中占优的一些倾向。一旦插入求值函数的值，遵循最小最大策略使用规则就可以计算出游戏的值。计算机科学家已经设"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.136,
                0.043,
                0.172,
                0.057
            ],
            "angle": 0,
            "content": "678"
        },
        {
            "type": "header",
            "bbox": [
                0.216,
                0.042,
                0.292,
                0.057
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.098,
                0.953,
                0.134
            ],
            "angle": 0,
            "content": "计出一些基于复杂的求值函数的下棋程序，比如IBM的“深蓝”，在正常规则下，深蓝成为第一个战胜当时的世界冠军的计算机程序。关于计算机如何下棋的更多信息请参看[Le91]。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.137,
                0.953,
                0.173
            ],
            "angle": 0,
            "content": "我们所研究的资料来自组合博弈论，它用于这样的游戏：玩家知道所有之前的移动，并在其他玩家选择移动方法之前选择一个动作。有关组合博弈论的更多信息，请参看[Alnowo07]、"
        },
        {
            "type": "image",
            "bbox": [
                0.142,
                0.178,
                0.925,
                0.482
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.392,
                0.485,
                0.671,
                0.501
            ],
            "angle": 0,
            "content": "图9 说明取石子游戏中顶点的值"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.507,
                0.619,
                0.524
            ],
            "angle": 0,
            "content": "[Becogu82a，82b]或[Be04]以及关于此主题的Web链接。"
        },
        {
            "type": "title",
            "bbox": [
                0.109,
                0.534,
                0.154,
                0.55
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.554,
                0.928,
                0.568
            ],
            "angle": 0,
            "content": "1. 用字母顺序建立下面这些单词的二叉搜索树：banana、peach、apple、pear、coconut、mango 和 papaya。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.571,
                0.95,
                0.604
            ],
            "angle": 0,
            "content": "2. 用字母顺序建立下面这些单词的二叉搜索树：oenology、phrenology、campanology、ornithology、ichthyology、limnology、alchemy 和 astrology。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.607,
                0.95,
                0.638
            ],
            "angle": 0,
            "content": "3.为了在练习1的搜索树里找出下面每个单词的位置或者添加它们，而且每次都重新开始，分别需要多少次比较？"
        },
        {
            "type": "list",
            "bbox": [
                0.105,
                0.554,
                0.95,
                0.638
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.643,
                0.186,
                0.657
            ],
            "angle": 0,
            "content": "a)pear"
        },
        {
            "type": "text",
            "bbox": [
                0.329,
                0.644,
                0.404,
                0.656
            ],
            "angle": 0,
            "content": "b) banana"
        },
        {
            "type": "text",
            "bbox": [
                0.531,
                0.644,
                0.619,
                0.657
            ],
            "angle": 0,
            "content": "c)kumquat"
        },
        {
            "type": "text",
            "bbox": [
                0.726,
                0.644,
                0.799,
                0.657
            ],
            "angle": 0,
            "content": "d)orange"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.66,
                0.95,
                0.692
            ],
            "angle": 0,
            "content": "4.为了在练习2的搜索树里找出下面每个单词的位置或者添加它们，而且每次都重新开始，分别需要多少次比较？"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.696,
                0.225,
                0.71
            ],
            "angle": 0,
            "content": "a) palmistry"
        },
        {
            "type": "text",
            "bbox": [
                0.329,
                0.697,
                0.431,
                0.71
            ],
            "angle": 0,
            "content": "b) etymology"
        },
        {
            "type": "text",
            "bbox": [
                0.531,
                0.697,
                0.649,
                0.71
            ],
            "angle": 0,
            "content": "c) paleontology"
        },
        {
            "type": "text",
            "bbox": [
                0.726,
                0.697,
                0.824,
                0.71
            ],
            "angle": 0,
            "content": "d) glaciology"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.714,
                0.922,
                0.728
            ],
            "angle": 0,
            "content": "5. 用字母顺序构造下面句子里的单词的二叉搜索树：“The quick brown fox jumps over the lazy dog”。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.731,
                0.95,
                0.762
            ],
            "angle": 0,
            "content": "6. 为了在4枚硬币中找出一枚较轻的伪币，需要用天平称多少次？描述用这些次数的称重来找出较轻的伪币的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.766,
                0.95,
                0.798
            ],
            "angle": 0,
            "content": "7. 若一枚伪币与其他硬币质量不等，那么为了在4枚硬币中找出这枚伪币，需要用天平称多少次？描述用同样的称重次数来找出这枚伪币的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.802,
                0.95,
                0.834
            ],
            "angle": 0,
            "content": "*8. 若一枚伪币与其他硬币质量不等，或者轻或者重，那么为了在 8 枚硬币中找出这枚伪币，需要用天平称多少次？描述用同样的称重次数来找出这枚伪币的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.837,
                0.95,
                0.869
            ],
            "angle": 0,
            "content": "*9. 若一枚伪币比其他硬币轻，那么为了在12枚硬币中找出这枚伪币，需要用天平称多少次？描述用同样的称重次数来找出这枚伪币的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.873,
                0.95,
                0.922
            ],
            "angle": 0,
            "content": "* 10.4枚硬币中一枚可能是伪币。伪币与其他硬币质量不等，或者轻或者重。那么为了确定是否有一个伪币，若有伪币，确定它是比其他硬币较重还是较轻，使用一台天平称，需要称多少次？描述用同样的称重次数来找出这枚伪币并且确定它是较轻还是较重的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.926,
                0.78,
                0.94
            ],
            "angle": 0,
            "content": "11. 求排序 4 个元素所需要的最少比较次数并且设计一个能够依此次数实现的算法。"
        },
        {
            "type": "list",
            "bbox": [
                0.091,
                0.802,
                0.95,
                0.94
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.768,
                0.035,
                0.876,
                0.05
            ],
            "angle": 0,
            "content": "树 679"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.091,
                0.731,
                0.106
            ],
            "angle": 0,
            "content": "* 12. 求排序 5 个元素所需要的最少比较次数并且设计一个能够依此次数实现的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.109,
                0.906,
                0.23
            ],
            "angle": 0,
            "content": "竞赛图排序是通过构造有序二叉树来进行排序的排序算法。用将成为树叶的顶点来表示待排序的元素。就像构造表示循环赛比赛胜者的树那样，一次构造这个树的一层。从左向右，比较成对的相邻元素，加入用所比较的两个元素中较大的那个来标记的一个父母顶点。在每一层顶点的标记之间进行类似的比较，直到到达了用最大元素标记的树根为止。22、8、14、17、3、9、27、11的竞赛图排序所构造的树如下图a所示。一旦确定了最大元素，具有这个标记的树叶就重新标记为一∞，定义为比每个元素都小。从这个顶点直到树根的通路上所有顶点的标记都重新计算，如下图b所示。这样就产生了第二大元素。这个过程继续进行下去，直到整个表都已经排序为止。"
        },
        {
            "type": "image",
            "bbox": [
                0.065,
                0.233,
                0.46,
                0.384
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.502,
                0.233,
                0.895,
                0.384
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.387,
                0.803,
                0.402
            ],
            "angle": 0,
            "content": "13. 完成列表22、8、14、17、3、9、27、11的竞赛图排序。说明在每个步骤上顶点的标记。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.405,
                0.549,
                0.419
            ],
            "angle": 0,
            "content": "14. 用竞赛图排序来排序列表17、4、1、5、13、10、14、6。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.423,
                0.288,
                0.437
            ],
            "angle": 0,
            "content": "15. 用伪码描述竞赛图排序。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.44,
                0.903,
                0.472
            ],
            "angle": 0,
            "content": "16. 假设对于某个正整数 \\(k\\) 来说，待排序元素的个数 \\(n\\) 等于 \\(2^k\\) ，若使用竞赛图排序来求这个列表的最大元素，确定竞赛图排序所用的比较次数。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.476,
                0.903,
                0.508
            ],
            "angle": 0,
            "content": "17. 用竞赛图排序求第二大元素、第三大元素……，直到第 \\((n - 1)\\) 大（或第二小）元素所使用的比较次数是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.511,
                0.905,
                0.544
            ],
            "angle": 0,
            "content": "18. 证明：竞赛图排序需要 \\(\\Theta(n \\log n)\\) 次比较来排序含有 \\(n\\) 个元素的列表。[提示：假设对于某个正整数 \\(k\\)，来说，\\(n = 2^k\\)，插入适当数目的哑元，比如 \\(-\\infty\\)，定义为比所有整数都小。]"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.547,
                0.29,
                0.561
            ],
            "angle": 0,
            "content": "19. 下面哪些编码是前缀码？"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.565,
                0.343,
                0.578
            ],
            "angle": 0,
            "content": "a) \\( \\mathrm{a} : {11},\\mathrm{e} : {00},\\mathrm{t} : {10},\\mathrm{\\;s} : {01} \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.583,
                0.336,
                0.595
            ],
            "angle": 0,
            "content": "b) \\(a:0\\) ，e:1，t:01，s:001"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.601,
                0.445,
                0.613
            ],
            "angle": 0,
            "content": "c) \\(a:101\\) ，e:11，t:001，s:011，n:010"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.618,
                0.551,
                0.63
            ],
            "angle": 0,
            "content": "d) a:010, e:11, t:011, s:1011, n:1001, i:10101"
        },
        {
            "type": "list",
            "bbox": [
                0.089,
                0.565,
                0.551,
                0.63
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.636,
                0.436,
                0.65
            ],
            "angle": 0,
            "content": "20. 构造表示下面编码方案的前缀码的二叉树。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.654,
                0.354,
                0.666
            ],
            "angle": 0,
            "content": "a) \\( \\mathrm{a} : {11},\\mathrm{e} : 0,\\mathrm{t} : {101},\\mathrm{\\;s} : {100} \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.672,
                0.455,
                0.684
            ],
            "angle": 0,
            "content": "b) \\(a:1\\) ，e:01，t:001，s:0001，n:00001"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.69,
                0.54,
                0.702
            ],
            "angle": 0,
            "content": "c) \\(a:1010\\) ， \\(\\mathrm{e}:0\\) ，t：11，s：1011，n：1001，i：10001"
        },
        {
            "type": "list",
            "bbox": [
                0.089,
                0.654,
                0.54,
                0.702
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.707,
                0.717,
                0.722
            ],
            "angle": 0,
            "content": "21. 若编码方案是用下面的树来表示，那么什么是a、e、i、k、o、p和u的编码？"
        },
        {
            "type": "image",
            "bbox": [
                0.114,
                0.727,
                0.406,
                0.917
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.92,
                0.907,
                0.935
            ],
            "angle": 0,
            "content": "22. 给定编码方案 \\( \\mathrm{a}:001, \\mathrm{~b}:0001, \\mathrm{e}:1, \\mathrm{r}:0000, \\mathrm{s}:0100, \\mathrm{t}:011, \\mathrm{x}:01010 \\)，找出用下面的比特"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.123,
                0.036,
                0.159,
                0.049
            ],
            "angle": 0,
            "content": "680"
        },
        {
            "type": "header",
            "bbox": [
                0.205,
                0.034,
                0.28,
                0.049
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.091,
                0.27,
                0.106
            ],
            "angle": 0,
            "content": "串来表示的单词。"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.109,
                0.25,
                0.123
            ],
            "angle": 0,
            "content": "a)01110100011"
        },
        {
            "type": "text",
            "bbox": [
                0.316,
                0.109,
                0.43,
                0.122
            ],
            "angle": 0,
            "content": "b)0001110000"
        },
        {
            "type": "text",
            "bbox": [
                0.518,
                0.11,
                0.63,
                0.122
            ],
            "angle": 0,
            "content": "c)0100101010"
        },
        {
            "type": "text",
            "bbox": [
                0.713,
                0.11,
                0.835,
                0.122
            ],
            "angle": 0,
            "content": "d)01100101010"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.127,
                0.941,
                0.159
            ],
            "angle": 0,
            "content": "23. 用哈夫曼编码来编码具有给定频率的如下符号：a:0.20，b:0.10，c:0.15，d:0.25，e:0.30。编码一个符号所需要的平均位数是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.162,
                0.511,
                0.177
            ],
            "angle": 0,
            "content": "24. 用哈夫曼编码来编码具有给定频率的如下符号："
        },
        {
            "type": "list",
            "bbox": [
                0.095,
                0.127,
                0.941,
                0.177
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.18,
                0.941,
                0.212
            ],
            "angle": 0,
            "content": "A:0.10，B:0.25，C:0.05，D:0.15，E:0.30，F:0.07，G:0.08。编码一个符号所需要的平均位数是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.215,
                0.806,
                0.229
            ],
            "angle": 0,
            "content": "25. 为如下符号和频率构造两个不同的哈夫曼编码：t:0.2，u:0.3，v:0.2，w:0.3。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.233,
                0.941,
                0.282
            ],
            "angle": 0,
            "content": "26. a) 以两种不同的方式用哈夫曼编码来编码具有这些频率的符号：a:0.4，b:0.2，c:0.2，d:0.1，e:0.1，在算法中用不同的方式打破平局。第一种，在算法的每个阶段从权最小的树中选择顶点数最多的两个树来组合。第二种，在每个阶段从权最小的树中选择顶点数最少的两个树来组合。"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.286,
                0.941,
                0.318
            ],
            "angle": 0,
            "content": "b)计算用每种编码来编码一个符号所需要的平均位数并且对每种编码计算这个位数的方差。对于编码一个符号所需要的位数的方差，哪种打破平局的过程所产生的会小一些？"
        },
        {
            "type": "list",
            "bbox": [
                0.095,
                0.215,
                0.941,
                0.318
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.321,
                0.806,
                0.336
            ],
            "angle": 0,
            "content": "27. 为英文字母表的字母构造哈夫曼编码，其中典型英文文本中字母的频率如下表所示。"
        },
        {
            "type": "table",
            "bbox": [
                0.127,
                0.344,
                0.941,
                0.553
            ],
            "angle": 0,
            "content": "<table><tr><td>字母</td><td>频率</td><td>字母</td><td>频率</td></tr><tr><td>A</td><td>0.0817</td><td>N</td><td>0.0662</td></tr><tr><td>B</td><td>0.0145</td><td>O</td><td>0.0781</td></tr><tr><td>C</td><td>0.0248</td><td>P</td><td>0.0156</td></tr><tr><td>D</td><td>0.0431</td><td>Q</td><td>0.0009</td></tr><tr><td>E</td><td>0.1232</td><td>R</td><td>0.0572</td></tr><tr><td>F</td><td>0.0209</td><td>S</td><td>0.0628</td></tr><tr><td>G</td><td>0.0182</td><td>T</td><td>0.0905</td></tr><tr><td>H</td><td>0.0668</td><td>U</td><td>0.0304</td></tr><tr><td>I</td><td>0.0689</td><td>V</td><td>0.0102</td></tr><tr><td>J</td><td>0.0010</td><td>W</td><td>0.0264</td></tr><tr><td>K</td><td>0.0080</td><td>X</td><td>0.0015</td></tr><tr><td>L</td><td>0.0397</td><td>Y</td><td>0.0211</td></tr><tr><td>M</td><td>0.0277</td><td>Z</td><td>0.0005</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.564,
                0.941,
                0.614
            ],
            "angle": 0,
            "content": "假设 \\(m\\) 是正整数且 \\(m \\geqslant 2\\) 。对于 \\(N\\) 个符号的集合来说，类似于二叉哈夫曼编码的构造，可以构造 \\(m\\) 又哈夫曼编码。在初始步骤，把由 \\(((N - 1) \\bmod (m - 1)) + 1\\) 个权最小的单个顶点所组成的树组合成以这些顶点作为树叶的一棵树。在每个后续步骤，把权最小的 \\(m\\) 棵树组合成一棵 \\(m\\) 叉树。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.617,
                0.405,
                0.632
            ],
            "angle": 0,
            "content": "28. 用伪码描述 \\(m\\) 叉哈夫曼编码算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.635,
                0.937,
                0.666
            ],
            "angle": 0,
            "content": "29. 使用符号 0、1 和 2，用三叉（\\(m = 3\\)）哈夫曼编码来编码具有给定频率的这些字母：A:0.25，E:0.30，N:0.10，R:0.05，T:0.12，Z:0.18。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.67,
                0.68,
                0.685
            ],
            "angle": 0,
            "content": "30. 考虑具有频率 \\( \\mathrm{A}: 0.80 \\)，\\( \\mathrm{B}: 0.19 \\)，\\( \\mathrm{C}: 0.01 \\) 的三个符号 A、B 和 C。"
        },
        {
            "type": "list",
            "bbox": [
                0.095,
                0.617,
                0.937,
                0.685
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.688,
                0.399,
                0.702
            ],
            "angle": 0,
            "content": "a)为这三个符号构造哈夫曼编码。"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.706,
                0.941,
                0.737
            ],
            "angle": 0,
            "content": "b)通过把两个符号的块AA、AB、AC、BA、BB、BC、CA、CB和CC分组，形成9个符号的一个新的集合。为这9个符号构造哈夫曼编码，假设在原始文本中符号的出现是独立的。"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.741,
                0.941,
                0.772
            ],
            "angle": 0,
            "content": "c)比较a中三个符号的哈夫曼编码与b)构造的9个双符号块的哈夫曼编码来编码文本所需要的平均位数。哪一种编码方式更有效？"
        },
        {
            "type": "list",
            "bbox": [
                0.126,
                0.688,
                0.941,
                0.772
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.776,
                0.941,
                0.827
            ],
            "angle": 0,
            "content": "31. 给定 \\(n + 1\\) 个符号 \\(x_{1}, x_{2}, \\cdots, x_{n}, x_{n + 1}\\)，它们在一个符号串中分别出现 1，\\(f_{1}, f_{2}, \\cdots, f_{n}\\) 次，其中 \\(f_{j}\\) 是第 \\(j\\) 个斐波那契数。当在哈夫曼编码算法的每个阶段考虑所有可能的打破平局的选择时，用来编码一个符号的最大位数是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.83,
                0.918,
                0.844
            ],
            "angle": 0,
            "content": "* 32. 证明：对于所有的二叉前缀码来说，如果使用最少的位来表示一个符号串，哈夫曼编码是最优的。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.848,
                0.941,
                0.897
            ],
            "angle": 0,
            "content": "33. 画出取石子游戏的博弈树，假设开局包括分别有2块和3块石子的两堆石子。在画这棵树的时候，用同一个顶点表示相同移动所导致的对称局面。求出这个博弈树每个顶点的值。如果两个选手都遵循最优策略，则哪个选手获胜？"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.901,
                0.941,
                0.933
            ],
            "angle": 0,
            "content": "34. 画出取石子游戏的博弈树，假设开局包括分别有1块、2块和3块石子的三堆石子。在画这棵树的时候，用同一个顶点表示相同移动所导致的对称局面。求出这棵博弈树每个顶点的值。如果两个选手"
        },
        {
            "type": "list",
            "bbox": [
                0.085,
                0.776,
                0.941,
                0.933
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.767,
                0.035,
                0.873,
                0.049
            ],
            "angle": 0,
            "content": "树 681"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.09,
                0.378,
                0.105
            ],
            "angle": 0,
            "content": "都遵循最优策略，则哪个选手获胜？"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.108,
                0.903,
                0.141
            ],
            "angle": 0,
            "content": "35. 假设在取石子游戏中修改获胜选手的得分，使得当 \\( n \\) 是到达终局前所做合法移动的步数时得分就是 \\( n \\) 美元。求第一个选手的得分，假设开局包括："
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.144,
                0.385,
                0.156
            ],
            "angle": 0,
            "content": "a)分别有1块和3块石头的两堆石子"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.162,
                0.385,
                0.174
            ],
            "angle": 0,
            "content": "b)分别有2块和4块石头的两堆石子"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.18,
                0.434,
                0.191
            ],
            "angle": 0,
            "content": "c)分别有1块、2块和3块石头的三堆石子"
        },
        {
            "type": "list",
            "bbox": [
                0.085,
                0.144,
                0.434,
                0.191
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.196,
                0.905,
                0.265
            ],
            "angle": 0,
            "content": "36. 假设在取石子游戏的一个变种中，允许一个选手要么从一堆取走1块以上的石子，要么把两堆石子合并成一堆，只要至少还剩下一个石子。画出这个游戏变种的博弈树，假设开局由分别含有2块、2块和1块石子的3堆石子组成。求出这棵博弈树中每个顶点的值，并且确定当两个选手都遵循最优策略时哪个选手获胜。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.268,
                0.655,
                0.282
            ],
            "angle": 0,
            "content": "37. 画出井字游戏博弈树从下列每个局面开始的子树。确定每个子树的值。"
        },
        {
            "type": "image",
            "bbox": [
                0.086,
                0.285,
                0.211,
                0.354
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.261,
                0.285,
                0.393,
                0.355
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.44,
                0.286,
                0.577,
                0.355
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.623,
                0.285,
                0.766,
                0.355
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.359,
                0.785,
                0.373
            ],
            "angle": 0,
            "content": "38. 假设井字游戏的前4步移动如下图所示。第一个选手(用 \\(\\times\\) 标记其移动)是否总能获胜？"
        },
        {
            "type": "image",
            "bbox": [
                0.086,
                0.376,
                0.211,
                0.444
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.252,
                0.377,
                0.391,
                0.444
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.44,
                0.377,
                0.578,
                0.444
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.633,
                0.377,
                0.772,
                0.444
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.449,
                0.903,
                0.481
            ],
            "angle": 0,
            "content": "39. 证明：如果取石子游戏从包含相同数目的两堆石子开始，而且这个数目至少是2，则当两个选手都遵循最优策略时第二个选手获胜。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.484,
                0.903,
                0.516
            ],
            "angle": 0,
            "content": "40. 证明：如果取石子游戏从包含不同数目的两堆石子开始，则当两个选手都遵循最优策略时第一个选手获胜。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.52,
                0.472,
                0.534
            ],
            "angle": 0,
            "content": "41. 跳棋博弈树的根有多少个孩子？有多少个孙子？"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.538,
                0.636,
                0.552
            ],
            "angle": 0,
            "content": "42. 取石子游戏博弈树的根有多少个孩子？有多少个孙子？假设开局是："
        },
        {
            "type": "list",
            "bbox": [
                0.055,
                0.449,
                0.903,
                0.552
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.556,
                0.331,
                0.567
            ],
            "angle": 0,
            "content": "a)分别有4块和5块石子的堆"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.573,
                0.381,
                0.584
            ],
            "angle": 0,
            "content": "b)分别有2块、3块和4块石子的堆"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.591,
                0.43,
                0.602
            ],
            "angle": 0,
            "content": "c)分别有1块、2块、3块和4块石子的堆"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.608,
                0.483,
                0.62
            ],
            "angle": 0,
            "content": "d)分别有2块、2块、3块、3块和5块石子的堆"
        },
        {
            "type": "list",
            "bbox": [
                0.085,
                0.556,
                0.483,
                0.62
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.626,
                0.903,
                0.676
            ],
            "angle": 0,
            "content": "43. 画出井字游戏博弈树前两步移动所对应的层。指明正文中所提到的求值函数的值，这个函数给局面指定不含 \\(\\bigcirc\\) 的直行数减去不含 \\(\\times\\) 的直行数来作为这一层每个顶点的值，并且在求值函数给出这些顶点的正确值的假设下，对这些顶点计算树的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.679,
                0.655,
                0.694
            ],
            "angle": 0,
            "content": "44. 用伪码描述当两个选手都遵循最小最大策略时确定博弈树的值的算法。"
        },
        {
            "type": "list",
            "bbox": [
                0.055,
                0.626,
                0.903,
                0.694
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.057,
                0.709,
                0.242,
                0.727
            ],
            "angle": 0,
            "content": "11.3 树的遍历"
        },
        {
            "type": "title",
            "bbox": [
                0.057,
                0.736,
                0.192,
                0.752
            ],
            "angle": 0,
            "content": "11.3.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.756,
                0.903,
                0.83
            ],
            "angle": 0,
            "content": "有序根树常常用来保存信息。掌握一些访问有序根树的每个顶点以存取数据的算法是非常必要的。下面将介绍几个重要的访问有序根树中所有顶点的算法。有序根树也可以用来表示各种类型的表达式，比如由数字、变量和运算所组成的算术表达式。对用来表示这些表达式的有序根树来说，它的顶点的一些不同的列表在这些表达式的求值中很有用。"
        },
        {
            "type": "title",
            "bbox": [
                0.057,
                0.84,
                0.283,
                0.857
            ],
            "angle": 0,
            "content": "11.3.2 通用地址系统"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.861,
                0.903,
                0.896
            ],
            "angle": 0,
            "content": "遍历有序根树所有顶点的过程，都依赖于孩子的顺序。在有序根树中，一个内点的孩子从左向右地显示在表示这些有向图的图形中。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.899,
                0.903,
                0.934
            ],
            "angle": 0,
            "content": "下面将描述一种完全地排序有序根树顶点的方法。为了产生这个顺序，必须首先标记所有的顶点。如下递归地完成这件事："
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.127,
                0.035,
                0.164,
                0.049
            ],
            "angle": 0,
            "content": "682"
        },
        {
            "type": "header",
            "bbox": [
                0.208,
                0.034,
                0.284,
                0.049
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.09,
                0.899,
                0.106
            ],
            "angle": 0,
            "content": "1)用整数0标记根。然后用1，2，3，…， \\(k\\) 从左向右标记它的 \\(k\\) 个孩子(在1层上)。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.11,
                0.945,
                0.144
            ],
            "angle": 0,
            "content": "2)对在 \\(n\\) 层上带标记 \\(A\\) 的每个顶点 \\(\\mathcal{V}\\) ，按照从左向右画出它的 \\(k_{v}\\) 个孩子的顺序，用A.1，A.2，…，A. \\(k\\) 标记它的 \\(k_{\\nu}\\) 个孩子。"
        },
        {
            "type": "list",
            "bbox": [
                0.097,
                0.09,
                0.945,
                0.144
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.147,
                0.945,
                0.201
            ],
            "angle": 0,
            "content": "遵循这个过程，对 \\(n \\geqslant 1\\) 来说，在 \\(n\\) 层上的顶点 \\(v\\) 标记成 \\(x_{1}, x_{2}, \\dots, x_{n}\\)，其中从根到 \\(v\\) 的唯一通路经过1层的第 \\(x_{1}\\) 个顶点，以及2层的第 \\(x_{2}\\) 个顶点，以此类推。这样的标记称为有根树的通用地址系统。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.204,
                0.945,
                0.259
            ],
            "angle": 0,
            "content": "可以利用顶点在通用地址系统里标记的字典顺序将这些顶点完全排序。若存在 \\(i(0 \\leqslant i \\leqslant n)\\) 满足 \\(x_{1} = y_{1}\\), \\(x_{2} = y_{2}\\), \\(\\cdots\\), \\(x_{i-1} = y_{i-1}\\), 并且 \\(x_{i} < y_{i}\\); 或者若 \\(n < m\\) 并且对 \\(i = 1, 2, \\cdots, n\\) 来说 \\(x_{i} = y_{i}\\), 那么标记 \\(x_{1}, x_{2}, \\cdots, x_{n}\\) 的顶点就小于标记 \\(y_{1}, y_{2}, \\cdots, y_{m}\\) 的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.264,
                0.945,
                0.302
            ],
            "angle": 0,
            "content": "例1 在如图1所示的有序根树的顶点的旁边，显示了通用地址系统的标记。这些标记的字典顺序是"
        },
        {
            "type": "equation",
            "bbox": [
                0.14,
                0.305,
                0.945,
                0.34
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} 0 <   1 <   1. 1 <   1. 2 <   1. 3 <   2 <   3 <   3. 1 <   3. 1. 1 <   3. 1. 2 <   3. 1. 2. 1 <   3. 1. 2. 2 \\\\ <   3. 1. 2. 3 <   3. 1. 2. 4 <   3. 1. 3 <   3. 2 <   4 <   4. 1 <   5 <   5. 1 <   5. 1. 1 <   5. 2 <   5. 3 \\quad \\triangleleft \\\\ \\end{array}\n\\]"
        },
        {
            "type": "image",
            "bbox": [
                0.269,
                0.344,
                0.785,
                0.666
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.395,
                0.669,
                0.658,
                0.684
            ],
            "angle": 0,
            "content": "图1 有序根树的通用地址系统"
        },
        {
            "type": "title",
            "bbox": [
                0.103,
                0.704,
                0.287,
                0.72
            ],
            "angle": 0,
            "content": "11.3.3 遍历算法"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.723,
                0.95,
                0.758
            ],
            "angle": 0,
            "content": "系统地访问有序根树每个顶点的过程称为遍历算法。下面描述三个最常用的算法：前序遍历、中序遍历和后序遍历。这些算法都可以递归地定义。首先定义前序遍历。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.767,
                0.943,
                0.824
            ],
            "angle": 0,
            "content": "定义1 设 \\(T\\) 是带根 \\(r\\) 的有序根树。若 \\(T\\) 只包含 \\(r\\)，则 \\(r\\) 是 \\(T\\) 的前序遍历。否则，假定 \\(T_{1}, T_{2}, \\cdots, T_{n}\\) 是 \\(T\\) 的以 \\(r\\) 为根的从左向右的子树。前序遍历首先访问 \\(r\\)。它接着以前序来遍历 \\(T_{1}\\)，然后以前序来遍历 \\(T_{2}\\)，以此类推，直到以前序遍历了 \\(T_{n}\\) 为止。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.834,
                0.95,
                0.869
            ],
            "angle": 0,
            "content": "读者应当验证，有序根树的前序遍历给出了与利用通用地址系统所得出的顺序相同的顶点顺序。图2说明如何执行前序遍历。"
        },
        {
            "type": "text",
            "bbox": [
                0.144,
                0.873,
                0.322,
                0.888
            ],
            "angle": 0,
            "content": "例2说明前序遍历。"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.894,
                0.707,
                0.91
            ],
            "angle": 0,
            "content": "例2 前序遍历以什么顺序访问图3所示的有序根树中的顶点？"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.916,
                0.951,
                0.932
            ],
            "angle": 0,
            "content": "解 \\(T\\) 的前序遍历的步骤如图4所示。这样以前序来遍历 \\(T\\) ，首先列出根 \\(a\\) ，接着依次是带"
        },
        {
            "type": "footer",
            "bbox": [
                0.027,
                0.891,
                0.091,
                0.908
            ],
            "angle": 0,
            "content": "Extra Examples"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.765,
                0.037,
                0.874,
                0.052
            ],
            "angle": 0,
            "content": "树 683"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.093,
                0.842,
                0.11
            ],
            "angle": 0,
            "content": "根 \\(b\\) 的子树的前序列表，带根 \\(c\\) 的子树(它只有 \\(c\\) )的前序列表和带根 \\(d\\) 的子树的前序列表。"
        },
        {
            "type": "image",
            "bbox": [
                0.071,
                0.114,
                0.829,
                0.319
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.195,
                0.321,
                0.326,
                0.337
            ],
            "angle": 0,
            "content": "图2 前序遍历"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.622,
                0.321,
                0.772,
                0.337
            ],
            "angle": 0,
            "content": "图3 有序根树 \\(T\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.214,
                0.344,
                0.748,
                0.917
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.398,
                0.921,
                0.565,
                0.937
            ],
            "angle": 0,
            "content": "图4 \\(T\\) 的前序遍历"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.137,
                0.037,
                0.172,
                0.05
            ],
            "angle": 0,
            "content": "684"
        },
        {
            "type": "header",
            "bbox": [
                0.218,
                0.035,
                0.294,
                0.05
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.092,
                0.957,
                0.146
            ],
            "angle": 0,
            "content": "带根 \\(b\\) 的子树的前序列表首先列出 \\(b\\) ，然后以前序列出带根 \\(e\\) 的子树的顶点，然后以前序列出带根 \\(f\\) 的子树(它只有 \\(f\\) )的顶点。带根 \\(d\\) 的子树的前序列表首先列出 \\(d\\) ，接着是带根 \\(g\\) 的子树的前序列表，接着是带根 \\(h\\) 的子树(它只有 \\(h\\) )，接着是带根 \\(i\\) 的子树(它只有 \\(i\\) )。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.149,
                0.957,
                0.203
            ],
            "angle": 0,
            "content": "带根 \\(e\\) 的子树的前序列表首先列出 \\(e\\) ，接着是带根 \\(j\\) 的子树(它只有 \\(j\\) )的前序列表，接着是带根\\(k\\) 的子树的前序列表。带根 \\(g\\) 的子树的前序列表是 \\(g\\) 接着 \\(l\\) ，接着是 \\(m\\) 。带根 \\(k\\) 的子树的前序列表是\\(k\\) ，\\(n\\) ，\\(o\\) ，\\(p\\) 。所以，\\(T\\) 的前序遍历是 \\(a\\) ，\\(b\\) ，\\(e\\) ，\\(j\\) ，\\(k\\) ，\\(n\\) ，\\(o\\) ，\\(p\\) ，\\(f\\) ，\\(c\\) ，\\(d\\) ，\\(g\\) ，\\(l\\) ，\\(m\\) ，\\(h\\) ，\\(i\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.206,
                0.348,
                0.222
            ],
            "angle": 0,
            "content": "现在将定义中序遍历。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.23,
                0.949,
                0.288
            ],
            "angle": 0,
            "content": "定义2 设 \\(T\\) 是带根 \\(r\\) 的有序根树。若 \\(T\\) 只包含 \\(r\\)，则 \\(r\\) 是 \\(T\\) 的中序遍历。否则，假定 \\(T_{1}, T_{2}, \\cdots, T_{n}\\) 是 \\(T\\) 中以 \\(r\\) 为根的从左向右的子树。中序遍历首先以中序来遍历 \\(T_{1}\\)，然后访问 \\(r\\)。它接着以中序来遍历 \\(T_{2}\\)，中序遍历 \\(T_{3}\\)，以此类推，直到以中序遍历了 \\(T_{n}\\) 为止。"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.297,
                0.841,
                0.314
            ],
            "angle": 0,
            "content": "图5说明如何执行中序遍历。例3说明对一棵特定的树，如何执行中序遍历。"
        },
        {
            "type": "image",
            "bbox": [
                0.319,
                0.321,
                0.75,
                0.48
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.468,
                0.484,
                0.598,
                0.498
            ],
            "angle": 0,
            "content": "图5 中序遍历"
        },
        {
            "type": "text",
            "bbox": [
                0.149,
                0.505,
                0.738,
                0.522
            ],
            "angle": 0,
            "content": "例3 中序遍历以什么顺序访问图3所示的有序根树 \\(T\\) 中的顶点？"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.527,
                0.957,
                0.562
            ],
            "angle": 0,
            "content": "解 \\(T\\) 的中序遍历的步骤显示在图6中。中序遍历首先是带根 \\(b\\) 的子树的中序遍历，然后是根 \\(a\\) 、带根 \\(c\\) 的子树(它只有 \\(c\\) )的中序列表和带根 \\(d\\) 的子树的中序列表。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.565,
                0.958,
                0.6
            ],
            "angle": 0,
            "content": "带根 \\(b\\) 的子树的中序列表，首先是带根 \\(e\\) 的子树的中序列表，然后是根 \\(b\\) ，以及根 \\(f\\) 。带根 \\(d\\) 的子树的中序列表，首先是带根 \\(g\\) 的子树的中序列表，接着是根 \\(d\\) ，接着是根 \\(h\\) ，接着是根 \\(i\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.603,
                0.957,
                0.658
            ],
            "angle": 0,
            "content": "带根 \\(e\\) 的子树的中序列表是 \\(j\\) ，接着是根 \\(e\\) ，接着是带根 \\(k\\) 的子树的中序列表。带根 \\(g\\) 的子树的中序列表是 \\(l\\) ，\\(g\\) ，\\(m\\) 。带根 \\(k\\) 的子树的中序列表是 \\(n\\) ，\\(k\\) ，\\(o\\) ，\\(p\\) 。所以，这个有根树的中序遍历是 \\(j\\) ，\\(e\\) ，\\(n\\) ，\\(k\\) ，\\(o\\) ，\\(p\\) ，\\(b\\) ，\\(f\\) ，\\(a\\) ，\\(c\\) ，\\(l\\) ，\\(g\\) ，\\(m\\) ，\\(d\\) ，\\(h\\) ，\\(i\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.661,
                0.328,
                0.676
            ],
            "angle": 0,
            "content": "现在定义后序遍历。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.685,
                0.949,
                0.742
            ],
            "angle": 0,
            "content": "定义3 设 \\(T\\) 是带根 \\(r\\) 的有序根树。若 \\(T\\) 只包含 \\(r\\)，则 \\(r\\) 是 \\(T\\) 的后序遍历。否则，假定 \\(T_{1}, T_{2}, \\cdots, T_{n}\\) 是 \\(T\\) 中以 \\(r\\) 为根的从左向右的子树。后序遍历首先以后序来遍历 \\(T_{1}\\)，然后以后序来遍历 \\(T_{2} \\cdots\\) 然后以后序来遍历 \\(T_{n}\\)，最后访问 \\(r\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.751,
                0.719,
                0.768
            ],
            "angle": 0,
            "content": "图7说明后序遍历是如何执行的。例4说明后序遍历如何工作。"
        },
        {
            "type": "text",
            "bbox": [
                0.149,
                0.773,
                0.738,
                0.79
            ],
            "angle": 0,
            "content": "例4后序遍历以什么顺序访问图3所示的有序根树 \\(T\\) 中的顶点？"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.795,
                0.956,
                0.831
            ],
            "angle": 0,
            "content": "解 \\(T\\) 的后序遍历的步骤显示在图8里。后序遍历首先是带根 \\(b\\) 的子树的后序遍历，然后是带根 \\(c\\) 的子树（它只有 \\(c\\)）的后序遍历，带根 \\(d\\) 的子树的后序遍历，接着是根 \\(a\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.834,
                0.956,
                0.869
            ],
            "angle": 0,
            "content": "带根 \\(b\\) 的子树的后序遍历首先是带根 \\(e\\) 的子树的后序遍历，接着是根 \\(f\\) ，接着是根 \\(b\\) 。带根 \\(d\\) 的子树的后序遍历首先是带根 \\(g\\) 的子树的后序遍历，接着是根 \\(h\\) ，接着是根 \\(i\\) ，接着是根 \\(d\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.871,
                0.956,
                0.927
            ],
            "angle": 0,
            "content": "带根 \\(e\\) 的子树的后序遍历是根 \\(j\\) ，接着是带根 \\(k\\) 的子树的后序遍历，接着是根 \\(e\\) 。带根 \\(g\\) 的子树的后序遍历是 \\(l\\) ，\\(m\\) ，\\(g\\) 。带根 \\(k\\) 的子树的后序遍历是 \\(n\\) ，\\(o\\) ，\\(p\\) ，\\(k\\) 。因此，有根树 \\(T\\) 的后序遍历是 \\(j\\) ，\\(n\\) ，\\(o\\) ，\\(p\\) ，\\(k\\) ，\\(e\\) ，\\(f\\) ，\\(b\\) ，\\(c\\) ，\\(l\\) ，\\(m\\) ，\\(g\\) ，\\(h\\) ，\\(i\\) ，\\(d\\) ，\\(a\\) 。"
        },
        {
            "type": "image",
            "bbox": [
                0.031,
                0.504,
                0.097,
                0.522
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.759,
                0.036,
                0.865,
                0.05
            ],
            "angle": 0,
            "content": "树 685"
        },
        {
            "type": "image",
            "bbox": [
                0.202,
                0.088,
                0.744,
                0.658
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.388,
                0.665,
                0.555,
                0.679
            ],
            "angle": 0,
            "content": "图6 \\(T\\) 的中序遍历"
        },
        {
            "type": "image",
            "bbox": [
                0.29,
                0.686,
                0.663,
                0.853
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.408,
                0.858,
                0.539,
                0.872
            ],
            "angle": 0,
            "content": "图7后序遍历"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.881,
                0.9,
                0.936
            ],
            "angle": 0,
            "content": "有些简易的方法以前序、中序和后序来列出有序根树的顶点。首先从根开始，沿着边移动，围绕有序根树画一条曲线，如图9所示。可以按照前序列出顶点：当曲线第一次经过一个顶点时，就列出这个顶点。可以按照中序列出顶点：当曲线第一次经过一个树叶时，就列出这个树"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.146,
                0.037,
                0.183,
                0.051
            ],
            "angle": 0,
            "content": "686"
        },
        {
            "type": "header",
            "bbox": [
                0.227,
                0.036,
                0.304,
                0.052
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.093,
                0.968,
                0.166
            ],
            "angle": 0,
            "content": "叶，当曲线第二次经过一个内点时就列出这个内点。可以按照后序列出顶点：当曲线最后一次经过一个顶点而返回这个顶点的父母时，就列出这个顶点。当在图9中的有根树这样做时，结果是前序遍历给出 \\(a, b, d, h, e, i, j, c, f, g, k\\)；中序遍历给出 \\(h, d, b, i, e, j, a, f, c, k, g\\)；后序遍历给出 \\(h, d, i, j, e, b, f, k, g, c, a\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.156,
                0.169,
                0.812,
                0.185
            ],
            "angle": 0,
            "content": "这些以前序、中序和后序来遍历有序根树的算法，最容易用递归来表示。"
        },
        {
            "type": "image",
            "bbox": [
                0.276,
                0.189,
                0.812,
                0.755
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.46,
                0.761,
                0.626,
                0.775
            ],
            "angle": 0,
            "content": "图8 \\(T\\) 的后序遍历"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.796,
                0.282,
                0.811
            ],
            "angle": 0,
            "content": "算法1 前序遍历"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.815,
                0.406,
                0.829
            ],
            "angle": 0,
            "content": "procedurepreorder（ \\(T\\) ：有序根树）"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.833,
                0.231,
                0.846
            ],
            "angle": 0,
            "content": "\\(r\\coloneqq T\\) 的根"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.851,
                0.19,
                0.863
            ],
            "angle": 0,
            "content": "列出 \\(r\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.868,
                0.379,
                0.882
            ],
            "angle": 0,
            "content": "for从左到右的 \\(r\\) 的每个孩子 \\(c\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.165,
                0.885,
                0.362,
                0.899
            ],
            "angle": 0,
            "content": "\\(T(c):=\\) 以 \\(c\\) 为根的子树"
        },
        {
            "type": "text",
            "bbox": [
                0.164,
                0.904,
                0.286,
                0.917
            ],
            "angle": 0,
            "content": "preorder \\((T(c))\\)"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.764,
                0.037,
                0.87,
                0.051
            ],
            "angle": 0,
            "content": "树 687"
        },
        {
            "type": "image",
            "bbox": [
                0.289,
                0.096,
                0.652,
                0.298
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.253,
                0.305,
                0.699,
                0.321
            ],
            "angle": 0,
            "content": "图9 以前序、中序和后序来遍历有序根树的快捷方法"
        },
        {
            "type": "code_caption",
            "bbox": [
                0.065,
                0.342,
                0.214,
                0.358
            ],
            "angle": 0,
            "content": "算法2 中序遍历"
        },
        {
            "type": "code",
            "bbox": [
                0.068,
                0.362,
                0.329,
                0.377
            ],
            "angle": 0,
            "content": "procedure inorder（T：有序根树）"
        },
        {
            "type": "code",
            "bbox": [
                0.069,
                0.38,
                0.166,
                0.393
            ],
            "angle": 0,
            "content": "\\(r\\coloneqq T\\) 的根"
        },
        {
            "type": "code",
            "bbox": [
                0.069,
                0.397,
                0.25,
                0.411
            ],
            "angle": 0,
            "content": "if \\(r\\) 是树叶 then 列出 \\(r\\)"
        },
        {
            "type": "code",
            "bbox": [
                0.07,
                0.416,
                0.102,
                0.428
            ],
            "angle": 0,
            "content": "else"
        },
        {
            "type": "code",
            "bbox": [
                0.098,
                0.432,
                0.359,
                0.447
            ],
            "angle": 0,
            "content": "\\(l:=\\) 从左到右的 \\(r\\) 的第一个孩子"
        },
        {
            "type": "code",
            "bbox": [
                0.098,
                0.45,
                0.296,
                0.464
            ],
            "angle": 0,
            "content": "\\(T(l) \\coloneqq\\) 以 \\(l\\) 为根的子树"
        },
        {
            "type": "code",
            "bbox": [
                0.098,
                0.468,
                0.211,
                0.482
            ],
            "angle": 0,
            "content": "inorder \\((T(l))\\)"
        },
        {
            "type": "code",
            "bbox": [
                0.098,
                0.486,
                0.152,
                0.5
            ],
            "angle": 0,
            "content": "列出 \\(r\\)"
        },
        {
            "type": "code",
            "bbox": [
                0.098,
                0.503,
                0.395,
                0.518
            ],
            "angle": 0,
            "content": "for除 \\(l\\) 外从左到右的 \\(r\\) 的每个孩子 \\(c\\)"
        },
        {
            "type": "code",
            "bbox": [
                0.126,
                0.521,
                0.326,
                0.535
            ],
            "angle": 0,
            "content": "\\(T(c)\\coloneqq\\) 以 \\(c\\) 为根的子树"
        },
        {
            "type": "code",
            "bbox": [
                0.126,
                0.539,
                0.241,
                0.552
            ],
            "angle": 0,
            "content": "inorder \\((T(c))\\)"
        },
        {
            "type": "code_caption",
            "bbox": [
                0.07,
                0.584,
                0.218,
                0.6
            ],
            "angle": 0,
            "content": "算法3 后序遍历"
        },
        {
            "type": "code",
            "bbox": [
                0.07,
                0.603,
                0.35,
                0.618
            ],
            "angle": 0,
            "content": "procedure postorder(T:有序根树)"
        },
        {
            "type": "code",
            "bbox": [
                0.072,
                0.621,
                0.168,
                0.635
            ],
            "angle": 0,
            "content": "\\(r\\coloneqq T\\) 的根"
        },
        {
            "type": "code",
            "bbox": [
                0.072,
                0.639,
                0.315,
                0.653
            ],
            "angle": 0,
            "content": "for从左到右的 \\(r\\) 的每个孩子 \\(c\\)"
        },
        {
            "type": "code",
            "bbox": [
                0.099,
                0.656,
                0.299,
                0.671
            ],
            "angle": 0,
            "content": "\\(T(c):=\\) 以 \\(c\\) 为根的子树"
        },
        {
            "type": "code",
            "bbox": [
                0.099,
                0.675,
                0.231,
                0.689
            ],
            "angle": 0,
            "content": "postorder \\((T(c))\\)"
        },
        {
            "type": "code",
            "bbox": [
                0.072,
                0.692,
                0.127,
                0.706
            ],
            "angle": 0,
            "content": "列出 \\(r\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.727,
                0.905,
                0.82
            ],
            "angle": 0,
            "content": "注意，当规定了每个顶点的孩子数时，有序根树的前序遍历和后序遍历都编码了有序根数的结构。也就是说，当指定树的前序遍历或者后序遍历所生成的顶点列表和每个顶点的孩子数目时，有序根树是唯一确定的（见练习26和27）。特别地，前序遍历和后序遍历都编码了有序 \\(m\\) 叉树的结构。然而，当不规定每个顶点的孩子数时，前序遍历和后序遍历都没有编码有序根树的结构（见练习28和29）。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.824,
                0.905,
                0.898
            ],
            "angle": 0,
            "content": "中序、前序和后序遍历的应用 树的遍历有许多应用，并且在许多算法的实现中起着关键作用。二元有序树可用于表示由对象和运算组成的格式良好的表达式。前序、后序和中序遍历这些树将产生表达式的前缀、后缀和中缀表示，可以在各类应用中使用。在将注意力转向使用树的遍历之前，我们先为如何使用树的遍历提供一些有用的建议。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.901,
                0.905,
                0.937
            ],
            "angle": 0,
            "content": "如果效率不是问题，则可以按任意顺序访问树的顶点，只要每个顶点只访问一次。但是，对于其他应用，有可能需要按某种顺序访问顶点，以保持特定的关系。此外，若效率很重要，"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.124,
                0.041,
                0.159,
                0.054
            ],
            "angle": 0,
            "content": "688"
        },
        {
            "type": "header",
            "bbox": [
                0.205,
                0.039,
                0.28,
                0.054
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.096,
                0.942,
                0.15
            ],
            "angle": 0,
            "content": "则应该使用对该应用最高效的遍历方法。决定要使用的遍历的一般原则是尽可能快地找到感兴趣的顶点。前序遍历对于内部顶点必须在叶子顶点前访问的应用来说是最佳选择，此外，前序遍历还用于复制二叉搜索树。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.153,
                0.942,
                0.226
            ],
            "angle": 0,
            "content": "有趣的是，前序遍历起源于古代。根据Knuth[Kn98]，当国王、公爵或伯爵去世时，他的头衔传给第一个儿子，然后传给这个儿子的子孙；若他们中没有一个还活着，就传给第二个儿子，以及他的后代，以此类推。（在更现代的时期，女儿也被包括在这个顺序中。）因此，一旦已故成员被移除，对相关家族树顶点的前序遍历就产生了王位继承顺序。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.229,
                0.942,
                0.303
            ],
            "angle": 0,
            "content": "后序遍历对于叶子顶点需要在内部顶点之前访问的应用来说是最佳选择。后序遍历在访问内部顶点之前访问叶子顶点，所以，它对于删除树是最佳选择，因为子树根顶点下面的顶点可以在子树的根顶点之前删除。拓扑排序是一种使用后序遍历实现的高效算法。在11.2节中，我们将讨论对二叉搜索树的中序遍历，按关键值的升序访问顶点。这种遍历对二叉树中的数据创建了排序列表。"
        },
        {
            "type": "title",
            "bbox": [
                0.098,
                0.313,
                0.414,
                0.331
            ],
            "angle": 0,
            "content": "11.3.4 中缀、前缀和后缀记法"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.333,
                0.942,
                0.406
            ],
            "angle": 0,
            "content": "可以用有序树来表示复杂的表达式，比如复合命题、集合的组合，以及算术表达式。例如，考虑由运算 \\(+\\) （加）、一（减）、\\*（乘）、/（除）、\\(\\uparrow\\)（幂）所组成的算术表达式的表示。我们将用括号来说明运算次序。有序根树可以用来表示这样的表达式，其中内点表示运算，树叶表示变量或数字。每个运算都作用在它的左子树和右子树上（以此顺序）。"
        },
        {
            "type": "text",
            "bbox": [
                0.137,
                0.412,
                0.712,
                0.429
            ],
            "angle": 0,
            "content": "例5 表示表达式 \\(((x + y) \\uparrow 2) + ((x - 4) / 3)\\) 的有序根树是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.434,
                0.942,
                0.508
            ],
            "angle": 0,
            "content": "解这个表达式的二叉树可以自底向上来构造。首先，构造表达式 \\(x + y\\) 的子树，然后，加入这个子树作为表示 \\((x + y)\\uparrow 2\\) 的更大子树的一部分。同样，构造表达式 \\(x - 4\\) 的子树，然后，加入这个子树到表示 \\((x - 4) / 3\\) 的子树中。最后，组合表示 \\((x + y)\\uparrow 2\\) 与 \\((x - 4) / 3\\) 的子树来形成表示 \\(((x + y)\\uparrow 2) + ((x - 4) / 3)\\) 的有序根树。这些步骤显示在图10中。"
        },
        {
            "type": "image",
            "bbox": [
                0.161,
                0.515,
                0.516,
                0.685
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.526,
                0.516,
                0.88,
                0.685
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.325,
                0.69,
                0.716,
                0.706
            ],
            "angle": 0,
            "content": "图10 表示 \\(((x + y) \\uparrow 2) + ((x - 4) / 3)\\) 的二叉树"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.711,
                0.942,
                0.766
            ],
            "angle": 0,
            "content": "对表示一个表达式的二叉树进行中序遍历，产生原来的表达式，其中元素和运算都是按原有的次序出现，例外的是一元运算，它们紧随运算对象。例如，图11中的二叉树分别表示表达式 \\((x + y) / (x + 3)\\) 、 \\((x + (y / x)) + 3\\) 和 \\(x + (y / (x + 3))\\) ，对它们的中序遍历都得出中缀表达"
        },
        {
            "type": "image",
            "bbox": [
                0.166,
                0.772,
                0.877,
                0.908
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.226,
                0.912,
                0.818,
                0.928
            ],
            "angle": 0,
            "content": "图11 表示 \\((x + y) / (x + 3)\\) 、 \\((x + (y / x)) + 3\\) 和 \\(x + (y / (x + 3))\\) 的有根树"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.776,
                0.038,
                0.885,
                0.052
            ],
            "angle": 0,
            "content": "树 689"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.093,
                0.913,
                0.129
            ],
            "angle": 0,
            "content": "式 \\(x + y / x + 3\\) 。为了让这样的表达式无二义性，当遇到运算时，就有必要在中序遍历里包含括号。以这种方式获得的带完整括号的表达式称为中缀形式。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.131,
                0.914,
                0.205
            ],
            "angle": 0,
            "content": "当以前序遍历表达式的有根树时，就获得它的前缀形式。写成前缀形式的表达式称为波兰记法，它的名字来源于逻辑学家扬·武卡谢维奇。用前缀记法表示的表达式（其中每个运算都有规定的运算对象数）都是无二义性的，所以在这样的表达式中不需要括号。对这个事实的验证留给读者作为练习。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.208,
                0.578,
                0.226
            ],
            "angle": 0,
            "content": "例6 \\(((x + y)\\uparrow 2) + ((x - 4) / 3)\\) 的前缀形式是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.23,
                0.915,
                0.267
            ],
            "angle": 0,
            "content": "解 通过遍历图10所示的表示这个表达式的二叉树，就可以获得它的前缀形式。这样就产生 \\(+\\uparrow +xy2 / - x43\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.269,
                0.915,
                0.324
            ],
            "angle": 0,
            "content": "在表达式的前缀形式里，二元运算符（比如 \\(+\\)）在它的两个运算对象之前。因此，可以从右向左地求前缀形式的表达式的值。当遇到一个运算符时，就对在这个运算对象右边紧接着的两个运算对象来执行相应的运算。另外，当一个运算执行时，就认为结果是新的运算对象。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.328,
                0.578,
                0.346
            ],
            "angle": 0,
            "content": "例7 前缀表达式 \\(+ - * 235 / \\uparrow 234\\) 的值是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.35,
                0.915,
                0.386
            ],
            "angle": 0,
            "content": "解如图12所示，用从右向左的步骤求这个表达式的值，并用右边的运算对象来执行运算。这个表达式的值是3。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.388,
                0.915,
                0.443
            ],
            "angle": 0,
            "content": "通过以后序遍历表达式的二叉树，就可以获得它的后缀形式。写成后缀形式的表达式称为逆波兰记法。用逆波兰记法表示的表达式都是无二义性的，所以不需要括号。对这个事实的验证留给读者。在20世纪70年代和80年代，逆波兰记法在电子计算器中广泛使用。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.447,
                0.578,
                0.465
            ],
            "angle": 0,
            "content": "例8 \\((x + y)\\uparrow 2) + ((x - 4) / 3)\\) 的后缀形式是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.469,
                0.915,
                0.505
            ],
            "angle": 0,
            "content": "解这个表达式的后缀形式是这样获得的：执行图10所示的表示二叉树的后序遍历，这样就产生后缀表达式 \\(xy + 2 \\uparrow x4 - 3 / +\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.507,
                0.915,
                0.562
            ],
            "angle": 0,
            "content": "在表达式的后缀形式里，二元运算都是在它的两个运算对象之后。所以，为了从一个表达式的后缀形式求它的值，就从左向右地进行，当一个运算符后面跟着两个运算对象时，就执行这个运算。在一个运算执行之后，这个运算的结果就成为一个新的运算对象。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.566,
                0.586,
                0.584
            ],
            "angle": 0,
            "content": "例9后缀表达式 \\(723* - 4\\uparrow 93 / +\\) 的值是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.588,
                0.915,
                0.624
            ],
            "angle": 0,
            "content": "解如图13所示，求这个表达式的值所用的步骤是这样的：从左边开始，当两个运算对象后面接着一个运算符时，就执行这个运算。这个表达式的值是4。"
        },
        {
            "type": "equation",
            "bbox": [
                0.082,
                0.629,
                0.451,
                0.671
            ],
            "angle": 0,
            "content": "\\[\n+ - * 2 3 5 / \\begin{array}{c} \\uparrow \\\\ \\downarrow \\\\ 2 \\uparrow 3 = 8 \\end{array}\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.12,
                0.629,
                0.451,
                0.871
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} + - * 2 3 5 \\underbrace {1 8 4} _ {8 / 4 = 2} \\\\ + - \\underbrace {*} 2 3 5 2 _ {2 * 3 = 6} \\\\ + \\underbrace {- 6 5} _ {6 - 5 = 1} 2 \\\\ \\underbrace { \\begin{array}{c c c} + & 1 & 2 \\\\ \\hline 1 + 2 = 3 \\end{array} } _  \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.873,
                0.258,
                0.888
            ],
            "angle": 0,
            "content": "表达式的值：3"
        },
        {
            "type": "equation",
            "bbox": [
                0.526,
                0.631,
                0.891,
                0.875
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} \\begin{array}{c c c c c c c c c} 7 & 2 & 3 & * \\\\ & \\hline & 2 * 3 = 6 \\end{array} - 4 \\uparrow 9 3 / + \\\\ \\underbrace {7 \\quad 6 \\quad -} _ {7 - 6 = 1} \\quad 4 \\quad \\uparrow \\quad 9 \\quad 3 \\quad / \\quad + \\\\ \\underbrace { \\begin{array}{c c c c c c c} 1 & 4 & \\uparrow \\\\ & & & 9 & 3 & / & + \\end{array} } _ {1 ^ {4} = 1} \\\\ 1 \\underbrace {9 3 /} _ {9 / 3 = 3} + \\\\ \\begin{array}{c} 1 \\quad 3 \\quad + \\\\ 1 + 3 = 4 \\end{array} \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.569,
                0.877,
                0.681,
                0.892
            ],
            "angle": 0,
            "content": "表达式的值：4"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.147,
                0.899,
                0.4,
                0.915
            ],
            "angle": 0,
            "content": "图12 求一个前缀表达式的值"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.582,
                0.9,
                0.834,
                0.915
            ],
            "angle": 0,
            "content": "图13 求一个后缀表达式的值"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.921,
                0.896,
                0.938
            ],
            "angle": 0,
            "content": "有根树可以用来表示其他类型的表达式，比如表示复合命题、集合组合的表达式。在这"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.132,
                0.036,
                0.167,
                0.049
            ],
            "angle": 0,
            "content": "690"
        },
        {
            "type": "header",
            "bbox": [
                0.212,
                0.035,
                0.29,
                0.051
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "header",
            "bbox": [
                0.027,
                0.13,
                0.09,
                0.147
            ],
            "angle": 0,
            "content": "Extra Examples"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.092,
                0.951,
                0.128
            ],
            "angle": 0,
            "content": "例子里会出现如命题否定这样的一元运算符。为了表示这样的运算符及其运算对象，就用顶点表示运算符并且用这个顶点的孩子表示运算对象。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.133,
                0.951,
                0.171
            ],
            "angle": 0,
            "content": "例10 求表示复合命题 \\((\\neg (p \\wedge q)) \\leftrightarrow (\\neg p \\vee \\neg q)\\) 的有序根树。然后用这个有根树求这个表达式的前缀、后缀和中缀形式。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.174,
                0.951,
                0.228
            ],
            "angle": 0,
            "content": "解 这个复合命题的有序根树是自底向上地构造的。首先，构造 \\(\\neg p\\) 和 \\(\\neg q\\) 的子树（其中把 \\(\\neg\\) 当作一元运算符）。另外，构造 \\(p \\wedge q\\) 的子树。然后构造 \\(\\neg (p \\wedge q)\\) 和 \\((\\neg p) \\vee (\\neg q)\\) 的子树。最后，用这两个子树来构造最终的有根树。这个过程的步骤显示在图14中。"
        },
        {
            "type": "image",
            "bbox": [
                0.178,
                0.235,
                0.501,
                0.419
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.559,
                0.235,
                0.88,
                0.419
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.383,
                0.424,
                0.673,
                0.438
            ],
            "angle": 0,
            "content": "图14 构造一个复合命题的有根树"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.449,
                0.951,
                0.504
            ],
            "angle": 0,
            "content": "求表达式的前缀、后缀和中缀形式时，可以分别以前序、后序和中序来遍历这个有根树（包含括号）。这些遍历分别给出 \\(\\leftrightarrow \\neg \\land pq \\lor \\neg p \\neg q\\) 、 \\(pq \\land \\neg p \\neg q \\lor \\neg V \\leftrightarrow\\) 和 \\((\\neg (p \\land q)) \\leftrightarrow ((\\neg p) \\lor (\\neg q))\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.507,
                0.95,
                0.542
            ],
            "angle": 0,
            "content": "因为前缀表达式和后缀表达式都是无二义性的，而且不用来回扫描就容易求出它们的值，所以它们在计算机科学里大量使用。这样的表达式对编译器的构造是特别有用的。"
        },
        {
            "type": "title",
            "bbox": [
                0.105,
                0.553,
                0.153,
                0.568
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.573,
                0.951,
                0.606
            ],
            "angle": 0,
            "content": "在练习 \\(1\\sim 3\\) 中，对给定的有序根树构造通用地址系统。然后利用这个通用地址系统用顶点的标记的字典顺序来排序顶点。"
        },
        {
            "type": "image",
            "bbox": [
                0.105,
                0.635,
                0.177,
                0.658
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.107,
                0.67,
                0.248,
                0.781
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.106,
                0.784,
                0.245,
                0.804
            ],
            "angle": 0,
            "content": "@UtCon Collection/Alamy Stock Photo"
        },
        {
            "type": "text",
            "bbox": [
                0.263,
                0.67,
                0.955,
                0.791
            ],
            "angle": 0,
            "content": "扬·武卡谢维奇（Jan Lukasiewicz，1878—1956）武卡谢维奇出生在勒沃的一个说波兰语的家庭。在他出生时，勒沃还是奥地利的一部分，现在则属于乌克兰。他的父亲是奥地利军队的上尉。武卡谢维奇上高中时开始对数学感兴趣。他在勒沃大学的本科和研究生阶段兼修数学和哲学。在读完博士后，武卡谢维奇留校当了讲师，并在1911年被提拔为教授。1915年当华沙大学作为波兰的大学重新开办时，武卡谢维奇应邀加入。1919年他担任波兰教育大臣。从1920年到1939年，他重返华沙大学担任教授，并曾两度任这所大学的校长。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.794,
                0.955,
                0.845
            ],
            "angle": 0,
            "content": "Stock Photo 武卡谢维奇是著名的逻辑学华沙学派的共同发起人之一。1928年，他出版了著名的教材《数理逻辑基础》(Elements of Mathematical Logic)。在他的影响下，数理逻辑在波兰成为数学和科学专业本科生的必修课程。他的讲座独具个人魅力，甚至吸引了人文学科的学生。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.847,
                0.953,
                0.898
            ],
            "angle": 0,
            "content": "武卡谢维奇和他的妻子在第二次世界大战期间遭受了极大的迫害，这些都在他死后出版的自传中有所记载。战后，他们在比利时过着流放生活。幸运的是，1949年他获得在都柏林的爱尔兰皇家科学院的职务。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.9,
                0.953,
                0.934
            ],
            "angle": 0,
            "content": "武卡谢维奇一生都致力于数理逻辑的研究。他关于三值逻辑的研究是对这个领域的重要贡献。不过，在数学和计算机科学界他最为著名的，是他引入了无括号记法，现今称为波兰记法。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.764,
                0.033,
                0.87,
                0.047
            ],
            "angle": 0,
            "content": "树 691"
        },
        {
            "type": "image",
            "bbox": [
                0.053,
                0.087,
                0.199,
                0.182
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.262,
                0.087,
                0.481,
                0.274
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.546,
                0.089,
                0.774,
                0.291
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.291,
                0.474,
                0.306
            ],
            "angle": 0,
            "content": "4. 假定在有序根树 \\(T\\) 中顶点 \\(v\\) 的地址是3.4.5.2.4。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.309,
                0.214,
                0.323
            ],
            "angle": 0,
            "content": "a) \\(v\\) 是在哪一层？"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.327,
                0.287,
                0.341
            ],
            "angle": 0,
            "content": "b) \\(v\\) 的父母的地址是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.345,
                0.267,
                0.358
            ],
            "angle": 0,
            "content": "c) \\(v\\) 的兄弟最少有多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.363,
                0.555,
                0.377
            ],
            "angle": 0,
            "content": "d) 若 \\(v\\) 具有这个地址，那么在 \\(T\\) 里最少可能有多少个顶点？"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.381,
                0.288,
                0.394
            ],
            "angle": 0,
            "content": "e)求其他必然出现的地址。"
        },
        {
            "type": "list",
            "bbox": [
                0.073,
                0.309,
                0.555,
                0.394
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.399,
                0.831,
                0.413
            ],
            "angle": 0,
            "content": "5. 假定在有序根树 \\(T\\) 中，地址最大的顶点的地址是2.3.4.3.1。是否有可能确定 \\(T\\) 中的顶点数？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.416,
                0.718,
                0.43
            ],
            "angle": 0,
            "content": "6. 有序根树的树叶能否具有下面的通用地址表？若能，则构造出这样的有序根树。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.434,
                0.785,
                0.448
            ],
            "angle": 0,
            "content": "a)1.1.1，1.1.2，1.2，2.1.1.1，2.1.2，2.1.3，2.2，3.1.1，3.1.2.1，3.1.2.2，3.2"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.452,
                0.895,
                0.466
            ],
            "angle": 0,
            "content": "b)1.1，1.2.1，1.2.2，1.2.3，2.1，2.2.1，2.3.1，2.3.2，2.4.2.1，2.4.2.2，3.1，3.2.1，3.2.2"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.47,
                0.627,
                0.484
            ],
            "angle": 0,
            "content": "c)1.1，1.2.1，1.2.2，1.2.2.1，1.3，1.4，2，3.1，3.2，4.1.1.1"
        },
        {
            "type": "list",
            "bbox": [
                0.073,
                0.434,
                0.895,
                0.484
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.489,
                0.592,
                0.502
            ],
            "angle": 0,
            "content": "在练习 \\(7\\sim 9\\) 中，确定前序遍历访问所给的有序根树的顶点的顺序。"
        },
        {
            "type": "image",
            "bbox": [
                0.053,
                0.506,
                0.242,
                0.662
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.247,
                0.506,
                0.507,
                0.7
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.518,
                0.506,
                0.864,
                0.7
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.703,
                0.562,
                0.717
            ],
            "angle": 0,
            "content": "10. 使用中序遍历，以什么顺序访问练习7中有序根树的顶点？"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.721,
                0.562,
                0.735
            ],
            "angle": 0,
            "content": "11. 使用中序遍历，以什么顺序访问练习8中有序根树的顶点？"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.739,
                0.562,
                0.753
            ],
            "angle": 0,
            "content": "12. 使用中序遍历，以什么顺序访问练习9中有序根树的顶点？"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.757,
                0.562,
                0.771
            ],
            "angle": 0,
            "content": "13. 使用后序遍历，以什么顺序访问练习7中有序根树的顶点？"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.775,
                0.562,
                0.788
            ],
            "angle": 0,
            "content": "14. 使用后序遍历，以什么顺序访问练习8中有序根树的顶点？"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.792,
                0.562,
                0.806
            ],
            "angle": 0,
            "content": "15. 使用后序遍历，以什么顺序访问练习9中有序根树的顶点？"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.81,
                0.683,
                0.824
            ],
            "angle": 0,
            "content": "16. 用二叉树来表示表达式 \\(((x + 2) \\uparrow 3) * (y - (3 + x)) - 5\\) 。表示方式应采用："
        },
        {
            "type": "list",
            "bbox": [
                0.052,
                0.703,
                0.683,
                0.824
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.828,
                0.181,
                0.842
            ],
            "angle": 0,
            "content": "a)前缀记法"
        },
        {
            "type": "text",
            "bbox": [
                0.274,
                0.828,
                0.37,
                0.842
            ],
            "angle": 0,
            "content": "b)后缀记法"
        },
        {
            "type": "text",
            "bbox": [
                0.475,
                0.829,
                0.57,
                0.842
            ],
            "angle": 0,
            "content": "c)中缀记法"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.846,
                0.724,
                0.861
            ],
            "angle": 0,
            "content": "17. 用二叉树来表示表达式 \\((x + xy) + (x / y)\\) 和 \\(x + ((xy + x) / y)\\) 。表示方式应采用："
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.864,
                0.181,
                0.878
            ],
            "angle": 0,
            "content": "a)前缀记法"
        },
        {
            "type": "text",
            "bbox": [
                0.274,
                0.864,
                0.37,
                0.877
            ],
            "angle": 0,
            "content": "b)后缀记法"
        },
        {
            "type": "text",
            "bbox": [
                0.475,
                0.864,
                0.57,
                0.877
            ],
            "angle": 0,
            "content": "c)中缀记法"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.882,
                0.823,
                0.897
            ],
            "angle": 0,
            "content": "18. 用有序根树来表示复合命题 \\(\\neg (p \\wedge q) \\leftrightarrow (\\neg p \\vee \\neg q)\\) 和 \\((\\neg p \\wedge (q \\leftrightarrow \\neg p)) \\vee \\neg q\\) 。表示方式应采用："
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.899,
                0.181,
                0.913
            ],
            "angle": 0,
            "content": "a)前缀记法"
        },
        {
            "type": "text",
            "bbox": [
                0.274,
                0.899,
                0.37,
                0.913
            ],
            "angle": 0,
            "content": "b)后缀记法"
        },
        {
            "type": "text",
            "bbox": [
                0.475,
                0.9,
                0.57,
                0.913
            ],
            "angle": 0,
            "content": "c)中缀记法"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.918,
                0.587,
                0.932
            ],
            "angle": 0,
            "content": "19. 用有序根树来表示 \\((A \\cap B) - (A \\cup (B - A))\\) 。表示方式应采用："
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.135,
                0.034,
                0.172,
                0.048
            ],
            "angle": 0,
            "content": "692"
        },
        {
            "type": "header",
            "bbox": [
                0.216,
                0.033,
                0.294,
                0.049
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.09,
                0.235,
                0.104
            ],
            "angle": 0,
            "content": "a)前缀记法"
        },
        {
            "type": "text",
            "bbox": [
                0.329,
                0.091,
                0.423,
                0.104
            ],
            "angle": 0,
            "content": "b)后缀记法"
        },
        {
            "type": "text",
            "bbox": [
                0.531,
                0.091,
                0.623,
                0.104
            ],
            "angle": 0,
            "content": "c)中缀记法"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.108,
                0.742,
                0.123
            ],
            "angle": 0,
            "content": "* 20. 有多少种方式给字符串 \\(\\neg p \\land q \\leftrightarrow p \\lor \\neg q\\) 完全加上括号以便产生中缀表达式？"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.126,
                0.767,
                0.14
            ],
            "angle": 0,
            "content": "* 21. 有多少种方式给字符串 \\( A \\cap  B - A \\cup  B - A \\) 完全加上括号以便产生中缀表达式?"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.143,
                0.911,
                0.158
            ],
            "angle": 0,
            "content": "22. 画出下面用前缀记法写出的每个算术表达式所对应的有序根树。然后用中缀记法写每个表达式。"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.161,
                0.306,
                0.175
            ],
            "angle": 0,
            "content": "a）+ \\(\\ast + - 53214\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.329,
                0.161,
                0.455,
                0.174
            ],
            "angle": 0,
            "content": "b) \\(\\uparrow + 23 - 51\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.531,
                0.162,
                0.726,
                0.174
            ],
            "angle": 0,
            "content": "c）\\*/93+ \\(\\ast\\) 24-76"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.179,
                0.414,
                0.193
            ],
            "angle": 0,
            "content": "23. 下面每个前缀表达式的值是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.197,
                0.275,
                0.209
            ],
            "angle": 0,
            "content": "a)-\\*2/843"
        },
        {
            "type": "text",
            "bbox": [
                0.531,
                0.197,
                0.71,
                0.21
            ],
            "angle": 0,
            "content": "b）\\(\\uparrow - * 33 * 425\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.214,
                0.376,
                0.227
            ],
            "angle": 0,
            "content": "c) + - ↑ 3 2 ↑ 2 3 / 6-4 2"
        },
        {
            "type": "text",
            "bbox": [
                0.531,
                0.214,
                0.724,
                0.227
            ],
            "angle": 0,
            "content": "d） \\(+3 + 3\\uparrow 3 + 333\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.232,
                0.414,
                0.246
            ],
            "angle": 0,
            "content": "24. 下面每个后缀表达式的值是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.249,
                0.324,
                0.262
            ],
            "angle": 0,
            "content": "a)521-314++\\*"
        },
        {
            "type": "text",
            "bbox": [
                0.348,
                0.25,
                0.499,
                0.262
            ],
            "angle": 0,
            "content": "b) \\(93 / 5 + 72 - *\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.531,
                0.25,
                0.77,
                0.262
            ],
            "angle": 0,
            "content": "c)32\\*2↑53-84/\\*一"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.267,
                0.953,
                0.299
            ],
            "angle": 0,
            "content": "25.构造前序遍历为 \\(a\\) ， \\(b\\) ， \\(f\\) ， \\(c\\) ， \\(g\\) ， \\(h\\) ， \\(i\\) ， \\(d\\) ， \\(e\\) ， \\(j\\) ， \\(k\\) ， \\(l\\) 的有序根树，其中 \\(a\\) 有4个孩子， \\(c\\) 有3个孩子， \\(j\\) 有2个孩子， \\(b\\) 和 \\(e\\) 都有1个孩子，所有其他顶点都是树叶。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.303,
                0.952,
                0.335
            ],
            "angle": 0,
            "content": "* 26. 证明：当指定了有序根树的前序遍历所生成的顶点列表，并且指定了每个顶点的孩子数时，这个有序根树是唯一确定的。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.338,
                0.952,
                0.369
            ],
            "angle": 0,
            "content": "* 27. 证明：当指定了有序根树的后序遍历所生成的顶点列表，并且指定了每个顶点的孩子数时，这个有序根树是唯一确定的。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.373,
                0.953,
                0.405
            ],
            "angle": 0,
            "content": "28. 证明：下图所示的两个有序根树的前序遍历产生相同的顶点列表。注意这个结果不与练习26的命题相矛盾，因为在这两个有序根树中内点的孩子数是不同的。"
        },
        {
            "type": "image",
            "bbox": [
                0.136,
                0.408,
                0.354,
                0.571
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.414,
                0.409,
                0.603,
                0.528
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.575,
                0.953,
                0.607
            ],
            "angle": 0,
            "content": "29. 证明：下图所示的两个有序根树的后序遍历产生相同的顶点列表。注意这个结果不与练习27里的命题相矛盾，因为在这两个有序根树中内点的孩子数是不同的。"
        },
        {
            "type": "image",
            "bbox": [
                0.137,
                0.61,
                0.327,
                0.737
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.382,
                0.611,
                0.569,
                0.737
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.741,
                0.86,
                0.755
            ],
            "angle": 0,
            "content": "在符号集合和二元运算符集合上用前缀记法表示的合式公式是用下面的规则来递归地定义的："
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.759,
                0.527,
                0.772
            ],
            "angle": 0,
            "content": "i) 若 \\(x\\) 是符号，则 \\(x\\) 是用前缀记法表示的合式公式；"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.776,
                0.622,
                0.79
            ],
            "angle": 0,
            "content": "ii) 若 \\(X\\) 和 \\(Y\\) 都是合式公式且 \\(*\\) 是运算符，则 \\(XY\\) 是合式公式。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.794,
                0.767,
                0.809
            ],
            "angle": 0,
            "content": "30. 下列哪些公式是在符号 \\(\\{x, y, z\\}\\) 和二元运算符集 \\(\\{\\times, +, \\circ\\}\\) 上的合式公式？"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.812,
                0.261,
                0.826
            ],
            "angle": 0,
            "content": "a) \\(\\times + + x y x\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.33,
                0.813,
                0.45,
                0.826
            ],
            "angle": 0,
            "content": "b) \\(0x y\\times xz\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.532,
                0.813,
                0.693,
                0.826
            ],
            "angle": 0,
            "content": "c） \\(\\times 0xz\\times x\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.726,
                0.813,
                0.893,
                0.826
            ],
            "angle": 0,
            "content": "d) \\(\\times +\\circ x x\\circ x x x\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.829,
                0.953,
                0.861
            ],
            "angle": 0,
            "content": "*31. 证明：在符号集合和二元运算符集合上用前缀记法表示的任何合式公式所包含的符号数都比运算符数恰好多一个。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.865,
                0.726,
                0.879
            ],
            "angle": 0,
            "content": "32. 给出在符号集合和二元运算符集合上用后缀记法表示的合式公式的定义。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.882,
                0.953,
                0.914
            ],
            "angle": 0,
            "content": "33. 给出在符号 \\(\\{x, y, z\\}\\) 和二元运算符集 \\(\\{+\\), \\(\\times\\), o\\}\\) 上带 3 个以上运算的、用后缀记法表示的合式公式的 6 个例子。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.918,
                0.923,
                0.932
            ],
            "angle": 0,
            "content": "34. 把用前缀记法表示的合式公式的定义推广到这样的符号和运算符集合上，其中运算符可能不是二元的。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.76,
                0.046,
                0.867,
                0.061
            ],
            "angle": 0,
            "content": "树 693"
        },
        {
            "type": "title",
            "bbox": [
                0.051,
                0.114,
                0.209,
                0.133
            ],
            "angle": 0,
            "content": "11.4 生成树"
        },
        {
            "type": "title",
            "bbox": [
                0.051,
                0.141,
                0.185,
                0.158
            ],
            "angle": 0,
            "content": "11.4.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.162,
                0.897,
                0.216
            ],
            "angle": 0,
            "content": "考虑图1a所示的简单图所表示的缅因州的道路系统。在冬天保持道路通畅的唯一方式就是经常扫雪。高速公路部门希望只扫尽可能少的道路上的雪，而确保总是存在连接任何两个乡镇的干净道路。如何才能做到这一点？"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.219,
                0.896,
                0.254
            ],
            "angle": 0,
            "content": "至少扫除5条道路上的雪才能保证在任何两个乡镇之间有一条通路。图1b显示了一些这样的道路集合。注意表示这些道路的子图是树，因为它是连通的并且包含6个顶点和5条边。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.257,
                0.896,
                0.292
            ],
            "angle": 0,
            "content": "这个问题是用包含原来简单图的所有顶点、边数最小的连通子图来解决的。这样的图必然是树。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.302,
                0.73,
                0.319
            ],
            "angle": 0,
            "content": "定义1 设 \\(G\\) 是简单图。\\(G\\) 的生成树是包含 \\(G\\) 的每个顶点的 \\(G\\) 的子图。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.328,
                0.897,
                0.364
            ],
            "angle": 0,
            "content": "有生成树的简单图必然是连通的，因为在生成树中，任何两个顶点之间都有通路。反过来也是对的，即每个连通图都有生成树。在证明这个结果之前将给出一个例子。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.369,
                0.443,
                0.386
            ],
            "angle": 0,
            "content": "例1 找出图2所示的简单图的生成树。"
        },
        {
            "type": "image",
            "bbox": [
                0.071,
                0.392,
                0.287,
                0.474
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.132,
                0.478,
                0.258,
                0.491
            ],
            "angle": 0,
            "content": "a）一个道路系统"
        },
        {
            "type": "image",
            "bbox": [
                0.306,
                0.392,
                0.501,
                0.474
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.321,
                0.478,
                0.482,
                0.491
            ],
            "angle": 0,
            "content": "b）需要除雪的道路集"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.261,
                0.497,
                0.31,
                0.511
            ],
            "angle": 0,
            "content": "图1"
        },
        {
            "type": "image",
            "bbox": [
                0.592,
                0.407,
                0.821,
                0.493
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.642,
                0.497,
                0.771,
                0.511
            ],
            "angle": 0,
            "content": "图2 简单图 \\(G\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.519,
                0.899,
                0.593
            ],
            "angle": 0,
            "content": "解 图 \\(G\\) 是连通的，但它不是树，因为它包含简单回路。删除边 \\(\\{a, e\\}\\) 。这样就消除了一个简单回路，而且所得出的子图仍然是连通的并且仍然包含 \\(G\\) 的每个顶点。其次删除边 \\(\\{e, f\\}\\) 以便消除第二个简单回路。最后，删除边 \\(\\{c, g\\}\\) 以便产生一个没有简单回路的简单图。这个子图是生成树，因为它是包含 \\(G\\) 的每个顶点的树。图3说明了用来产生这个生成树的边的删除序列。"
        },
        {
            "type": "image",
            "bbox": [
                0.117,
                0.597,
                0.345,
                0.681
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.12,
                0.683,
                0.222,
                0.697
            ],
            "angle": 0,
            "content": "删除边： \\(\\{a,e\\}\\)"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.197,
                0.705,
                0.212,
                0.714
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "image",
            "bbox": [
                0.361,
                0.597,
                0.588,
                0.681
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.429,
                0.685,
                0.464,
                0.697
            ],
            "angle": 0,
            "content": "{e.f}"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.441,
                0.704,
                0.456,
                0.714
            ],
            "angle": 0,
            "content": "b)"
        },
        {
            "type": "image",
            "bbox": [
                0.606,
                0.597,
                0.832,
                0.682
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.67,
                0.685,
                0.71,
                0.697
            ],
            "angle": 0,
            "content": "\\(\\{c,g\\}\\)"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.685,
                0.704,
                0.701,
                0.714
            ],
            "angle": 0,
            "content": "c）"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.241,
                0.721,
                0.707,
                0.736
            ],
            "angle": 0,
            "content": "图3 通过删除形成简单回路的边来产生 \\(G\\) 的一个生成树"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.746,
                0.899,
                0.763
            ],
            "angle": 0,
            "content": "图3所示的生成树不是唯一的 \\(G\\) 的生成树。例如，图4所示的每个树都是 \\(G\\) 的生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.772,
                0.519,
                0.789
            ],
            "angle": 0,
            "content": "定理1 简单图是连通的当且仅当它有生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.797,
                0.899,
                0.852
            ],
            "angle": 0,
            "content": "证明 首先，假定简单图 \\(G\\) 有生成树 \\(T\\) 。\\(T\\) 包含 \\(G\\) 的每个顶点。另外，在 \\(T\\) 的任何两个顶点之间都有在 \\(T\\) 中的通路。因为 \\(T\\) 是 \\(G\\) 的子图，所以在 \\(G\\) 的任何两个顶点之间都有通路。因此，\\(G\\) 是连通的。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.855,
                0.899,
                0.947
            ],
            "angle": 0,
            "content": "现在假定 \\(G\\) 是连通的。若 \\(G\\) 不是树，则它必然包含简单回路。从这些简单回路中的一个里删除一条边。所得出的子图少了一条边，但是仍然包含 \\(G\\) 的所有顶点并且是连通的。这个子图仍然是连通的，因为当两个顶点由包含这条被删除边的通路相连接时，它们被一条不包含这条边的通路相连接。我们可以通过在原来的通路中，在被删除的边的位置，插入一条带有被删除边的简单的回路构造这样的通路。若这个子图不是树，则它有简单回路，所以像前面那样，"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.144,
                0.045,
                0.18,
                0.059
            ],
            "angle": 0,
            "content": "694"
        },
        {
            "type": "header",
            "bbox": [
                0.226,
                0.044,
                0.301,
                0.059
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "image",
            "bbox": [
                0.302,
                0.097,
                0.528,
                0.186
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.544,
                0.097,
                0.78,
                0.188
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.302,
                0.203,
                0.528,
                0.285
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.545,
                0.203,
                0.779,
                0.292
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.447,
                0.296,
                0.632,
                0.311
            ],
            "angle": 0,
            "content": "图4 \\(G\\) 的一些生成树"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.317,
                0.962,
                0.371
            ],
            "angle": 0,
            "content": "删除一个简单回路里的一条边。重复这个过程直到没有简单回路为止。这是可能的，因为在图里只有有穷的边数。当没有简单回路剩下时，这个过程终止。产生一棵树，因为在删除边时这个图保持连通。这棵树是生成树，因为它包含 \\(G\\) 的每个顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.156,
                0.374,
                0.541,
                0.39
            ],
            "angle": 0,
            "content": "例2说明，在数据网络里生成树是重要的。"
        },
        {
            "type": "image",
            "bbox": [
                0.062,
                0.396,
                0.102,
                0.409
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.395,
                0.965,
                0.529
            ],
            "angle": 0,
            "content": "例2 IP组播 在网络互连协议(IP)网络上的组播里，生成树起到重要的作用。为了从源计算机发送数据到多个接收计算机（每个接收计算机是一个子网），可以分别发送数据到每个计算机。这种类型的网络称为单点广播，效率很低，因为在网络上发送了存有相同数据的多个副本。为了更有效地传送数据到多个接收计算机，就使用IP组播。在IP组播里，一个计算机在网络上发送数据的单一副本，当数据到达中间路由器时，就把数据分发到一个或更多的其他路由器，以便接收计算机都在它们不同的子网里最终接收到这些数据。（路由器是专门在网络子网之间分发IP数据报的计算机。在组播时，路由器使用D类地址，每个都表示接收计算机可以加入的一个会话，见6.1节例17。）"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.532,
                0.964,
                0.643
            ],
            "angle": 0,
            "content": "为了让数据尽可能快地到达接收计算机，在数据穿过网络的通路里就不应当存在环路（在图论术语中它们是回路）。即，一旦数据已经到达一个具体的路由器，数据就再也不应当返回这个路由器。为了避免环路，组播路由器用网络算法来构造图中的生成树，这个图以组播源、路由器和包含接收计算机的子网来作为顶点，以边表示计算机和路由器之间的连接。这个生成树的根就是组播源。包含接收计算机的子网就是这个树的树叶（注意不包含接收计算机的子网都不包含在这个图里）。图5说明这些内容。"
        },
        {
            "type": "image",
            "bbox": [
                0.21,
                0.648,
                0.516,
                0.875
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.524,
                0.649,
                0.721,
                0.875
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_footnote",
            "bbox": [
                0.727,
                0.741,
                0.79,
                0.758
            ],
            "angle": 0,
            "content": "□路由"
        },
        {
            "type": "image_footnote",
            "bbox": [
                0.734,
                0.76,
                0.788,
                0.773
            ],
            "angle": 0,
            "content": "- 子网"
        },
        {
            "type": "image_footnote",
            "bbox": [
                0.729,
                0.776,
                0.87,
                0.791
            ],
            "angle": 0,
            "content": "\\(\\odot\\) 带接收站的子网"
        },
        {
            "type": "list",
            "bbox": [
                0.727,
                0.741,
                0.87,
                0.791
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.448,
                0.88,
                0.633,
                0.894
            ],
            "angle": 0,
            "content": "图5 一个组播生成树"
        },
        {
            "type": "title",
            "bbox": [
                0.119,
                0.908,
                0.347,
                0.925
            ],
            "angle": 0,
            "content": "11.4.2 深度优先搜索"
        },
        {
            "type": "image",
            "bbox": [
                0.064,
                0.929,
                0.102,
                0.941
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.158,
                0.929,
                0.962,
                0.944
            ],
            "angle": 0,
            "content": "定理1的证明给出了通过从简单回路删除边来找出生成树的算法。这个算法是低效的，因"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.769,
                0.028,
                0.794,
                0.042
            ],
            "angle": 0,
            "content": "树"
        },
        {
            "type": "page_number",
            "bbox": [
                0.84,
                0.028,
                0.874,
                0.041
            ],
            "angle": 0,
            "content": "695"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.083,
                0.905,
                0.119
            ],
            "angle": 0,
            "content": "为它要求找出简单回路。另一种不采用删除边来构造生成树的方法是，通过依次添加边来建立生成树。这里将给出基于这个原理的两个算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.122,
                0.906,
                0.253
            ],
            "angle": 0,
            "content": "可以用深度优先搜索来建立连通简单图的生成树。我们将形成一个有根树，而这个生成树将是这个有根树的基本无向图。任意选择图中一个顶点作为根。通过依次添加边来形成从这个顶点开始的通路，其中每条新边都与通路上的最后一个顶点以及还不在通路上的一个顶点相关联。继续尽可能地添加边到这条通路。若这条通路经过图的所有顶点，则由这条通路组成的树就是生成树。不过，若这条通路没有经过图中的所有顶点，则必须添加其他的顶点和边。退到通路中的倒数第二个顶点，若有可能，则形成从这个顶点开始的经过还没有访问过的顶点的通路。若不能这样做，则后退到通路中的另一个顶点，即在通路里后退两个顶点，然后再试。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.255,
                0.906,
                0.329
            ],
            "angle": 0,
            "content": "重复这个过程，从所访问过的最后一个顶点开始，在通路上一次后退一个顶点，只要有可能就形成新的通路，直到不能添加更多的边为止。因为这个图有有穷的边数并且是连通的，所以这个过程以产生生成树而告终。在这个算法的一个阶段上通路末端的顶点将是有根树中的树叶，而在其上开始构造一条通路的顶点将是内点。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.331,
                0.906,
                0.386
            ],
            "angle": 0,
            "content": "读者应当注意这个过程的递归本质。另外，注意若图中的顶点是排序的，则当总是选择在该顺序里可用的第一个顶点时，在这个过程的每个阶段上对边的选择就全都是确定的。不过，将不总是明显地对图的顶点排序。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.388,
                0.904,
                0.424
            ],
            "angle": 0,
            "content": "深度优先搜索也称为回溯，因为这个算法返回以前访问过的顶点以便添加边。例3说明了回溯。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.429,
                0.504,
                0.467
            ],
            "angle": 0,
            "content": "例3 用深度优先搜索来找出图6所示图 \\(G\\) 的生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.47,
                0.504,
                0.582
            ],
            "angle": 0,
            "content": "解图7显示了用深度优先搜索产生 \\(G\\) 的生成树的步骤。任意地从顶点 \\(f\\) 开始。一条通路是这样建立的：依次添加与还不在通路上的顶点相关联的边，只要有可能就这样做。这样就产生通路 \\(f, g, h, k, j\\) （注意也可能建立其他的通路）。下一步，回溯到 \\(k\\) 。不存在从 \\(k\\) 开始，包含还没"
        },
        {
            "type": "image",
            "bbox": [
                0.524,
                0.429,
                0.88,
                0.549
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.657,
                0.558,
                0.751,
                0.572
            ],
            "angle": 0,
            "content": "图6 图 \\(G\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.584,
                0.909,
                0.621
            ],
            "angle": 0,
            "content": "有访问过的顶点的通路。所以回溯到 \\(h\\) 。形成通路 \\(h\\) ，\\(i\\) 。然后回溯到 \\(g\\) ，然后再回溯到 \\(f\\) 。从 \\(f\\) 建立通路 \\(f\\) ，\\(d\\) ，\\(e\\) ，\\(c\\) ，\\(a\\) 。然后再回溯到 \\(c\\) 并且形成通路 \\(c\\) ，\\(b\\) 。这样就产生了生成树。"
        },
        {
            "type": "image",
            "bbox": [
                0.199,
                0.625,
                0.778,
                0.761
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.381,
                0.765,
                0.585,
                0.78
            ],
            "angle": 0,
            "content": "图7 \\(G\\) 的深度优先搜索"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.791,
                0.505,
                0.864
            ],
            "angle": 0,
            "content": "一个图的深度优先搜索所选择的边称为树边。这个图所有其他的边都必然连接一个顶点与这个顶点在树中的祖先或后代。这些边都称为背边（练习43要求证明这个事实）。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.87,
                0.505,
                0.928
            ],
            "angle": 0,
            "content": "例4图8中突出了从顶点 \\(f\\) 开始的深度优先搜索所找到的树边，用粗线显示这些树边。用细黑线显示背边 \\((e,f)\\) 和 \\((f,h)\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.527,
                0.791,
                0.882,
                0.912
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.536,
                0.914,
                0.871,
                0.929
            ],
            "angle": 0,
            "content": "图8例4中深度优先搜索的树边和背边"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.14,
                0.028,
                0.176,
                0.042
            ],
            "angle": 0,
            "content": "696"
        },
        {
            "type": "header",
            "bbox": [
                0.222,
                0.027,
                0.298,
                0.043
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.083,
                0.959,
                0.176
            ],
            "angle": 0,
            "content": "我们已经解释了如何用深度优先搜索来求图的生成树。但是，迄今为止的讨论还没有指出深度优先搜索的递归本质。为了弄清楚深度优先搜索的递归本质，需要几个术语。当执行深度优先搜索的步骤时，当把顶点 \\( v \\) 加入树时说从顶点 \\( v \\) 开始探索，当最后一次回溯回到 \\( v \\) 时说从顶点 \\( v \\) 结束探索。理解算法的递归本质所需要的关键事实是，当加入连接顶点 \\( v \\) 到顶点 \\( w \\) 的边时，在回到 \\( v \\) 完成从 \\( v \\) 的探索之前就结束了从 \\( w \\) 的探索。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.179,
                0.96,
                0.291
            ],
            "angle": 0,
            "content": "算法1构造了带顶点 \\(v_{1}\\)，…，\\(v_{n}\\) 的图 \\(G\\) 的生成树，首先选择顶点 \\(v_{1}\\) 作为树根。开始时令 \\(T\\) 是只有这一个顶点的树。在每个步骤，加入一个新顶点到 \\(T\\) 以及从已在 \\(T\\) 中的一个顶点到这个新顶点的一条边，并且从这个新顶点开始探索。注意当算法完成时，\\(T\\) 没有简单回路，因为没有加入连接两个已在树中的顶点的边。另外，\\(T\\) 在构造时保持连通（用数学归纳法可以轻而易举地证明最后这两个事实）。由于 \\(G\\) 是连通的，所以 \\(G\\) 的每个顶点都被算法访问到并加入到树中（读者可以验证）。因此 \\(T\\) 是 \\(G\\) 的生成树。"
        },
        {
            "type": "title",
            "bbox": [
                0.127,
                0.309,
                0.312,
                0.325
            ],
            "angle": 0,
            "content": "算法1 深度优先搜索"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.327,
                0.521,
                0.342
            ],
            "angle": 0,
            "content": "procedure DFS \\((G\\) ：带顶点 \\(v_{1}\\) ，…， \\(v_{n}\\) 的连通图）"
        },
        {
            "type": "text",
            "bbox": [
                0.129,
                0.345,
                0.331,
                0.36
            ],
            "angle": 0,
            "content": "\\(T\\coloneqq\\) 只包含顶点 \\(v_{1}\\) 的树"
        },
        {
            "type": "text",
            "bbox": [
                0.129,
                0.364,
                0.199,
                0.378
            ],
            "angle": 0,
            "content": "visit(v1)"
        },
        {
            "type": "text",
            "bbox": [
                0.129,
                0.388,
                0.361,
                0.403
            ],
            "angle": 0,
            "content": "procedure visit(v: \\(G\\) 的顶点）"
        },
        {
            "type": "text",
            "bbox": [
                0.129,
                0.405,
                0.478,
                0.42
            ],
            "angle": 0,
            "content": "for与 \\(v\\) 相邻并且还不在 \\(T\\) 中的每个顶点 \\(\\boldsymbol{w}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.156,
                0.423,
                0.392,
                0.437
            ],
            "angle": 0,
            "content": "加入顶点 \\(w\\) 和边 \\(\\{v, w\\}\\) 到 \\(T\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.157,
                0.442,
                0.223,
                0.455
            ],
            "angle": 0,
            "content": "visit(w)"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.475,
                0.96,
                0.605
            ],
            "angle": 0,
            "content": "现在分析深度优先搜索算法的计算复杂度。关键事实是对于每个顶点 \\(v\\) 来说，当在搜索中首次遇到顶点 \\(v\\) 时，就调用过程 \\(\\operatorname{visit}(v)\\) 并且以后不再调用这个过程。假设 \\(G\\) 的邻接表是可用的（参见10.3节），那么求出与 \\(v\\) 相邻的顶点不需要任何计算。当遵循算法的步骤时，至多检查每条边两次以确定是否加入这条边及其一个端点到树中。因此，过程DFS用 \\(O(e)\\) 或 \\(O(n^{2})\\) 个步骤来构造一个生成树，其中 \\(e\\) 和 \\(n\\) 分别是 \\(G\\) 的边数和顶点数。（注意一个步骤包括：检查一个顶点是否已在正在构造的树中，如果这个顶点还不在树中，则加入这个顶点和对应的边。还利用了不等式 \\(e \\leqslant n(n - 1) / 2\\) ，对于任意简单图来说这个不等式都成立。）"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.608,
                0.96,
                0.682
            ],
            "angle": 0,
            "content": "深度优先搜索可以作为解决许多不同问题的算法的基础。例如，可以用来求图中的通路和回路、求图的连通分支，并且可以用来求连通图的割点。将要看到，深度优先搜索是用来搜索计算困难问题的解的回溯技术的基础（参见[GrYe05]、[Ma89]和[CoLeRiSt09]对基于深度优先搜索算法的讨论）。"
        },
        {
            "type": "title",
            "bbox": [
                0.115,
                0.692,
                0.342,
                0.709
            ],
            "angle": 0,
            "content": "11.4.3 宽度优先搜索"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.712,
                0.96,
                0.747
            ],
            "angle": 0,
            "content": "也可以通过使用宽度优先搜索来产生简单图的生成树。同样，将构造一个有根树，而这个有根树的基本无向图就形成了生成树。从图的顶点中任意地选择一个根。然后添加与这个顶点"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.75,
                0.714,
                0.901
            ],
            "angle": 0,
            "content": "相关联的所有边。在这个阶段所添加的新顶点成为生成树在第1层上的顶点。将新顶点任意排序。下一步，按顺序访问第1层上的每个顶点，只要不产生简单回路，就将与这个顶点相关联的每条边添加到树中。任意排序第一层的每个顶点的孩子。这样就产生了树在第2层上的顶点。遵循相同的过程，直到已经添加了树中的所有顶点。因为在图中的边数是有限的，所以这个过程会终止。在产生了包含图中每一个顶点的树之后，生成树也就产生了。例5给出了宽度优先搜索的一个例子。"
        },
        {
            "type": "image",
            "bbox": [
                0.727,
                0.752,
                0.962,
                0.911
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.8,
                0.915,
                0.891,
                0.928
            ],
            "angle": 0,
            "content": "图9 图 \\(G\\)"
        },
        {
            "type": "footer",
            "bbox": [
                0.036,
                0.903,
                0.099,
                0.92
            ],
            "angle": 0,
            "content": "Extra Examples"
        },
        {
            "type": "text",
            "bbox": [
                0.152,
                0.907,
                0.633,
                0.924
            ],
            "angle": 0,
            "content": "例5 用宽度优先搜索来找出图9所示的图的生成树。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.765,
                0.039,
                0.873,
                0.054
            ],
            "angle": 0,
            "content": "树 697"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.095,
                0.904,
                0.189
            ],
            "angle": 0,
            "content": "解 图10显示了宽度优先搜索过程的各步骤。选择顶点 \\(e\\) 作为根。然后添加与 \\(e\\) 相关联的所有边，所以添加了从 \\(e\\) 到 \\(b\\)、\\(d\\)、\\(f\\) 和 \\(i\\) 的边。这4个顶点都是在树的第1层上。下一步，添加从第1层上的顶点到还不在树上的相邻顶点的边。因此，添加从 \\(b\\) 到 \\(a\\) 和 \\(c\\) 的边，从 \\(d\\) 到 \\(h\\)，从 \\(f\\) 到 \\(j\\) 和 \\(g\\)，以及从 \\(i\\) 到 \\(k\\) 的边。新顶点 \\(a\\)、\\(c\\)、\\(h\\)、\\(j\\)、\\(g\\) 和 \\(k\\) 都是在第2层上。下一步，添加从这些顶点到还不在树上的相邻顶点的边。这样就添加从 \\(g\\) 到 \\(l\\) 以及从 \\(k\\) 到 \\(m\\) 的边。"
        },
        {
            "type": "image",
            "bbox": [
                0.116,
                0.192,
                0.843,
                0.328
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.372,
                0.332,
                0.585,
                0.348
            ],
            "angle": 0,
            "content": "图10 \\(G\\) 的宽度优先搜索"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.36,
                0.903,
                0.417
            ],
            "angle": 0,
            "content": "算法2的伪码描述了宽度优先搜索。在这个算法中，假设连通图 \\(G\\) 的顶点排序为 \\(\\nu_{1}\\)，…，\\(\\nu_{n}\\)。在算法中，我们用“处理”来描述这个过程：只要还没有产生简单回路，就加入与正在处理的当前顶点相邻的新顶点和对应的边到树中。"
        },
        {
            "type": "title",
            "bbox": [
                0.068,
                0.436,
                0.253,
                0.452
            ],
            "angle": 0,
            "content": "算法2 宽度优先搜索"
        },
        {
            "type": "text",
            "bbox": [
                0.068,
                0.454,
                0.461,
                0.47
            ],
            "angle": 0,
            "content": "procedure BFS( \\(G\\) ：带顶点 \\(v_{1}\\) ，…， \\(v_{n}\\) 的连通图）"
        },
        {
            "type": "text",
            "bbox": [
                0.07,
                0.472,
                0.273,
                0.488
            ],
            "angle": 0,
            "content": "\\(T:=\\) 只包含顶点 \\(v_{1}\\) 的树"
        },
        {
            "type": "text",
            "bbox": [
                0.07,
                0.492,
                0.154,
                0.506
            ],
            "angle": 0,
            "content": "\\(L:=\\) 空表"
        },
        {
            "type": "text",
            "bbox": [
                0.07,
                0.509,
                0.341,
                0.524
            ],
            "angle": 0,
            "content": "把 \\( v_{1} \\) 放入尚未处理顶点的表 \\( L \\) 中"
        },
        {
            "type": "text",
            "bbox": [
                0.07,
                0.528,
                0.172,
                0.542
            ],
            "angle": 0,
            "content": "while \\(L\\) 非空"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.545,
                0.284,
                0.559
            ],
            "angle": 0,
            "content": "删除 \\(L\\) 中第一个顶点 \\(\\mathcal{V}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.563,
                0.254,
                0.577
            ],
            "angle": 0,
            "content": "for \\(v\\) 的每个邻居 \\(\\omega\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.125,
                0.58,
                0.395,
                0.594
            ],
            "angle": 0,
            "content": "if \\(w\\) 既不在 \\(L\\) 中也不在 \\(T\\) 中 then"
        },
        {
            "type": "text",
            "bbox": [
                0.153,
                0.598,
                0.331,
                0.612
            ],
            "angle": 0,
            "content": "加入 \\(w\\) 到表 \\(L\\) 的末尾"
        },
        {
            "type": "text",
            "bbox": [
                0.154,
                0.616,
                0.351,
                0.63
            ],
            "angle": 0,
            "content": "加入 \\(w\\) 和边 \\(\\{v, w\\}\\) 到 \\(T\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.651,
                0.905,
                0.727
            ],
            "angle": 0,
            "content": "现在分析宽度优先搜索的计算复杂度。对于图中的每个顶点 \\(v\\) 来说，检查所有与 \\(v\\) 相邻的顶点并加入每个尚未访问过的顶点到树 \\(T\\) 中。假设图的邻接表是可用的，确定哪些顶点与给定顶点相邻就不需要任何计算。如同在深度优先搜索算法的分析中那样，我们检查每条边至多两次来确定是否应当加入这条边及其尚未在树中的端点。所以宽度优先搜索算法使用 \\(O(e)\\) 或 \\(O(n^{2})\\) 个步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.729,
                0.904,
                0.784
            ],
            "angle": 0,
            "content": "宽度优先搜索是图论中最有用的算法之一。特别是，它可以作为求解各种问题的算法的基础。例如：求图的连通分支的算法、判断图是否是二分图的算法以及求图中两个顶点之间具有最少边数的通路的算法，这些算法都可以使用宽度优先搜索进行构造。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.787,
                0.904,
                0.843
            ],
            "angle": 0,
            "content": "宽度优先搜索与深度优先搜索的比较我们介绍了两种广泛使用的用于构建图的生成树算法——宽度优先搜索(BFS)和深度优先搜索(DFS)搜索。当给定一个连通图时，两种算法都可用于构建生成树。但为什么有可能用一个比另一个更好呢？"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.845,
                0.905,
                0.94
            ],
            "angle": 0,
            "content": "虽然BFS和DFS都可以用来解决相同的问题，但考虑到理论原因和实际原因，我们需要在两者之间做出选择。解决特定类型的问题时，这些搜索算法中的一种可能比其他算法更容易应用，或者能提供更多的洞察力。对于有些问题，BFS比DFS更容易使用，因为BFS对图中的顶点进行了分层，这告知我们顶点离根有多远。此外，边连接了同一层或相邻层的顶点（参见练习34）。另一方面，有许多类型的问题使用DFS解决更自然，例如在例 \\(6\\sim 8\\) 中讨论的问"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.137,
                0.039,
                0.172,
                0.052
            ],
            "angle": 0,
            "content": "698"
        },
        {
            "type": "header",
            "bbox": [
                0.218,
                0.038,
                0.294,
                0.053
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.095,
                0.953,
                0.13
            ],
            "angle": 0,
            "content": "题。一般来说，当我们需要更深层地搜索图，而不是系统地逐层搜索时，DFS 是一个更好的选择。使用 DFS 时获得的结构（参见练习 51），也可以在解决问题时使用。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.133,
                0.955,
                0.226
            ],
            "angle": 0,
            "content": "BFS和DFS在实践中都得到了广泛的应用。选择哪一个经常取决于实现细节，例如使用的数据结构。时间和空间的考虑是最重要的，尤其是当正在解决的问题涉及巨大的图时。同时也要记住，在使用图的搜索解决问题时，我们经常不必完成找到一棵生成树的任务。当我们在稠密的图上使用BFS时，在逐层搜索图的过程中，会花费很多时间并使用大量的空间。在这种情况下，最好是使用DFS以快速到达远离根的顶点。然而，对于稀疏图，逐层搜索图可能更有效。"
        },
        {
            "type": "title",
            "bbox": [
                0.11,
                0.236,
                0.315,
                0.253
            ],
            "angle": 0,
            "content": "11.4.4 回溯的应用"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.256,
                0.955,
                0.368
            ],
            "angle": 0,
            "content": "有些问题只能通过执行对所有可行解的穷举搜索来解决。系统地搜索出一个解的一种方式是使用决策树，其中每个内点都表示一次决策，而每个树叶都表示一个可行解。为了通过回溯来求出一个解，首先尽可能地做出一系列决策来尝试得出一个解。可以用决策树里的通路来表示决策序列。一旦知道了决策序列的任何扩展都不能得出解，就回溯到父母顶点并且若有可能，则用另一个决策序列来尝试得出一个解。继续这个过程，直到找到一个解，或者证明没有解存在为止。例6到例8说明了回溯的用处。"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.373,
                0.773,
                0.39
            ],
            "angle": 0,
            "content": "例6 图着色 如何用回溯来判定是否可以用 \\(n\\) 种颜色给一个图着色？"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.395,
                0.955,
                0.563
            ],
            "angle": 0,
            "content": "解 以下面的方式用回溯来解决这个问题。首先选择某个顶点 \\(a\\) 并且指定它的颜色为1。然后挑选第二个顶点 \\(b\\) ，而且若 \\(b\\) 不与 \\(a\\) 相邻，则指定它的颜色为1。否则，指定 \\(b\\) 的颜色为2。然后来到第三个顶点 \\(c\\) 。若有可能，则对 \\(c\\) 用颜色1。否则若有可能，则用颜色2。只有当颜色1和颜色2都不能用时才使用颜色3。继续这个过程，只要有可能就为每个新顶点指定 \\(n\\) 种颜色中的一种，而且总是使用表中第一种允许的颜色。若遇到不能用 \\(n\\) 种颜色中任何一种来着色的顶点时，则回溯到最后一次所指定的顶点，并且若有可能就用表中下一种允许的颜色改变最后着色的顶点的颜色。若不可能改变这个颜色，则再回溯到更前面指定的顶点，一次后退一步，直到有可能改变一个顶点的颜色为止。然后只要有可能就继续指定新顶点的颜色。若使用 \\(n\\) 种颜色的着色存在，则可以通过回溯来产生（但是这个过程是极其低效的）。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.566,
                0.955,
                0.621
            ],
            "angle": 0,
            "content": "具体地说，考虑用3种颜色来着色图11所示的图。图11所示的树说明了如何用回溯来构造3着色。在这个过程中，首先用红色，其次用蓝色，最后用绿色。显然不用回溯也可以求解这个简单的例子，这里只是为了能够比较好地说明这项技术。"
        },
        {
            "type": "image",
            "bbox": [
                0.212,
                0.627,
                0.856,
                0.867
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.438,
                0.873,
                0.633,
                0.889
            ],
            "angle": 0,
            "content": "图11 用回溯给图着色"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.901,
                0.957,
                0.937
            ],
            "angle": 0,
            "content": "在这棵树中，从根开始的表示指定红色给 \\(a\\) 的最初的通路，导致 \\(a\\) 红色、\\(b\\) 蓝色、\\(c\\) 红色而 \\(d\\) 绿色的着色。当以这种方式来着色 \\(a\\)、\\(b\\)、\\(c\\) 和 \\(d\\) 时，就不可能用三种颜色中的任何一种来着色 \\(e\\)。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.775,
                0.034,
                0.88,
                0.047
            ],
            "angle": 0,
            "content": "树 699"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.088,
                0.909,
                0.125
            ],
            "angle": 0,
            "content": "所以，回溯到表示这个着色的顶点的父母。因为没有其他颜色可以用在 \\(d\\) 上，所以再回溯一层。然后改变 \\(c\\) 的颜色为绿色。通过接着指定红色给 \\(d\\) 和绿色给 \\(e\\) ，就获得这个图的着色。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.13,
                0.909,
                0.17
            ],
            "angle": 0,
            "content": "例7 \\(n\\) 皇后问题 \\(n\\) 皇后问题问：在 \\(n \\times n\\) 棋盘上如何放置 \\(n\\) 个皇后，使得没有两个皇后可以互相攻击。如何用回溯来解决 \\(n\\) 皇后问题？"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.172,
                0.911,
                0.325
            ],
            "angle": 0,
            "content": "解为了解决这个问题，必须在 \\(n \\times n\\) 棋盘上找出 \\(n\\) 个位置，使得这些位置中没有两个皇后是在同一行上、同一列上或在同一斜线上（斜线是由对某个 \\(m\\) 来说满足 \\(i + j = m\\) 或对某个 \\(m\\) 来说满足 \\(i - j = m\\) 的所有位置的 \\((i, j)\\) 组成的）。将用回溯来解决 \\(n\\) 皇后问题。从空棋盘开始。在 \\(k + 1\\) 阶段，尝试在棋盘上第 \\(k + 1\\) 列里放置一个新皇后，其中在前 \\(k\\) 列里已经有了皇后。检查第 \\(k + 1\\) 列里的格子，从第一行的格子开始，寻找放置这个皇后的位置，使得它不与已经在棋盘上的皇后在同一行或在同一斜线上（已经知道它不在同一列里）。若不可能在第 \\(k + 1\\) 列里找到放置皇后的位置，则回溯到第 \\(k\\) 列里皇后放置的位置。在这一列里下一个允许的行里放置皇后，若这样的行存在。若没有这样的行存在，则继续回溯。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.328,
                0.911,
                0.422
            ],
            "angle": 0,
            "content": "具体地说，图12显示了四皇后问题的回溯解法。在这种解法里，在第一行第一列里放置一个皇后。然后在第二列的第三行里放置一个皇后。不过，这样就使得不可能在第三列里放置一个皇后。所以就回溯并且在第二列的第四行里放置一个皇后。当这样做时，就可以在第三列的第二行里放置一个皇后。但是没有办法在第四列里添加一个皇后。这说明当在第一行第一列里放置一个皇后时就得不出解。回溯到空棋盘，在第一列第二行里放置一个皇后。这样就得出图12所示的解。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.427,
                0.909,
                0.467
            ],
            "angle": 0,
            "content": "例8 子集之和 考虑下面的问题。给定一组正整数 \\(x_{1}, x_{2}, \\cdots, x_{n}\\) 的集合，求这组整数的集合的一个子集，使其和为 \\(M\\)。如何用回溯来解决这个问题？"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.47,
                0.909,
                0.526
            ],
            "angle": 0,
            "content": "解 从空无一个元素的和来开始。通过依次添加元素来构造这个和。若当添加这个序列里的一个整数到和里而这个和仍然小于 \\(M\\) 时，则子集中包含这个整数。若得出使得添加任何一个元素就大于 \\(M\\) 的一个和，则通过去掉这个和的最后一个元素来回溯。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.529,
                0.832,
                0.545
            ],
            "angle": 0,
            "content": "图13显示了下面这个问题的回溯解法，求{31，27，15，11，7，5}的一个和等于39的子集。"
        },
        {
            "type": "image",
            "bbox": [
                0.089,
                0.552,
                0.424,
                0.908
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.132,
                0.917,
                0.38,
                0.932
            ],
            "angle": 0,
            "content": "图12 四皇后问题的回溯解法"
        },
        {
            "type": "image",
            "bbox": [
                0.465,
                0.696,
                0.895,
                0.909
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.561,
                0.917,
                0.802,
                0.933
            ],
            "angle": 0,
            "content": "图13 用回溯求等于39的和"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.133,
                0.034,
                0.169,
                0.048
            ],
            "angle": 0,
            "content": "700"
        },
        {
            "type": "header",
            "bbox": [
                0.213,
                0.033,
                0.29,
                0.049
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "title",
            "bbox": [
                0.106,
                0.097,
                0.445,
                0.116
            ],
            "angle": 0,
            "content": "11.4.5 有向图中的深度优先搜索"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.118,
                0.953,
                0.21
            ],
            "angle": 0,
            "content": "可以轻而易举地修改深度优先搜索和宽度优先搜索，使得以有向图作为输入时它们也能运行。但是，输出不一定是生成树，而可能是森林。在这两个算法中，只有当一条边从正在访问的顶点出发并且到一个尚未加入的顶点时才加入这条边。如果在其中任何一个算法的某个阶段找不到从已经加入的顶点到尚未加入的顶点的边，则算法加入的下一个顶点成为生成森林中一个新树的根。这一点在例9中解释。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.215,
                0.746,
                0.234
            ],
            "angle": 0,
            "content": "例9 给定图14a所示的图作为输入，深度优先搜索的输出是什么？"
        },
        {
            "type": "image",
            "bbox": [
                0.171,
                0.238,
                0.51,
                0.404
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.334,
                0.415,
                0.353,
                0.426
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "image",
            "bbox": [
                0.546,
                0.245,
                0.727,
                0.404
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.734,
                0.248,
                0.886,
                0.404
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.713,
                0.415,
                0.731,
                0.426
            ],
            "angle": 0,
            "content": "b)"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.405,
                0.432,
                0.655,
                0.447
            ],
            "angle": 0,
            "content": "图14 有向图的深度优先搜索"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.454,
                0.955,
                0.528
            ],
            "angle": 0,
            "content": "解 从顶点 \\(a\\) 开始深度优先搜索并且加入顶点 \\(b\\)、\\(c\\) 和 \\(g\\) 以及相对应的边，直到无路可走。回溯到 \\(c\\)，但是仍然无路可走，于是回溯到 \\(b\\)，这里加入顶点 \\(f\\) 和 \\(e\\) 以及对应的边。回溯最终又回到 \\(a\\)。然后在 \\(d\\) 开始一个新的树并且加入顶点 \\(h\\)、\\(l\\)、\\(k\\) 和 \\(j\\) 以及对应的边。回溯到 \\(k\\)，然后到 \\(l\\)，然后到 \\(h\\) 并且回到 \\(d\\)。最后，在 \\(i\\) 开始一个新的树，完成深度优先搜索。输出如图14b所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.53,
                0.953,
                0.585
            ],
            "angle": 0,
            "content": "有向图中的深度优先搜索是许多算法的基础（参见[GrYe05]、[Ma89]和[CoLeRiSt09]）。它可以用来确定有向图是否具有回路，可以用来完成图的拓扑排序，也可以用来求有向图的强连通分支。"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.587,
                0.778,
                0.604
            ],
            "angle": 0,
            "content": "用深度优先搜索和宽度优先搜索在网络搜索引擎上的应用来结束本节。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.608,
                0.955,
                0.819
            ],
            "angle": 0,
            "content": "例10 网络蜘蛛 为了给网站建立索引，Google和Yahoo等著名的搜索引擎从已知的网站开始系统地搜索网络。这些搜索引擎使用所谓的网络蜘蛛（或网络爬虫、网络机器人）的程序来访问网站并且分析其内容。网络蜘蛛同时使用深度优先搜索和宽度优先搜索来创建索引。如10.1节例5所述，可以用所谓的网络图的有向图来为网页和网页之间的链接建立模型。用顶点表示网页，用有向边表示链接。利用深度优先搜索，选择一个初始的网页，沿着一个链接（如果存在这样的链接的话）到达第二个网页，沿着第二个网页的一个链接（如果存在这样的链接）到达第三个网页，等等，直到找到一个没有新的链接的网页为止。然后使用回溯来检查前面阶段的链接去寻找新的链接，等等。（由于实际限制，网络蜘蛛在深度优先搜索中的搜索深度是有限的。）利用宽度优先搜索，选择一个初始的网页并且沿着这个网页上的一个链接到达第二个网页，然后沿着初始网页上的第二个链接（如果存在），以此类推，直到已经走过了初始网页上的所有链接为止。然后逐页地沿着下一层网页上的链接，以此类推。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.82,
                0.955,
                0.894
            ],
            "angle": 0,
            "content": "搜索引擎已经为利用BFS和DFS的网络爬虫开发出了复杂的策略。（谷歌的网络爬虫被称为谷歌机器人。）它们使用BFS，从被称为种子的高质量的网页开始，并搜索这些网页上的所有链接。随着网络爬虫的继续，它会将访问的新页面上所有链接的URL添加到爬行边界。这些URL根据特定策略进行排序，以决定搜索这些网页的顺序。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.896,
                0.955,
                0.933
            ],
            "angle": 0,
            "content": "选择好种子后，利用谷歌的方法可以很快到达有许多指向它们的链接的高质量页面。但是，到达的页面质量随着Web爬网的继续而减少。这种方法能很好地到达流行的网页，但却"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.765,
                0.032,
                0.87,
                0.046
            ],
            "angle": 0,
            "content": "树 701"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.087,
                0.902,
                0.142
            ],
            "angle": 0,
            "content": "不能到达那些有用的但不太流行的网页。如果种子网页无法产生好的结果，则可从其他种子或网页开始，使用DFS查找高质量的候选页面。此外，当BFS被限制特定层数时，可使用DFS到达BFS不能到达的部分网页。"
        },
        {
            "type": "title",
            "bbox": [
                0.055,
                0.154,
                0.099,
                0.168
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.17,
                0.687,
                0.203
            ],
            "angle": 0,
            "content": "1. 为了产生生成树，必须从带有 \\(n\\) 个顶点和 \\(m\\) 条边的连通图里删除多少条边？在练习 \\(2 \\sim 6\\) 中，通过删除简单回路里的边来求所示图的生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.208,
                0.07,
                0.22
            ],
            "angle": 0,
            "content": "2."
        },
        {
            "type": "image",
            "bbox": [
                0.074,
                0.209,
                0.256,
                0.298
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.27,
                0.209,
                0.286,
                0.22
            ],
            "angle": 0,
            "content": "3."
        },
        {
            "type": "image",
            "bbox": [
                0.291,
                0.209,
                0.541,
                0.33
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.555,
                0.209,
                0.571,
                0.22
            ],
            "angle": 0,
            "content": "4."
        },
        {
            "type": "image",
            "bbox": [
                0.577,
                0.21,
                0.864,
                0.32
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.341,
                0.07,
                0.352
            ],
            "angle": 0,
            "content": "5."
        },
        {
            "type": "image",
            "bbox": [
                0.075,
                0.343,
                0.337,
                0.495
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.37,
                0.341,
                0.385,
                0.352
            ],
            "angle": 0,
            "content": "6."
        },
        {
            "type": "image",
            "bbox": [
                0.391,
                0.343,
                0.684,
                0.505
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.514,
                0.272,
                0.528
            ],
            "angle": 0,
            "content": "7. 求下面每个图的生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.077,
                0.533,
                0.119,
                0.546
            ],
            "angle": 0,
            "content": "a) \\(K_{5}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.277,
                0.533,
                0.328,
                0.546
            ],
            "angle": 0,
            "content": "b) \\(K_{4,4}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.479,
                0.533,
                0.528,
                0.546
            ],
            "angle": 0,
            "content": "c) \\(K_{1,6}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.552,
                0.117,
                0.564
            ],
            "angle": 0,
            "content": "d) \\(Q_{3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.277,
                0.552,
                0.312,
                0.564
            ],
            "angle": 0,
            "content": "e) \\(C_5\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.478,
                0.552,
                0.519,
                0.564
            ],
            "angle": 0,
            "content": "f) \\(W_{5}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.568,
                0.474,
                0.583
            ],
            "angle": 0,
            "content": "在练习 \\(8\\sim 10\\) 中，画出所给的简单图的所有生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.588,
                0.07,
                0.6
            ],
            "angle": 0,
            "content": "8."
        },
        {
            "type": "image",
            "bbox": [
                0.075,
                0.589,
                0.19,
                0.649
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.203,
                0.588,
                0.218,
                0.6
            ],
            "angle": 0,
            "content": "9."
        },
        {
            "type": "image",
            "bbox": [
                0.223,
                0.589,
                0.537,
                0.682
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.55,
                0.588,
                0.574,
                0.6
            ],
            "angle": 0,
            "content": "10."
        },
        {
            "type": "image",
            "bbox": [
                0.579,
                0.589,
                0.846,
                0.67
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.69,
                0.452,
                0.705
            ],
            "angle": 0,
            "content": "* 11. 下面的每个简单图各有多少棵不同的生成树？"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.71,
                0.128,
                0.723
            ],
            "angle": 0,
            "content": "a) \\(K_{3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.314,
                0.71,
                0.354,
                0.723
            ],
            "angle": 0,
            "content": "b) \\(K_{4}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.54,
                0.71,
                0.59,
                0.723
            ],
            "angle": 0,
            "content": "c) \\(K_{2,2}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.702,
                0.71,
                0.739,
                0.723
            ],
            "angle": 0,
            "content": "d) \\(C_5\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.727,
                0.471,
                0.742
            ],
            "angle": 0,
            "content": "* 12. 下面的每个简单图各有多少棵不同构的生成树？"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.746,
                0.128,
                0.759
            ],
            "angle": 0,
            "content": "a) \\(K_{3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.314,
                0.747,
                0.354,
                0.759
            ],
            "angle": 0,
            "content": "b) \\(K_{4}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.541,
                0.747,
                0.579,
                0.759
            ],
            "angle": 0,
            "content": "c) \\(K_{5}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.764,
                0.902,
                0.797
            ],
            "angle": 0,
            "content": "在练习 \\(13\\sim 15\\) 中，用深度优先搜索来构造所给的简单图的生成树。选择 \\(a\\) 作为这棵生成树的根并且假定顶点都以字母顺序来排序。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.802,
                0.08,
                0.814
            ],
            "angle": 0,
            "content": "13."
        },
        {
            "type": "image",
            "bbox": [
                0.085,
                0.804,
                0.432,
                0.884
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.501,
                0.802,
                0.526,
                0.814
            ],
            "angle": 0,
            "content": "14."
        },
        {
            "type": "image",
            "bbox": [
                0.531,
                0.804,
                0.869,
                0.928
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.141,
                0.03,
                0.178,
                0.045
            ],
            "angle": 0,
            "content": "702"
        },
        {
            "type": "header",
            "bbox": [
                0.221,
                0.029,
                0.298,
                0.046
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.087,
                0.138,
                0.1
            ],
            "angle": 0,
            "content": "15."
        },
        {
            "type": "image",
            "bbox": [
                0.141,
                0.088,
                0.567,
                0.234
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.239,
                0.87,
                0.255
            ],
            "angle": 0,
            "content": "16. 用宽度优先搜索来构造练习 \\(13 \\sim 15\\) 中每个简单图的生成树。选择 \\(a\\) 作为每棵生成树的根。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.256,
                0.472,
                0.271
            ],
            "angle": 0,
            "content": "17. 用深度优先搜索求下列这些图的生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.273,
                0.641,
                0.289
            ],
            "angle": 0,
            "content": "a) \\(W_{6}\\) （参见10.2节例7），从度数为6的顶点开始 b) \\(K_{5}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.291,
                0.638,
                0.306
            ],
            "angle": 0,
            "content": "c) \\(K_{3,4}\\)，从度数为3的顶点开始 d) \\(Q_{3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.308,
                0.536,
                0.323
            ],
            "angle": 0,
            "content": "18. 用宽度优先搜索求练习17中的每个图的生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.325,
                0.959,
                0.356
            ],
            "angle": 0,
            "content": "19. 描述轮图 \\( W_{n} \\) 的宽度优先搜索和深度优先搜索所产生的树，从度数为 \\( n \\) 的顶点开始，其中 \\( n \\) 是整数满足 \\( n \\geq 3 \\) （参见10.2节例7）。说明答案的合理性。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.359,
                0.957,
                0.39
            ],
            "angle": 0,
            "content": "20. 描述完全图 \\(K_{n}\\) 的宽度优先搜索和深度优先搜索所产生的树，从度数为 \\(m\\) 的顶点开始，其中 \\(n\\) 是正整数。说明答案的合理性。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.393,
                0.96,
                0.424
            ],
            "angle": 0,
            "content": "21. 描述完全二分图 \\(K_{m,n}\\) 的宽度优先搜索和深度优先搜索所产生的树，从度数为 \\(m\\) 的顶点开始，其中 \\(m\\) 和 \\(n\\) 都是正整数。说明答案的合理性。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.427,
                0.816,
                0.442
            ],
            "angle": 0,
            "content": "22. 描述 \\(n\\) 立方体图 \\(Q_{n}\\) 的宽度优先搜索和深度优先搜索所产生的树，其中 \\(n\\) 是正整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.444,
                0.959,
                0.476
            ],
            "angle": 0,
            "content": "23. 假定一家航空公司必须压缩它的航班以节省资金。若它原来的航线如下图所示，则可以中断哪些飞行以保持在所有城市对之间的服务（其中从一个城市飞往另一个城市可能需要换乘飞机）？"
        },
        {
            "type": "image",
            "bbox": [
                0.142,
                0.478,
                0.543,
                0.613
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.615,
                0.657,
                0.63
            ],
            "angle": 0,
            "content": "24. 解释如何用宽度优先搜索或深度优先搜索来排序连通图的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.632,
                0.957,
                0.664
            ],
            "angle": 0,
            "content": "* 25. 证明：在连通简单图里顶点 \\( v \\) 和 \\( u \\) 之间的最短通路的长度，等于在以 \\( v \\) 为根的 \\( G \\) 的宽度优先生成树里 \\( u \\) 的层数。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.666,
                0.673,
                0.681
            ],
            "angle": 0,
            "content": "26. 用回溯来试验使用3种颜色对10.8节练习 \\(7\\sim 9\\) 中每个图的着色。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.683,
                0.472,
                0.698
            ],
            "angle": 0,
            "content": "27. 用回溯来对下面的 \\(n\\) 值解决 \\(n\\) 皇后问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.7,
                0.204,
                0.714
            ],
            "angle": 0,
            "content": "a) \\(n = 3\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.37,
                0.7,
                0.43,
                0.714
            ],
            "angle": 0,
            "content": "b) \\(n = 5\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.596,
                0.7,
                0.655,
                0.714
            ],
            "angle": 0,
            "content": "c) \\(n = 6\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.717,
                0.775,
                0.732
            ],
            "angle": 0,
            "content": "28. 用回溯来求集合 \\(\\{27, 24, 19, 14, 11, 8\\}\\) 的和为下列值的子集，若存在的话。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.734,
                0.185,
                0.747
            ],
            "angle": 0,
            "content": "a)20"
        },
        {
            "type": "text",
            "bbox": [
                0.37,
                0.735,
                0.411,
                0.747
            ],
            "angle": 0,
            "content": "b)41"
        },
        {
            "type": "text",
            "bbox": [
                0.596,
                0.735,
                0.636,
                0.747
            ],
            "angle": 0,
            "content": "c)60"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.751,
                0.601,
                0.766
            ],
            "angle": 0,
            "content": "29. 解释如何用回溯来找出图中的哈密顿通路或哈密顿回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.768,
                0.957,
                0.8
            ],
            "angle": 0,
            "content": "30. a) 解释如何用回溯来找出迷宫的出路，给定出发位置和出口位置。考虑把迷宫划分成位置，其中在每个位置上的移动包括四种可能性之一（上、下、右、左）。"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.802,
                0.643,
                0.817
            ],
            "angle": 0,
            "content": "b)找出在下面的迷宫里从标记为 \\(X\\) 的出发位置到出口的通路。"
        },
        {
            "type": "image",
            "bbox": [
                0.143,
                0.818,
                0.448,
                0.929
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.772,
                0.042,
                0.879,
                0.056
            ],
            "angle": 0,
            "content": "树 703"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.098,
                0.908,
                0.13
            ],
            "angle": 0,
            "content": "图 \\(G\\) 的生成森林是包含 \\(G\\) 的每个顶点的森林，使得当两个顶点在 \\(G\\) 里有通路时，这两个顶点就在同一个树里。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.133,
                0.401,
                0.148
            ],
            "angle": 0,
            "content": "31. 证明：每个有穷简单图都有生成森林。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.151,
                0.348,
                0.165
            ],
            "angle": 0,
            "content": "32. 在图的生成森林里有多少棵树？"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.168,
                0.864,
                0.183
            ],
            "angle": 0,
            "content": "33. 对带有 \\(n\\) 个顶点、\\(m\\) 条边和 \\(c\\) 个连通分支的图来说，必须删除多少条边才能产生它的生成森林？"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.186,
                0.907,
                0.217
            ],
            "angle": 0,
            "content": "34. 设 \\(G\\) 是连通图。证明：如果 \\(T\\) 是用宽度优先搜索构造的 \\(G\\) 的生成树，则 \\(G\\) 的不在 \\(T\\) 中的边必定连接这个生成树中在同一层上或相差一层的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.221,
                0.661,
                0.235
            ],
            "angle": 0,
            "content": "35. 解释如何使用宽度优先搜索求无向图中两个顶点之间最短通路的长度。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.239,
                0.807,
                0.253
            ],
            "angle": 0,
            "content": "36. 设计一个基于宽度优先搜索的算法，判断一个图是否有简单回路，如果有，找出该回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.256,
                0.568,
                0.271
            ],
            "angle": 0,
            "content": "37. 设计一个基于宽度优先搜索的算法，求一个图的连通分支。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.274,
                0.735,
                0.289
            ],
            "angle": 0,
            "content": "38. 解释如何使用宽度优先搜索和如何使用深度优先搜索判断一个图是否为二分图。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.292,
                0.422,
                0.306
            ],
            "angle": 0,
            "content": "39.哪种连通的简单图恰好只有一棵生成树？"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.309,
                0.568,
                0.324
            ],
            "angle": 0,
            "content": "40. 设计基于删除形成简单回路的边来构造图的生成树的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.327,
                0.513,
                0.342
            ],
            "angle": 0,
            "content": "41. 设计基于深度优先搜索来构造图的生成森林的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.344,
                0.513,
                0.359
            ],
            "angle": 0,
            "content": "42. 设计基于宽度优先搜索来构造图的生成森林的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.362,
                0.907,
                0.394
            ],
            "angle": 0,
            "content": "43. 设 \\(G\\) 是连通图。证明：如果 \\(T\\) 是用深度优先搜索构造的 \\(G\\) 的生成树，则 \\(G\\) 的不在 \\(T\\) 中的边必定是背边，换句话说，这条边必定连接一个顶点到这个顶点在 \\(T\\) 中的祖先或后代。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.397,
                0.608,
                0.412
            ],
            "angle": 0,
            "content": "44. 什么情况下，连通简单图的一条边一定在该图的每棵生成树中？"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.414,
                0.909,
                0.447
            ],
            "angle": 0,
            "content": "45. 对于哪些图来说，无论选择哪个顶点作为树根，深度优先搜索和宽度优先搜索都产生同样的生成树？说明答案的合理性。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.449,
                0.907,
                0.482
            ],
            "angle": 0,
            "content": "46. 用练习43证明：如果 \\(G\\) 是含有 \\(n\\) 个顶点的连通简单图并且 \\(G\\) 不含长度为 \\(k\\) 的简单通路，则 \\(G\\) 至多含有 \\((k - 1)n\\) 条边。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.485,
                0.864,
                0.5
            ],
            "angle": 0,
            "content": "47. 用数学归纳法证明：宽度优先搜索按照顶点在所得出的生成树中的层数的顺序来访问这些顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.503,
                0.907,
                0.535
            ],
            "angle": 0,
            "content": "48. 用伪码来描述深度优先搜索的一个变种，它把整数 \\( n \\) 指定给在搜索中访问的第 \\( n \\) 个顶点。证明：这个编号对应着生成树的前序遍历所建立的顶点的编号。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.538,
                0.818,
                0.553
            ],
            "angle": 0,
            "content": "49. 用伪码来描述宽度优先搜索的一个变种，它把整数 \\( m \\) 指定给在搜索中访问的第 \\( m \\) 个顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.555,
                0.907,
                0.588
            ],
            "angle": 0,
            "content": "* 50. 假设 \\(G\\) 是有向图并且 \\(T\\) 是用宽度优先搜索构造的生成树。证明：\\(G\\) 的每条边都连接同一层的两个顶点、连接一个顶点到低一层的一个顶点或者连接一个顶点到更高层的一个顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.591,
                0.909,
                0.641
            ],
            "angle": 0,
            "content": "51. 证明：如果 \\(G\\) 是有向图并且 \\(T\\) 是用深度优先搜索构造的生成树，则不在这个生成树上的每条边都是连接祖先到后代的前进边、连接后代到祖先的后退边，或者连接一个顶点到从前访问过的子树的一个顶点的交叉边。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.644,
                0.909,
                0.694
            ],
            "angle": 0,
            "content": "*52. 描述深度优先搜索的一个变种，当算法完全处理完一个顶点时，它把最小可用的正整数指定给这个顶点。证明：在这个编号中，每个顶点的编号大于其孩子的编号并且孩子的编号从左到右递增。设 \\(T_{1}\\) 和 \\(T_{2}\\) 都是一个图的生成树。\\(T_{1}\\) 和 \\(T_{2}\\) 之间的距离是 \\(T_{1}\\) 和 \\(T_{2}\\) 中非 \\(T_{1}\\) 和 \\(T_{2}\\) 所共有的边的数目。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.697,
                0.637,
                0.712
            ],
            "angle": 0,
            "content": "53. 求图2所示图 \\(G\\) 的在图3c和图4里所示的每对生成树之间的距离。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.714,
                0.909,
                0.746
            ],
            "angle": 0,
            "content": "* 54. 假定 \\(T_{1}\\)、\\(T_{2}\\) 和 \\(T_{3}\\) 都是简单图 \\(G\\) 的生成树。证明：在 \\(T_{1}\\) 和 \\(T_{3}\\) 之间的距离不超过 \\(T_{1}\\) 和 \\(T_{2}\\) 之间的距离与 \\(T_{2}\\) 和 \\(T_{3}\\) 之间的距离的和。"
        },
        {
            "type": "text",
            "bbox": [
                0.04,
                0.749,
                0.91,
                0.8
            ],
            "angle": 0,
            "content": "**55. 假定 \\(T_{1}\\) 和 \\(T_{2}\\) 都是简单图 \\(G\\) 的生成树。另外，假定 \\(e_{1}\\) 是在 \\(T_{1}\\) 里但不在 \\(T_{2}\\) 里的一条边。证明：存在在 \\(T_{2}\\) 里但不在 \\(T_{1}\\) 里的一条边 \\(e_{2}\\)，使得若从 \\(T_{1}\\) 里删除 \\(e_{1}\\) 而添加 \\(e_{2}\\) 到 \\(T_{1}\\) 里，则 \\(T_{1}\\) 仍然是生成树，并且若从 \\(T_{2}\\) 里删除 \\(e_{2}\\) 而添加 \\(e_{1}\\) 到 \\(T_{2}\\) 里，则 \\(T_{2}\\) 仍然是生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.802,
                0.904,
                0.835
            ],
            "angle": 0,
            "content": "* 56. 证明：通过依次删除一条边而添加另外一条边，就有可能从任何一个生成树得出一个生成树的序列。有向图的有根生成树是由这个图的边组成的有根树，使得这个图的每个顶点都是树中一条边的终点。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.838,
                0.885,
                0.853
            ],
            "angle": 0,
            "content": "57. 对10.5节练习 \\(18\\sim 23\\) 中的每个有向图来说，求这个图的有根生成树，或者确定不存在这样的树。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.856,
                0.85,
                0.871
            ],
            "angle": 0,
            "content": "* 58. 证明：每个顶点的入度和出度都相等的连通有向图具有有根生成树。[提示：使用欧拉回路。]"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.874,
                0.701,
                0.889
            ],
            "angle": 0,
            "content": "* 59. 给出构造每个顶点的入度和出度都相等的连通有向图的有根生成树的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.891,
                0.909,
                0.923
            ],
            "angle": 0,
            "content": "* 60. 证明：如果 \\(G\\) 是有向图并且 \\(T\\) 是用深度优先搜索构造的生成树，则 \\(G\\) 含有回路当且仅当 \\(G\\) 含有相对于生成树 \\(T\\) 的背面（参见练习51）。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.927,
                0.543,
                0.941
            ],
            "angle": 0,
            "content": "* 61. 用练习 60 来构造一个确定有向图是否含有回路的算法。"
        },
        {
            "type": "list",
            "bbox": [
                0.04,
                0.098,
                0.91,
                0.941
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.134,
                0.041,
                0.17,
                0.054
            ],
            "angle": 0,
            "content": "704"
        },
        {
            "type": "header",
            "bbox": [
                0.215,
                0.04,
                0.291,
                0.054
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "title",
            "bbox": [
                0.105,
                0.109,
                0.321,
                0.127
            ],
            "angle": 0,
            "content": "11.5 最小生成树"
        },
        {
            "type": "title",
            "bbox": [
                0.105,
                0.136,
                0.243,
                0.153
            ],
            "angle": 0,
            "content": "11.5.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.156,
                0.955,
                0.249
            ],
            "angle": 0,
            "content": "一家公司计划建立一个通信网络来连接它的5个计算机中心。可以用租用的电话线连接这些中心的任何一对。应当建立哪些连接，以便保证在任何两个计算机中心之间都有通路，且网络的总成本最小？可以用图1所示的带权图为这个问题建模，其中顶点表示计算机中心，边表示可能租用的电话线，边上的权是边所表示的电话线的月租费。通过找出一棵使各边的权之和为最小的生成树，就可以解决这个问题。这样的生成树称为最小生成树。"
        },
        {
            "type": "image",
            "bbox": [
                0.277,
                0.257,
                0.785,
                0.378
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.324,
                0.39,
                0.735,
                0.406
            ],
            "angle": 0,
            "content": "图1 说明计算机网络中的线路的月租费的加权图"
        },
        {
            "type": "title",
            "bbox": [
                0.106,
                0.424,
                0.357,
                0.441
            ],
            "angle": 0,
            "content": "11.5.2 最小生成树算法"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.444,
                0.953,
                0.479
            ],
            "angle": 0,
            "content": "有大量的问题可以这样解决：求加权图里的一棵生成树，使得这棵树的各边的权之和为最小。"
        },
        {
            "type": "text",
            "bbox": [
                0.155,
                0.489,
                0.78,
                0.506
            ],
            "angle": 0,
            "content": "定义1 连通加权图里的最小生成树是具有边的权之和最小的生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.515,
                0.954,
                0.588
            ],
            "angle": 0,
            "content": "下面将给出构造最小生成树的两个算法。这两个算法都是通过添加还没有使用过的、具有特定性质的、权最小的边来进行的。这些算法都是贪心算法。回顾3.1节，贪心算法是在每个步骤上都做最优选择的算法。在算法的每个步骤上都最优化，并不能保证产生全局最优解。不过，本节里给出的构造最小生成树的这两个算法都是产生最优解的贪心算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.591,
                0.954,
                0.684
            ],
            "angle": 0,
            "content": "要讨论的第一个算法最早由捷克的数学家Vojtěch Jarník在1930年发现，并把它发表于捷克的一个期刊上。当罗伯特·普林在1957年重新给出这个算法时，该算法就变得很著名了。因此，该算法称为普林(Prim)算法（有时也称为prim-Jarník算法）。为了执行普林算法，首先选择带最小权的边，把它放进生成树里。依次向树里添加与已在树里的顶点关联的且不与已在树里的边形成简单回路的权最小的边。当已经添加了 \\(n - 1\\) 条边时就停止。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.686,
                0.954,
                0.722
            ],
            "angle": 0,
            "content": "本节稍后将证明这个算法产生任何连通加权图的最小生成树。算法1给出普林算法的伪码描述。"
        },
        {
            "type": "image",
            "bbox": [
                0.106,
                0.766,
                0.177,
                0.791
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.11,
                0.803,
                0.252,
                0.914
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.107,
                0.917,
                0.233,
                0.937
            ],
            "angle": 0,
            "content": "Courtesy of Robert Clay Prim"
        },
        {
            "type": "text",
            "bbox": [
                0.265,
                0.803,
                0.955,
                0.925
            ],
            "angle": 0,
            "content": "罗伯特·克雷·普林（Robert Clay Prim，1921—）普林1921年出生在得克萨斯的斯威特沃特。1941年，普林获得普林斯顿大学电机工程学士学位，1949年获得数学博士学位。1941年到1944年，普林在通用电气公司担任工程师。1944年到1949年，他担任美国海军军械实验室的工程师和数学家。1948年到1949年担任普林斯顿大学的助理研究员。除此之外，他担任过的其他职务还包括1958年到1961年间担任贝尔电话实验室的数学与力学研究主任，以及桑地亚公司的研究副总裁。目前，他已经退休。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.763,
                0.037,
                0.87,
                0.052
            ],
            "angle": 0,
            "content": "树 705"
        },
        {
            "type": "title",
            "bbox": [
                0.065,
                0.103,
                0.214,
                0.118
            ],
            "angle": 0,
            "content": "算法1 普林算法"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.121,
                0.476,
                0.136
            ],
            "angle": 0,
            "content": "procedure Prim \\((G\\) ：带 \\(n\\) 个顶点的连通加权无向图）"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.139,
                0.207,
                0.153
            ],
            "angle": 0,
            "content": "\\(T:=\\) 权最小的边"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.157,
                0.209,
                0.17
            ],
            "angle": 0,
            "content": "for \\(i\\coloneqq 1\\) to \\(n - 2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.174,
                0.662,
                0.189
            ],
            "angle": 0,
            "content": "\\(e \\coloneqq\\) 与 \\(T\\) 里顶点关联且若添加到 \\(T\\) 里则不形成简单回路的权最小的边"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.191,
                0.269,
                0.206
            ],
            "angle": 0,
            "content": "\\(T\\coloneqq\\) 添加 \\(e\\) 之后的 \\(T\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.209,
                0.321,
                0.224
            ],
            "angle": 0,
            "content": "return \\(T\\{T\\) 是 \\(G\\) 的最小生成树 \\(\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.243,
                0.898,
                0.298
            ],
            "angle": 0,
            "content": "注意，当有超过一条满足相应条件的带相同权的边时，在算法的这个阶段里对所添加的边的选择就不是确定的。需要排序这些边以便让选择是确定的。在本节剩下的部分将不再考虑这个问题。另外注意，所给的连通加权简单图可能有多于一个的最小生成树（见练习9）。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.301,
                0.414,
                0.317
            ],
            "angle": 0,
            "content": "例1和例2说明如何使用普林算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.322,
                0.816,
                0.34
            ],
            "angle": 0,
            "content": "例1用普林算法设计连接图1所表示的所有计算机的具有最小成本的通信网络。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.345,
                0.9,
                0.399
            ],
            "angle": 0,
            "content": "解办法是求图1的最小生成树。普林算法是这样执行的：选择权最小的初始边，并且依次添加与树里顶点关联的不形成回路的权最小的边。在图2中，加颜色的边表示普林算法所产生的最小生成树，并且显示在每个步骤上所做的选择。"
        },
        {
            "type": "image",
            "bbox": [
                0.231,
                0.407,
                0.72,
                0.602
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.346,
                0.604,
                0.605,
                0.618
            ],
            "angle": 0,
            "content": "图2 图1加权图的最小生成树"
        },
        {
            "type": "title",
            "bbox": [
                0.053,
                0.64,
                0.122,
                0.659
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.056,
                0.673,
                0.197,
                0.783
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.055,
                0.787,
                0.197,
                0.798
            ],
            "angle": 0,
            "content": "Courtesy of Joseph Kruskal"
        },
        {
            "type": "text",
            "bbox": [
                0.211,
                0.673,
                0.902,
                0.812
            ],
            "angle": 0,
            "content": "约瑟夫·伯纳德·克鲁斯卡尔（Joseph Bernard Kruskal，1928—2010）克鲁斯卡尔于1928年出生在纽约。他的父亲经营皮毛生意，母亲在电视上教授手工折纸。克鲁斯卡尔来到芝加哥大学学习，1954年他从普林斯顿大学获得博士学位。他是普林斯顿和威斯康星大学的数学教师，随后他在密歇根大学任助理教授。1959年，他成为贝尔实验室的技术委员会成员，并一直担任这个职务到20世纪90年代末期退休为止。当克鲁斯卡尔还在读研究生二年级的时候，他发现了最小生成树算法。当时他还不能肯定关于这个题目所写的两页半的论文是否值得发表，后来经其他人说服之后才递交上去。他的研究兴趣包括统计语言学和心理测量学。除了最小生成树的成果之外，克鲁斯卡尔还因"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.814,
                0.856,
                0.83
            ],
            "angle": 0,
            "content": "为对多维分级的贡献而著名。另外，值得一提的是克鲁斯卡尔的两个兄弟马丁和威廉也是著名的数学家。"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.853,
                0.903,
                0.939
            ],
            "angle": 0,
            "content": "历史注解 约瑟夫·克鲁斯卡尔和罗伯特·普林在20世纪50年代中期提出了构建最小生成树的算法。不过，他们不是首先发现这个算法的人。例如，人类学家扬·切卡诺夫斯基(JanCzekanowski)在1909年的研究中就涵盖了求最小生成树所需要的许多想法。1926年，奥塔卡·勃鲁乌卡（OtakarBoruvka)在与构造电力网有关的工作中描述了构造最小生成树的方法。正如书中提到的，现今的普林算法实际上是由沃伊切克·亚尔尼克(VojtechJarnik)在1930年发现的。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.125,
                0.038,
                0.161,
                0.052
            ],
            "angle": 0,
            "content": "706"
        },
        {
            "type": "header",
            "bbox": [
                0.206,
                0.037,
                0.282,
                0.053
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.042,
                0.098,
                0.083,
                0.11
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.096,
                0.574,
                0.114
            ],
            "angle": 0,
            "content": "例2 用普林算法求图3所示的图的最小生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.118,
                0.617,
                0.154
            ],
            "angle": 0,
            "content": "解用普林算法构造的最小生成树显示在图4中。依次选择的边都显示在图中。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.156,
                0.619,
                0.23
            ],
            "angle": 0,
            "content": "将要讨论的第二个算法是约瑟夫·克鲁斯卡尔在1956年发现的，尽管在此之前已经有人阐述过这一算法的基本思路。为了执行克鲁斯卡尔算法，要选择图中权最小的一条边。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.232,
                0.618,
                0.269
            ],
            "angle": 0,
            "content": "依次添加不与已经选择的边形成简单回路的权最小的边。在已经挑选了 \\(n - 1\\) 条边之后就停止。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.27,
                0.62,
                0.326
            ],
            "angle": 0,
            "content": "把克鲁斯卡尔算法对每个连通加权图都产生最小生成树的证明留作练习。算法2给出了克鲁斯卡尔算法的伪代码。"
        },
        {
            "type": "image",
            "bbox": [
                0.634,
                0.117,
                0.945,
                0.267
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.715,
                0.272,
                0.863,
                0.287
            ],
            "angle": 0,
            "content": "图3 一个带权图"
        },
        {
            "type": "image",
            "bbox": [
                0.203,
                0.33,
                0.538,
                0.524
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.587,
                0.33,
                0.627,
                0.523
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.695,
                0.33,
                0.847,
                0.522
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.373,
                0.527,
                0.671,
                0.543
            ],
            "angle": 0,
            "content": "图4 用普林算法构造的最小生成树"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.558,
                0.317,
                0.573
            ],
            "angle": 0,
            "content": "算法2 克鲁斯卡尔算法"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.576,
                0.547,
                0.592
            ],
            "angle": 0,
            "content": "procedure Kruskal( \\(G\\) ：带 \\(n\\) 个顶点的加权连通无向图）"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.594,
                0.199,
                0.608
            ],
            "angle": 0,
            "content": "\\(T\\coloneqq\\) 空图"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.612,
                0.254,
                0.625
            ],
            "angle": 0,
            "content": "for \\(i\\coloneqq 1\\) to \\(n - 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.629,
                0.649,
                0.644
            ],
            "angle": 0,
            "content": "\\(e:=G\\) 中权最小的任一边且当添加到 \\(T\\) 里时不形成简单回路边"
        },
        {
            "type": "text",
            "bbox": [
                0.144,
                0.648,
                0.256,
                0.661
            ],
            "angle": 0,
            "content": "\\(T\\coloneqq T\\) 添加 \\(e\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.665,
                0.37,
                0.68
            ],
            "angle": 0,
            "content": "return \\(T\\{T\\) 是 \\(G\\) 的最小生成树}"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.699,
                0.945,
                0.794
            ],
            "angle": 0,
            "content": "读者应当注意普林算法与克鲁斯卡尔算法的区别。在普林算法里，选择与已在树中的一个顶点相关联且不形成回路的权最小的边；相对地，在克鲁斯卡尔算法里，选择不一定与已在树中的一个顶点相关联且不形成回路的权最小的边。注意，在普林算法里，若没有对边排序，则在这个过程的某个阶段上，对添加的边来说就可能有多于一种的选择。因此，为了让这个过程是确定的，就需要对边进行排序。例3说明如何使用克鲁斯卡尔算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.799,
                0.68,
                0.817
            ],
            "angle": 0,
            "content": "例3 用克鲁斯卡尔算法求图3所示的加权图的最小生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.822,
                0.853,
                0.839
            ],
            "angle": 0,
            "content": "解 在图5里显示这个最小生成树和在克鲁斯卡尔算法每个阶段上对边的选择。"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.842,
                0.607,
                0.858
            ],
            "angle": 0,
            "content": "现在将证明普林算法产生连通加权图的最小生成树。"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.055,
                0.861,
                0.086,
                0.886
            ],
            "angle": 0,
            "content": "2"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.861,
                0.945,
                0.937
            ],
            "angle": 0,
            "content": "证明 设 \\(G\\) 是一个连通加权图。假定普林算法依次选择的边是 \\(e_1, e_2, \\dots, e_{n-1}\\) 。设 \\(S\\) 是以 \\(e_1, e_2, \\dots, e_{n-1}\\) 作为边的树，而设 \\(S_k\\) 是以 \\(e_1, e_2, \\dots, e_k\\) 作为边的树。设 \\(T\\) 是包含边 \\(e_1, e_2, \\dots, e_k\\) 的 \\(G\\) 的最小生成树，其中 \\(k\\) 是满足下列性质的最大整数：存在着包含普林算法所选择的前 \\(k\\) 条边的最小生成树。若证明了 \\(S = T\\) ，则该定理得证。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.768,
                0.035,
                0.874,
                0.049
            ],
            "angle": 0,
            "content": "树 707"
        },
        {
            "type": "image",
            "bbox": [
                0.157,
                0.093,
                0.805,
                0.301
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.312,
                0.31,
                0.647,
                0.325
            ],
            "angle": 0,
            "content": "图5 克鲁斯卡尔算法产生的最小生成树"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.336,
                0.906,
                0.441
            ],
            "angle": 0,
            "content": "假定 \\(S \\neq T\\) ，所以 \\(k < n - 1\\) 。因此，\\(T\\) 包含边 \\(e_1, e_2, \\dots, e_k\\) ，但是不包含 \\(e_{k+1}\\) 。考虑由 \\(T\\) 和 \\(e_{k+1}\\) 所组成的图。因为这个图是连通的并且有 \\(n\\) 条边，若是树，边过多了，所以它必然包含简单回路。这个简单回路必然包含 \\(e_{k+1}\\) ，因为在 \\(T\\) 里没有简单回路。另外，在这个简单回路中必然有不属于 \\(S_{k+1}\\) 的边，因为 \\(S_{k+1}\\) 是一棵树。通过从 \\(e_{k+1}\\) 的一个端点开始，该端点也是边 \\(e_1, e_2, \\dots, e_k\\) 之一的端点，并且沿着回路直到它到达一条不在 \\(S_{k+1}\\) 里的边为止，就可以找出一条不在 \\(S_{k+1}\\) 里的边 \\(e\\) ，它有一个端点也是边 \\(e_1, e_2, \\dots, e_k\\) 之一的端点。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.443,
                0.906,
                0.55
            ],
            "angle": 0,
            "content": "通过从 \\(T\\) 里删除 \\(e\\) 并且添加 \\(e_{k + 1}\\) ，就获得带 \\(n - 1\\) 条边的树 \\(T^{\\prime}\\) （它是树，因为它没有简单回路）。注意树 \\(T^{\\prime}\\) 包含 \\(e_1,e_2,\\dots ,e_{k + 1}\\) 。另外，因为普林算法在第 \\(k + 1\\) 个步骤上选择 \\(e_{k + 1}\\) ，并且在这个步骤上 \\(e\\) 也是可用的，所以 \\(e_{k + 1}\\) 的权就小于或等于 \\(e\\) 的权。根据这个观察结果就得出\\(T^{\\prime}\\) 也是最小生成树，因为它的边的权之和不超过 \\(T\\) 的边的权之和。这与对 \\(k\\) 的选择相矛盾， \\(k\\) 是使得包含 \\(e_1,e_2,\\dots ,e_k\\) 的最小生成树存在的最大整数。因此， \\(k = n - 1\\) 并且 \\(S = T\\) 。所以普林算法产生最小生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.552,
                0.906,
                0.626
            ],
            "angle": 0,
            "content": "可以证明（参见[CoLeRiSt09]）为了求出具有 \\(m\\) 条边和 \\(n\\) 个顶点的图的最小生成树，克鲁斯卡尔算法需要用 \\(O(m\\log m)\\) 次运算来完成，而普林算法需要用 \\(O(m\\log n)\\) 次运算来完成。因此，对于稀疏图来说，使用克鲁斯卡尔算法更好。在稀疏图中，\\(m\\) 远远小于 \\(C(n,2) = n(n - 1) / 2\\)，即具有 \\(n\\) 个顶点的无向图的可能的总边数。否则，这两个算法的复杂度没有什么差别。"
        },
        {
            "type": "title",
            "bbox": [
                0.06,
                0.636,
                0.105,
                0.652
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.655,
                0.906,
                0.703
            ],
            "angle": 0,
            "content": "1.下图所表示的道路都还没有铺设路面。边的权表示在成对的乡镇之间的道路长度。哪些道路应当铺设路面，以便在每对乡镇之间都有铺设路面的道路，而且使得铺设的道路的长度最短？（注意：这些乡镇都在内华达州。）"
        },
        {
            "type": "image",
            "bbox": [
                0.08,
                0.705,
                0.573,
                0.939
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.139,
                0.037,
                0.175,
                0.05
            ],
            "angle": 0,
            "content": "708"
        },
        {
            "type": "header",
            "bbox": [
                0.22,
                0.036,
                0.297,
                0.051
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.093,
                0.596,
                0.107
            ],
            "angle": 0,
            "content": "在练习 \\(2\\sim 4\\) 中，用普林算法求所给的加权图的最小生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.111,
                0.129,
                0.124
            ],
            "angle": 0,
            "content": "2."
        },
        {
            "type": "image",
            "bbox": [
                0.132,
                0.111,
                0.26,
                0.203
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.29,
                0.111,
                0.308,
                0.124
            ],
            "angle": 0,
            "content": "3."
        },
        {
            "type": "image",
            "bbox": [
                0.313,
                0.111,
                0.486,
                0.23
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.517,
                0.111,
                0.536,
                0.124
            ],
            "angle": 0,
            "content": "4."
        },
        {
            "type": "image",
            "bbox": [
                0.539,
                0.111,
                0.852,
                0.325
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.328,
                0.573,
                0.342
            ],
            "angle": 0,
            "content": "5. 用克鲁斯卡尔算法设计在本节开头所描述的通信网络。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.346,
                0.555,
                0.36
            ],
            "angle": 0,
            "content": "6. 用克鲁斯卡尔算法求练习2里加权图的最小生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.364,
                0.554,
                0.377
            ],
            "angle": 0,
            "content": "7. 用克鲁斯卡尔算法求练习3里加权图的最小生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.382,
                0.554,
                0.395
            ],
            "angle": 0,
            "content": "8. 用克鲁斯卡尔算法求练习4里加权图的最小生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.399,
                0.721,
                0.413
            ],
            "angle": 0,
            "content": "9. 找出具有多于一棵最小生成树的、带有最少可能边数的连通加权简单图。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.417,
                0.955,
                0.449
            ],
            "angle": 0,
            "content": "10. 加权图里的最小生成森林是权最小的生成森林。解释如何修改普林算法和克鲁斯卡尔算法来构造最小生成森林。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.453,
                0.588,
                0.467
            ],
            "angle": 0,
            "content": "连通加权无向图的最大生成树是带最大可能的权的生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.472,
                0.656,
                0.485
            ],
            "angle": 0,
            "content": "11. 设计与普林算法类似的、构造连通加权图的最大生成树的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.489,
                0.711,
                0.503
            ],
            "angle": 0,
            "content": "12. 设计与克鲁斯卡尔算法类似的、构造连通加权图的最大生成树的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.507,
                0.415,
                0.521
            ],
            "angle": 0,
            "content": "13. 求练习2里加权图的最大生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.525,
                0.415,
                0.539
            ],
            "angle": 0,
            "content": "14. 求练习3里加权图的最大生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.543,
                0.415,
                0.557
            ],
            "angle": 0,
            "content": "15. 求练习4里加权图的最大生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.561,
                0.729,
                0.574
            ],
            "angle": 0,
            "content": "16. 求在本节开头所提出问题中连接 5 个计算机中心的次最便宜的通信网络。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.579,
                0.49,
                0.593
            ],
            "angle": 0,
            "content": "* 17. 设计求连通加权图里次最短生成树的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.597,
                0.675,
                0.611
            ],
            "angle": 0,
            "content": "* 18. 证明：连通加权图里权最小的边，必然属于任何一个最小生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.615,
                0.711,
                0.629
            ],
            "angle": 0,
            "content": "19. 证明：若所有边的权都不相同，则连通加权图里有唯一的最小生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.633,
                0.955,
                0.665
            ],
            "angle": 0,
            "content": "20. 假定连接图1里城市的计算机网络必须包含纽约与丹佛之间的直接连接。那么应当包含哪些其他的连接，使得在每两个计算机中心之间都存在连接，并且费用最少？"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.669,
                0.652,
                0.683
            ],
            "angle": 0,
            "content": "21. 求图3的加权图里包含边 \\(\\{e, i\\}\\) 和 \\(\\{g, k\\}\\) 的总权最小的生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.687,
                0.823,
                0.701
            ],
            "angle": 0,
            "content": "22. 描述一个算法，它求连通加权无向简单图里包含所规定的一组边的权最小的生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.705,
                0.406,
                0.718
            ],
            "angle": 0,
            "content": "23. 用伪码表达练习22设计的算法。"
        },
        {
            "type": "list",
            "bbox": [
                0.096,
                0.472,
                0.955,
                0.718
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.722,
                0.957,
                0.863
            ],
            "angle": 0,
            "content": "索林(Sollin)算法从连通加权简单图 \\(G = (V, E)\\) 这样产生最小生成树：依次添加成组的边。假定对 \\(V\\) 中的顶点进行了排序。这样产生边的一个顺序，其中若 \\(u_0\\) 先于 \\(u_1\\) ，或者若 \\(u_0 = u_1\\) 并且 \\(v_0\\) 先于 \\(v_1\\) ，则 \\(\\{u_0, v_0\\}\\) 先于 \\(\\{u_1, v_1\\}\\) 。这个算法首先同时选择每个顶点关联的权最小的边。在平局情形下选择在上述顺序里的第一条边。这样就产生出一个没有简单回路的图，即一些树组成的一个森林（练习24要求证明这个事实）。其次，对森林中的每棵树，同时选择在该树中一个顶点与在不同的一棵树中顶点之间的最短的边。同样在平局情形下选择在上述顺序里的第一条边。（这样就产生出一个没有简单回路的图，它包含比在这一步之前出现的更少的树。参见练习24。）继续进行同时添加连接树的边的过程，直到已经选择了 \\(n - 1\\) 条边为止。在这个阶段已经构造了一棵最小生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.866,
                0.619,
                0.88
            ],
            "angle": 0,
            "content": "* 24. 证明：在索林算法的每个阶段，边的添加都产生一个森林。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.884,
                0.49,
                0.898
            ],
            "angle": 0,
            "content": "25. 用索林算法产生下列加权图的最小生成树。"
        },
        {
            "type": "list",
            "bbox": [
                0.096,
                0.866,
                0.619,
                0.898
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.902,
                0.198,
                0.915
            ],
            "angle": 0,
            "content": "a)图1"
        },
        {
            "type": "text",
            "bbox": [
                0.37,
                0.902,
                0.425,
                0.915
            ],
            "angle": 0,
            "content": "b)图3"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.92,
                0.341,
                0.934
            ],
            "angle": 0,
            "content": "* 26. 用伪代码表达索林算法。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.771,
                0.044,
                0.794,
                0.057
            ],
            "angle": 0,
            "content": "树"
        },
        {
            "type": "page_number",
            "bbox": [
                0.843,
                0.045,
                0.876,
                0.056
            ],
            "angle": 0,
            "content": "709"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.099,
                0.531,
                0.114
            ],
            "angle": 0,
            "content": "**27. 证明：索林算法产生连通无向加权图里的最小生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.117,
                0.854,
                0.132
            ],
            "angle": 0,
            "content": "* 28. 证明：当输入为含有 \\( n \\) 个顶点的无向图时，索林算法的第一步产生至少包含 \\( \\lceil n / 2 \\rceil \\) 条边的森林。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.136,
                0.832,
                0.15
            ],
            "angle": 0,
            "content": "* 29. 证明：若在索林算法的某个中间步骤存在 \\( r \\) 棵树，则算法的下一次迭代至少添加 \\( \\lceil r / 2 \\rceil \\) 条边。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.154,
                0.904,
                0.186
            ],
            "angle": 0,
            "content": "* 30. 证明：当输入为含有 \\( n \\) 个顶点的无向图时，在已经完成索林算法的第一步，并且已经 \\( k - 1 \\) 次执行索林算法的第二步之后，还剩下不超过 \\( \\lfloor n / 2^k \\rfloor \\) 棵树。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.19,
                0.904,
                0.221
            ],
            "angle": 0,
            "content": "* 31. 证明：索林算法至少需要 \\(\\log n\\) 次迭代，以便从带有 \\(n\\) 个顶点的连通无向加权图产生一棵最小生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.225,
                0.419,
                0.24
            ],
            "angle": 0,
            "content": "32. 证明：克鲁斯卡尔算法产生最小生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.243,
                0.905,
                0.275
            ],
            "angle": 0,
            "content": "33. 证明：若 \\(G\\) 是各边权值都不同的加权图，则对于 \\(G\\) 中的每条简单回路，该回路中权值最大的边不属于 \\(G\\) 的任何一棵最小生成树。"
        },
        {
            "type": "list",
            "bbox": [
                0.06,
                0.225,
                0.905,
                0.275
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.279,
                0.904,
                0.311
            ],
            "angle": 0,
            "content": "当克鲁斯卡尔发明了按权值递增的顺序增加不形成简单回路的边的求最小生成树的算法时，他还发明了另外一个称为逆删除的算法。该算法从连通图中依次删除不使图变成不可连通的权值最大的边。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.315,
                0.289,
                0.329
            ],
            "angle": 0,
            "content": "34. 用伪码描述逆删除算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.333,
                0.904,
                0.347
            ],
            "angle": 0,
            "content": "35. 证明：若输入为各边权值都不同的加权图，则逆删除算法总能产生最小生成树。[提示：用练习33。]"
        },
        {
            "type": "list",
            "bbox": [
                0.062,
                0.315,
                0.904,
                0.347
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.064,
                0.362,
                0.248,
                0.382
            ],
            "angle": 0,
            "content": "关键术语和结论"
        },
        {
            "type": "title",
            "bbox": [
                0.064,
                0.39,
                0.108,
                0.405
            ],
            "angle": 0,
            "content": "术语"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.41,
                0.378,
                0.424
            ],
            "angle": 0,
            "content": "树（tree）：没有简单回路的连通无向图。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.428,
                0.375,
                0.442
            ],
            "angle": 0,
            "content": "森林(forest)：没有简单回路的无向图。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.446,
                0.905,
                0.478
            ],
            "angle": 0,
            "content": "有根树(rooted tree)：具有一个规定的顶点（称为根），使得从这个根到任意其他顶点有唯一通路的有向图。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.481,
                0.479,
                0.496
            ],
            "angle": 0,
            "content": "子树(subtree)：树的子图，该子图本身也是一棵树。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.5,
                0.817,
                0.514
            ],
            "angle": 0,
            "content": "有根树中顶点 \\(v\\) 的父母(parent of \\(v\\) in a rooted tree)：使得 \\((u, v)\\) 是有根树的一条边的顶点 \\(u\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.518,
                0.767,
                0.532
            ],
            "angle": 0,
            "content": "有根树中顶点 \\(\\pmb{v}\\) 的孩子（child of a vertex \\(v\\) in a rooted tree）：以 \\(\\pmb{v}\\) 作为父母的任何顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.535,
                0.782,
                0.549
            ],
            "angle": 0,
            "content": "有根树中顶点 \\( v \\) 的兄弟 (sibling of a vertex \\( v \\) in a rooted tree): 与 \\( v \\) 具有相同父母的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.553,
                0.849,
                0.568
            ],
            "angle": 0,
            "content": "有根树中顶点 \\(\\pmb{v}\\) 的祖先(ancestor of a vertex \\(v\\) in a rooted tree): 在从根到 \\(v\\) 的通路上的任何顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.571,
                0.814,
                0.585
            ],
            "angle": 0,
            "content": "有根树中顶点 \\(v\\) 的后代（descendant of a vertex \\(v\\) in a rooted tree）：以 \\(v\\) 作为祖先的任何顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.589,
                0.388,
                0.603
            ],
            "angle": 0,
            "content": "内点 (internal vertex): 具有孩子的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.607,
                0.302,
                0.621
            ],
            "angle": 0,
            "content": "树叶(leaf)：没有孩子的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.625,
                0.549,
                0.639
            ],
            "angle": 0,
            "content": "顶点的层(level of a vertex)：从根到这个顶点的通路的长度。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.643,
                0.47,
                0.657
            ],
            "angle": 0,
            "content": "树的高度（height of a tree）：树里顶点的最大层数。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.661,
                0.527,
                0.675
            ],
            "angle": 0,
            "content": "\\(m\\) 叉树 \\((m\\)-ary tree)：每个内点都有不超过 \\(m\\) 个孩子的树。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.679,
                0.564,
                0.693
            ],
            "angle": 0,
            "content": "满 \\(m\\) 叉树(full \\(m\\)-ary tree)：每个内点都有恰好 \\(m\\) 个孩子的树。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.697,
                0.767,
                0.711
            ],
            "angle": 0,
            "content": "二叉树（binary tree）：满足 \\(m = 2\\) 的 \\(m\\) 叉树（可以指定每个孩子作为父母的左子或右子）。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.715,
                0.556,
                0.728
            ],
            "angle": 0,
            "content": "有序树(ordered tree)：对每个内点的孩子都线性地排序的树。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.732,
                0.776,
                0.746
            ],
            "angle": 0,
            "content": "平衡树（balanced tree）：每个顶点都是在 \\(h\\) 层或 \\(h - 1\\) 层上的树，其中 \\(h\\) 是这棵树的高度。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.75,
                0.907,
                0.782
            ],
            "angle": 0,
            "content": "二叉搜索树（binary search tree）：二叉树，在其中以元素对顶点进行标记，使得一个顶点的标记大于这个顶点的左子树里所有顶点的标记，并且小于这个顶点的右子树里所有顶点的标记。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.786,
                0.907,
                0.817
            ],
            "angle": 0,
            "content": "决策树(decision tree)：性质如下的有根树，在其中每个顶点表示一次决策的可能输出，而树叶表示可能的解。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.821,
                0.797,
                0.835
            ],
            "angle": 0,
            "content": "博弈树(gametree)：顶点表示博弈过程中的局面，边表示这些局面间的合法移动的有根树。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.839,
                0.806,
                0.853
            ],
            "angle": 0,
            "content": "前缀码(prefix code)：一种编码，其中一个字符的编码永远不是另外一个字符的编码的前缀。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.857,
                0.907,
                0.889
            ],
            "angle": 0,
            "content": "最小最大策略（minmax strategy）：第一个选手和第二个选手分别移动到具有最大值和最小值的孩子顶点所表示的局面的策略。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.893,
                0.907,
                0.942
            ],
            "angle": 0,
            "content": "博弈树里顶点的值(value of a vertex in a game tree)：对于树叶来说，就是当游戏在这个树叶所表示的局面里结束时第一个选手的得分。对于分别在偶数或奇数层上的内点来说，就是这个内点的孩子的最大值或最小值。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.146,
                0.046,
                0.182,
                0.059
            ],
            "angle": 0,
            "content": "710"
        },
        {
            "type": "header",
            "bbox": [
                0.228,
                0.045,
                0.302,
                0.06
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.102,
                0.473,
                0.116
            ],
            "angle": 0,
            "content": "树的遍历（tree traversal）：树的顶点的列表。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.12,
                0.962,
                0.151
            ],
            "angle": 0,
            "content": "前序遍历(preorder traversal)：通过递归地定义的有序根树的顶点列表——列出根，接着列出第一棵子树，接着以从左到右的出现顺序列出其余子树。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.155,
                0.962,
                0.186
            ],
            "angle": 0,
            "content": "中序遍历(inorder traversal)：通过递归地定义的有序根树的顶点列表——列出第一棵子树，接着列出根，接着以从左到右的出现顺序列出其余子树。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.19,
                0.962,
                0.221
            ],
            "angle": 0,
            "content": "后序遍历(postorder traversal)：通过递归地定义的有序根树的顶点列表——以从左到右的出现顺序列出各子树，接着列出根。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.225,
                0.918,
                0.239
            ],
            "angle": 0,
            "content": "中缀记法(infix notation)：从表示表达式(包括全套括号)的二叉树的中序遍历所获得的表达式形式。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.243,
                0.962,
                0.273
            ],
            "angle": 0,
            "content": "前缀记法，或波兰记法(prefix(or Polish)notation)：从表示表达式的二叉树的前序遍历所获得的表达式形式。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.279,
                0.962,
                0.31
            ],
            "angle": 0,
            "content": "后缀记法，或逆波兰记法(postfix(or reverse Polish)notation)：从表示表达式的二叉树的后序遍历所获得的表达式形式。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.314,
                0.512,
                0.328
            ],
            "angle": 0,
            "content": "生成树（spanning tree）：包含图的所有顶点的树。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.332,
                0.644,
                0.346
            ],
            "angle": 0,
            "content": "最小生成树（minimum spanning tree）：边的权之和最小的生成树。"
        },
        {
            "type": "title",
            "bbox": [
                0.117,
                0.358,
                0.166,
                0.373
            ],
            "angle": 0,
            "content": "结论"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.377,
                0.686,
                0.391
            ],
            "angle": 0,
            "content": "一个图是树，当且仅当在它的任何两个顶点之间都存在唯一简单通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.395,
                0.398,
                0.408
            ],
            "angle": 0,
            "content": "带有 \\(n\\) 个顶点的树具有 \\(n - 1\\) 条边。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.413,
                0.485,
                0.426
            ],
            "angle": 0,
            "content": "带有 \\(i\\) 个内点的满 \\(m\\) 叉树具有 \\(mi + 1\\) 个顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.431,
                0.693,
                0.444
            ],
            "angle": 0,
            "content": "在满 \\(m\\) 叉树的顶点数、树叶数和内点数之间的关系（见11.1节定理4）。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.448,
                0.481,
                0.462
            ],
            "angle": 0,
            "content": "在高度为 \\(h\\) 的满 \\(m\\) 叉树中至多有 \\(m^h\\) 个树叶。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.466,
                0.962,
                0.497
            ],
            "angle": 0,
            "content": "若 \\(m\\) 叉树有 \\(l\\) 个树叶，则它的高度 \\(h\\) 至少是 \\(\\lceil \\log_m l \\rceil\\) 。若这树也是满的和平衡的，则它的高度就是 \\(\\lceil \\log_m l \\rceil\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.501,
                0.847,
                0.515
            ],
            "angle": 0,
            "content": "哈夫曼编码（Huffman coding）：给定一组符号的频率，为这些符号构造最优二元码的过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.519,
                0.962,
                0.551
            ],
            "angle": 0,
            "content": "深度优先搜索，或回溯(depth-first search, or backtracking)：构造生成树的过程，通过添加形成通路的边，直到不可能这样做为止，然后沿这条通路往回移动，直到找到可以形成新的通路的顶点为止。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.554,
                0.962,
                0.586
            ],
            "angle": 0,
            "content": "宽度优先搜索（breadth-first search）：构造生成树的过程，通过依次添加与上次添加的边相关联的所有边，除非形成简单回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.59,
                0.962,
                0.622
            ],
            "angle": 0,
            "content": "普林算法(Prim'salgorithm)：产生加权图里最小生成树的过程，通过依次添加与已经在树里的顶点相关联的所有边中权最小的边，使得再添加边时不会产生简单回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.625,
                0.962,
                0.658
            ],
            "angle": 0,
            "content": "克鲁斯卡尔算法(Kruskal's algorithm)：产生加权图里最小生成树的过程，通过依次添加还不在树里的权最小的边，使得再添加边时不会产生简单回路。"
        },
        {
            "type": "title",
            "bbox": [
                0.119,
                0.673,
                0.201,
                0.691
            ],
            "angle": 0,
            "content": "复习题"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.699,
                0.339,
                0.713
            ],
            "angle": 0,
            "content": "1. a)定义树。b)定义森林。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.717,
                0.507,
                0.73
            ],
            "angle": 0,
            "content": "2. 在树的顶点之间能否有两条不同的简单通路？"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.734,
                0.45,
                0.747
            ],
            "angle": 0,
            "content": "3. 至少给出 3 个例子说明如何用树建模。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.752,
                0.394,
                0.765
            ],
            "angle": 0,
            "content": "4. a) 定义有根树和这样的树的根。"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.77,
                0.486,
                0.783
            ],
            "angle": 0,
            "content": "b)定义有根树中顶点的父母和顶点的孩子。"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.787,
                0.468,
                0.801
            ],
            "angle": 0,
            "content": "c) 什么是有根树中的内点、树叶和子树？"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.805,
                0.962,
                0.837
            ],
            "angle": 0,
            "content": "d) 画出至少带 10 个顶点的有根树，其中每个顶点的度都不超过 3。指出树根、每个顶点的父母、每个顶点的孩子、内点和树叶。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.841,
                0.395,
                0.854
            ],
            "angle": 0,
            "content": "5. a) 带 \\( n \\) 个顶点的树有多少条边？"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.858,
                0.636,
                0.872
            ],
            "angle": 0,
            "content": "b)为确定带有 \\(n\\) 个顶点的森林里的边数，你需要知道什么值？"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.876,
                0.286,
                0.89
            ],
            "angle": 0,
            "content": "6. a)定义满 \\(m\\) 叉树。"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.893,
                0.694,
                0.907
            ],
            "angle": 0,
            "content": "b)若满 \\(m\\) 叉树有 \\(i\\) 个内点，则它有多少个顶点？此树有多少个树叶？"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.911,
                0.339,
                0.925
            ],
            "angle": 0,
            "content": "7. a) 什么是有根树的高度？"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.928,
                0.284,
                0.942
            ],
            "angle": 0,
            "content": "b) 什么是平衡树？"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.789,
                0.033,
                0.893,
                0.047
            ],
            "angle": 0,
            "content": "树 711"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.089,
                0.432,
                0.104
            ],
            "angle": 0,
            "content": "c)高度为 \\(h\\) 的 \\(m\\) 叉树可以有多少个树叶？"
        },
        {
            "type": "text",
            "bbox": [
                0.077,
                0.107,
                0.281,
                0.122
            ],
            "angle": 0,
            "content": "8. a) 什么是二叉搜索树？"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.125,
                0.353,
                0.139
            ],
            "angle": 0,
            "content": "b)描述构造二叉搜索树的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.143,
                0.773,
                0.158
            ],
            "angle": 0,
            "content": "c)构造单词vireo、warbler、egret、grosbeak、nuthatch和kingfisher的二叉搜索树。"
        },
        {
            "type": "list",
            "bbox": [
                0.099,
                0.125,
                0.773,
                0.158
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.077,
                0.162,
                0.243,
                0.175
            ],
            "angle": 0,
            "content": "9. a) 什么是前缀码？"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.179,
                0.318,
                0.193
            ],
            "angle": 0,
            "content": "b)二叉树如何表示前缀码？"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.197,
                0.436,
                0.211
            ],
            "angle": 0,
            "content": "10. a) 定义前序遍历、中序遍历和后序遍历。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.214,
                0.722,
                0.229
            ],
            "angle": 0,
            "content": "b)给出至少带12个顶点的二叉树的前序遍历、中序遍历和后序遍历的实例。"
        },
        {
            "type": "list",
            "bbox": [
                0.078,
                0.197,
                0.722,
                0.229
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.232,
                0.899,
                0.246
            ],
            "angle": 0,
            "content": "11. a)解释如何用前序遍历、中序遍历和后序遍历来求算术表达式的前缀形式、中缀形式和后缀形式。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.25,
                0.583,
                0.265
            ],
            "angle": 0,
            "content": "b)画出表示 \\(((x - 3) + ((x / 4) + (x - y)\\uparrow 3))\\) 的有序根树。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.269,
                0.436,
                0.283
            ],
            "angle": 0,
            "content": "c)求在b里的表达式的前缀和后缀形式。"
        },
        {
            "type": "list",
            "bbox": [
                0.108,
                0.25,
                0.583,
                0.283
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.286,
                0.741,
                0.301
            ],
            "angle": 0,
            "content": "12. 证明：排序含有 \\( n \\) 个元素的列表，排序算法所使用的比较次数至少是 \\( \\lceil \\log n! \\rceil \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.305,
                0.677,
                0.319
            ],
            "angle": 0,
            "content": "13. a) 描述哈夫曼编码算法，这个算法求一组给定频率的符号的最优编码。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.322,
                0.798,
                0.337
            ],
            "angle": 0,
            "content": "b)用哈夫曼编码求下列符号和频率的最优编码：A:0.2，B:0.1，C:0.3，C:0.4。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.341,
                0.924,
                0.373
            ],
            "angle": 0,
            "content": "14. 画出取石子游戏的博弈树，假设初始局面由两堆石子组成，分别含有1块和4块石子。假如两个选手都遵循最优策略的话，谁将赢得游戏呢？"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.377,
                0.327,
                0.391
            ],
            "angle": 0,
            "content": "15. a) 什么是简单图的生成树？"
        },
        {
            "type": "list",
            "bbox": [
                0.078,
                0.305,
                0.924,
                0.391
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.394,
                0.327,
                0.408
            ],
            "angle": 0,
            "content": "b)哪些简单图具有生成树？"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.412,
                0.639,
                0.427
            ],
            "angle": 0,
            "content": "c)描述需要求出简单图的生成树的应用，至少举两个不同的应用。"
        },
        {
            "type": "list",
            "bbox": [
                0.108,
                0.394,
                0.639,
                0.427
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.431,
                0.455,
                0.445
            ],
            "angle": 0,
            "content": "16. a) 描述求简单图里生成树的两个不同算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.448,
                0.924,
                0.48
            ],
            "angle": 0,
            "content": "b) 用你所选择的至少带 8 个顶点和 15 条边的图，来解释你在 a 里所描述的两个算法是如何求简单图的生成树的。"
        },
        {
            "type": "list",
            "bbox": [
                0.078,
                0.431,
                0.924,
                0.48
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.484,
                0.567,
                0.499
            ],
            "angle": 0,
            "content": "17. a) 解释如何用回溯来确定能否用 \\( n \\) 种颜色来着色简单图。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.502,
                0.924,
                0.535
            ],
            "angle": 0,
            "content": "b)用例子说明如何用回溯来证明：着色数等于4的图不能用3种颜色来着色，但是可以用4种颜色来着色。"
        },
        {
            "type": "list",
            "bbox": [
                0.078,
                0.484,
                0.924,
                0.535
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.538,
                0.402,
                0.552
            ],
            "angle": 0,
            "content": "18. a) 什么是连通加权图的最小生成树？"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.556,
                0.678,
                0.57
            ],
            "angle": 0,
            "content": "b)至少描述出两个不同的、需要求出连通加权图的最小生成树的应用。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.574,
                0.53,
                0.588
            ],
            "angle": 0,
            "content": "19. a) 描述求最小生成树的普林算法和克鲁斯卡尔算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.591,
                0.89,
                0.606
            ],
            "angle": 0,
            "content": "b)用至少带8个顶点和15条边的图，来解释克鲁斯卡尔算法和普林算法是如何求最小生成树的。"
        },
        {
            "type": "list",
            "bbox": [
                0.078,
                0.538,
                0.89,
                0.606
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.08,
                0.621,
                0.187,
                0.64
            ],
            "angle": 0,
            "content": "补充练习"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.648,
                0.926,
                0.681
            ],
            "angle": 0,
            "content": "*1. 证明：简单图是树当且仅当它不包含简单回路，并且添加连接两个不相邻顶点的一条边所产生的新图恰好有一条简单回路（这里包含相同边的回路只算作一个）。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.685,
                0.431,
                0.699
            ],
            "angle": 0,
            "content": "* 2. 有多少种非同构的带 6 个顶点的有根树？"
        },
        {
            "type": "list",
            "bbox": [
                0.065,
                0.648,
                0.926,
                0.699
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.702,
                0.54,
                0.717
            ],
            "angle": 0,
            "content": "3. 证明：每一个至少有一条边的树都至少有两个悬挂点。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.72,
                0.641,
                0.735
            ],
            "angle": 0,
            "content": "4. 证明：有 \\(n - 1\\) 个悬挂点的、带有 \\(n\\) 个顶点的树必然同构于 \\(K_{1,n - 1}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.738,
                0.45,
                0.752
            ],
            "angle": 0,
            "content": "5. 带有 \\( n \\) 个顶点的树的顶点的度之和是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.756,
                0.926,
                0.788
            ],
            "angle": 0,
            "content": "* 6. 假定 \\(d_{1}, d_{2}, \\cdots, d_{n}\\) 是和为 \\(2n - 2\\) 的 \\(n\\) 个正整数。证明：存在一个带有 \\(n\\) 个顶点的树，使得这些顶点的度为 \\(d_{1}, d_{2}, \\cdots, d_{n}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.792,
                0.337,
                0.806
            ],
            "angle": 0,
            "content": "7. 证明：每个树都是可平面图。"
        },
        {
            "type": "list",
            "bbox": [
                0.065,
                0.702,
                0.926,
                0.806
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.81,
                0.318,
                0.824
            ],
            "angle": 0,
            "content": "8. 证明：每个树都是二分图。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.828,
                0.448,
                0.842
            ],
            "angle": 0,
            "content": "9. 证明：每个森林都可以用两种颜色来着色。"
        },
        {
            "type": "list",
            "bbox": [
                0.078,
                0.81,
                0.448,
                0.842
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.031,
                0.848,
                0.066,
                0.861
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.846,
                0.926,
                0.896
            ],
            "angle": 0,
            "content": "\\(k\\) 度 \\(B\\) 树是一个有根树，它的所有树叶都是在同一层上，它的根具有至少两个并且至多 \\(k\\) 个孩子，除了非根就是树叶，并且除了根外每个内点有至少 \\(\\lceil k / 2\\rceil\\) 个但不超过 \\(k\\) 个孩子。当用 \\(B\\) 树来表示计算机文件时，就可以有效地访问这些文件。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.899,
                0.424,
                0.914
            ],
            "angle": 0,
            "content": "10. 画出3种不同的高度为4的3度 \\(B\\) 树。"
        },
        {
            "type": "list",
            "bbox": [
                0.078,
                0.846,
                0.926,
                0.914
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.918,
                0.517,
                0.932
            ],
            "angle": 0,
            "content": "* 11. 给出高度为 \\(h\\) 的 \\(k\\) 度 \\(B\\) 树里树叶数的上界和下界。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.132,
                0.034,
                0.169,
                0.048
            ],
            "angle": 0,
            "content": "712"
        },
        {
            "type": "header",
            "bbox": [
                0.212,
                0.033,
                0.29,
                0.049
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.09,
                0.54,
                0.105
            ],
            "angle": 0,
            "content": "* 12. 给出有 \\( n \\) 个树叶的 \\( k \\) 度 \\( B \\) 树的高度的上界和下界。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.108,
                0.58,
                0.123
            ],
            "angle": 0,
            "content": "二项式树 \\(B_{i}(i = 0,1,2,\\dots)\\) 是如下递归定义的有序根树："
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.126,
                0.48,
                0.141
            ],
            "angle": 0,
            "content": "基础步骤：二项式树 \\(B_{0}\\) 是具有单个顶点的树。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.144,
                0.949,
                0.177
            ],
            "angle": 0,
            "content": "递归步骤：设 \\(k\\) 是非负整数。为了构造二项式树 \\(B_{k + 1}\\) ，把 \\(B_{k}\\) 的一个副本加入 \\(B_{k}\\) 的第二个副本，方法是加入一条边，这条边让 \\(B_{k}\\) 的第一个副本的根成为 \\(B_{k}\\) 的第二个副本的最左子。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.18,
                0.398,
                0.194
            ],
            "angle": 0,
            "content": "13. 对 \\(k = 0, 1, 2, 3, 4\\)，画出 \\(B_{k}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.198,
                0.48,
                0.212
            ],
            "angle": 0,
            "content": "14. \\(B_{k}\\) 有多少个顶点？证明你的答案是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.216,
                0.455,
                0.23
            ],
            "angle": 0,
            "content": "15. 求 \\(B_{k}\\) 的高度。证明你的答案是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.234,
                0.678,
                0.248
            ],
            "angle": 0,
            "content": "16. \\(B_{k}\\) 在深度 \\(j\\) 有多少个顶点？其中 \\(0 \\leqslant j < k\\) 。证明你的答案是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.252,
                0.52,
                0.266
            ],
            "angle": 0,
            "content": "17. \\(B_{k}\\) 的根的度数是多少？证明你的答案是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.27,
                0.414,
                0.284
            ],
            "angle": 0,
            "content": "18. 证明：\\(B_{k}\\) 中度数最大的顶点是根。"
        },
        {
            "type": "list",
            "bbox": [
                0.102,
                0.18,
                0.678,
                0.284
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.287,
                0.951,
                0.338
            ],
            "angle": 0,
            "content": "若有根树 \\(T\\) 满足下面的递归定义，则称它为 \\(S_{k}\\) 树。若它只有一个顶点，则它是 \\(S_{0}\\) 树。对 \\(k > 0\\) 来说，若通过把一个 \\(S_{k - 1}\\) 树的根作为一个新树的根，把另外一个 \\(S_{k - 1}\\) 树的根作为新树的根的孩子，从两个 \\(S_{k - 1}\\) 树来建立一个新树，则这个新树是 \\(S_{k}\\) 树。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.341,
                0.457,
                0.356
            ],
            "angle": 0,
            "content": "19. 对 \\(k = 0, 1, 2, 3, 4\\)，画出一个 \\(S_{k}\\) 树。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.359,
                0.825,
                0.374
            ],
            "angle": 0,
            "content": "20. 证明：\\(S_{k}\\) 树有 \\(2^{k}\\) 个顶点并且在 \\(k\\) 层上有唯一一个顶点。在 \\(k\\) 层上的这个顶点称为柄。"
        },
        {
            "type": "list",
            "bbox": [
                0.102,
                0.341,
                0.825,
                0.374
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.377,
                0.95,
                0.428
            ],
            "angle": 0,
            "content": "*21. 假定 \\(T\\) 是带有柄 \\(v\\) 的 \\(S_{k}\\) 树。证明：\\(T\\) 可以从根分别为 \\(r_{1}, r_{2} \\cdots r_{k-1}\\) 的不相交的树 \\(T_{0}, T_{1}, \\cdots, T_{k-1}\\) 来获得，其中 \\(v\\) 不在这些树的任何一个中，对 \\(i = 0, 1, \\cdots, k-1\\) 来说，\\(T_{i}\\) 是通过对 \\(i = 0, 1, \\cdots, k-2\\)，连接 \\(v\\) 到 \\(v_{0}\\) 并且连接 \\(r_{i}\\) 到 \\(r_{i+1}\\) 得到的 \\(S_{i}\\) 树。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.431,
                0.95,
                0.464
            ],
            "angle": 0,
            "content": "有序根树在层顺序下的顶点列表从根开始，接着是从左到右在1层上的顶点，从左到右在2层上的顶点，以此类推。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.467,
                0.639,
                0.482
            ],
            "angle": 0,
            "content": "22. 列出11.3节图3和图9中的有序根树在层顺序下的顶点列表。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.485,
                0.538,
                0.5
            ],
            "angle": 0,
            "content": "23. 设计列出有序根树在层顺序下的顶点列表的算法。"
        },
        {
            "type": "list",
            "bbox": [
                0.103,
                0.467,
                0.639,
                0.5
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.503,
                0.649,
                0.518
            ],
            "angle": 0,
            "content": "* 24. 设计一种算法，确定一组通用地址能否成为有根树的树叶地址。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.522,
                0.502,
                0.536
            ],
            "angle": 0,
            "content": "25. 设计从树叶的通用地址来构造有根树的算法。"
        },
        {
            "type": "list",
            "bbox": [
                0.103,
                0.503,
                0.502,
                0.536
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.539,
                0.95,
                0.572
            ],
            "angle": 0,
            "content": "图的割集是一些边的集合，使得删除这些边就产生一个子图，这个子图的连通分支比原来的图要多，但是这些边的任何真子集都没有这个性质。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.575,
                0.668,
                0.59
            ],
            "angle": 0,
            "content": "26. 证明：图的割集必然与这个图的任何生成树都有至少一条公共边。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.593,
                0.95,
                0.644
            ],
            "angle": 0,
            "content": "仙人掌图是连通图，其中没有边是在多于一条的简单回路上，这些简单回路不经过除了起点以外的任何顶点超过一次，而且不在除了终点以外的其他地方经过起点（其中不认为由相同的边所组成的两个回路是不同的）。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.647,
                0.355,
                0.662
            ],
            "angle": 0,
            "content": "27. 下面的图哪些是仙人掌图？"
        },
        {
            "type": "image",
            "bbox": [
                0.136,
                0.669,
                0.243,
                0.768
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.365,
                0.669,
                0.548,
                0.814
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.695,
                0.669,
                0.877,
                0.858
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.863,
                0.337,
                0.878
            ],
            "angle": 0,
            "content": "28. 树是否必然是仙人掌图？"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.881,
                0.89,
                0.896
            ],
            "angle": 0,
            "content": "29. 证明：若在树里添加一条回路，它包含一些起止于树里顶点上的新边，则形成一个仙人掌图。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.899,
                0.95,
                0.933
            ],
            "angle": 0,
            "content": "* 30. 证明：若在连通图里，每条不经过任何顶点（除起点以外）超过一次的回路都包含奇数条边，则这个图必然是仙人掌图。"
        },
        {
            "type": "list",
            "bbox": [
                0.09,
                0.863,
                0.95,
                0.933
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.754,
                0.039,
                0.861,
                0.054
            ],
            "angle": 0,
            "content": "树 713"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.095,
                0.888,
                0.146
            ],
            "angle": 0,
            "content": "简单图 \\(G\\) 的限制度数生成树具有下面性质，在这个树中顶点的度不能超过某个规定的界限。限制度数生成树在运输系统的模型（该模型在交叉路口处的道路数目是有限的）、在通信网络的模型（该模型进入一个结点的连接数目是有限的）等很多模型中都很有用。"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.149,
                0.888,
                0.182
            ],
            "angle": 0,
            "content": "在练习 \\(31\\sim 33\\) 中，求所给图的限制度数生成树，其中每个顶点的度都小于或等于3，或者证明不存在这样的生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.186,
                0.069,
                0.2
            ],
            "angle": 0,
            "content": "31."
        },
        {
            "type": "image",
            "bbox": [
                0.071,
                0.185,
                0.25,
                0.289
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.297,
                0.186,
                0.325,
                0.2
            ],
            "angle": 0,
            "content": "32."
        },
        {
            "type": "image",
            "bbox": [
                0.329,
                0.185,
                0.474,
                0.301
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.53,
                0.186,
                0.557,
                0.2
            ],
            "angle": 0,
            "content": "33."
        },
        {
            "type": "image",
            "bbox": [
                0.56,
                0.185,
                0.732,
                0.308
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.311,
                0.848,
                0.326
            ],
            "angle": 0,
            "content": "34. 证明：每个顶点的度都不超过2的简单图的限制度数生成树包含该图中的单独一条哈密顿通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.329,
                0.892,
                0.362
            ],
            "angle": 0,
            "content": "35. 若可以用整数 1, 2, …, \\( n \\) 来标记带有 \\( n \\) 个顶点的树的顶点，使得相邻顶点的标记之差的绝对值都是不同的，则称这棵树为优美的。证明：下面的树都是优美的。"
        },
        {
            "type": "list",
            "bbox": [
                0.043,
                0.311,
                0.892,
                0.362
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.364,
                0.237,
                0.379
            ],
            "angle": 0,
            "content": "a）"
        },
        {
            "type": "image",
            "bbox": [
                0.269,
                0.364,
                0.433,
                0.405
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.464,
                0.364,
                0.637,
                0.407
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.682,
                0.364,
                0.88,
                0.433
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.438,
                0.891,
                0.453
            ],
            "angle": 0,
            "content": "毛虫图是含有一条简单通路的树，使得不包含在这条通路中的每个顶点都与这条通路中的一个顶点相邻。"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.456,
                0.321,
                0.471
            ],
            "angle": 0,
            "content": "36. 练习 35 的图，哪些是毛虫图？"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.474,
                0.424,
                0.489
            ],
            "angle": 0,
            "content": "37. 带6个顶点的互不同构的毛虫图有多少种？"
        },
        {
            "type": "text",
            "bbox": [
                0.02,
                0.493,
                0.569,
                0.507
            ],
            "angle": 0,
            "content": "**38. a) 证明或反证：其边形成一条唯一通路的所有树都是优美的。"
        },
        {
            "type": "list",
            "bbox": [
                0.02,
                0.456,
                0.569,
                0.507
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.074,
                0.511,
                0.421,
                0.525
            ],
            "angle": 0,
            "content": "b) 证明或反证：所有的毛虫图都是优美的。"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.528,
                0.892,
                0.561
            ],
            "angle": 0,
            "content": "39. 假设在一个很长的比特串中，比特0出现的频率是0.9，比特1出现的频率是0.1，并且比特都是独立地出现的。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.564,
                0.89,
                0.596
            ],
            "angle": 0,
            "content": "a)为4个2比特的块00、01、10和11构造哈夫曼编码。用这个编码来编码一个比特串，所需要的平均比特数是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.6,
                0.888,
                0.614
            ],
            "angle": 0,
            "content": "b)为8个3比特的块构造哈夫曼编码。用这个编码来编码一个比特串，所需要的平均比特数是多少？"
        },
        {
            "type": "list",
            "bbox": [
                0.073,
                0.564,
                0.89,
                0.614
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.618,
                0.764,
                0.633
            ],
            "angle": 0,
            "content": "40. 假设 \\(G\\) 是没有回路的有向图。描述如何用深度优先搜索来完成 \\(G\\) 的顶点的拓扑排序。"
        },
        {
            "type": "text",
            "bbox": [
                0.03,
                0.636,
                0.892,
                0.669
            ],
            "angle": 0,
            "content": "* 41. 假定 \\( e \\) 是加权图里与顶点 \\( v \\) 关联的一条边，使得 \\( e \\) 的权不超过与顶点 \\( v \\) 关联的任何其他边的权。证明：存在一棵包含这条边的最小生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.672,
                0.892,
                0.723
            ],
            "angle": 0,
            "content": "42.3对夫妇到达一条河流的岸边。每个妻子都容易嫉妒，当她的丈夫与其他的妻子（或其他人）在一起，但是她不在场时，她就不信任她的丈夫。6个人如何用一条只能装载不超过两个人的船来渡河，使得每位丈夫无法与妻子之外的女人单独相处？解答时使用图论模型。"
        },
        {
            "type": "text",
            "bbox": [
                0.03,
                0.726,
                0.892,
                0.759
            ],
            "angle": 0,
            "content": "* 43. 证明：若在加权图里没有两条边具有相同的权，则在每个最小生成树里都包含着与顶点 \\( v \\) 关联的权最小的边。"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.762,
                0.66,
                0.777
            ],
            "angle": 0,
            "content": "44. 求下面两个图的最小生成树，其中在生成树里每个顶点的度都不超过2。"
        },
        {
            "type": "list",
            "bbox": [
                0.03,
                0.636,
                0.892,
                0.777
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.076,
                0.78,
                0.275,
                0.884
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.324,
                0.78,
                0.59,
                0.885
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.888,
                0.894,
                0.94
            ],
            "angle": 0,
            "content": "设 \\(G = (V,E)\\) 是有向图，\\(r\\) 是 \\(G\\) 中的顶点。以 \\(r\\) 为根的 \\(G\\) 的树形图是 \\(G\\) 的子图 \\(T = (V,F)\\)，使得 \\(T\\) 的基本无向图是 \\(G\\) 的基本无向图的生成树且对于每个 \\(v \\in V\\)，在 \\(T\\) 中都有一条从 \\(r\\) 到 \\(v\\) 的通路（考虑边的方向）。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.145,
                0.041,
                0.179,
                0.055
            ],
            "angle": 0,
            "content": "714"
        },
        {
            "type": "header",
            "bbox": [
                0.225,
                0.04,
                0.301,
                0.056
            ],
            "angle": 0,
            "content": "第11章"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.096,
                0.962,
                0.13
            ],
            "angle": 0,
            "content": "45. 证明：\\(G = (V, E)\\) 的子图 \\(T = (V, F)\\) 是以 \\(r\\) 为根的 \\(G\\) 的树形图，当且仅当 \\(T\\) 包含 \\(r\\)，\\(T\\) 中没有简单回路，对 \\(T\\) 中每一个非 \\(r\\) 的顶点 \\(v \\in V\\)，\\(\\deg^{-}(v) = 1\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.133,
                0.962,
                0.166
            ],
            "angle": 0,
            "content": "46. 证明：有向图 \\(G = (V, E)\\) 有一个以 \\(r\\) 为根的树形图，当且仅当每一个顶点 \\(v \\in V\\)，有一条从 \\(r\\) 到 \\(v\\) 的有向通路。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.17,
                0.962,
                0.203
            ],
            "angle": 0,
            "content": "47. 在本练习中，将开发一个求有向图 \\(G = (V, E)\\) 的强连通分支的算法。当有一条从 \\(\\mathcal{V}\\) 到 \\(\\mathcal{W}\\) 的有向通路时，顶点 \\(\\boldsymbol{\\varpi} \\in V\\) 是从顶点 \\(\\boldsymbol{\\upsilon} \\in V\\) 可到达。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.206,
                0.767,
                0.221
            ],
            "angle": 0,
            "content": "a) 解释如何用有向图 \\(G\\) 中的宽度优先搜索，求从顶点 \\(v \\in G\\) 可达的所有顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.225,
                0.961,
                0.257
            ],
            "angle": 0,
            "content": "b)解释如何用 \\(G^{\\mathrm{conv}}\\) 中的宽度优先搜索，求从顶点 \\(\\upsilon \\in G\\) 可达的所有顶点。（ \\(G^{\\mathrm{conv}}\\) 是把 \\(G\\) 中所有边的方向取反后得到的有向图。）"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.262,
                0.961,
                0.294
            ],
            "angle": 0,
            "content": "c)解释如何使用a)和b)构造一个求有向图 \\(G\\) 的强连通分支的算法，并且解释你所设计的算法的正确性。"
        },
        {
            "type": "title",
            "bbox": [
                0.116,
                0.31,
                0.252,
                0.329
            ],
            "angle": 0,
            "content": "计算机课题"
        },
        {
            "type": "title",
            "bbox": [
                0.116,
                0.336,
                0.352,
                0.351
            ],
            "angle": 0,
            "content": "按给定的输入和输出写程序。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.355,
                0.56,
                0.368
            ],
            "angle": 0,
            "content": "1. 给定无向简单图的相邻矩阵，确定这个图是不是树。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.373,
                0.91,
                0.387
            ],
            "angle": 0,
            "content": "2. 给定有根树的相邻矩阵和这棵树的一个顶点，求出这个顶点的父母、孩子、祖先、后代和层数。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.391,
                0.91,
                0.405
            ],
            "angle": 0,
            "content": "3. 给定有根树的边的列表和这棵树的一个顶点，求出这个顶点的父母、孩子、祖先、后代和层数。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.409,
                0.56,
                0.423
            ],
            "angle": 0,
            "content": "4. 给定元素的列表，构造包含这些元素的二叉搜索树。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.428,
                0.855,
                0.442
            ],
            "angle": 0,
            "content": "5. 给定二叉搜索树和一个元素，在这个二叉搜索树里求出这个元素的位置或添加这个元素。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.446,
                0.597,
                0.46
            ],
            "angle": 0,
            "content": "6. 给定有序根树的边的有序列表，求出它的边的通用地址。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.465,
                0.689,
                0.478
            ],
            "angle": 0,
            "content": "7. 给定有序根树的边的有序列表，以前序、中序和后序列出它的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.483,
                0.466,
                0.497
            ],
            "angle": 0,
            "content": "8. 给定前缀形式的算术表达式，求它的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.501,
                0.466,
                0.515
            ],
            "angle": 0,
            "content": "9. 给定后缀形式的算术表达式，求它的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.52,
                0.661,
                0.533
            ],
            "angle": 0,
            "content": "10. 给定一组符号的频率，用哈夫曼编码来求这些符号的最优编码。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.538,
                0.588,
                0.551
            ],
            "angle": 0,
            "content": "11. 给定取石子游戏的开局，确定第一个选手的最优策略。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.556,
                0.735,
                0.569
            ],
            "angle": 0,
            "content": "12. 给定连通无向简单图的相邻矩阵，用深度优先搜索找出这个图的生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.574,
                0.735,
                0.587
            ],
            "angle": 0,
            "content": "13. 给定连通无向简单图的相邻矩阵，用宽度优先搜索找出这个图的生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.593,
                0.812,
                0.606
            ],
            "angle": 0,
            "content": "14. 给定一组正整数和一个正整数 \\(N\\)，利用回溯求这些整数的一个子集，使其和为 \\(N\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.611,
                0.809,
                0.625
            ],
            "angle": 0,
            "content": "* 15. 给定无向简单图的相邻矩阵，若有可能，则利用回溯，用3种颜色为这个图着色。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.629,
                0.546,
                0.643
            ],
            "angle": 0,
            "content": "* 16. 给定一个正整数 \\( n \\)，利用回溯来解决 \\( n \\) 皇后问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.648,
                0.809,
                0.662
            ],
            "angle": 0,
            "content": "17. 给定加权无向连通图的边的列表和它们的权，用普林算法求这个图的最小生成树。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.666,
                0.865,
                0.68
            ],
            "angle": 0,
            "content": "18. 给定加权无向连通图的边的列表和它们的权，用克鲁斯卡尔算法求这个图的最小生成树。"
        },
        {
            "type": "list",
            "bbox": [
                0.103,
                0.355,
                0.91,
                0.68
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.116,
                0.696,
                0.252,
                0.715
            ],
            "angle": 0,
            "content": "计算和探索"
        },
        {
            "type": "title",
            "bbox": [
                0.116,
                0.722,
                0.538,
                0.737
            ],
            "angle": 0,
            "content": "用一个计算程序或你自己编写的程序做下面的练习。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.74,
                0.394,
                0.754
            ],
            "angle": 0,
            "content": "1. 显示所有的带有6个顶点的树。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.759,
                0.486,
                0.772
            ],
            "angle": 0,
            "content": "2. 显示全部的互不同构的带有7个顶点的树。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.777,
                0.71,
                0.791
            ],
            "angle": 0,
            "content": "* 3. 根据 ASCII 码字符在典型输入中出现的频率，构造它们的哈夫曼编码。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.795,
                0.961,
                0.827
            ],
            "angle": 0,
            "content": "4. 对 \\(n = 1, 2, 3, 4, 5, 6\\)，计算 \\(K_{n}\\) 的不同的生成树的个数。当 \\(n\\) 是正整数时，猜想这种生成树的个数的公式。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.833,
                0.961,
                0.864
            ],
            "angle": 0,
            "content": "5. 对于 \\( n = 100 \\) 、 \\( n = 1000 \\) 和 \\( n = 10000 \\) 来说，比较排序 \\( n \\) 个从小于 1000000 的正整数的集合中随机选择的正整数所需要的比较次数，使用选择排序、插入排序、归并排序和快速排序。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.869,
                0.961,
                0.901
            ],
            "angle": 0,
            "content": "6. 对于不超过 10 的所有正整数 \\( n \\) 来说，计算在 \\( n \\times n \\) 棋盘上放置 \\( n \\) 个皇后，使得这些皇后不能互相攻击的不同方式数。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.905,
                0.921,
                0.92
            ],
            "angle": 0,
            "content": "*7. 求把美国50个州的首府互相连接起来的图的最小生成树，其中每条边上的权是首府之间的距离。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.924,
                0.476,
                0.937
            ],
            "angle": 0,
            "content": "8. 画出 \\(4 \\times 4\\) 棋盘上跳棋游戏的完全博弈树。"
        },
        {
            "type": "list",
            "bbox": [
                0.102,
                0.74,
                0.961,
                0.937
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.777,
                0.034,
                0.885,
                0.048
            ],
            "angle": 0,
            "content": "树 715"
        },
        {
            "type": "title",
            "bbox": [
                0.066,
                0.101,
                0.175,
                0.12
            ],
            "angle": 0,
            "content": "写作课题"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.128,
                0.431,
                0.142
            ],
            "angle": 0,
            "content": "用本教材以外的资料，按下列要求写成论文。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.145,
                0.545,
                0.159
            ],
            "angle": 0,
            "content": "1. 解释凯莱如何用树来枚举特定类型的碳水化合物的个数。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.163,
                0.49,
                0.177
            ],
            "angle": 0,
            "content": "2. 解释在研究进化论时，如何使用树表示祖先关系。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.181,
                0.38,
                0.194
            ],
            "angle": 0,
            "content": "3. 讨论分层的簇树以及如何使用它们。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.198,
                0.883,
                0.212
            ],
            "angle": 0,
            "content": "4. 定义AVL树(有时也称为高度平衡树)。解释如何以及为什么在许多不同的算法中都用到AVL树。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.216,
                0.911,
                0.247
            ],
            "angle": 0,
            "content": "5. 定义四叉树并解释如何用四叉树来表示图像。描述如何通过操纵对应的四叉树来旋转、缩放和转换图像。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.252,
                0.621,
                0.266
            ],
            "angle": 0,
            "content": "6. 定义一个堆，并解释如何把树转化成堆。堆为什么在排序中有用？"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.269,
                0.876,
                0.284
            ],
            "angle": 0,
            "content": "7.描述针对连续读入字符时字母频率发生变化的数据压缩的动态规划算法，比如自适应哈夫曼编码。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.287,
                0.484,
                0.301
            ],
            "angle": 0,
            "content": "8. 解释如何用 \\(\\alpha-\\beta\\) 剪枝来简化对博弈树的值的计算。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.305,
                0.415,
                0.319
            ],
            "angle": 0,
            "content": "9. 描述下棋程序（比如深蓝）所使用的技术。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.323,
                0.776,
                0.337
            ],
            "angle": 0,
            "content": "10. 为树网这种类型的图下定义。解释这种图如何用在非常大的系统集成和并行计算中。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.34,
                0.507,
                0.355
            ],
            "angle": 0,
            "content": "11. 讨论在 IP 组播中避免路由器之间回路所用的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.358,
                0.462,
                0.372
            ],
            "angle": 0,
            "content": "12. 描述基于深度优先搜索来求图的断点的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.376,
                0.555,
                0.39
            ],
            "angle": 0,
            "content": "13. 描述基于深度优先搜索来求有向图的强连通分支的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.393,
                0.654,
                0.407
            ],
            "angle": 0,
            "content": "14. 描述在Web上不同搜索引擎的网络爬虫和网络蜘蛛所用的搜索技术。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.411,
                0.845,
                0.425
            ],
            "angle": 0,
            "content": "15. 描述求图的最小生成树的算法，使得生成树上任意顶点的最大度数不超过一个固定的常数 \\(k\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.429,
                0.61,
                0.443
            ],
            "angle": 0,
            "content": "16. 就复杂度和应用场合而言，对一些最重要的排序算法进行比较。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.447,
                0.443,
                0.46
            ],
            "angle": 0,
            "content": "17. 讨论构造最小生成树的算法的历史和起源。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.465,
                0.294,
                0.479
            ],
            "angle": 0,
            "content": "18. 描述产生随机树的算法。"
        },
        {
            "type": "list",
            "bbox": [
                0.064,
                0.145,
                0.911,
                0.479
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.1,
                0.088,
                0.191,
                0.106
            ],
            "angle": 0,
            "content": "第12章"
        },
        {
            "type": "header",
            "bbox": [
                0.1,
                0.11,
                0.388,
                0.122
            ],
            "angle": 0,
            "content": "Discrete Mathematics and Its Applications, 8E"
        },
        {
            "type": "title",
            "bbox": [
                0.091,
                0.131,
                0.277,
                0.158
            ],
            "angle": 0,
            "content": "布尔代数"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.209,
                0.938,
                0.419
            ],
            "angle": 0,
            "content": "计算机和其他电子设备中的电路都有输入和输出，输入是0或1，输出也是0或1。电路可以用任何具有两个不同状态的基本元件来构造，开关和光学装置都是这样的元件，开关可能处于开或关的位置，光学装置可能是点亮或未点亮的。1854年，乔治·布尔(GeorgeBoole)在《TheLawsofThought》一书中第一次给出了逻辑的基本规则。1938年，克劳德·香农(ClaudeShannon)揭示了怎么用逻辑的基本规则来设计电路，这些基本规则形成了布尔代数的基础。本章将逐步展开布尔代数基本性质的讨论。电路的操作可以用布尔函数来定义，这样的布尔函数对任意一组输入都能指出其输出的值。构造电路的第一步是用由布尔代数的基本运算构造的表达式来表示布尔函数。我们将介绍一个能产生这些表达式的算法，所得到的表达式可能包含一些冗余运算。本章的后面部分将描述一个求表达式的方法，求得的表达式中所包含的和与积的个数是表示一个布尔函数所需数量中最少的。将要展开讨论的这些方法称为卡诺(Karnaugh)图方法和奎因莫可拉斯基(Quine-McCluskey)方法，它们对于有效电路的设计十分重要。"
        },
        {
            "type": "title",
            "bbox": [
                0.09,
                0.432,
                0.279,
                0.451
            ],
            "angle": 0,
            "content": "12.1 布尔函数"
        },
        {
            "type": "title",
            "bbox": [
                0.091,
                0.459,
                0.229,
                0.476
            ],
            "angle": 0,
            "content": "12.1.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.48,
                0.938,
                0.534
            ],
            "angle": 0,
            "content": "布尔代数提供的是集合 \\(\\{0,1\\}\\) 上的运算和规则，这个集合及布尔代数的规则还可以用来研究电子和光学开关。我们用得最多的三个布尔代数运算是补、布尔和与布尔积。元素的补用上划线加以标记，其定义为： \\(\\overline{0} = 1\\) ， \\(\\overline{1} = 0\\) 。布尔和记为 \\(+\\) 或OR，它的值如下："
        },
        {
            "type": "equation",
            "bbox": [
                0.29,
                0.538,
                0.735,
                0.552
            ],
            "angle": 0,
            "content": "\\[\n1 + 1 = 1, \\quad 1 + 0 = 1, \\quad 0 + 1 = 1, \\quad 0 + 0 = 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.13,
                0.557,
                0.461,
                0.573
            ],
            "angle": 0,
            "content": "布尔积记为·或AND，它的值如下："
        },
        {
            "type": "equation",
            "bbox": [
                0.301,
                0.576,
                0.725,
                0.59
            ],
            "angle": 0,
            "content": "\\[\n1 \\cdot 1 = 1, \\quad 1 \\cdot 0 = 0, \\quad 0 \\cdot 1 = 0, \\quad 0 \\cdot 0 = 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.595,
                0.938,
                0.631
            ],
            "angle": 0,
            "content": "在不引起混淆时，可以删去·，就像写代数积时一样。除非使用括号，否则布尔运算的优先级规则是：首先计算所有补，然后是布尔积，然后是布尔和，如例1所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.636,
                0.408,
                0.653
            ],
            "angle": 0,
            "content": "例1 计算 \\( 1 \\cdot 0 + \\overline{(0 + 1)} \\) 的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.659,
                0.525,
                0.674
            ],
            "angle": 0,
            "content": "解 根据补、布尔积与布尔和的定义，得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.406,
                0.677,
                0.622,
                0.73
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} 1 \\cdot 0 + \\overline {{(0 + 1)}} = 0 + \\overline {{1}} \\\\ = 0 + 0 \\\\ = 0 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.754,
                0.938,
                0.828
            ],
            "angle": 0,
            "content": "补、布尔和与布尔积分别对应于逻辑运算 \\(\\neg\\) 、 \\(\\forall\\) 和 \\(\\land\\) ，且0对应于F（假)，1对应于T（真）。布尔代数中的恒等式可以直接转换为复合命题中的等价式。反之，复合命题中的等价式也可以转换为布尔代数中的恒等式。本节后面部分将会介绍，为什么这些转换产生有效的逻辑等价式和布尔代数恒等式。例2显示了如何把布尔代数恒等式转换为命题逻辑等价式。"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.833,
                0.692,
                0.851
            ],
            "angle": 0,
            "content": "例2 把例1中的恒等式 \\( 1 \\cdot 0 + \\overline{(0 + 1)} = 0 \\) 转换成逻辑等价式。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.856,
                0.938,
                0.891
            ],
            "angle": 0,
            "content": "解 把恒等式中的1转换成T、0转换成F、布尔和转换成析取、布尔积转换成合取、补转换成否定，就可以得到逻辑等价式"
        },
        {
            "type": "equation",
            "bbox": [
                0.391,
                0.894,
                0.64,
                0.91
            ],
            "angle": 0,
            "content": "\\[\n(\\mathbf {T} \\wedge \\mathbf {F}) \\vee \\neg (\\mathbf {T} \\vee \\mathbf {F}) \\equiv \\mathbf {F}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.13,
                0.913,
                0.72,
                0.93
            ],
            "angle": 0,
            "content": "下面的例3显示了如何把命题逻辑等价式转换为布尔代数恒等式。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.677,
                0.031,
                0.787,
                0.046
            ],
            "angle": 0,
            "content": "布尔代数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.833,
                0.032,
                0.869,
                0.045
            ],
            "angle": 0,
            "content": "717"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.089,
                0.635,
                0.107
            ],
            "angle": 0,
            "content": "例3 把逻辑等价式 \\((\\mathrm{T} \\land \\mathrm{T}) \\lor \\neg \\mathrm{F} \\equiv \\mathrm{T}\\) 转换成布尔代数恒等式。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.112,
                0.896,
                0.147
            ],
            "angle": 0,
            "content": "解把逻辑等价式中的T转换成1、F转换成0、析取转换成布尔和、合取转换成布尔积、否定转换成补，就可以得到布尔代数恒等式"
        },
        {
            "type": "equation",
            "bbox": [
                0.404,
                0.15,
                0.545,
                0.166
            ],
            "angle": 0,
            "content": "\\[\n(1 \\cdot 1) + \\bar {0} = 1\n\\]"
        },
        {
            "type": "title",
            "bbox": [
                0.053,
                0.177,
                0.37,
                0.194
            ],
            "angle": 0,
            "content": "12.1.2 布尔表达式和布尔函数"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.197,
                0.899,
                0.253
            ],
            "angle": 0,
            "content": "设 \\(B = \\{0,1\\}\\) ，则 \\(B^n = \\{(x_1,x_2,\\dots ,x_n)\\mid x_i\\in B\\) ， \\(1\\leqslant i\\leqslant n\\}\\) 是由0和1能构成的所有 \\(n\\) 元组的集合。变元 \\(x\\) 如果仅从 \\(B\\) 中取值，则称该变元为布尔变元，即它的值只可能为0或1。从 \\(B^n\\) 到 \\(B\\) 的函数称为 \\(\\pmb{n}\\) 元布尔函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.258,
                0.898,
                0.297
            ],
            "angle": 0,
            "content": "例4从布尔变元有序对的取值集合到集合 \\(\\{0,1\\}\\) 的函数 \\(F(x,y) = x\\overline{y}\\) 就是一个2元布尔函数，且 \\(F(1,1) = 0\\) ， \\(F(1,0) = 1\\) ， \\(F(0,1) = 0\\) ， \\(F(0,0) = 0\\) 。 \\(F\\) 的值如表1所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.3,
                0.692,
                0.335
            ],
            "angle": 0,
            "content": "布尔函数也可用由变元和布尔运算构成的表达式来表示。关于变元 \\(x_{1}, x_{2}, \\cdots, x_{n}\\) 的布尔表达式可以递归地定义如下："
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.338,
                0.455,
                0.353
            ],
            "angle": 0,
            "content": "1)0，1， \\(x_{1}\\) ， \\(x_{2}\\) ，…， \\(x_{n}\\) 是布尔表达式；"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.358,
                0.692,
                0.393
            ],
            "angle": 0,
            "content": "2)如果 \\(E_{1}\\) 和 \\(E_{2}\\) 是布尔表达式，则 \\(\\overline{E}_1\\) 、 \\((E_1E_2)\\) 和 \\((E_{1} + E_{2})\\) 是布尔表达式。"
        },
        {
            "type": "list",
            "bbox": [
                0.051,
                0.338,
                0.692,
                0.393
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.396,
                0.898,
                0.432
            ],
            "angle": 0,
            "content": "每个布尔表达式表示一个布尔函数，此函数的值是通过在表达式中 0 0 0用0和1替换变元得到的。在12.2节中我们将介绍怎么用布尔表达式来表示布尔函数。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.782,
                0.307,
                0.831,
                0.321
            ],
            "angle": 0,
            "content": "表1"
        },
        {
            "type": "table",
            "bbox": [
                0.716,
                0.325,
                0.899,
                0.408
            ],
            "angle": 0,
            "content": "<table><tr><td>x</td><td>y</td><td>F(x,y)</td></tr><tr><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.437,
                0.571,
                0.454
            ],
            "angle": 0,
            "content": "例5 求由 \\( F(x, y, z) = xy + \\overline{z} \\) 表示的布尔函数的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.46,
                0.371,
                0.475
            ],
            "angle": 0,
            "content": "解 这个函数的值由表2表示。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.45,
                0.488,
                0.501,
                0.501
            ],
            "angle": 0,
            "content": "表2"
        },
        {
            "type": "table",
            "bbox": [
                0.053,
                0.504,
                0.9,
                0.585
            ],
            "angle": 0,
            "content": "<table><tr><td>x</td><td>y</td><td>z</td><td>xy</td><td>z</td><td>F(x,y,z)=xy+z</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr></table>"
        },
        {
            "type": "image",
            "bbox": [
                0.053,
                0.617,
                0.122,
                0.637
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.054,
                0.651,
                0.195,
                0.764
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.055,
                0.768,
                0.185,
                0.797
            ],
            "angle": 0,
            "content": "©Alfred Eisenstaedt/The LIFE Picture Collection/ Getty Images"
        },
        {
            "type": "text",
            "bbox": [
                0.212,
                0.651,
                0.901,
                0.807
            ],
            "angle": 0,
            "content": "克劳德·艾尔伍德·香农(Claude Elwood Shannon，1916—2001）1916年，香农出生于密歇根州的配托斯基(Petoskey)，并在盖劳得(Gaylod)长大。他的父亲是商人同时也是遗嘱检验法官，母亲是语言教师兼中学校长。1936年，他毕业于密歇根大学，之后他来到了麻省理工学院继续学业，并得到了一份维护微分分析器的工作。这种机器是由轴和齿轮构成的机械计算装置，由他的硕士论文指导老师文那瓦·布什(Vannevar Bush)构建。他的硕士论文写于1936年，主要研究微分分析器的逻辑性质。他在论文中第一次提出了布尔代数在开关电路设计中的应用，使得这几乎成为了20世纪最著名的硕士论文。1940年，他在麻省理工学院获得博士学位，同年加入贝尔实验室。在这里他主要负责数据有效传输方面的工作，他也是首批用比特表示信息的人之"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.81,
                0.901,
                0.843
            ],
            "angle": 0,
            "content": "一。同时，他还从事确定电话线所能承载的流量方面的研究。香农对信息论做出了卓越的贡献。在20世纪50年代初期，他是人工智能的主要奠基人之一。1956年，他来到麻省理工学院继续从事信息论研究。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.846,
                0.901,
                0.932
            ],
            "angle": 0,
            "content": "香农有着不合传统的一面。他被认为是以火箭为动力的塑料玩具飞盘的发明者。他曾在贝尔实验室的门厅里骑着单轮脚踏车，并同时耍着4个球，也因此成了家喻户晓的名人。香农50岁就退休了，但在其后的十多年中还零星地发表了一些文章。他在晚年将精力主要放在了研制一些宠物用品上，例如他建造了机动化的跳跃用高跷杖。香农曾经说过一句很有意思的话：“我可以想象，我们成为机器人，狗成为人的时代将会到来，我为机器鼓气加油。”这句话发表在1987年的《Omni Magazine》杂志上。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.134,
                0.03,
                0.172,
                0.044
            ],
            "angle": 0,
            "content": "718"
        },
        {
            "type": "header",
            "bbox": [
                0.215,
                0.029,
                0.292,
                0.045
            ],
            "angle": 0,
            "content": "第12章"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.877,
                0.085,
                0.915,
                0.099
            ],
            "angle": 0,
            "content": "（续）"
        },
        {
            "type": "table",
            "bbox": [
                0.107,
                0.103,
                0.954,
                0.2
            ],
            "angle": 0,
            "content": "<table><tr><td>x</td><td>y</td><td>z</td><td>xy</td><td>z</td><td>F(x,y,z)=xy+ z</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.215,
                0.954,
                0.252
            ],
            "angle": 0,
            "content": "注意，布尔函数还可用图形来表示，方法是：将 \\( n \\) 元二进制数组与 \\( n \\) 方体的顶点一一对应，再标出那些函数值为1的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.256,
                0.954,
                0.274
            ],
            "angle": 0,
            "content": "例6例5中从 \\(B^3\\) 到 \\(B\\) 的函数 \\(F(x,y,z) = xy + \\overline{z}\\) 可如下表示：标出满足 \\(F(x,y,z) = 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.278,
                0.752,
                0.314
            ],
            "angle": 0,
            "content": "的五个3元组(1，1，1)、（1，1，0）、（1，0，0）、（0，1，0）和（0，0，0)所对应的顶点。如图1所示，这些顶点用实心的黑圈标出。"
        },
        {
            "type": "image",
            "bbox": [
                0.769,
                0.281,
                0.955,
                0.395
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.838,
                0.403,
                0.887,
                0.417
            ],
            "angle": 0,
            "content": "图1"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.317,
                0.755,
                0.43
            ],
            "angle": 0,
            "content": "\\(n\\) 个变元的布尔函数 \\(F\\) 和 \\(G\\) 是相等的，当且仅当 \\(F(b_{1}, b_{2}, \\cdots, b_{n}) = G(b_{1}, b_{2}, \\cdots, b_{n})\\) ，其中 \\(b_{1}, b_{2}, \\cdots, b_{n}\\) 属于 \\(B\\) 。表示同一个函数的不同的布尔表达式称为是等价的。例如，布尔表达式 \\(xy\\)、\\(xy + 0\\) 和 \\(xy \\cdot 1\\) 都是等价的。布尔函数 \\(F\\) 的补函数是 \\(\\overline{F}\\)，其中 \\(\\overline{F}(x_{1}, \\cdots, x_{n}) = \\overline{F(x_{1}, \\cdots, x_{n})}\\) 。设 \\(F\\) 和 \\(G\\) 是 \\(n\\) 元布尔函数，函数的布尔和 \\(F + G\\) 与布尔积 \\(FG\\) 分别定义为"
        },
        {
            "type": "equation",
            "bbox": [
                0.3,
                0.433,
                0.76,
                0.468
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} (F + G) \\left(x _ {1}, \\dots , x _ {n}\\right) = F \\left(x _ {1}, \\dots , x _ {n}\\right) + G \\left(x _ {1}, \\dots , x _ {n}\\right) \\\\ (F G) \\left(x _ {1}, \\dots , x _ {n}\\right) = F \\left(x _ {1}, \\dots , x _ {n}\\right) G \\left(x _ {1}, \\dots , x _ {n}\\right) \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.471,
                0.955,
                0.527
            ],
            "angle": 0,
            "content": "2元布尔函数是从一个4个元素的集合到 \\(B\\) 的函数，这4个元素是 \\(B = \\{0,1\\}\\) 中元素构成的元素对， \\(B\\) 是有2个元素的集合。因此有16个不同的2元布尔函数。在表3中，我们列出了这16个不同的2元布尔函数的值，这16个不同的2元布尔函数记为 \\(F_{1}, F_{2}, \\dots, F_{16}\\) 。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.428,
                0.539,
                0.636,
                0.554
            ],
            "angle": 0,
            "content": "表 3 16 个 2 元布尔函数"
        },
        {
            "type": "table",
            "bbox": [
                0.108,
                0.557,
                0.955,
                0.658
            ],
            "angle": 0,
            "content": "<table><tr><td>x</td><td>y</td><td>F1</td><td>F2</td><td>F3</td><td>F4</td><td>F5</td><td>F6</td><td>F7</td><td>F8</td><td>F9</td><td>F10</td><td>F11</td><td>F12</td><td>F13</td><td>F14</td><td>F15</td><td>F16</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.149,
                0.677,
                0.485,
                0.695
            ],
            "angle": 0,
            "content": "例7 有多少个不同的 \\(n\\) 元布尔函数？"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.7,
                0.955,
                0.736
            ],
            "angle": 0,
            "content": "解 由计数的乘积法则可知：有 \\(2^{n}\\) 个由0和1构成的不同的 \\(n\\) 元组。因为布尔函数就是对这 \\(2^{n}\\) 个 \\(n\\) 元组中的每一个进行赋值，所以乘积法则表明有 \\(2^{2^n}\\) 个不同的 \\(n\\) 元布尔函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.739,
                0.79,
                0.756
            ],
            "angle": 0,
            "content": "表4列出了 \\(1\\sim 6\\) 元不同布尔函数的个数。这种函数的个数增长非常快。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.422,
                0.768,
                0.643,
                0.782
            ],
            "angle": 0,
            "content": "表 4 \\( n \\) 度布尔函数的个数"
        },
        {
            "type": "table",
            "bbox": [
                0.11,
                0.785,
                0.957,
                0.868
            ],
            "angle": 0,
            "content": "<table><tr><td>度数</td><td>数量</td><td>度数</td><td>数量</td></tr><tr><td>1</td><td>4</td><td>4</td><td>65536</td></tr><tr><td>2</td><td>16</td><td>5</td><td>4294967296</td></tr><tr><td>3</td><td>256</td><td>6</td><td>18446744073709551616</td></tr></table>"
        },
        {
            "type": "title",
            "bbox": [
                0.11,
                0.891,
                0.363,
                0.908
            ],
            "angle": 0,
            "content": "12.1.3 布尔代数恒等式"
        },
        {
            "type": "text",
            "bbox": [
                0.149,
                0.911,
                0.955,
                0.928
            ],
            "angle": 0,
            "content": "布尔代数有许多恒等式，表5列出了其中最重要的恒等式。这些恒等式对于电路设计的简"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.682,
                0.041,
                0.79,
                0.056
            ],
            "angle": 0,
            "content": "布尔代数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.838,
                0.043,
                0.872,
                0.055
            ],
            "angle": 0,
            "content": "719"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.097,
                0.902,
                0.133
            ],
            "angle": 0,
            "content": "化特别有用。表5中的每个恒等式都可以用表来证明。例8就以这种方法证明了一个分配律。其余性质的证明留作练习。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.407,
                0.143,
                0.553,
                0.158
            ],
            "angle": 0,
            "content": "表 5 布尔恒等式"
        },
        {
            "type": "table",
            "bbox": [
                0.056,
                0.16,
                0.905,
                0.393
            ],
            "angle": 0,
            "content": "<table><tr><td>恒等式</td><td>名称</td><td>恒等式</td><td>名称</td></tr><tr><td rowspan=\"2\">\\(\\overline{x}=x\\)</td><td rowspan=\"2\">双重补律</td><td>\\(x+yz=(x+y)(x+z)\\)</td><td rowspan=\"2\">分配律</td></tr><tr><td>\\(x(y+z)=xy+xz\\)</td></tr><tr><td>\\(x+x=x\\)</td><td rowspan=\"2\">幂等律</td><td>\\(\\overline{(xy)}=\\overline{x}+\\overline{y}\\)</td><td rowspan=\"2\">德·摩根律</td></tr><tr><td>\\(x\\cdot x=x\\)</td><td>\\(\\overline{(x+y)}=\\overline{x}\\overline{y}\\)</td></tr><tr><td>\\(x+0=x\\)</td><td rowspan=\"2\">同一律</td><td>\\(x+xy=x\\)</td><td rowspan=\"2\">吸收律</td></tr><tr><td>\\(x\\cdot 1=x\\)</td><td>\\(x(x+y)=x\\)</td></tr><tr><td>\\(x+1=1\\)</td><td rowspan=\"2\">支配律</td><td>\\(x+\\overline{x}=1\\)</td><td rowspan=\"2\">单位元性质</td></tr><tr><td>\\(x\\cdot 0=0\\)</td><td></td></tr><tr><td>\\(x+y=y+x\\)</td><td rowspan=\"2\">交换律</td><td>\\(x\\overline{x}=0\\)</td><td rowspan=\"2\">零元性质</td></tr><tr><td>\\(xy=yx\\)</td><td></td></tr><tr><td>\\(x+(y+z)=(x+y)+z\\)</td><td rowspan=\"2\">结合律</td><td></td><td rowspan=\"2\"></td></tr><tr><td>\\(x(yz)=(xy)x\\)</td><td></td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.411,
                0.517,
                0.428
            ],
            "angle": 0,
            "content": "例8 证明分配律 \\(x(y + z) = xy + xz\\) 是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.433,
                0.807,
                0.449
            ],
            "angle": 0,
            "content": "解表6表示了此恒等式的验证。这个恒等式成立，因为此表的最后两列相同。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.407,
                0.46,
                0.553,
                0.474
            ],
            "angle": 0,
            "content": "表 6 验证分配率"
        },
        {
            "type": "table",
            "bbox": [
                0.058,
                0.477,
                0.904,
                0.662
            ],
            "angle": 0,
            "content": "<table><tr><td>x</td><td>y</td><td>z</td><td>y+z</td><td>xy</td><td>xz</td><td>x(y+z)</td><td>xy+xz</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.678,
                0.905,
                0.771
            ],
            "angle": 0,
            "content": "读者应该将表5中的布尔恒等式与1.3节表6中的逻辑等价式和2.2节表1中的集合恒等式相比较。所有这些都是一个更抽象结构中恒等式集合的特殊情形。每个恒等式集合都可以通过适当的转换得到。例如，通过把布尔变元变为命题变元、0变为F、1变为T、布尔和变为析取、布尔积变为合取以及补变为否定，这样就可以把表5中的布尔恒等式转换成逻辑等价式，如例9所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.776,
                0.697,
                0.793
            ],
            "angle": 0,
            "content": "例9 把表5中的分配律 \\(x + yz = (x + y)(x + z)\\) 转换成逻辑等价式。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.798,
                0.905,
                0.872
            ],
            "angle": 0,
            "content": "解为了把布尔恒等式转换成逻辑等价式，首先需要把布尔变元变为命题变元。这里的布尔变元 \\(x\\) 、 \\(y\\) 和 \\(z\\) 分别变为命题变元 \\(p\\) 、 \\(q\\) 和 \\(r\\) 。然后把布尔和变为析取，布尔积变为合取（注意在这个布尔恒等式中，0、1和补都没有出现）。这样就把此布尔恒等式转换成了逻辑等价式"
        },
        {
            "type": "equation",
            "bbox": [
                0.321,
                0.876,
                0.64,
                0.892
            ],
            "angle": 0,
            "content": "\\[\np \\vee (q \\wedge r) \\equiv (p \\vee q) \\wedge (p \\vee r)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.894,
                0.543,
                0.91
            ],
            "angle": 0,
            "content": "此逻辑等价式是1.3节表6中命题逻辑的一个分配律。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.913,
                0.675,
                0.929
            ],
            "angle": 0,
            "content": "布尔代数中的恒等式可以用来证明其他的恒等式，如例10所示。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.146,
                0.041,
                0.182,
                0.054
            ],
            "angle": 0,
            "content": "720"
        },
        {
            "type": "header",
            "bbox": [
                0.227,
                0.04,
                0.302,
                0.054
            ],
            "angle": 0,
            "content": "第12章"
        },
        {
            "type": "header",
            "bbox": [
                0.041,
                0.096,
                0.104,
                0.113
            ],
            "angle": 0,
            "content": "Extra Examples"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.1,
                0.962,
                0.138
            ],
            "angle": 0,
            "content": "例10 用表5所示的布尔代数的其他恒等式证明吸收律 \\(x(x + y) = x\\) （这称为吸收律，因为将 \\(x + y\\) 吸收进 \\(x\\) 而保持 \\(x\\) 不变。）"
        },
        {
            "type": "text",
            "bbox": [
                0.156,
                0.141,
                0.623,
                0.157
            ],
            "angle": 0,
            "content": "解推导此恒等式的步骤以及每步使用的定律如下："
        },
        {
            "type": "equation",
            "bbox": [
                0.29,
                0.16,
                0.789,
                0.251
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} x (x + y) = (x + 0) (x + y) \\quad {\\text {布 尔 和 的 同 一 律}} \\\\ = x + 0 \\cdot y \\quad \\text {布 尔 和 对 布 尔 积 的 分 配 律} \\\\ = x + y \\cdot 0 \\quad \\text {布 尔 积 的 交 换 律} \\\\ = x + 0 \\quad \\text {布 尔 积 的 支 配 律} \\\\ = x \\quad \\text {布 尔 和 的 同 一 律} \\\\ \\end{array}\n\\]"
        },
        {
            "type": "title",
            "bbox": [
                0.119,
                0.263,
                0.279,
                0.279
            ],
            "angle": 0,
            "content": "12.1.4 对偶性"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.284,
                0.964,
                0.338
            ],
            "angle": 0,
            "content": "表5中的恒等式都是成对出现的（除了双重补律、单位元性质及零元性质外）。为了解释每一对恒等式中两个式子的关系，我们使用“对偶”这个概念。一个布尔表达式的对偶可用如下方法得到：交换布尔和与布尔积，并交换0与1。"
        },
        {
            "type": "text",
            "bbox": [
                0.156,
                0.343,
                0.562,
                0.36
            ],
            "angle": 0,
            "content": "例11 写出 \\(x(y + 0)\\) 和 \\(\\overline{x} \\cdot 1 + (\\overline{y} + z)\\) 的对偶。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.365,
                0.964,
                0.4
            ],
            "angle": 0,
            "content": "解在这两个表达式中交换符号 \\(+\\) 和·以及0和1，就产生它们的对偶，这两个对偶分别是 \\(x + (y\\cdot 1)\\) 和 \\((\\overline{x} +0)(\\overline{y} z)\\) □"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.403,
                0.964,
                0.477
            ],
            "angle": 0,
            "content": "布尔表达式所表示的布尔函数 \\(F\\) 的对偶是由这个表达式的对偶所表示的函数，这个对偶函数记为 \\(F^{d}\\)，它不依赖于表示 \\(F\\) 的那个特定的布尔表达式。对于由布尔表达式表示的函数的恒等式，当取恒等式两边的函数的对偶时，等式仍然成立（原因参见练习30），此结果叫作对偶性原理，它对于获得新的恒等式十分有用。"
        },
        {
            "type": "text",
            "bbox": [
                0.156,
                0.482,
                0.763,
                0.499
            ],
            "angle": 0,
            "content": "例12 通过取对偶的方法，用吸收律 \\(x(x + y) = x\\) 构造一个恒等式。"
        },
        {
            "type": "text",
            "bbox": [
                0.156,
                0.505,
                0.893,
                0.521
            ],
            "angle": 0,
            "content": "解取此恒等式两边的对偶，得到恒等式 \\(x + xy = x\\) ，它也被称为吸收律，见表5。"
        },
        {
            "type": "title",
            "bbox": [
                0.119,
                0.531,
                0.412,
                0.548
            ],
            "angle": 0,
            "content": "12.1.5 布尔代数的抽象定义"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.552,
                0.964,
                0.606
            ],
            "angle": 0,
            "content": "虽然本节着重讨论布尔函数和表达式，但所有的结论都可以转换成关于命题的结论，也可以转换成关于集合的结论。因此，抽象地定义布尔代数十分有用。一旦一个特定的结构被证明是布尔代数，则所有关于布尔代数的一般结果都可应用于这个特定的结构。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.609,
                0.962,
                0.643
            ],
            "angle": 0,
            "content": "布尔代数可以用多种方法来定义，最常用的方法是指明运算所必须满足的性质，如定义1所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.653,
                0.955,
                0.689
            ],
            "angle": 0,
            "content": "定义1 一个布尔代数是一个集合 \\(B\\)，它有两个二元运算 \\(\\vee\\) 和 \\(\\wedge\\)、元素0和1，以及一个一元运算 \\(-\\)，且对 \\(B\\) 中的所有元素 \\(x\\)、\\(y\\) 和 \\(z\\)，下列性质成立："
        },
        {
            "type": "equation",
            "bbox": [
                0.361,
                0.694,
                0.722,
                0.914
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l l} x \\vee 0 = x \\\\ x \\wedge 1 = x \\\\ x \\vee \\overline {{x}} = 1 \\\\ x \\wedge \\overline {{x}} = 0 \\\\ (x \\vee y) \\vee z = x \\vee (y \\vee z) \\\\ (x \\wedge y) \\wedge z = x \\wedge (y \\wedge z) \\\\ x \\vee y = y \\vee x \\\\ x \\wedge y = y \\wedge x \\\\ x \\vee (y \\wedge z) = (x \\vee y) \\wedge (x \\vee z) \\\\ x \\wedge (y \\vee z) = (x \\wedge y) \\vee (x \\wedge z) \\\\ \\end{array} \\text {同 一 律}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.157,
                0.923,
                0.962,
                0.939
            ],
            "angle": 0,
            "content": "使用定义1所给的定律，可以证明，对于每个布尔代数，许多其他的定律成立，例如幂等"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.685,
                0.038,
                0.796,
                0.053
            ],
            "angle": 0,
            "content": "布尔代数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.842,
                0.039,
                0.875,
                0.053
            ],
            "angle": 0,
            "content": "721"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.095,
                0.342,
                0.11
            ],
            "angle": 0,
            "content": "律和支配律。（见练习 \\(35\\sim 42\\) 。）"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.114,
                0.907,
                0.224
            ],
            "angle": 0,
            "content": "以前讨论过，\\(B = \\{0, 1\\}\\) 连同 OR、AND 运算及“补”运算满足所有这些性质。有 \\(n\\) 个变元的所有命题构成的集合，连同 \\(\\vee\\) 和 \\(\\wedge\\) 运算、F 和 T 及“非”运算，也满足布尔代数的所有性质，这可以从 1.3 节中的表 6 看出来。类似地，一个全集 \\(U\\) 的所有子集构成的集合，连同并和交运算、空集和全集以及集合的补运算是一个布尔代数，这可以从 2.2 节的表 1 中看出来。所以，为了建立关于布尔表达式、命题和集合的结果，我们只要证明关于抽象布尔代数的结果即可。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.228,
                0.907,
                0.302
            ],
            "angle": 0,
            "content": "布尔代数也可以用第9章中所讨论的格的概念来定义。一个格 \\(L\\) 是一个偏序集，其每对元素 \\(x\\)、\\(y\\) 都有一个最小上界，记为 \\(\\operatorname{lub}(x, y)\\)，也有一个最大下界，记为 \\(\\operatorname{glb}(x, y)\\)。给定 \\(L\\) 的两个元素 \\(x\\) 和 \\(y\\)，我们可以定义 \\(L\\) 的两个运算 \\(\\vee\\) 和 \\(\\wedge\\) 如下：\\(x \\vee y = \\operatorname{lub}(x, y)\\)，\\(x \\wedge y = \\operatorname{glb}(x, y)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.305,
                0.907,
                0.398
            ],
            "angle": 0,
            "content": "要使一个格 \\(L\\) 成为定义1中所定义的布尔代数，它必须还有两个性质。第一，它必须是有补的。为使一个格成为有补的，它必须有一个最小元素0和一个最大元素1，且对格的每个元素 \\(x\\) ，必须存在一个元素 \\(\\overline{x}\\) ，使得 \\(x\\vee \\overline{x} = 1\\) 且 \\(x\\wedge \\overline{x} = 0\\) 。第二，它必须是分配的。也就是说，对于 \\(L\\) 中的每个 \\(x\\) 、 \\(y\\) 和 \\(z\\) ， \\(x\\vee (y\\wedge z) = (x\\vee y)\\wedge (x\\vee z)\\) 且 \\(x\\wedge (y\\vee z) = (x\\wedge y)\\vee (x\\wedge z)\\) 。证明有补分配格是布尔代数已在第9章中留作补充练习39。"
        },
        {
            "type": "title",
            "bbox": [
                0.06,
                0.408,
                0.106,
                0.423
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.428,
                0.242,
                0.442
            ],
            "angle": 0,
            "content": "1. 求下列表达式的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.083,
                0.445,
                0.143,
                0.459
            ],
            "angle": 0,
            "content": "a) \\(1\\cdot \\overline{0}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.267,
                0.445,
                0.326,
                0.459
            ],
            "angle": 0,
            "content": "b)1+1"
        },
        {
            "type": "text",
            "bbox": [
                0.433,
                0.445,
                0.49,
                0.459
            ],
            "angle": 0,
            "content": "c) \\(\\overline{0} \\cdot 0\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.617,
                0.445,
                0.693,
                0.459
            ],
            "angle": 0,
            "content": "d) \\(\\overline{(1 + 0)}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.464,
                0.485,
                0.478
            ],
            "angle": 0,
            "content": "2. 求满足下列方程的布尔变元 \\(x\\) 的值（如果有的话）。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.482,
                0.171,
                0.495
            ],
            "angle": 0,
            "content": "a) \\(x\\cdot 1 = 0\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.267,
                0.482,
                0.356,
                0.495
            ],
            "angle": 0,
            "content": "b) \\(x + x = 0\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.433,
                0.482,
                0.522,
                0.495
            ],
            "angle": 0,
            "content": "c) \\(x\\cdot 1 = x\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.617,
                0.482,
                0.704,
                0.495
            ],
            "angle": 0,
            "content": "d) \\(x\\cdot \\overline{x} = 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.499,
                0.333,
                0.513
            ],
            "angle": 0,
            "content": "3. a) 证明 \\((1 \\cdot 1) + (\\overline{0 \\cdot 1} + 0) = 1\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.517,
                0.906,
                0.549
            ],
            "angle": 0,
            "content": "b) 通过如下方式把 a) 中的布尔恒等式转换成命题等价式：0 变为 F、1 变为 T、布尔和变为析取、布尔积变为合取、补变为否定以及等于号变为命题逻辑的等价符号。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.552,
                0.306,
                0.566
            ],
            "angle": 0,
            "content": "4. a) 证明 \\((\\overline{1} \\cdot \\overline{0}) + (1 \\cdot \\overline{0}) = 1\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.569,
                0.906,
                0.602
            ],
            "angle": 0,
            "content": "b)通过如下方式把a)中的布尔恒等式转换成命题等价式：0变为F、1变为T、布尔和变为析取、布尔积变为合取、补变为否定以及等于号变为命题逻辑的等价符号。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.605,
                0.373,
                0.619
            ],
            "angle": 0,
            "content": "5. 用表来表示下列每个布尔函数的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.623,
                0.242,
                0.638
            ],
            "angle": 0,
            "content": "a) \\(F(x,y,z) = \\overline{x} y\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.433,
                0.623,
                0.62,
                0.638
            ],
            "angle": 0,
            "content": "b) \\(F(x,y,z) = x + yz\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.64,
                0.312,
                0.655
            ],
            "angle": 0,
            "content": "c) \\(F(x,y,z) = x\\overline{y} +\\overline{(xyz)}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.434,
                0.641,
                0.66,
                0.655
            ],
            "angle": 0,
            "content": "d) \\(F(x,y,z) = x(yz + \\overline{y}\\overline{z})\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.659,
                0.373,
                0.673
            ],
            "angle": 0,
            "content": "6. 用表来表示下列每个布尔函数的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.676,
                0.231,
                0.69
            ],
            "angle": 0,
            "content": "a) \\(F(x,y,z) = \\overline{z}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.433,
                0.676,
                0.629,
                0.69
            ],
            "angle": 0,
            "content": "b) \\(F(x,y,z) = \\overline{x} y + \\overline{y} z\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.694,
                0.32,
                0.708
            ],
            "angle": 0,
            "content": "c) \\(F(x,y,z) = x\\overline{y} z + \\overline{(xyz)}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.434,
                0.694,
                0.661,
                0.708
            ],
            "angle": 0,
            "content": "d) \\(F(x,y,z) = \\overline{y} (xz + \\overline{x}\\overline{z})\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.712,
                0.845,
                0.726
            ],
            "angle": 0,
            "content": "7. 用3立方体 \\(Q_{3}\\) 表示练习5中的每个布尔函数，将函数值为1的3元组所对应的顶点画成黑圈。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.729,
                0.845,
                0.744
            ],
            "angle": 0,
            "content": "8. 用3立方体 \\(Q_{3}\\) 表示练习6中的每个布尔函数，将函数值为1的3元组所对应的顶点画成黑圈。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.747,
                0.442,
                0.761
            ],
            "angle": 0,
            "content": "9.布尔变元 \\(x\\) 和 \\(y\\) 取什么值可满足 \\(xy = x + y?\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.765,
                0.347,
                0.778
            ],
            "angle": 0,
            "content": "10. 有多少个不同的7度布尔函数？"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.782,
                0.447,
                0.796
            ],
            "angle": 0,
            "content": "11. 用表5中的其他定律证明吸收律 \\(x + xy = x\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.029,
                0.8,
                0.814,
                0.814
            ],
            "angle": 0,
            "content": "12. 证明 \\( F(x, y, z) = xy + xz + yz \\) 取值为 1 当且仅当变元 \\( x \\)、\\( y \\) 和 \\( z \\) 中至少有两个取值为 1。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.818,
                0.372,
                0.832
            ],
            "angle": 0,
            "content": "13. 证明 \\(x\\overline{y} + y\\overline{z} + \\overline{x} z = \\overline{x} y + \\overline{y} z + x\\overline{z}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.836,
                0.907,
                0.867
            ],
            "angle": 0,
            "content": "练习 \\(14\\sim 23\\) 处理由本节开始定义的 \\(\\{0,1\\}\\) 上的加法、乘法和补所定义的布尔代数。对每一题，采用与例8中的表相似的形式进行验证。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.871,
                0.215,
                0.885
            ],
            "angle": 0,
            "content": "14. 验证双重补律。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.889,
                0.196,
                0.903
            ],
            "angle": 0,
            "content": "15. 验证幂等律。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.907,
                0.196,
                0.921
            ],
            "angle": 0,
            "content": "16. 验证同一律。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.924,
                0.196,
                0.938
            ],
            "angle": 0,
            "content": "17. 验证支配律。"
        },
        {
            "type": "list",
            "bbox": [
                0.029,
                0.8,
                0.907,
                0.938
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.12,
                0.039,
                0.156,
                0.052
            ],
            "angle": 0,
            "content": "722"
        },
        {
            "type": "header",
            "bbox": [
                0.201,
                0.038,
                0.277,
                0.053
            ],
            "angle": 0,
            "content": "第12章"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.095,
                0.228,
                0.109
            ],
            "angle": 0,
            "content": "18. 验证交换律。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.113,
                0.228,
                0.127
            ],
            "angle": 0,
            "content": "19. 验证结合律。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.13,
                0.357,
                0.145
            ],
            "angle": 0,
            "content": "20. 验证表5中的第一个分配律。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.149,
                0.266,
                0.163
            ],
            "angle": 0,
            "content": "21. 验证德·摩根律。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.166,
                0.266,
                0.18
            ],
            "angle": 0,
            "content": "22. 验证单位元性质。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.184,
                0.246,
                0.198
            ],
            "angle": 0,
            "content": "23. 验证零元性质。"
        },
        {
            "type": "list",
            "bbox": [
                0.09,
                0.095,
                0.357,
                0.198
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.2,
                0.938,
                0.233
            ],
            "angle": 0,
            "content": "布尔运算符 \\(\\oplus\\) 的定义如下： \\(1\\oplus 1 = 0\\) ， \\(1\\oplus 0 = 1\\) ， \\(0\\oplus 1 = 1\\) ， \\(0\\oplus 0 = 0\\) 。此运算符被称为“异或”(XOR)运算符。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.237,
                0.266,
                0.251
            ],
            "angle": 0,
            "content": "24. 化简下列表达式。"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.255,
                0.199,
                0.269
            ],
            "angle": 0,
            "content": "a) \\(x\\oplus 0\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.298,
                0.255,
                0.369,
                0.269
            ],
            "angle": 0,
            "content": "b) \\(x\\oplus 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.465,
                0.255,
                0.535,
                0.269
            ],
            "angle": 0,
            "content": "c) \\(x\\oplus x\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.649,
                0.255,
                0.716,
                0.269
            ],
            "angle": 0,
            "content": "d) \\(x\\oplus \\overline{x}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.273,
                0.303,
                0.287
            ],
            "angle": 0,
            "content": "25. 证明下列恒等式成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.29,
                0.31,
                0.305
            ],
            "angle": 0,
            "content": "a) \\(x\\oplus y = (x + y)\\overline{(xy)}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.465,
                0.291,
                0.655,
                0.305
            ],
            "angle": 0,
            "content": "b) \\(x\\oplus y = (x\\overline{y}) + (\\overline{x} y)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.308,
                0.293,
                0.323
            ],
            "angle": 0,
            "content": "26. 证明 \\(x \\oplus y = y \\oplus x\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.326,
                0.358,
                0.34
            ],
            "angle": 0,
            "content": "27. 证明下列等式成立或不成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.344,
                0.364,
                0.358
            ],
            "angle": 0,
            "content": "a) \\(x\\oplus (y\\oplus z) = (x\\oplus y)\\oplus z\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.465,
                0.344,
                0.732,
                0.358
            ],
            "angle": 0,
            "content": "b) \\(x + (y\\oplus z) = (x + y)\\oplus (x + z)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.362,
                0.403,
                0.375
            ],
            "angle": 0,
            "content": "c) \\(x\\oplus (y + z) = (x\\oplus y) + (x\\oplus z)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.379,
                0.34,
                0.393
            ],
            "angle": 0,
            "content": "28. 求下列布尔表达式的对偶。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.398,
                0.187,
                0.411
            ],
            "angle": 0,
            "content": "a) \\(x + y\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.465,
                0.398,
                0.514,
                0.411
            ],
            "angle": 0,
            "content": "b) \\(\\overline{x}\\overline{y}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.416,
                0.233,
                0.429
            ],
            "angle": 0,
            "content": "c) \\(xyz + \\overline{x}\\overline{y}\\overline{z}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.465,
                0.416,
                0.625,
                0.428
            ],
            "angle": 0,
            "content": "d) \\(x\\overline{z} + x \\cdot 0 + \\overline{x} \\cdot 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.077,
                0.432,
                0.938,
                0.467
            ],
            "angle": 0,
            "content": "* 29. 设 \\(F\\) 是一个布尔函数，它由一个含有变元 \\(x_{1}, \\cdots, x_{n}\\) 的布尔表达式表示。证明 \\(F^{d}(x_{1}, \\cdots, x_{n}) = \\overline{F(\\overline{x}_{1}, \\cdots, \\overline{x}_{n})}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.077,
                0.471,
                0.938,
                0.503
            ],
            "angle": 0,
            "content": "* 30. 设 \\(F\\) 和 \\(G\\) 是由 \\(n\\) 个变元的布尔表达式表示的布尔函数且 \\(F = G\\) 。证明 \\(F^{d} = G^{d}\\)，其中 \\(F^{d}\\) 和 \\(G^{d}\\) 分别是由表示 \\(F\\) 和 \\(G\\) 的布尔表达式的对偶表示的布尔函数。[提示：使用练习29的结果。]"
        },
        {
            "type": "text",
            "bbox": [
                0.077,
                0.507,
                0.936,
                0.522
            ],
            "angle": 0,
            "content": "* 31. 有多少个不同的布尔函数 \\( F\\left( {x,y,z}\\right) \\) 使得对于布尔变元 \\( x \\) 、 \\( y \\) 、 \\( z \\) 的所有值, \\( F\\left( {\\bar{x},\\bar{y},\\bar{z}}\\right)  = F\\left( {x,y,z}\\right) \\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.525,
                0.938,
                0.556
            ],
            "angle": 0,
            "content": "* 32. 有多少个不同的布尔函数 \\( F(x, y, z) \\) 使得对于布尔变元 \\( x, y, z \\) 的所有值，\\( F(\\overline{x}, y, z) = F(x, \\overline{y}, z) = F(x, y, \\overline{z}) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.56,
                0.938,
                0.592
            ],
            "angle": 0,
            "content": "33. 证明：把表6中的布尔代数的德·摩根律转换成逻辑等价式时，它就是命题逻辑中的德·摩根律（见1.3节中的表6）。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.596,
                0.938,
                0.628
            ],
            "angle": 0,
            "content": "34. 证明：把表6中的布尔代数的吸收律转换成逻辑等价式时，它就是命题逻辑中的吸收律（见1.3节中的表6）。"
        },
        {
            "type": "list",
            "bbox": [
                0.077,
                0.432,
                0.938,
                0.628
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.631,
                0.708,
                0.646
            ],
            "angle": 0,
            "content": "在练习 \\(35\\sim 42\\) 中，用定义1中的定律来证明所述性质对每个布尔代数成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.649,
                0.687,
                0.664
            ],
            "angle": 0,
            "content": "35. 在布尔代数中证明，幂等律 \\(x \\vee x = x\\) 和 \\(x \\wedge x = x\\) 对每个元素 \\(x\\) 成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.667,
                0.762,
                0.682
            ],
            "angle": 0,
            "content": "36. 在布尔代数中证明，每个元素 \\(x\\) 都有唯一的一个补 \\(\\overline{x}\\) 使得 \\(x \\vee \\overline{x} = 1\\) 且 \\(x \\wedge \\overline{x} = 0\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.685,
                0.541,
                0.699
            ],
            "angle": 0,
            "content": "37. 在布尔代数中证明，元素0的补是1，反之也成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.703,
                0.601,
                0.717
            ],
            "angle": 0,
            "content": "38. 证明双重补律在布尔代数中成立，即对每个元素 \\(x\\)，\\(\\overline{x} = x\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.72,
                0.867,
                0.735
            ],
            "angle": 0,
            "content": "39. 证明德·摩根律在布尔代数中成立，即对任意元素 \\(x\\) 和 \\(y\\) ，\\(\\overline{(x \\vee y)} = \\overline{x} \\wedge \\overline{y}\\) 且 \\(\\overline{(x \\wedge y)} = \\overline{x} \\vee \\overline{y}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.738,
                0.938,
                0.77
            ],
            "angle": 0,
            "content": "40. 证明模性质在布尔代数中成立，即证明 \\(x \\wedge (y \\vee (x \\wedge z)) = (x \\wedge y) \\vee (x \\wedge z)\\) 且 \\(x \\vee (y \\wedge (x \\vee z)) = (x \\vee y) \\wedge (x \\vee z)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.773,
                0.831,
                0.788
            ],
            "angle": 0,
            "content": "41. 在布尔代数中证明，如果 \\(x \\vee y = 0\\)，则 \\(x = 0\\) 且 \\(y = 0\\)；如果 \\(x \\wedge y = 1\\)，则 \\(x = 1\\) 且 \\(y = 1\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.791,
                0.938,
                0.824
            ],
            "angle": 0,
            "content": "42. 在布尔代数中证明，一个恒等式的对偶还是一个恒等式，其中，恒等式的对偶是如下得到的：交换 \\(\\wedge\\) 和 \\(\\vee\\) 运算符，并交换元素 0 和 1。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.827,
                0.452,
                0.842
            ],
            "angle": 0,
            "content": "43. 证明一个有补的分配格是一个布尔代数。"
        },
        {
            "type": "list",
            "bbox": [
                0.091,
                0.649,
                0.938,
                0.842
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.096,
                0.856,
                0.364,
                0.875
            ],
            "angle": 0,
            "content": "12.2 布尔函数的表示"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.882,
                0.94,
                0.937
            ],
            "angle": 0,
            "content": "本节将研究布尔代数的两个重要问题。第一个问题是：给定一个布尔函数的值，怎样才能找到表示这个布尔函数的布尔表达式？这个问题将通过证明如下结论来解决：任何一个布尔函数都可由变元及其补的布尔积的布尔和表示。这个问题的答案还说明了任意布尔函数都可用三"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.68,
                0.035,
                0.792,
                0.051
            ],
            "angle": 0,
            "content": "布尔代数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.836,
                0.036,
                0.871,
                0.05
            ],
            "angle": 0,
            "content": "723"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.091,
                0.902,
                0.147
            ],
            "angle": 0,
            "content": "个布尔运算符（·、+和\\~）表示。第二个问题是：有没有一个更小的运算符集合可以用来表示所有的布尔函数？我们将通过证明下列结论来解决这个问题：所有的布尔函数都可以仅用一个运算符来表示。这两个问题在电路设计中都有特殊的重要性。"
        },
        {
            "type": "title",
            "bbox": [
                0.057,
                0.157,
                0.283,
                0.174
            ],
            "angle": 0,
            "content": "12.2.1 积之和展开式"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.177,
                0.702,
                0.193
            ],
            "angle": 0,
            "content": "下面用例子来说明寻找表示布尔函数的布尔表达式的一个重要方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.198,
                0.856,
                0.216
            ],
            "angle": 0,
            "content": "例1 函数 \\( F(x, y, z) \\) 和 \\( G(x, y, z) \\) 如表1所示，求表示这两个函数的布尔表达式。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.221,
                0.492,
                0.314
            ],
            "angle": 0,
            "content": "解我们需要这样一个表达式来表示 \\(F\\) ：当\\(x = z = 1\\) 且 \\(y = 0\\) 时它的值为1，否则它的值为0。此表达式可取为 \\(x\\) 、 \\(\\overline{y}\\) 和 \\(z\\) 的布尔积，这个积 \\(x\\overline{y} z\\) 具有值1当且仅当 \\(x = \\overline{y} = z = 1\\) ，即当且仅当\\(x = z = 1\\) 且 \\(y = 0\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.317,
                0.492,
                0.389
            ],
            "angle": 0,
            "content": "为了表示 \\(G\\) ，我们需要一个表达式满足：当\\(x = y = 1\\) 且 \\(z = 0\\) 时，或当 \\(x = z = 0\\) 且 \\(y = 1\\) 时，它的值为1。此表达式可以取为两个不同的布尔积的布尔和。布尔积 \\(xy\\overline{z}\\) 具有值1当且仅当 \\(x =\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.393,
                0.902,
                0.428
            ],
            "angle": 0,
            "content": "\\(y = 1\\) 且 \\(z = 0\\)；类似地，布尔积 \\(\\overline{x} y\\overline{z}\\) 具有值1当且仅当 \\(x = z = 0\\) 且 \\(y = 1\\)。这两个布尔积的布尔和 \\(xy\\overline{z} + \\overline{x} y\\overline{z}\\) 就表示 \\(G\\)，因为它具有值1当且仅当 \\(x = y = 1\\) 且 \\(z = 0\\)，或 \\(x = z = 0\\) 且 \\(y = 1\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.433,
                0.902,
                0.472
            ],
            "angle": 0,
            "content": "例1 说明一个过程，用这个过程可以构造布尔表达式来表示具有给定值的函数。如果变元值的一个组合使得函数值为1，则此组合确定了变元或其补的一个布尔积。"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.48,
                0.894,
                0.538
            ],
            "angle": 0,
            "content": "定义1 布尔变元或其补称为字面值。布尔变元 \\(x_{1}, x_{2}, \\cdots, x_{n}\\) 的极小项是一个布尔积 \\(y_{1} y_{2} \\cdots y_{n}\\)，其中 \\(y_{i} = x_{i}\\) 或 \\(y_{i} = \\overline{x}_{i}\\)。因此极小项是 \\(n\\) 个字面值的积，每个字面值对应于一个变元。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.546,
                0.903,
                0.583
            ],
            "angle": 0,
            "content": "一个极小项对一个且只对一个变元值的组合取值1。更确切地说，极小项 \\( y_{1}y_{2}\\dots y_{n} \\) 为1当且仅当每个 \\( y_{i} \\) 为1；并且它成立当且仅当 \\( y_{i} = x_{i} \\) 时 \\( x_{i} \\) 为1， \\( y_{i} = \\overline{x}_{i} \\) 时 \\( x_{i} \\) 为0。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.587,
                0.805,
                0.604
            ],
            "angle": 0,
            "content": "例2 求一个极小项使得当 \\(x_{1} = x_{3} = 0\\) 且 \\(x_{2} = x_{4} = x_{5} = 1\\) 时，它为1；否则为0。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.609,
                0.467,
                0.626
            ],
            "angle": 0,
            "content": "解 极小项 \\(\\overline{x}_1x_2\\overline{x}_3x_4x_5\\) 有正确的值集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.628,
                0.905,
                0.74
            ],
            "angle": 0,
            "content": "通过取不同极小项的布尔和，就能构造布尔表达式，使其具有给定的值集合。特别地，极小项的布尔和具有值1仅当和中的某个极小项具有值1时才成立。对于变元值的其他组合，它具有值0。因此，给定一个布尔函数，可以构造极小项的布尔和使得，当该布尔函数具有值1时它的值为1，当该布尔函数具有值0时它的值为0。该布尔和中的极小项与使得该函数值为1的值的组合相对应。表示布尔函数的极小项的和称为此函数的积之和展开式或析取范式。（命题逻辑的析取范式见1.3节练习46。）"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.745,
                0.576,
                0.763
            ],
            "angle": 0,
            "content": "例3 求函数 \\( F(x, y, z) = (x + y)\\overline{z} \\) 的积之和展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.767,
                0.905,
                0.802
            ],
            "angle": 0,
            "content": "解下面用两种方法求 \\(F(x,y,z)\\) 的积之和展开式。第一种方法是用布尔恒等式将这个积展开然后化简。过程如下："
        },
        {
            "type": "equation",
            "bbox": [
                0.247,
                0.807,
                0.717,
                0.915
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} F (x, y, z) = (x + y) \\bar {z} \\\\ = x \\bar {z} + y \\bar {z} \\quad \\text {分 配 律} \\\\ = x 1 \\bar {z} + 1 y \\bar {z} \\quad \\text {同 一 律} \\\\ = x (y + \\bar {y}) \\bar {z} + (x + \\bar {x}) y \\bar {z} \\quad \\text {单 位 元 性 质} \\\\ = x y \\bar {z} + x \\bar {y} \\bar {z} + x y \\bar {z} + \\bar {x} y \\bar {z} \\quad \\text {分 配 律} \\\\ = x y \\bar {z} + x \\bar {y} \\bar {z} + \\bar {x} y \\bar {z} \\quad \\text {幂 等 律} \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.92,
                0.905,
                0.936
            ],
            "angle": 0,
            "content": "构造积之和展开式的第二种方法是，对 \\(x\\) 、y和 \\(\\textbf{z}\\) 所有可能的取值都计算出 \\(F\\) 的值，这些"
        },
        {
            "type": "table",
            "bbox": [
                0.52,
                0.238,
                0.9,
                0.384
            ],
            "angle": 0,
            "content": "<table><tr><td>x</td><td>y</td><td>z</td><td>F</td><td>G</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></table>"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.67,
                0.221,
                0.72,
                0.235
            ],
            "angle": 0,
            "content": "表1"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.122,
                0.038,
                0.156,
                0.051
            ],
            "angle": 0,
            "content": "724"
        },
        {
            "type": "header",
            "bbox": [
                0.204,
                0.036,
                0.278,
                0.051
            ],
            "angle": 0,
            "content": "第12章"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.092,
                0.942,
                0.147
            ],
            "angle": 0,
            "content": "值见表2。 \\(F\\) 的积之和展开式是三个极小项的布尔和，这三个极小项对应于表2的三行，它们使该函数的值为1。从而 \\(F(x,y,z) = xy\\overline{z} +\\) \\(x\\overline{y}\\overline{z} +\\overline{x} y\\overline{z}_{\\circ}\\) 表2"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.15,
                0.532,
                0.261
            ],
            "angle": 0,
            "content": "也可以通过取布尔和的布尔积来求一个布尔表达式，使其表示一个布尔函数，所得到的展开式称为这个函数的合取范式或和之积展开式，这个展开式可以通过求积之和展开式的对偶而得到。本节练习10描述了怎样直接求这样的展开式。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.722,
                0.125,
                0.773,
                0.138
            ],
            "angle": 0,
            "content": "表2"
        },
        {
            "type": "table",
            "bbox": [
                0.556,
                0.141,
                0.937,
                0.278
            ],
            "angle": 0,
            "content": "<table><tr><td>x</td><td>y</td><td>z</td><td>x+y</td><td>z</td><td>(x+y)z</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></table>"
        },
        {
            "type": "title",
            "bbox": [
                0.095,
                0.272,
                0.301,
                0.289
            ],
            "angle": 0,
            "content": "12.2.2 函数完备性"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.292,
                0.942,
                0.384
            ],
            "angle": 0,
            "content": "每个布尔函数都可以表示为极小项的布尔和。每个极小项都是布尔变元或其补的布尔积。这说明每个布尔函数都可以用布尔运算·、+和-来表示。因为每个布尔函数都可以由这些布尔运算表示，所以我们称集合{·，十，}是函数完备的。还有没有更小的函数完备运算符集合呢？如果这三个运算中的某一个能够由其余两个表示，则就还有更小的函数完备运算符集合。用德·摩根律可以做到这一点。使用等式"
        },
        {
            "type": "equation",
            "bbox": [
                0.461,
                0.388,
                0.576,
                0.404
            ],
            "angle": 0,
            "content": "\\[\nx + y = \\overline {{\\overline {{x}} \\overline {{y}}}}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.406,
                0.941,
                0.442
            ],
            "angle": 0,
            "content": "可以消去所有的布尔和，此等式可如下得到：先对12.1节中的表5的第二个德·摩根律的两边求补，再应用双重补律。这意味着 \\(\\{\\cdot, -\\}\\) 是函数完备的。类似地，使用等式"
        },
        {
            "type": "equation",
            "bbox": [
                0.464,
                0.445,
                0.575,
                0.461
            ],
            "angle": 0,
            "content": "\\[\nx y = \\overline {{\\bar {x}}} + \\overline {{\\bar {y}}}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.463,
                0.942,
                0.517
            ],
            "angle": 0,
            "content": "可以消去所有的布尔积，此等式可如下得到：先对12.1节中的表5的第一个德·摩根律的两边求补，再应用双重补律。因此，\\(\\{+, -\\}\\) 是函数完备的。注意，\\(\\{+, \\cdot\\}\\) 不是函数完备的，因为用这两个运算符不可能表示布尔函数 \\(F(x) = \\overline{x}\\)（见练习19）。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.521,
                0.942,
                0.634
            ],
            "angle": 0,
            "content": "我们已经找到了一些含有两个运算符的函数完备集合，还能不能找到更小的集合（即只含一个运算的集合），它仍然是函数完备运算符集合呢？这样的集合是存在的。定义运算符“|”或“NAND”如下： \\(1\\mid 1 = 0\\) 且 \\(1\\mid 0 = 0\\mid 1 = 0\\mid 0 = 1\\) 。定义运算符“↓”或“NOR”如下： \\(1\\downarrow 1 = 1\\downarrow\\) \\(0 = 0\\downarrow 1 = 0\\) 且 \\(0\\downarrow 0 = 1\\) 。集合 \\(\\{\\}\\) 和 \\(\\{\\downarrow \\}\\) 都是函数完备的。因为 \\(\\{\\cdot ,\\cdot \\}\\) 是函数完备的，所以要说明 \\(\\{\\}\\) 是函数完备的，只要证明两个运算符·和-都可以只用运算符|表示，这可由下面两式完成："
        },
        {
            "type": "equation",
            "bbox": [
                0.439,
                0.638,
                0.521,
                0.655
            ],
            "angle": 0,
            "content": "\\[\n\\bar {x} = x \\mid x\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.428,
                0.658,
                0.609,
                0.674
            ],
            "angle": 0,
            "content": "\\[\nx y = (x \\mid y) \\mid (x \\mid y)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.677,
                0.926,
                0.694
            ],
            "angle": 0,
            "content": "读者应当验证这些等式（见练习14）。证明 \\(\\{\\downarrow\\}\\) 的函数完备性留给读者（见练习15和16）。"
        },
        {
            "type": "title",
            "bbox": [
                0.095,
                0.705,
                0.143,
                0.72
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.724,
                0.663,
                0.739
            ],
            "angle": 0,
            "content": "1. 求布尔变元 \\(x\\) 、 \\(y\\) 、 \\(z\\) 或其补的布尔积，使得它具有值为1当且仅当"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.743,
                0.262,
                0.757
            ],
            "angle": 0,
            "content": "a) \\(x = y = 0\\) ， \\(z = 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.47,
                0.743,
                0.641,
                0.756
            ],
            "angle": 0,
            "content": "b) \\(x = 0\\) ， \\(y = 1\\) ， \\(z = 0\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.761,
                0.261,
                0.774
            ],
            "angle": 0,
            "content": "c) \\(x = 0\\) ， \\(y = z = 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.47,
                0.761,
                0.585,
                0.774
            ],
            "angle": 0,
            "content": "d) \\(x = y = z = 0\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.778,
                0.391,
                0.792
            ],
            "angle": 0,
            "content": "2. 求下列布尔函数的积之和展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.796,
                0.27,
                0.81
            ],
            "angle": 0,
            "content": "a) \\(F(x,y) = \\overline{x} +y\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.47,
                0.796,
                0.607,
                0.81
            ],
            "angle": 0,
            "content": "b) \\(F(x,y) = x\\overline{y}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.815,
                0.236,
                0.828
            ],
            "angle": 0,
            "content": "c) \\(F(x,y) = 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.47,
                0.814,
                0.591,
                0.828
            ],
            "angle": 0,
            "content": "d) \\(F(x,y) = \\overline{y}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.832,
                0.391,
                0.846
            ],
            "angle": 0,
            "content": "3. 求下列布尔函数的积之和展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.849,
                0.325,
                0.864
            ],
            "angle": 0,
            "content": "a) \\(F(x,y,z) = x + y + z\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.47,
                0.849,
                0.676,
                0.864
            ],
            "angle": 0,
            "content": "b) \\(F(x,y,z) = (x + z)y\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.868,
                0.267,
                0.881
            ],
            "angle": 0,
            "content": "c) \\(F(x,y,z) = x\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.47,
                0.868,
                0.634,
                0.881
            ],
            "angle": 0,
            "content": "d) \\(F(x,y,z) = x\\overline{y}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.885,
                0.694,
                0.899
            ],
            "angle": 0,
            "content": "4. 求布尔函数 \\( F(x, y, z) \\) 的积之和展开式，\\( F(x, y, z) \\) 等于 1 当且仅当"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.903,
                0.18,
                0.915
            ],
            "angle": 0,
            "content": "a) \\(x = 0\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.304,
                0.903,
                0.374,
                0.916
            ],
            "angle": 0,
            "content": "b) \\(xy = 0\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.47,
                0.903,
                0.557,
                0.916
            ],
            "angle": 0,
            "content": "c) \\(x + y = 0\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.655,
                0.903,
                0.733,
                0.916
            ],
            "angle": 0,
            "content": "d) \\(xyz = 0\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.92,
                0.942,
                0.935
            ],
            "angle": 0,
            "content": "5. 求布尔函数 \\( F(w, x, y, z) \\) 的积之和展开式，\\( F(w, x, y, z) \\) 等于 1 当且仅当 \\( w, x, y \\) 和 \\( z \\) 中有奇"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.682,
                0.038,
                0.792,
                0.055
            ],
            "angle": 0,
            "content": "布尔代数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.838,
                0.04,
                0.874,
                0.054
            ],
            "angle": 0,
            "content": "725"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.095,
                0.235,
                0.11
            ],
            "angle": 0,
            "content": "数个变元的值为1。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.113,
                0.903,
                0.146
            ],
            "angle": 0,
            "content": "6. 求布尔函数 \\( F(x_{1}, x_{2}, x_{3}, x_{4}, x_{5}) \\) 的积之和展开式，\\( F(x_{1}, x_{2}, x_{3}, x_{4}, x_{5}) \\) 等于 1 当且仅当 \\( x_{1} \\)、\\( x_{2} \\)、\\( x_{3} \\)、\\( x_{4} \\) 和 \\( x_{5} \\) 中至少有三个变元的值为 1。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.149,
                0.903,
                0.182
            ],
            "angle": 0,
            "content": "求表示布尔函数的布尔表达式的另一种方法是：构造字面值之布尔和的布尔积。练习 \\(7\\sim 11\\) 涉及这种表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.184,
                0.624,
                0.199
            ],
            "angle": 0,
            "content": "7. 求布尔和，它包含 \\( x \\) 或 \\( \\overline{x} \\) 、 \\( y \\) 或 \\( \\overline{y} \\) 、 \\( z \\) 或 \\( \\overline{z} \\)，使得它具有值0当且仅当"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.203,
                0.223,
                0.216
            ],
            "angle": 0,
            "content": "a) \\(x = y = 1\\) ， \\(z = 0\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.264,
                0.203,
                0.38,
                0.216
            ],
            "angle": 0,
            "content": "b) \\(x = y = z = 0\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.43,
                0.203,
                0.571,
                0.216
            ],
            "angle": 0,
            "content": "c) \\(x = z = 0\\) ， \\(y = 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.22,
                0.903,
                0.253
            ],
            "angle": 0,
            "content": "8. 求字面值之布尔和的布尔积，使得它的值为0当且仅当 \\(x = y = 1\\) 且 \\(z = 0\\) ，或者 \\(x = z = 0\\) 且 \\(y = 1\\) ，或者 \\(x = y = z = 0\\) 。[提示：取练习7a、b、c中求得的布尔和的布尔积。]"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.256,
                0.903,
                0.289
            ],
            "angle": 0,
            "content": "9. 设布尔和为 \\( y_{1} + y_{2} + \\dots + y_{n} \\)，其中 \\( y_{i} = x_{i} \\) 或 \\( y_{i} = \\overline{x}_{i} \\) 。证明此布尔和对且只对变元值的一个组合取0值，这个组合为，若 \\( y_{i} = x_{i} \\)，则 \\( x_{i} = 0 \\)；若 \\( y_{i} = \\overline{x}_{i} \\)，则 \\( x_{i} = 1 \\)。这样的布尔和叫作极大项。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.291,
                0.903,
                0.325
            ],
            "angle": 0,
            "content": "10. 证明：布尔函数可以表示为极大项的布尔积。此表示称为该函数的和之积展开式或合取范式。[提示：对于使得函数值为0的每个变元值组合，此积都含有一个对应的极大项。]"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.327,
                0.397,
                0.342
            ],
            "angle": 0,
            "content": "11. 求练习3中每个函数的和之积展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.345,
                0.373,
                0.359
            ],
            "angle": 0,
            "content": "12. 用运算符·和 \\(-\\) 表示下列布尔函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.362,
                0.18,
                0.377
            ],
            "angle": 0,
            "content": "a) \\(x + y + z\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.264,
                0.362,
                0.38,
                0.376
            ],
            "angle": 0,
            "content": "b) \\(x + \\overline{y} (\\overline{x} +z)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.431,
                0.362,
                0.492,
                0.377
            ],
            "angle": 0,
            "content": "c）x+"
        },
        {
            "type": "text",
            "bbox": [
                0.614,
                0.362,
                0.73,
                0.377
            ],
            "angle": 0,
            "content": "d) \\(\\overline{x} (x + \\overline{y} +\\overline{z})\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.38,
                0.419,
                0.395
            ],
            "angle": 0,
            "content": "13. 用运算 \\(+\\) 和 \\(-\\) 表示练习12中的布尔函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.398,
                0.138,
                0.412
            ],
            "angle": 0,
            "content": "14. 证明："
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.415,
                0.174,
                0.431
            ],
            "angle": 0,
            "content": "a) \\(\\overline{x} = x\\mid x\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.264,
                0.416,
                0.441,
                0.431
            ],
            "angle": 0,
            "content": "b) \\( xy = (x|y)(x|y) \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.614,
                0.416,
                0.807,
                0.431
            ],
            "angle": 0,
            "content": "c) \\(x + y = (x|x)(y|y)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.435,
                0.138,
                0.449
            ],
            "angle": 0,
            "content": "15. 证明："
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.453,
                0.18,
                0.468
            ],
            "angle": 0,
            "content": "a) \\(\\overline{x} = x\\downarrow x\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.264,
                0.453,
                0.458,
                0.468
            ],
            "angle": 0,
            "content": "b) \\(xy = (x\\downarrow x)\\downarrow (y\\downarrow y)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.614,
                0.453,
                0.824,
                0.468
            ],
            "angle": 0,
            "content": "c) \\(x + y = (x\\downarrow y)\\downarrow (x\\downarrow y)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.471,
                0.387,
                0.486
            ],
            "angle": 0,
            "content": "16. 利用练习 15 证明 \\(\\{\\downarrow\\}\\) 是函数完备集。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.489,
                0.373,
                0.504
            ],
            "angle": 0,
            "content": "17. 用运算 表示练习3中的布尔函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.509,
                0.379,
                0.523
            ],
            "angle": 0,
            "content": "18. 用运算 \\(\\downarrow\\) 表示练习3中的布尔函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.526,
                0.415,
                0.541
            ],
            "angle": 0,
            "content": "19. 证明运算符集 \\(\\{+\\), \\(\\cdot\\}\\) 不是函数完备的。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.544,
                0.381,
                0.558
            ],
            "angle": 0,
            "content": "20. 下列运算符集是否为函数完备的呢？"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.562,
                0.185,
                0.577
            ],
            "angle": 0,
            "content": "a）{+， \\(\\oplus\\) 1"
        },
        {
            "type": "text",
            "bbox": [
                0.264,
                0.562,
                0.354,
                0.577
            ],
            "angle": 0,
            "content": "b) \\(\\{\\text{一},\\oplus \\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.433,
                0.562,
                0.524,
                0.577
            ],
            "angle": 0,
            "content": "c）{， \\(\\oplus\\) 1"
        },
        {
            "type": "title",
            "bbox": [
                0.061,
                0.59,
                0.275,
                0.609
            ],
            "angle": 0,
            "content": "12.3 逻辑门电路"
        },
        {
            "type": "title",
            "bbox": [
                0.061,
                0.616,
                0.197,
                0.634
            ],
            "angle": 0,
            "content": "12.3.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.636,
                0.908,
                0.768
            ],
            "angle": 0,
            "content": "布尔代数用于为电子装置的电路建立模型，这种装置的输入和输出都可以认为是集合\\(\\{0,1\\}\\)中的元素。计算机或其他的电子装置就是由许多电路构成的。电路可以根据布尔代数的规则来设计，这些规则已经在12.1节和12.2节中讨论过。电路的基本元件是1.2节中介绍过的所谓的门，每种类型的门实现一种布尔运算。本节将定义几种类型的门。应用布尔代数的结果，使用这些门就可以设计电路来执行各种任务。在本章所讨论的电路中，输出都只与输入有关，而与电路的当前状态无关。换句话说，这些电路都没有存储能力，这样的电路叫作组合电路或门电路。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.77,
                0.908,
                0.825
            ],
            "angle": 0,
            "content": "我们将使用三种元件来构造组合电路，第一种是反相器，它以布尔值作为输入，并产生此布尔值的补作为输出。用来表示反相器的符号如图1a所示，进入元件的输入画在左边，离开元件的输出画在右边。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.827,
                0.908,
                0.864
            ],
            "angle": 0,
            "content": "第二种元件是或门（OR gate），其输入是两个或两个以上的布尔值，输出是这些值的布尔和。用来表示或门的符号如图1b所示，进入元件的输入画在左边，离开元件的输出画在右边。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.865,
                0.908,
                0.902
            ],
            "angle": 0,
            "content": "第三种元件是与门(AND gate)，其输入是两个或两个以上的布尔值，输出是这些值的布尔积。用来表示与门的符号如图1c所示，进入元件的输入画在左边，离开元件的输出画在右边。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.904,
                0.907,
                0.94
            ],
            "angle": 0,
            "content": "与门和或门允许有多个输入，进入元件的输入都画在左边，离开元件的输出都画在右边。具有 \\(n\\) 个输入的与门和或门如图2所示。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.118,
                0.039,
                0.154,
                0.053
            ],
            "angle": 0,
            "content": "726"
        },
        {
            "type": "header",
            "bbox": [
                0.199,
                0.038,
                0.275,
                0.054
            ],
            "angle": 0,
            "content": "第12章"
        },
        {
            "type": "image",
            "bbox": [
                0.169,
                0.095,
                0.345,
                0.127
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.212,
                0.142,
                0.292,
                0.156
            ],
            "angle": 0,
            "content": "a）反相器"
        },
        {
            "type": "image",
            "bbox": [
                0.402,
                0.095,
                0.61,
                0.129
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.471,
                0.142,
                0.534,
                0.156
            ],
            "angle": 0,
            "content": "b）或门"
        },
        {
            "type": "image",
            "bbox": [
                0.661,
                0.096,
                0.855,
                0.128
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.741,
                0.142,
                0.802,
                0.156
            ],
            "angle": 0,
            "content": "c）与门"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.428,
                0.159,
                0.596,
                0.174
            ],
            "angle": 0,
            "content": "图1 门的基本类型"
        },
        {
            "type": "image",
            "bbox": [
                0.189,
                0.179,
                0.476,
                0.223
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.532,
                0.18,
                0.835,
                0.223
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.41,
                0.225,
                0.615,
                0.24
            ],
            "angle": 0,
            "content": "图2 具有 \\(n\\) 个输入的门"
        },
        {
            "type": "title",
            "bbox": [
                0.09,
                0.252,
                0.273,
                0.269
            ],
            "angle": 0,
            "content": "12.3.2 门的组合"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.272,
                0.938,
                0.364
            ],
            "angle": 0,
            "content": "使用反相器、或门和与门的组合可以构造组合电路。在构造电路的组合时，某些门可能有公共的输入。有两种方法可以描述公共输入，一种方法是用分支标出使用给定输入的所有门；另一种方法是对每个门分别标出其输入。图3说明了这两种方法，其中的门有相同的输入值。注意，一个门的输出可能作为另一个元件或更多元件的输入，如图3所示。图3中的两个图描述了输出为 \\(xy + \\overline{xy}\\) 的电路。"
        },
        {
            "type": "image",
            "bbox": [
                0.277,
                0.371,
                0.75,
                0.569
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.391,
                0.574,
                0.635,
                0.589
            ],
            "angle": 0,
            "content": "图3 画相同电路的两种方法"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.599,
                0.829,
                0.616
            ],
            "angle": 0,
            "content": "例1构造产生下列输出的电路：a) \\((x + y)\\overline{x}\\) ；b) \\(\\overline{x(y + z)}\\) ；c) \\((x + y + z)\\overline{x}\\overline{y}\\overline{z}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.62,
                0.473,
                0.636
            ],
            "angle": 0,
            "content": "解产生这些输出的电路如图4所示。"
        },
        {
            "type": "title",
            "bbox": [
                0.091,
                0.647,
                0.296,
                0.663
            ],
            "angle": 0,
            "content": "12.3.3 电路的例子"
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.667,
                0.453,
                0.683
            ],
            "angle": 0,
            "content": "下面给出一些具有实际功能的电路。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.687,
                0.938,
                0.744
            ],
            "angle": 0,
            "content": "例2 某个组织的一切事务都由一个三人委员会决定。每个委员对提出的建议可以投赞成票或反对票。一个建议如果得到了至少两张赞成票就获通过。设计一个电路，判断建议是否获得通过。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.747,
                0.938,
                0.839
            ],
            "angle": 0,
            "content": "解如果第一个委员投赞成票，则令 \\(x = 1\\) ；如果这个委员投反对票，则令 \\(x = 0\\) 。如果第二个委员投赞成票，则令 \\(y = 1\\) ；如果这个委员投反对票，则令 \\(y = 0\\) 。如果第三个委员投赞成票，则令 \\(z = 1\\) ；如果这个委员投反对票，则令 \\(z = 0\\) 。必须设计一个电路使得对于输入 \\(x\\) 、\\(y\\) 和 \\(z\\) ，如果其中至少有两个为1，则此电路产生输出1。具有这样的输出值的一个布尔函数表示是 \\(xy + xz + yz\\) （见12.1节练习12）。实现这个函数的电路如图5所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.844,
                0.938,
                0.9
            ],
            "angle": 0,
            "content": "例3有时候灯需要由多个开关来控制，因此有必要设计这样的电路：当灯不亮时，敲击任何一个开关都可以使此灯变亮；反之，当灯是打开时，敲击任何一个开关都可以使灯不亮。在有两个开关和三个开关的两种情形下，设计电路来完成这个任务。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.903,
                0.938,
                0.939
            ],
            "angle": 0,
            "content": "解 首先设计使用两个开关的电路来控制灯。当第一个开关关闭时，令 \\(x = 1\\)；当它打开时，令 \\(x = 0\\)。当第二个开关关闭时，令 \\(y = 1\\)；当它打开时，令 \\(y = 0\\)。当灯亮时，令 \\(F(x, y) = 1\\)；当"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.691,
                0.036,
                0.8,
                0.051
            ],
            "angle": 0,
            "content": "布尔代数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.847,
                0.037,
                0.884,
                0.052
            ],
            "angle": 0,
            "content": "727"
        },
        {
            "type": "image",
            "bbox": [
                0.149,
                0.095,
                0.827,
                0.514
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.365,
                0.519,
                0.608,
                0.534
            ],
            "angle": 0,
            "content": "图4产生例1中输出的电路"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.543,
                0.911,
                0.618
            ],
            "angle": 0,
            "content": "灯不亮时，令 \\( F(x, y) = 0 \\) 。我们可以随意地假定：当两个开关都是关闭的时候，灯是亮的，即 \\( F(1, 1) = 1 \\) 。这个假定决定了 \\( F \\) 的所有其他值：当两个开关中有一个是打开的时候，灯变灭了，故 \\( F(1, 0) = F(0, 1) = 0 \\) ；当第二个开关也被打开的时候，灯又变亮了，故 \\( F(0, 0) = 1 \\) 。表1列出了这些值。我们可以看到 \\( F(x, y) = xy + \\overline{x}\\overline{y} \\) 。实现这个函数的电路如图6所示。"
        },
        {
            "type": "image",
            "bbox": [
                0.107,
                0.632,
                0.531,
                0.742
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.206,
                0.746,
                0.431,
                0.761
            ],
            "angle": 0,
            "content": "图5 用于多数表决的电路"
        },
        {
            "type": "table",
            "bbox": [
                0.556,
                0.631,
                0.851,
                0.76
            ],
            "angle": 0,
            "content": "<table><tr><td>x</td><td>y</td><td>F(x,y)</td></tr><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td></tr></table>"
        },
        {
            "type": "image",
            "bbox": [
                0.23,
                0.777,
                0.743,
                0.904
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.355,
                0.913,
                0.617,
                0.928
            ],
            "angle": 0,
            "content": "图6 由两个开关控制灯的电路"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.122,
                0.036,
                0.159,
                0.05
            ],
            "angle": 0,
            "content": "728"
        },
        {
            "type": "header",
            "bbox": [
                0.203,
                0.035,
                0.281,
                0.051
            ],
            "angle": 0,
            "content": "第12章"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.092,
                0.941,
                0.146
            ],
            "angle": 0,
            "content": "现在设计有三个开关的电路。设 \\(x\\)、\\(y\\) 和 \\(z\\) 是三个布尔变元，它们分别表示这三个开关是否是关闭的。当第一个开关处于关闭时，令 \\(x = 1\\)；当它处于打开时，令 \\(x = 0\\)。当第二个开关处于关闭时，令 \\(y = 1\\)；当它处于打开时，令 \\(y = 0\\)。当第三个开关处于关闭时，令 \\(z = 1\\)；当它处"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.149,
                0.534,
                0.336
            ],
            "angle": 0,
            "content": "于打开时，令 \\(z = 0\\) 。灯亮时，令 \\(F(x,y,z) = 1\\) 灯不亮时，令 \\(F(x,y,z) = 0\\) 。当所有开关都关闭时，我们可以随意地指定灯是亮的，即 \\(F(1,1,1) = 1\\) ，这确定了 \\(F\\) 的所有其他值。当一个开关被打开时，灯就变灭，故 \\(F(1,1,0) = F(1,0,1) = F(0,1,1) = 0\\) 。当第二个开关被打开时，灯又变亮了，故 \\(F(1,0,0) = F(0,1,0) = F(0,0,1) = 1\\) 。最后，当三个开关都打开时，灯又变灭了，故 \\(F(0,0,0) = 0\\) 。这个函数的值如表2所示。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.722,
                0.156,
                0.774,
                0.169
            ],
            "angle": 0,
            "content": "表2"
        },
        {
            "type": "table",
            "bbox": [
                0.552,
                0.172,
                0.941,
                0.333
            ],
            "angle": 0,
            "content": "<table><tr><td>x</td><td>y</td><td>z</td><td>F(x,y,z)</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.339,
                0.941,
                0.374
            ],
            "angle": 0,
            "content": "函数 \\(F\\) 可以表示成积之和展开式：\\(F(x, y, z) = xyz + x\\overline{y}\\overline{z} + \\overline{x}y\\overline{z} + \\overline{x}\\overline{y}z\\)。实现这个函数的电路如图7所示。"
        },
        {
            "type": "image",
            "bbox": [
                0.216,
                0.38,
                0.825,
                0.705
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.37,
                0.71,
                0.671,
                0.726
            ],
            "angle": 0,
            "content": "图7 由3个开关混合控制灯的电路"
        },
        {
            "type": "title",
            "bbox": [
                0.098,
                0.743,
                0.259,
                0.76
            ],
            "angle": 0,
            "content": "12.3.4 加法器"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.764,
                0.945,
                0.799
            ],
            "angle": 0,
            "content": "下面说明如何用逻辑电路从两个正整数的二进制表示来实现加法。我们先构造一些分支电路，然后再从这些分支电路来构造加法电路。首先构造电路来计算 \\(x + y\\) ，其中 \\(x\\) 和 \\(y\\) 是两个二"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.803,
                0.537,
                0.935
            ],
            "angle": 0,
            "content": "进制数字。因为 \\(x\\) 和 \\(y\\) 的值为0或1，所以此电路的输入就是 \\(x\\) 和 \\(y\\) 。输出由两个二进制数字 \\(s\\) 和 \\(c\\) 构成，其中 \\(s\\) 和 \\(c\\) 分别是和与进位。因为这种电路具有多个输出，所以称为多重输出电路。又由于此电路只是将两个二进制数字相加，而没有考虑以前加法所产生的进位，所以被称为半加法器。表3说明了半加法器的输入和输出。由此表"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.63,
                0.809,
                0.871,
                0.823
            ],
            "angle": 0,
            "content": "表 3 半加法器的输入和输出"
        },
        {
            "type": "table",
            "bbox": [
                0.556,
                0.826,
                0.945,
                0.931
            ],
            "angle": 0,
            "content": "<table><tr><td colspan=\"2\">输入</td><td colspan=\"2\">输出</td></tr><tr><td>x</td><td>y</td><td>s</td><td>c</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr></table>"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.683,
                0.036,
                0.796,
                0.052
            ],
            "angle": 0,
            "content": "布尔代数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.84,
                0.037,
                0.876,
                0.05
            ],
            "angle": 0,
            "content": "729"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.092,
                0.908,
                0.127
            ],
            "angle": 0,
            "content": "可以看出 \\(c = xy\\) 且 \\(s = x\\overline{y} + \\overline{x} y = (x + y)\\overline{(xy)}\\)。因此图8所示的电路计算了 \\(x\\) 与 \\(y\\) 的和 \\(s\\) 与进位 \\(c\\)。"
        },
        {
            "type": "image",
            "bbox": [
                0.231,
                0.135,
                0.737,
                0.275
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.415,
                0.283,
                0.547,
                0.298
            ],
            "angle": 0,
            "content": "图8 半加法器"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.309,
                0.908,
                0.326
            ],
            "angle": 0,
            "content": "当两个二进制数字与一个进位相加时，我们用全加法器来计算和与进位。全加法器的输入"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.328,
                0.436,
                0.382
            ],
            "angle": 0,
            "content": "是 \\(x\\) 和 \\(y\\) 以及进位 \\(c_{i}\\) ，输出是和 \\(s\\) 与新的进位 \\(c_{i + 1}\\) 。全加法器的输入和输出如表4所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.385,
                0.436,
                0.516
            ],
            "angle": 0,
            "content": "全加法器的两个输出，即和 \\(s\\) 与进位\\(c_{i + 1}\\) ，可分别由积之和展开式 \\(xyc_{i}+\\) \\(x\\overline{y}\\bar{c}_i + \\overline{x} y\\bar{c}_i + \\overline{x}\\overline{y} c_i\\) 与 \\(xyc_{i} + xy\\bar{c}_{i} + x\\overline{y} c_{i}+\\) \\(\\overline{x} y c_{i}\\) 表示。但我们并不直接构造全加法器，而是使用半加法器来产生所需的输出。使用半加法器构造全加法器的方法如图9所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.519,
                0.437,
                0.593
            ],
            "angle": 0,
            "content": "最后，图10说明了怎样用全加法器和半加法器来计算两个3位二进制整数\\((x_{2}x_{1}x_{0})_{2}\\) 与 \\((y_{2}y_{1}y_{0})_{2}\\) 之和 \\((s_3s_2s_1s_0)_2\\) 。注意，和中的最高位 \\(s_3\\) 是由进位 \\(c_{2}\\) 产生的。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.559,
                0.335,
                0.8,
                0.35
            ],
            "angle": 0,
            "content": "表 4 全加法器的输入和输出"
        },
        {
            "type": "table",
            "bbox": [
                0.455,
                0.352,
                0.907,
                0.571
            ],
            "angle": 0,
            "content": "<table><tr><td colspan=\"3\">输入</td><td colspan=\"2\">输出</td></tr><tr><td>x</td><td>y</td><td>ci</td><td>s</td><td>ci+1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></table>"
        },
        {
            "type": "image",
            "bbox": [
                0.065,
                0.616,
                0.517,
                0.735
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.225,
                0.748,
                0.357,
                0.763
            ],
            "angle": 0,
            "content": "图9 全加法器"
        },
        {
            "type": "image",
            "bbox": [
                0.53,
                0.601,
                0.902,
                0.738
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.58,
                0.748,
                0.851,
                0.781
            ],
            "angle": 0,
            "content": "图10 用全加法器和半加法器将两个3位二进制整数相加"
        },
        {
            "type": "title",
            "bbox": [
                0.058,
                0.796,
                0.106,
                0.811
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.816,
                0.359,
                0.831
            ],
            "angle": 0,
            "content": "在练习 \\(1\\sim 5\\) 中，求所给电路的输出。"
        },
        {
            "type": "image",
            "bbox": [
                0.06,
                0.834,
                0.432,
                0.937
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.461,
                0.834,
                0.834,
                0.932
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.127,
                0.038,
                0.162,
                0.051
            ],
            "angle": 0,
            "content": "730"
        },
        {
            "type": "header",
            "bbox": [
                0.208,
                0.036,
                0.284,
                0.052
            ],
            "angle": 0,
            "content": "第12章"
        },
        {
            "type": "image",
            "bbox": [
                0.097,
                0.092,
                0.471,
                0.192
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.503,
                0.093,
                0.934,
                0.267
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.098,
                0.269,
                0.472,
                0.448
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.452,
                0.523,
                0.466
            ],
            "angle": 0,
            "content": "6. 用反相器、与门和或门构造产生下列输出的电路："
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.469,
                0.185,
                0.484
            ],
            "angle": 0,
            "content": "a) \\(\\overline{x} +y\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.458,
                0.469,
                0.546,
                0.484
            ],
            "angle": 0,
            "content": "b) \\(\\overline{(x + y)} x\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.122,
                0.488,
                0.23,
                0.501
            ],
            "angle": 0,
            "content": "c) \\(xyz + \\overline{x}\\overline{y}\\overline{z}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.458,
                0.487,
                0.59,
                0.502
            ],
            "angle": 0,
            "content": "d) \\((\\overline{x} + z)(y + \\overline{z})\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.505,
                0.486,
                0.519
            ],
            "angle": 0,
            "content": "7. 试设计一个电路来实现5个人的多数表决器。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.523,
                0.942,
                0.554
            ],
            "angle": 0,
            "content": "8. 试设计一个由4个开关混合控制灯的电路，使得当灯亮时，按任意一个开关都可使它不亮，或者当电灯不亮时，按任意一个开关都可使它变亮。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.558,
                0.671,
                0.572
            ],
            "angle": 0,
            "content": "9. 说明如何使用全加法器和半加法器来计算两个5位二进制整数的和。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.576,
                0.942,
                0.607
            ],
            "angle": 0,
            "content": "10. 半减法器的输入是两个二进制数字，输出是差位和借位。试用与门、或门和反相器构造一个半减法器电路。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.612,
                0.942,
                0.643
            ],
            "angle": 0,
            "content": "11. 全减法器的输入是两个二进制数字及一个借位，输出是差位和借位。试用与门、或门和反相器构造一个全减法器电路。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.648,
                0.882,
                0.662
            ],
            "angle": 0,
            "content": "12. 使用练习 10 和 11 中的电路计算两个 4 位二进制整数的差，其中第一个整数大于第二个整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.666,
                0.942,
                0.696
            ],
            "angle": 0,
            "content": "* 13. 构造一个电路来比较 2 位二进制整数 \\((x_{1}x_{0})_{2}\\) 和 \\((y_{1}y_{0})_{2}\\), 使得当第一个整数大于第二个时, 输出 1, 否则输出 0。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.701,
                0.85,
                0.715
            ],
            "angle": 0,
            "content": "*14. 构造一个计算 2 位二进制整数 \\((x_{1}x_{0})_{2}\\) 与 \\((y_{1}y_{0})_{2}\\) 之积的电路。此电路应该有 4 个输出位。"
        },
        {
            "type": "list",
            "bbox": [
                0.082,
                0.505,
                0.942,
                0.715
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.719,
                0.942,
                0.75
            ],
            "angle": 0,
            "content": "与非(NAND)门和或非(NOR)门也是电路中常用的两种门，如果使用这两种门来表示电路，就没有必要使用其他类型的门了。这两种门的记号如下："
        },
        {
            "type": "image",
            "bbox": [
                0.134,
                0.753,
                0.51,
                0.791
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.795,
                0.439,
                0.808
            ],
            "angle": 0,
            "content": "* 15. 使用与非门构造具有下列输出的电路："
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.814,
                0.164,
                0.826
            ],
            "angle": 0,
            "content": "a) \\(\\overline{x}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.327,
                0.814,
                0.389,
                0.827
            ],
            "angle": 0,
            "content": "b) \\(x + y\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.46,
                0.814,
                0.5,
                0.827
            ],
            "angle": 0,
            "content": "c)xy"
        },
        {
            "type": "text",
            "bbox": [
                0.571,
                0.814,
                0.64,
                0.827
            ],
            "angle": 0,
            "content": "d) \\(x\\oplus y\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.831,
                0.503,
                0.844
            ],
            "angle": 0,
            "content": "* 16. 使用或非门构造具有练习 15 中的输出的电路。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.849,
                0.346,
                0.862
            ],
            "angle": 0,
            "content": "* 17. 试用与非门构造半加法器。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.866,
                0.346,
                0.88
            ],
            "angle": 0,
            "content": "* 18. 试用或非门构造半加法器。"
        },
        {
            "type": "list",
            "bbox": [
                0.082,
                0.831,
                0.503,
                0.88
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.884,
                0.648,
                0.898
            ],
            "angle": 0,
            "content": "多路转接器是一种开关电路，它根据控制位的值将某组输入位输出。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.902,
                0.942,
                0.934
            ],
            "angle": 0,
            "content": "19. 用与门、或门和反相器构造一个多路转接器，它的4位输入是二进制数字 \\(x_0\\)、\\(x_1\\)、\\(x_2\\) 和 \\(x_3\\)，控制位是 \\(c_0\\) 和 \\(c_1\\)。构造此电路使得 \\(x_i\\) 为输出，其中 \\(i\\) 是2位整数 \\((c_1c_0)_2\\) 的值。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.685,
                0.037,
                0.796,
                0.052
            ],
            "angle": 0,
            "content": "布尔代数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.842,
                0.038,
                0.875,
                0.051
            ],
            "angle": 0,
            "content": "731"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.093,
                0.908,
                0.144
            ],
            "angle": 0,
            "content": "组合电路的深度可定义如下：初始输入的深度为0；如果一个门有 \\(n\\) 个输入，且其深度分别为 \\(d_{1}\\)，\\(d_{2}\\)，…，\\(d_{n}\\)，则它的输出的深度为 \\(\\max(d_{1}, d_{2}, \\cdots, d_{n}) + 1\\)。这个值也定义为该门的深度。组合电路的深度为该电路中门的最大深度。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.147,
                0.252,
                0.162
            ],
            "angle": 0,
            "content": "20. 求下列电路的深度："
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.164,
                0.361,
                0.178
            ],
            "angle": 0,
            "content": "a)例2中构造的3人多数表决器。"
        },
        {
            "type": "text",
            "bbox": [
                0.417,
                0.164,
                0.745,
                0.178
            ],
            "angle": 0,
            "content": "b) 例3中构造的2个开关控制的灯电路。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.182,
                0.287,
                0.196
            ],
            "angle": 0,
            "content": "c)图8所示的半加法器。"
        },
        {
            "type": "text",
            "bbox": [
                0.418,
                0.182,
                0.615,
                0.197
            ],
            "angle": 0,
            "content": "d)图9所示的全加法器。"
        },
        {
            "type": "title",
            "bbox": [
                0.062,
                0.211,
                0.3,
                0.231
            ],
            "angle": 0,
            "content": "12.4 电路的极小化"
        },
        {
            "type": "title",
            "bbox": [
                0.062,
                0.238,
                0.197,
                0.256
            ],
            "angle": 0,
            "content": "12.4.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.258,
                0.91,
                0.39
            ],
            "angle": 0,
            "content": "组合电路的效率依赖于门的个数及排列。在组合电路的设计过程中，首先构造一个表，对于每种可能的输入值，此表说明对应的输出值。对于任一个电路，总可以用“积之和展开式”找到一组逻辑门来实现这个电路。但是，积之和展开式可能包含许多不必要的项。在一个积之和展开式中，若其中的一些项只在一个变元处不一样，即在某个项中此变元本身出现，而在另一个项中此变元的补出现，则这些项可以合并。例如，考虑这样的电路，它输出1当且仅当\\(x = y = z = 1\\) ，或 \\(x = z = 1\\) 且 \\(y = 0\\) 。此电路的积之和展开式为 \\(xyz + x\\overline{y}z\\) ，在这个展开式的两个积中，只有一个变元以不同的形式出现，即 \\(y\\) 。它们可以如下合并："
        },
        {
            "type": "equation",
            "bbox": [
                0.367,
                0.394,
                0.601,
                0.445
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} x y z + x \\bar {y} z = (y + \\bar {y}) (x z) \\\\ = 1 \\cdot (x z) \\\\ = x z \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.449,
                0.909,
                0.467
            ],
            "angle": 0,
            "content": "这样， \\(xz\\) 也是一个表示这个电路的布尔表达式，但包含更少的运算符。图1说明了这个"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.469,
                0.476,
                0.504
            ],
            "angle": 0,
            "content": "电路两个不同实现，第二个电路只使用一个门，但第一个却使用了三个门和一个反相器。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.507,
                0.478,
                0.58
            ],
            "angle": 0,
            "content": "这个例子说明，在一个电路的积之和展开式中，将一些项合并会导致出这个电路的更简单的表达式。下面将描述化简积之和展开式的两个过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.583,
                0.479,
                0.733
            ],
            "angle": 0,
            "content": "这两个过程的目的都是产生表示布尔函数满足下列条件的积之和，它在该布尔函数的所有积之和表达式中，包含最少的布尔积而且包含最少的字面值。寻求这种积之和称为布尔函数的最小化。最小化布尔函数可以为这个函数构造一个电路，这个电路在最小化布尔表达式的所有电路中，用最少的门并在电路中对AND门和OR门有最少的输入。"
        },
        {
            "type": "image",
            "bbox": [
                0.49,
                0.473,
                0.911,
                0.682
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.571,
                0.689,
                0.832,
                0.706
            ],
            "angle": 0,
            "content": "图1具有相同输出的两个电路"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.735,
                0.91,
                0.809
            ],
            "angle": 0,
            "content": "直到20世纪60年代早期，逻辑门都是单独的组件。为了降低成本，采用最少的门得到期望的结果是非常重要的。在20世纪60年代中期，集成电路技术的发展使得将多个门组合到一个芯片成为可能。即使现在可以用非常低的成本对许多芯片构建非常复杂的集成电路，布尔函数的最小化仍然十分重要。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.81,
                0.91,
                0.883
            ],
            "angle": 0,
            "content": "减少芯片上门数量可以得到更可靠的电路，并降低芯片的生产成本。同时，最小化还可以在同一芯片上设计更合适的电路。而且，最小化减少了电路中对门的输入的个数。这就减少了用电路计算输出结果所用的时间。此外，因为在构建逻辑门的电路时采用了特殊的技术，所以使得门的输入是有限的。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.885,
                0.91,
                0.94
            ],
            "angle": 0,
            "content": "在第一个过程中，我们介绍20世纪50年代发明的手动最小化电路的、著名的卡诺图（或K图）。K图在最多6个变量的最小化电路中非常有用，尽管对于五六个变量来说已经变得相当复杂。第二个过程将介绍20世纪60年代发明的奎因-莫可拉斯基方法。这是一个自动的最"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.124,
                0.038,
                0.16,
                0.052
            ],
            "angle": 0,
            "content": "732"
        },
        {
            "type": "header",
            "bbox": [
                0.205,
                0.037,
                0.281,
                0.053
            ],
            "angle": 0,
            "content": "第12章"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.094,
                0.519,
                0.11
            ],
            "angle": 0,
            "content": "小化组合电路的过程，可以用计算机程序实现。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.113,
                0.944,
                0.225
            ],
            "angle": 0,
            "content": "布尔函数最小化的复杂度遗憾的是，最小化有许多变量的布尔函数需要深入的计算。已经证明这个问题是NP完全问题（见3.3节和[Ka93]），因此，最小化布尔电路的多项式时间算法也不太可能存在。奎因-莫可拉斯基方法具有指数复杂度。实际上，只能用于字面值数量不超过10的情况。自从20世纪70年代，在最小化组合电路方面开发了大量的新算法（见[Ha93]和[KaBe04]）。但是，最好的算法也只能计算不超过25个变量的电路的最小化。也可以用启发式(或者经验式)方法对有许多变量的布尔表达式进行简化，但不一定是最小化。"
        },
        {
            "type": "title",
            "bbox": [
                0.097,
                0.235,
                0.256,
                0.251
            ],
            "angle": 0,
            "content": "12.4.2 卡诺图"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.251,
                0.945,
                0.4
            ],
            "angle": 0,
            "content": "对于表示电路的一个布尔表达式，为了减少其中项的个数，有必要去发现可以合并的项。如果布尔函数所包含的变元相对较少，可以用一种图形法来发现能被合并的项，此方法称为卡诺图（或者K图），它是由MauriceKarnaugh在1953年发现的。他的方法建立在更早的E.W.Veitch工作的基础上（Veitch的方法通常只适用于6个或者6个以下变元的函数）。卡诺图给出了一种化简积之和展开式的可视化方法，但此方法不适合机械化。下面首先说明怎么用卡诺图来化简包含2个变元的布尔函数的展开式，然后说明如何用卡诺图来化简包含3个变元和4个变元的布尔函数，最后，我们将介绍卡诺图的扩展概念，可用于化简包含4个以上变元的布尔函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.402,
                0.756,
                0.514
            ],
            "angle": 0,
            "content": "在具有两个变元 \\(x\\) 和 \\(y\\) 的布尔函数的积之和展开式中，有4种可能的极小项。具有这两个变元的布尔函数的卡诺图由4个方格组成，如果一个极小项在此展开式中出现，则表示这个极小项的方格就被放置1。如果有些方格所表示的极小项只有一处字面值不同，则称这两个方格是相邻的。例如，表示 \\(\\overline{x} y\\) 的方格与表示 \\(xy\\) 的方格和表示 \\(\\overline{x}\\overline{y}\\) 的方格都相邻。4个方格及其表示的项如图2所示。"
        },
        {
            "type": "image",
            "bbox": [
                0.781,
                0.406,
                0.914,
                0.503
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.783,
                0.511,
                0.913,
                0.543
            ],
            "angle": 0,
            "content": "图2 两个变元的卡诺图"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.519,
                0.756,
                0.558
            ],
            "angle": 0,
            "content": "例1 找出下列各式的卡诺图：a) \\(xy + \\overline{x} y\\) ；b) \\(x\\overline{y} +\\overline{x} y\\) ；c) \\(x\\overline{y} +\\overline{x} y+\\) \\(\\overline{x}\\overline{y}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.56,
                0.944,
                0.596
            ],
            "angle": 0,
            "content": "解当一个方格所表示的极小项在积之和展开式中出现时，我们就在这个方格中放置一个1。3个卡诺图如图3所示。"
        },
        {
            "type": "image",
            "bbox": [
                0.253,
                0.602,
                0.391,
                0.7
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.321,
                0.712,
                0.34,
                0.724
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "image",
            "bbox": [
                0.449,
                0.602,
                0.588,
                0.701
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.517,
                0.712,
                0.537,
                0.724
            ],
            "angle": 0,
            "content": "b)"
        },
        {
            "type": "image",
            "bbox": [
                0.651,
                0.602,
                0.788,
                0.701
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.719,
                0.712,
                0.737,
                0.724
            ],
            "angle": 0,
            "content": "c)"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.372,
                0.728,
                0.669,
                0.744
            ],
            "angle": 0,
            "content": "图3例1中积之和展开式的卡诺图"
        },
        {
            "type": "title",
            "bbox": [
                0.095,
                0.762,
                0.165,
                0.785
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.097,
                0.797,
                0.238,
                0.907
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.097,
                0.912,
                0.203,
                0.933
            ],
            "angle": 0,
            "content": "Courtesy of Maurice  \nKarnaugh"
        },
        {
            "type": "text",
            "bbox": [
                0.255,
                0.797,
                0.945,
                0.902
            ],
            "angle": 0,
            "content": "莫里斯·卡诺(MauriceKarnaugh，1924—）卡诺出生于纽约。他从纽约城市学院获得学士学位，从耶鲁大学获得硕士和博士学位。1952年至1966年，卡诺一直在贝尔实验室从事技术工作，1966年至1970年，他担任AT&T公司联邦系统事业部的研发主管。1970年，卡诺加入IBM并成为一名研究员。卡诺对数字技术在计算和远程通信领域的应用做出了重要贡献。他目前的研究兴趣包括计算机中基于知识的系统和启发式搜索方法。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.677,
                0.038,
                0.787,
                0.053
            ],
            "angle": 0,
            "content": "布尔代数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.832,
                0.039,
                0.868,
                0.052
            ],
            "angle": 0,
            "content": "733"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.095,
                0.898,
                0.251
            ],
            "angle": 0,
            "content": "我们可以从卡诺图中识别出能够合并的极小项。在卡诺图中，一旦有两个方格是相邻的，则由这两个方格所表示的极小项就可合并成一个积，且此积只涉及其中的一个变元。例如，\\(x\\overline{y}\\) 和 \\(\\overline{x}\\overline{y}\\) 是由两个相邻的方格表示的，它们可以合并成 \\(\\overline{y}\\)，因为 \\(x\\overline{y} + \\overline{x}\\overline{y} = (x + \\overline{x})\\overline{y} = \\overline{y}\\)。而且，如果所有4个方格都是1，则4个极小项可以合并成一个项，即布尔表达式1，它不涉及任何变元。在卡诺图中，如果有些极小项能够合并，则在卡诺图中，我们将表示这些极小项的方格所组成的块用圆圈圈起来，然后找出对应的积之和。其目的是尽可能找出最大的块，并以最少的块覆盖所有的1，在此过程中，首先使用最大的块，并总是使用最大的可能块。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.256,
                0.405,
                0.274
            ],
            "angle": 0,
            "content": "例2 化简例1中的积之和展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.279,
                0.899,
                0.316
            ],
            "angle": 0,
            "content": "解 用这些展开式的卡诺图对极小项进行分组的方式如图4所示。这些积之和式的最小展开式是a) \\(y\\)；b) \\(x\\overline{y} + \\overline{x}y\\)；c) \\(\\overline{x} + \\overline{y}\\)。"
        },
        {
            "type": "image",
            "bbox": [
                0.229,
                0.322,
                0.368,
                0.417
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.297,
                0.43,
                0.317,
                0.442
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "image",
            "bbox": [
                0.406,
                0.322,
                0.543,
                0.417
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.474,
                0.43,
                0.495,
                0.442
            ],
            "angle": 0,
            "content": "b)"
        },
        {
            "type": "image",
            "bbox": [
                0.582,
                0.322,
                0.72,
                0.417
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.653,
                0.431,
                0.669,
                0.442
            ],
            "angle": 0,
            "content": "c)"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.325,
                0.448,
                0.625,
                0.464
            ],
            "angle": 0,
            "content": "图4例2中的积之和展开式的化简"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.47,
                0.899,
                0.544
            ],
            "angle": 0,
            "content": "3个变元的卡诺图被分成8个方格的矩形，这些方格代表由3个变元组成的8个可能的极小项。两个方格称为是相邻的，如果它们表示的极小项只在一处字面值不一样。一种画3个变元卡诺图的方法如图5a所示。可以认为这个卡诺图是贴在圆柱体的表面上，如图5b所示。在这个圆柱体的表面上，两个方格有公共边界当且仅当它们是相邻的。"
        },
        {
            "type": "image",
            "bbox": [
                0.149,
                0.557,
                0.504,
                0.7
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.326,
                0.714,
                0.344,
                0.724
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "image",
            "bbox": [
                0.586,
                0.554,
                0.804,
                0.7
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.691,
                0.713,
                0.71,
                0.724
            ],
            "angle": 0,
            "content": "b)"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.376,
                0.734,
                0.577,
                0.75
            ],
            "angle": 0,
            "content": "图53个变元的卡诺图"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.763,
                0.9,
                0.861
            ],
            "angle": 0,
            "content": "为了化简3个变元的积之和展开式，我们用卡诺图来识别由可以合并的极小项组成的块。两个相邻方格组成的块代表了一对可以合并成两个字面值的积的极小项，\\(2 \\times 2\\) 和 \\(4 \\times 1\\) 方格组成的块代表可以合并成一个字面值的极小项，全部8个方格组成的块表示一个不包含任何字面值的积，即代表函数1。\\(1 \\times 2\\)、\\(2 \\times 1\\)、\\(2 \\times 2\\)、\\(4 \\times 1\\) 和 \\(4 \\times 2\\) 块及其代表的积如图6所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.864,
                0.9,
                0.9
            ],
            "angle": 0,
            "content": "对应于卡诺图中全是1的块的字面值之积称为极小化函数的隐含。如果这个全1的块没有包含在一个更大的由1组成的表示更少字面值的积的块中，则称它为素隐含。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.903,
                0.9,
                0.939
            ],
            "angle": 0,
            "content": "我们的目的是在图中标出最大可能块，然后用最大块优先法则以最少的块覆盖图中所有的1。最大可能的块总是会被选取，但如果卡诺图中只有一个块覆盖一个1，则必须选取它，这"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.136,
                0.038,
                0.171,
                0.051
            ],
            "angle": 0,
            "content": "734"
        },
        {
            "type": "header",
            "bbox": [
                0.216,
                0.037,
                0.292,
                0.052
            ],
            "angle": 0,
            "content": "第12章"
        },
        {
            "type": "image",
            "bbox": [
                0.119,
                0.095,
                0.378,
                0.214
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.246,
                0.219,
                0.266,
                0.231
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "image",
            "bbox": [
                0.397,
                0.095,
                0.648,
                0.214
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.519,
                0.218,
                0.539,
                0.23
            ],
            "angle": 0,
            "content": "b)"
        },
        {
            "type": "image",
            "bbox": [
                0.689,
                0.095,
                0.944,
                0.214
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.816,
                0.219,
                0.834,
                0.23
            ],
            "angle": 0,
            "content": "c)"
        },
        {
            "type": "image",
            "bbox": [
                0.243,
                0.242,
                0.495,
                0.364
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.365,
                0.384,
                0.385,
                0.395
            ],
            "angle": 0,
            "content": "d)"
        },
        {
            "type": "image",
            "bbox": [
                0.535,
                0.242,
                0.79,
                0.376
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.663,
                0.385,
                0.68,
                0.396
            ],
            "angle": 0,
            "content": "e)"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.403,
                0.406,
                0.658,
                0.421
            ],
            "angle": 0,
            "content": "图63个变元的卡诺图中的块"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.432,
                0.953,
                0.467
            ],
            "angle": 0,
            "content": "样的块表示本原素隐含。通过使用素隐含对应的块来覆盖图中所有的1，就可以用素隐含之和来表达积之和。注意，以最少的块覆盖所有的1可能有不止一种方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.47,
                0.47,
                0.485
            ],
            "angle": 0,
            "content": "例3说明了如何使用三变元卡诺图。"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.492,
                0.523,
                0.508
            ],
            "angle": 0,
            "content": "例3 用卡诺图最小化下列积之和展开式："
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.514,
                0.4,
                0.529
            ],
            "angle": 0,
            "content": "(a) \\(xy\\overline{z} +x\\overline{y}\\overline{z} +\\overline{x} yz + \\overline{x}\\overline{y}\\overline{z}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.533,
                0.46,
                0.548
            ],
            "angle": 0,
            "content": "(b) \\(x\\overline{y} z + x\\overline{y}\\overline{z} +\\overline{x} xyz + \\overline{x}\\overline{y} z + \\overline{x}\\overline{y}\\overline{z}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.552,
                0.569,
                0.567
            ],
            "angle": 0,
            "content": "(c) \\(xyz + xy\\overline{z} +x\\overline{y} z + x\\overline{y}\\overline{z} +\\overline{x} xyz + \\overline{x}\\overline{y} z + \\overline{x}\\overline{y}\\overline{z}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.571,
                0.406,
                0.586
            ],
            "angle": 0,
            "content": "(d) \\(xy\\overline{z} +x\\overline{y}\\overline{z} +\\overline{x}\\overline{y} z + \\overline{x}\\overline{y}\\overline{z}\\)"
        },
        {
            "type": "list",
            "bbox": [
                0.147,
                0.514,
                0.569,
                0.586
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.59,
                0.955,
                0.644
            ],
            "angle": 0,
            "content": "解这些积之和展开式的卡诺图如图7所示。块的分组表明，这些积之和展开式的最小表达式为：a) \\(x\\overline{z} +\\overline{y}\\overline{z} +\\overline{x} yz\\) ；b) \\(\\overline{y} +\\overline{x} z\\) ；c) \\(x + \\overline{y} +z\\) ；d) \\(x\\overline{z} +\\overline{x}\\overline{y}\\) 。在d)中，注意素隐含 \\(x\\bar{z}\\) 和 \\(\\overline{x}\\overline{y}\\) 是本原素隐含，但素隐含 \\(\\overline{y}\\overline{z}\\) 则不是本原的，因为它覆盖的方格被其他两个素隐含覆盖了。"
        },
        {
            "type": "image",
            "bbox": [
                0.25,
                0.655,
                0.504,
                0.759
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.562,
                0.655,
                0.815,
                0.759
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.251,
                0.762,
                0.503,
                0.868
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.561,
                0.762,
                0.815,
                0.867
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.418,
                0.881,
                0.643,
                0.896
            ],
            "angle": 0,
            "content": "图7 三变元卡诺图的使用"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.907,
                0.954,
                0.924
            ],
            "angle": 0,
            "content": "四变元卡诺图是被分成16个方格的正方形，这些方格代表由4个变元组成的16个可能的"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.678,
                0.038,
                0.787,
                0.052
            ],
            "angle": 0,
            "content": "布尔代数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.835,
                0.039,
                0.869,
                0.051
            ],
            "angle": 0,
            "content": "735"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.094,
                0.516,
                0.11
            ],
            "angle": 0,
            "content": "极小项。一种画四个变元卡诺图的方法如图8所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.113,
                0.899,
                0.129
            ],
            "angle": 0,
            "content": "两个方格是相邻的当且仅当它们表示的极小项只有一处字面值不一样。因此，每个方格都"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.132,
                0.607,
                0.282
            ],
            "angle": 0,
            "content": "与另外4个方格相邻。4个变元的积之和展开式的卡诺图可以认为是贴在圆环面上，因此相邻的方格具有公共的边界（见练习28）。4个变元的积之和展开式的化简也是通过识别一些块来实现的，这些块可能由2、4、8或16个方格组成，它们代表的极小项可以合并。每个表示极小项的方格都必须产生更少个字面值的积，或者包含在展开式中。在图9中，给出了一些块的例子，这些块表示3个字面值的积、2个字面值的积或1个字面值的积。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.285,
                0.607,
                0.358
            ],
            "angle": 0,
            "content": "就像2个或3个变元卡诺图一样，我们的目的也是在图中标出1构成的对应于素隐含的最大块，然后用最大块优先法则以最少的块覆盖所有的1。也总是使用最大可能块。例4说明了四变元卡诺图的使用。"
        },
        {
            "type": "image",
            "bbox": [
                0.622,
                0.138,
                0.88,
                0.31
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.669,
                0.319,
                0.834,
                0.333
            ],
            "angle": 0,
            "content": "图8 四变元卡诺图"
        },
        {
            "type": "image",
            "bbox": [
                0.191,
                0.364,
                0.428,
                0.53
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.314,
                0.546,
                0.331,
                0.556
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "image",
            "bbox": [
                0.509,
                0.363,
                0.747,
                0.541
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.636,
                0.545,
                0.653,
                0.556
            ],
            "angle": 0,
            "content": "b)"
        },
        {
            "type": "image",
            "bbox": [
                0.191,
                0.56,
                0.427,
                0.736
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.315,
                0.74,
                0.331,
                0.75
            ],
            "angle": 0,
            "content": "c)"
        },
        {
            "type": "image",
            "bbox": [
                0.511,
                0.56,
                0.765,
                0.737
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.637,
                0.74,
                0.653,
                0.75
            ],
            "angle": 0,
            "content": "d)"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.369,
                0.76,
                0.59,
                0.774
            ],
            "angle": 0,
            "content": "图9 四变元卡诺图中的块"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.788,
                0.449,
                0.805
            ],
            "angle": 0,
            "content": "例4 用卡诺图化简下列积之和展开式："
        },
        {
            "type": "equation",
            "bbox": [
                0.053,
                0.81,
                0.905,
                0.882
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} \\mathrm {a}) w x y z + w x y \\bar {z} + w x \\bar {y} \\bar {z} + w \\bar {x} y z + w \\bar {x} \\bar {y} z + w \\bar {x} \\bar {y} \\bar {z} + \\bar {w} x \\bar {y} z + \\bar {w} \\bar {x} y z + \\bar {w} \\bar {x} y \\bar {z} \\\\ b) w x \\bar {y} \\bar {z} + w \\bar {x} y z + w \\bar {x} y \\bar {z} + w \\bar {x} \\bar {y} \\bar {z} + \\bar {w} x \\bar {y} \\bar {z} + \\bar {w} \\bar {x} y \\bar {z} + \\bar {w} \\bar {x} \\bar {y} \\bar {z} \\\\ \\begin{array}{l} c) w x y \\bar {z} + w x \\bar {y} \\bar {z} + w \\bar {x} y z + w \\bar {x} \\bar {y} \\bar {z} + \\bar {w} x y z + \\bar {w} x \\bar {y} \\bar {z} + \\bar {w} x \\bar {y} z + \\bar {w} \\bar {x} y \\bar {z} + \\bar {w} \\\\ \\bar {x} \\bar {y} \\bar {z} \\end{array} \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.886,
                0.902,
                0.939
            ],
            "angle": 0,
            "content": "解 这些展开式的卡诺图如图10所示。用所示的块可导出如下的积之和：a) \\( wyz + wx\\overline{z} + w\\overline{x}\\overline{y} + \\overline{w}\\overline{x}y + \\overline{w}x\\overline{y}z \\); b) \\( \\overline{y}\\overline{z} + w\\overline{x}y + \\overline{x}\\overline{z} \\); c) \\( \\overline{z} + \\overline{w}x + w\\overline{x}y \\) 。读者应该确定，在每部分中是否可能选择其他的块，它们导致表示这些布尔函数的不同积之和。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.132,
                0.038,
                0.167,
                0.052
            ],
            "angle": 0,
            "content": "736"
        },
        {
            "type": "header",
            "bbox": [
                0.212,
                0.037,
                0.288,
                0.052
            ],
            "angle": 0,
            "content": "第12章"
        },
        {
            "type": "image",
            "bbox": [
                0.134,
                0.095,
                0.38,
                0.276
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.403,
                0.095,
                0.651,
                0.275
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.675,
                0.095,
                0.921,
                0.275
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.411,
                0.28,
                0.643,
                0.296
            ],
            "angle": 0,
            "content": "图10 四变元卡诺图的使用"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.302,
                0.951,
                0.377
            ],
            "angle": 0,
            "content": "卡诺图可以实际用于化简五变元或六变元的布尔函数，但对更多变元的布尔函数就很少使用卡诺图了，因为它们非常复杂。然而，卡诺图中用到的概念在更新的算法中起着重要的作用。而且，掌握这些概念有助于理解这些新算法及实现算法的计算机辅助设计(CAD)程序。在介绍这些概念时，会用到前面化简三变元、四变元布尔函数的内容。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.379,
                0.951,
                0.55
            ],
            "angle": 0,
            "content": "用于化简两变元、三变元和四变元布尔函数的卡诺图分别是用 \\(2 \\times 2\\)、\\(2 \\times 4\\) 和 \\(4 \\times 4\\) 的矩形构建的。而且，在顶行和底行、最左列和最右列中的相应方格是相邻的，因为它们表示的极小项只有一处字面值不同。我们可以用类似的方法构造有4个以上变元的布尔函数卡诺图。我们使用包含 \\(2^{\\lfloor n/2\\rfloor}\\) 行和 \\(2^{\\lceil n/2\\rceil}\\) 列的矩形（这些卡诺图包含 \\(2^n\\) 个方格，因为 \\(\\lceil n/2 \\rceil + \\lfloor n/2 \\rfloor = n\\)）。其中行和列的安排需要满足如下条件：如果两个极小项只有一处字面值不同，则表示这两个极小项的方格是相邻的或者通过特别指定相邻行和相邻列之后被认为是相邻的。因此（但不只限于此原因），用格雷码(见10.5节)安排卡诺图的行和列。其中通过指明1对应于变量的出现和0对应于变量的补的出现，可以将比特串和积关联起来。例如，在一个10变元卡诺图中，格雷码01110标记的行对应于积 \\(\\overline{x}_1 x_2 x_3 x_4 \\overline{x}_5\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.555,
                0.951,
                0.633
            ],
            "angle": 0,
            "content": "例5 用于化简四变元布尔函数的卡诺图有两行两列。行和列均用格雷码11、10、00、01来安排。行分别表示积 \\(wx\\) 、 \\(w\\overline{x}\\) 、 \\(\\overline{w}\\overline{x}\\) 和 \\(\\overline{wx}\\) 。列分别对应积 \\(yz\\) 、 \\(y\\overline{z}\\) 、 \\(\\overline{y}\\overline{z}\\) 和 \\(\\overline{yz}\\) 。使用格雷码并且认为第1行和最末行、第1列和最末列的方格相邻，我们确保只在一个变元上不同的极小项总是相邻的。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.638,
                0.951,
                0.775
            ],
            "angle": 0,
            "content": "例6为了化简五变元的布尔函数，我们使用 \\(2^{3} = 8\\) 列和 \\(2^{2} = 4\\) 行的卡诺图。使用格雷码11、10、00、01标记4行，分别对应于 \\(x_{1}x_{2}\\) 、 \\(x_{1}\\overline{x}_{2}\\) 、 \\(\\overline{x}_1\\overline{x}_2\\) 和 \\(\\overline{x}_1x_2\\) 。使用格雷码111、110、100、101、001、000、010、011标记8列，分别对应项 \\(x_{3}x_{4}x_{5}\\) 、 \\(x_{3}x_{4}\\overline{x}_{5}\\) 、 \\(x_{3}\\overline{x}_{4}\\overline{x}_{5}\\) 、 \\(x_{3}\\overline{x}_{4}x_{5}\\) 、 \\(\\overline{x}_3\\overline{x}_4x_5\\) 、 \\(\\overline{x}_3\\overline{x}_4\\overline{x}_5\\) 、 \\(\\overline{x}_3x_4\\overline{x}_5\\) 和 \\(\\overline{x}_3x_4x_5\\) 。使用格雷码标记行和列确保相邻方格表示的极小项只在一个变元上不同。然而，要确保所有只在一个变元上不同的极小项表示的方格是相邻的，我们认为顶行和底行的方格是相邻的，第1列和第8列、第1列和第4列、第2列和第7列、第3列和第6列、第5列和第8列的方格是相邻的（读者可自行验证）。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.777,
                0.951,
                0.892
            ],
            "angle": 0,
            "content": "为了用卡诺图化简 \\(n\\) 变元的布尔函数，首先应画出合适大小的卡诺图。我们在积之和扩展式中的极小项对应的所有方格中放入1，然后确定函数的所有素隐含。要做到这一点，我们寻找由 \\(2^{k}\\) 个聚簇方格(全包含1)组成的块，其中 \\(1 \\leqslant k \\leqslant n\\) 。这些块对应于 \\(n - k\\) 个字面值的积。（练习33要求读者对此进行验证。）而且，若 \\(2^{k}\\) 个方格(全包含1)的块没有包含在一个 \\(2^{k + 1}\\) 个方格(全含1)组成的块中，则这 \\(2^{k}\\) 个方格的块表示一个素隐含，因为没有一个删除一个字面值后得到的字面值积还能用全是1的方格组成的块表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.897,
                0.951,
                0.937
            ],
            "angle": 0,
            "content": "例7 在化简五变元布尔函数的卡诺图中，有一个表示两个字面值之积的8个方格全是1的块，若它没有包含在一个16个方格全是1且表示单个字面值的块中，则此块是素隐含的。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.677,
                0.038,
                0.786,
                0.053
            ],
            "angle": 0,
            "content": "布尔代数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.832,
                0.039,
                0.868,
                0.052
            ],
            "angle": 0,
            "content": "737"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.094,
                0.897,
                0.169
            ],
            "angle": 0,
            "content": "一旦所有的素隐含确定后，我们的目标是找出具有如下性质的这些素隐含的最小可能子集：子集中的素隐含覆盖了卡诺图中所有包含1的方格。首先应选择本原素隐含，因为每个本原素隐含由一个块表示，这个块覆盖了不能由其他素隐含覆盖的是1的方格。然后增加其他素隐含以确保覆盖图中所有为1的方格。当变元的数量较大时，这最后一步会极为复杂。"
        },
        {
            "type": "title",
            "bbox": [
                0.053,
                0.178,
                0.3,
                0.195
            ],
            "angle": 0,
            "content": "12.4.3 无须在意的条件"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.198,
                0.897,
                0.311
            ],
            "angle": 0,
            "content": "在某些电路中，由于输入值的一些组合从未出现过，所以我们只关心电路对输入值的其他组合的输出，这使得我们在生产具有所需输出的电路时有很大自由，因为对于所有不出现的输入值的组合，其输出值可以任意选择。这种组合的函数值被称为无须在意的条件。在卡诺图中，对于那些其函数值可以任意选择的变元值组合，用 \\(d\\) 对其做记号。在化简过程中，我们可以将这些输入值的组合赋值1，以便在卡诺图中得到最大的块。例8说明了这一点。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.316,
                0.897,
                0.431
            ],
            "angle": 0,
            "content": "例8 用二进制数字对十进制表达式进行编码的一种方法是：对十进制表达式中的每一位，在编码的二进制表达式中用4位对其编码。例如，873的编码为100001110011。十进制表达式的这种编码方式称为二进制编码的十进制展开式。因为有16个4位二进制数，但只有10个十进制数字，所以还有6个4位二进制数没有用于对数进行编码。假设现在需要构造一个电路，如果十进制数大于或等于5，则输出1；若十进制数小于5，则输出0。怎么仅用与门、或门和反相器来构造这个电路？"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.433,
                0.897,
                0.564
            ],
            "angle": 0,
            "content": "解 以 \\( F(w, x, y, z) \\) 表示此电路的输出，其中 \\( wxyz \\) 是一个十进制数的二进制扩展式。\\( F \\) 的值如表1所示，图11a是 \\( F \\) 的卡诺图，其中无须在意位置都是 \\( d \\) 。我们可以将 \\( d \\) 包括在块中或者将它剔除，这样块就有很多可能的选择。例如，如果剔除所有的 \\( d \\) 方格，则形成如图11b所示的块，所产生的表达式为 \\( w\\overline{x}\\overline{y} + \\overline{w}xy + \\overline{w}xz \\) 。如果包括某些 \\( d \\) 而剔除其余的，则形成的块如图11c所示，且所产生的表达式为 \\( w\\overline{x} + \\overline{w}xy + x\\overline{y}z \\) 。最后，如果包括所有的 \\( d \\) 块，且使用如图11d所示的块，则产生最简单的积之和展开式，即 \\( F(x, y, z) = w + xy + xz \\) 。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.45,
                0.581,
                0.499,
                0.595
            ],
            "angle": 0,
            "content": "表1"
        },
        {
            "type": "table",
            "bbox": [
                0.052,
                0.597,
                0.897,
                0.728
            ],
            "angle": 0,
            "content": "<table><tr><td>数字</td><td>w</td><td>x</td><td>y</td><td>z</td><td>F</td><td>数字</td><td>w</td><td>x</td><td>y</td><td>z</td><td>F</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>5</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>6</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>2</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>7</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>3</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>8</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>4</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>9</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr></table>"
        },
        {
            "type": "title",
            "bbox": [
                0.053,
                0.751,
                0.356,
                0.769
            ],
            "angle": 0,
            "content": "12.4.4 奎因-莫可拉斯基方法"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.772,
                0.897,
                0.904
            ],
            "angle": 0,
            "content": "我们已经看到，可以用卡诺图将布尔函数展开为形如积之和的极小表达式。但当变元超过4个时，卡诺图就变得难以使用。而且，卡诺图的使用还要依赖于用目测方法将项分成组。鉴于这些原因，需要可以机械化的过程来化简积之和展开式。奎因-莫可拉斯基方法就是这样一种过程，它可以用于含有任意多个变元的布尔函数。此方法是由W.V奎因和E.J莫可拉斯基于20世纪50年代提出的。奎因-莫可拉斯基方法由两部分组成，第一部分寻找可能包含在积之和的最小展开式中的候选项，第二部分才确定哪些项将真正使用。下面用例9来说明这个过程是怎样通过将隐含合并到含有更少字面值的隐含来进行的。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.127,
                0.038,
                0.162,
                0.051
            ],
            "angle": 0,
            "content": "738"
        },
        {
            "type": "header",
            "bbox": [
                0.208,
                0.036,
                0.284,
                0.051
            ],
            "angle": 0,
            "content": "第12章"
        },
        {
            "type": "image",
            "bbox": [
                0.25,
                0.095,
                0.514,
                0.269
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.389,
                0.281,
                0.406,
                0.293
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "image",
            "bbox": [
                0.532,
                0.095,
                0.795,
                0.268
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.669,
                0.281,
                0.687,
                0.293
            ],
            "angle": 0,
            "content": "b)"
        },
        {
            "type": "image",
            "bbox": [
                0.251,
                0.313,
                0.514,
                0.487
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.389,
                0.5,
                0.405,
                0.512
            ],
            "angle": 0,
            "content": "c)"
        },
        {
            "type": "image",
            "bbox": [
                0.535,
                0.313,
                0.794,
                0.487
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.67,
                0.499,
                0.687,
                0.511
            ],
            "angle": 0,
            "content": "d)"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.371,
                0.522,
                0.676,
                0.537
            ],
            "angle": 0,
            "content": "图11 表明其无须在意位置的卡诺图"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.55,
                0.945,
                0.588
            ],
            "angle": 0,
            "content": "例9 下面说明怎么用奎因-莫可拉斯基方法寻找等价于 \\(xyz + x\\overline{y}z + \\overline{x}yz + \\overline{x}\\overline{y}z + \\overline{x}\\overline{y}\\overline{z}\\) 的极小展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.592,
                0.569,
                0.704
            ],
            "angle": 0,
            "content": "我们用比特串来表示此展开式中的极小项。如果 \\(x\\) 出现，则第一位为1；如果 \\(\\overline{x}\\) 出现，则第一位为0。如果 \\(y\\) 出现，则第二位为1；如果 \\(\\overline{y}\\) 出现，则第二位为0。如果 \\(z\\) 出现，则第三位为1；如果 \\(\\overline{z}\\) 出现，则第三位为0。然后根据对应比特串中1的个数来对这些项进行分组。这些信息如表2所示。"
        },
        {
            "type": "table",
            "bbox": [
                0.596,
                0.596,
                0.945,
                0.716
            ],
            "angle": 0,
            "content": "<table><tr><td>极小项</td><td>比特串</td><td>1的个数</td></tr><tr><td>xyz</td><td>111</td><td>3</td></tr><tr><td>x y z</td><td>101</td><td>2</td></tr><tr><td>x y z</td><td>011</td><td>2</td></tr><tr><td>x y z</td><td>001</td><td>1</td></tr><tr><td>x y z</td><td>000</td><td>0</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.706,
                0.946,
                0.742
            ],
            "angle": 0,
            "content": "可以合并的极小项只有一处字面值不同。所以，对于两个可以合并的极小项，在表示它们的比特串中，1的个数仅相差1。当两个极小项合并"
        },
        {
            "type": "title",
            "bbox": [
                0.101,
                0.761,
                0.147,
                0.774
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.102,
                0.792,
                0.244,
                0.904
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.102,
                0.908,
                0.244,
                0.928
            ],
            "angle": 0,
            "content": "©Stanford University News Service"
        },
        {
            "type": "text",
            "bbox": [
                0.26,
                0.792,
                0.95,
                0.932
            ],
            "angle": 0,
            "content": "爱德华·莫可拉斯基(Edward J. McCluskey, 1929—) 莫可拉斯基生于1929年，就读于鲍登学院和麻省理工学院，并于1956年获得麻省理工学院电子工程学博士学位。1955年，莫可拉斯基进入贝尔电话实验室，并在那里工作了五年。1959年到1966年，莫可拉斯基在普林斯顿大学担任电子工程学教授，并在1961年到1966年期间兼任在普林斯顿大学计算中心主任一职。1967年，他在斯坦福大学担任计算机科学和电子工程学教授，并于1969年到1978年期间，担任数字系统实验室的主任。莫可拉斯基的研究范围很广泛，涉及计算机科学的许多领域，包括容错计算、计算机体系结构、测试和逻辑设计。他现在是斯坦福大学可靠性计算中心的主任，同时也是美国计算机协会的会员。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.682,
                0.037,
                0.792,
                0.052
            ],
            "angle": 0,
            "content": "布尔代数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.838,
                0.037,
                0.874,
                0.051
            ],
            "angle": 0,
            "content": "739"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.092,
                0.905,
                0.147
            ],
            "angle": 0,
            "content": "成一个积时，这个积只含有两个字面值。两个字面值的积可以如下表示：以短划线来表示没有出现的变元。例如，比特串101和001所表示的极小项 \\(x\\overline{y} z\\) 和 \\(\\overline{x}\\overline{y} z\\) 可以合并成 \\(\\overline{y} z\\) ，而 \\(\\overline{y} z\\) 可以用比特串-01表示。表3列出了所有可以合并的成对极小项以及它们合并后所产生的积。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.15,
                0.906,
                0.244
            ],
            "angle": 0,
            "content": "下一步，对于由两个字面值构成的积，如果两个这样的积能够合并，则将它们合并成一个字面值。两个这样的积能够合并的条件是：它们所包含的字面值是两个相同变元的字面值，并且只有其中一个变元的字面值不一致。就表示这些积的串来说，它们必定在相同位置有一个短划线，且在其余的两个位置中必定有一个位置的内容不相同。我们可以将串-11和-01所表示的积 \\(yz\\) 和 \\(\\overline{yz}\\) 合并成 \\(z\\) ，并用串-1表示。所有能够以这种方式合并的项如表3所示。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.455,
                0.256,
                0.505,
                0.27
            ],
            "angle": 0,
            "content": "表3"
        },
        {
            "type": "table",
            "bbox": [
                0.056,
                0.273,
                0.905,
                0.387
            ],
            "angle": 0,
            "content": "<table><tr><td colspan=\"2\"></td><td colspan=\"2\">步骤1</td><td colspan=\"2\">步骤2</td></tr><tr><td>项</td><td>比特串</td><td>项</td><td>比特串</td><td>项</td><td>比特串</td></tr><tr><td>1 xyz</td><td>111</td><td>(1, 2)</td><td>1-1</td><td>(1, 2, 3, 4)</td><td>z</td></tr><tr><td>2 x y z</td><td>101</td><td>(1, 3)</td><td>-11</td><td></td><td></td></tr><tr><td>3 x y z</td><td>011</td><td>(2, 4)</td><td>-01</td><td></td><td></td></tr><tr><td>4 x y z</td><td>001</td><td>(3, 4)</td><td>0-1</td><td></td><td></td></tr><tr><td>5 x y z</td><td>000</td><td>(4, 5)</td><td>00-</td><td></td><td></td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.401,
                0.906,
                0.534
            ],
            "angle": 0,
            "content": "在表3中，我们还指出了哪些项可以用来形成更少字面值的积，在极小展开式中不需要这些项。下一步是找出积的一个极小集合，使之可以用来表示此布尔函数。我们从那些还没有被用来形成更少字面值之积的积着手。再下一步，我们构造表4，通过合并原来项所形成的每一个候选积构成此表的行，原来的项构成列。如果积之和展开式中原来的项被用来形成这个候选积，则在相应的位置打上 \\(\\times\\) ，此时称此候选项覆盖了原来的极小项。我们需要至少一个积，它覆盖原来的每一个极小项。因此，一旦此表的某一列只有一个 \\(\\times\\) ，则此 \\(\\times\\) 所在的行所对应的积必定被使用。从表4可以看出， \\(z\\) 和 \\(\\overline{x}\\overline{y}\\) 都是必需的。所以，最后的答案是 \\(z + \\overline{x}\\overline{y}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.536,
                0.905,
                0.553
            ],
            "angle": 0,
            "content": "就像例9所说明的那样，奎因-莫可拉斯基方法用下面一系列步骤来化简一个积之和展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.556,
                0.905,
                0.592
            ],
            "angle": 0,
            "content": "1)将由 \\(n\\) 个变元构成的每一个极小项表示成一个长度为 \\(n\\) 的比特串，如果 \\(x_{i}\\) 出现，则比特串的第 \\(i\\) 个位置为1；如果 \\(\\overline{x}_i\\) 出现，则比特串的第 \\(i\\) 个位置为0。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.595,
                0.377,
                0.611
            ],
            "angle": 0,
            "content": "2)根据串中1的个数将串分组。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.614,
                0.906,
                0.65
            ],
            "angle": 0,
            "content": "3)确定所有这样 \\(n - 1\\) 个变元的积，它们可以通过取展开式中极小项的布尔和得到。将能够合并的极小项表示成比特串，且这些串只在一个位置不相同。将这些 \\(n - 1\\) 个变元的积用如下"
        },
        {
            "type": "list",
            "bbox": [
                0.057,
                0.556,
                0.906,
                0.65
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.058,
                0.655,
                0.125,
                0.678
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.059,
                0.691,
                0.201,
                0.802
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.06,
                0.805,
                0.199,
                0.815
            ],
            "angle": 0,
            "content": "Courtesy of Douglas Quine"
        },
        {
            "type": "text",
            "bbox": [
                0.217,
                0.691,
                0.908,
                0.829
            ],
            "angle": 0,
            "content": "威拉德·冯·奥曼·奎因（Willard Van Orman Quine，1908—2000）奎因生于俄亥俄州阿克伦郡，早年就读于奥柏林学院，之后考入哈佛大学，并于1932年获得哲学博士学位。1933年，他成为哈佛大学的初级研究员，3年后他在该学院任职并执教终身。第二次世界大战期间，他在美国海军服役，破译来自德国潜艇的密码。奎因对算法有着浓厚的兴趣，而不是硬件方面。他发明的“奎因-莫可拉斯基方法”，在当时是一种数理逻辑的教学设备，而不仅仅是化简开关电路的方法。奎因是20世纪最著名的哲学家之一。他对知识理论、数理逻辑、集合论以及语言和逻辑哲学都做出了重要的贡献。他1937年出版的《数理逻辑的新基础》（New Foundations of"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.832,
                0.909,
                0.937
            ],
            "angle": 0,
            "content": "Mathematical Logic)和1960年出版的《词语和对象》(Word and Object)都有着深远的影响。1978年他从哈佛大学退休后，继续奔波于办公室和他在比根山住所之间。他一生都在使用1927年生产的雷明顿打字机，也正是用该打字机他完成了博士论文。他甚至对此打字机做了改造：增加了一些特殊符号，去掉了第二句号、第二逗号和问号。当他被问到是否漏掉了问号时，他回答说：“你看，我只做确定的事。”《新黑客词典》(New Hacker's Dictionary)中用奎因的姓名命名了一个新词即“奎因”，其含义是能复制其源代码作为完整输出的一个程序。对黑客而言，用特定的程序语言中产生最短的奎因是个非常流行的难题。"
        },
        {
            "type": "image",
            "bbox": [
                0.919,
                0.536,
                0.948,
                0.563
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.123,
                0.038,
                0.159,
                0.051
            ],
            "angle": 0,
            "content": "740"
        },
        {
            "type": "header",
            "bbox": [
                0.205,
                0.036,
                0.281,
                0.052
            ],
            "angle": 0,
            "content": "第12章"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.093,
                0.943,
                0.129
            ],
            "angle": 0,
            "content": "的串表示：如果 \\( x_{i} \\) 出现在此积中，则此串的第 \\( i \\) 个位置为1；如果 \\( \\overline{x}_i \\) 出现，则此位置为0；如果此积中没有涉及 \\( x_{i} \\) 的字面值，则此位置为短划线。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.495,
                0.141,
                0.546,
                0.154
            ],
            "angle": 0,
            "content": "表4"
        },
        {
            "type": "table",
            "bbox": [
                0.095,
                0.157,
                0.943,
                0.213
            ],
            "angle": 0,
            "content": "<table><tr><td></td><td>xyz</td><td>x y z</td><td>x y z</td><td>x y z</td><td>x y z</td></tr><tr><td>z</td><td>x</td><td>x</td><td>x</td><td>x</td><td></td></tr><tr><td>x y</td><td></td><td></td><td></td><td>x</td><td>x</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.229,
                0.943,
                0.283
            ],
            "angle": 0,
            "content": "4)确定所有这样 \\(n - 2\\) 个变元的积，它们可以取为在前一个步骤形成的 \\(n - 1\\) 个变元的积的布尔和。将能够合并的 \\(n - 1\\) 个变元的积，表示成如下的串：在同一位置有一个短划线，且只在一个位置不相同。"
        },
        {
            "type": "text",
            "bbox": [
                0.137,
                0.286,
                0.581,
                0.302
            ],
            "angle": 0,
            "content": "5)只要可能，继续将布尔积合并成更少变元的积。"
        },
        {
            "type": "text",
            "bbox": [
                0.137,
                0.305,
                0.929,
                0.322
            ],
            "angle": 0,
            "content": "6)找到所有这样的布尔积：它们虽然出现，但还没有被用来形成少一个字面值的布尔积。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.324,
                0.945,
                0.512
            ],
            "angle": 0,
            "content": "7)找到这些布尔积的最小集合，使得这些积之和表示此布尔函数。这可以用如下方法来完成：构造一个表，列出哪些积覆盖了哪些极小项。每一个极小项必定被至少一个积覆盖。使用此表的第一步是找到所有的本原素隐含。每个本原素隐含必须被包含，因为它是覆盖某个极小项的唯一素隐含。如果找到了本原素隐含，就可以通过除去由此素隐含覆盖的极小项的行化简此表。第二步，去掉所有满足如下条件的素隐含，此素隐含覆盖一个极小项集合，此极小项集合被另一个素隐含覆盖（读者应该证明）。第三步，从表中去掉满足如下条件的极小项所在的行，覆盖此极小项的某些素隐含也覆盖另一个极小项。首先找到必须被包含的本原素隐含，然后去掉冗余的素隐含，最后找到可以被忽略的极小项，迭代此过程直到此表不再改变为止。这里使用回溯过程寻找最优解，为覆盖所有的字面值积逐步添加素隐含以寻找可能的解，在每一步都与已经找到的最优解进行比较。"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.514,
                0.766,
                0.532
            ],
            "angle": 0,
            "content": "最后一个例子说明了怎么用这个过程来化简4个变元的积之和展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.536,
                0.941,
                0.574
            ],
            "angle": 0,
            "content": "例10 用奎因-莫可拉斯基法化简积之和展开式 \\( wxy\\overline{z} + w\\overline{x}yz + w\\overline{x}y\\overline{z} + \\overline{w}xyz + \\overline{wx}\\overline{y}z + \\overline{w}\\overline{x}yz + \\overline{w}\\overline{x}\\overline{y}z \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.577,
                0.943,
                0.613
            ],
            "angle": 0,
            "content": "解首先将极小项表示成比特串，然后根据比特串中1的个数来对项进行分组，如表5所示。表6给出了所有由这些积的布尔和得到的布尔积。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.496,
                0.624,
                0.546,
                0.638
            ],
            "angle": 0,
            "content": "表5"
        },
        {
            "type": "table",
            "bbox": [
                0.095,
                0.641,
                0.945,
                0.801
            ],
            "angle": 0,
            "content": "<table><tr><td>项</td><td>比特串</td><td>1 的个数</td></tr><tr><td>\\( {wxy}\\bar{z} \\)</td><td>1110</td><td>3</td></tr><tr><td>\\( w\\overline{x}{yz} \\)</td><td>1011</td><td>3</td></tr><tr><td>\\( \\overline{w}{xyz} \\)</td><td>0111</td><td>3</td></tr><tr><td>\\( w\\bar{x}y\\bar{z} \\)</td><td>1010</td><td>2</td></tr><tr><td>\\( \\overline{w}x\\bar{y}z \\)</td><td>0101</td><td>2</td></tr><tr><td>\\( \\overline{w}x{yz} \\)</td><td>0011</td><td>2</td></tr><tr><td>\\( \\overline{w}x\\bar{y}z \\)</td><td>0001</td><td>1</td></tr></table>"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.496,
                0.818,
                0.546,
                0.832
            ],
            "angle": 0,
            "content": "表6"
        },
        {
            "type": "table",
            "bbox": [
                0.095,
                0.834,
                0.945,
                0.925
            ],
            "angle": 0,
            "content": "<table><tr><td colspan=\"2\"></td><td colspan=\"2\">步骤1</td><td colspan=\"2\">步骤2</td></tr><tr><td>项</td><td>比特串</td><td>项</td><td>比特串</td><td>项</td><td>比特串</td></tr><tr><td>1</td><td>\\( \\begin{array}{c}\\text{wxy}\\overline{z}\\end{array} \\)</td><td>1110(1,4)</td><td>\\( \\begin{array}{c}\\text{wy}\\overline{z}\\end{array} \\)</td><td>1-10(3,5,6,7)</td><td>\\( \\overline{w}z \\)0--1</td></tr><tr><td>2</td><td>\\( \\begin{array}{c}\\text{w}\\overline{x}\\text{y}z\\end{array} \\)</td><td>1011(2,4)</td><td>\\( \\begin{array}{c}\\text{w}\\overline{x}\\text{y}\\end{array} \\)</td><td>101-</td><td></td></tr><tr><td>3</td><td>\\( \\overline{w}xyz \\)</td><td>0111(2,6)</td><td>\\( \\overline{x}yz \\)</td><td>-011</td><td></td></tr></table>"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.671,
                0.041,
                0.781,
                0.056
            ],
            "angle": 0,
            "content": "布尔代数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.829,
                0.043,
                0.862,
                0.055
            ],
            "angle": 0,
            "content": "741"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.816,
                0.098,
                0.854,
                0.112
            ],
            "angle": 0,
            "content": "（续）"
        },
        {
            "type": "table",
            "bbox": [
                0.046,
                0.115,
                0.894,
                0.223
            ],
            "angle": 0,
            "content": "<table><tr><td colspan=\"2\"></td><td colspan=\"2\">步骤1</td><td colspan=\"2\">步骤2</td></tr><tr><td>项</td><td>比特串</td><td>项</td><td>比特串</td><td>项</td><td>比特串</td></tr><tr><td>4 w x y z</td><td>1010</td><td>(3,5)</td><td>01-1</td><td></td><td></td></tr><tr><td>5 w x y z</td><td>0101</td><td>(3,6)</td><td>0-11</td><td></td><td></td></tr><tr><td>6 w x y z</td><td>0011</td><td>(5,7)</td><td>0-01</td><td></td><td></td></tr><tr><td>7 w x y z</td><td>0001</td><td>(6,7)</td><td>00-1</td><td></td><td></td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.239,
                0.892,
                0.314
            ],
            "angle": 0,
            "content": "没有被用来形成更少变元之积的只有 \\(\\overline{w}z\\)、\\(wy\\overline{z}\\)、\\(w\\overline{x}y\\) 和 \\(\\overline{x}yz\\)。表7表明了每个这样的积覆盖的极小项。为覆盖这些极小项，必须包括 \\(\\overline{w}z\\) 和 \\(wy\\overline{z}\\)，因为它们是分别覆盖 \\(\\overline{w}xyz\\) 和 \\(wxy\\overline{z}\\) 的唯一的积。一旦将这两个积包括进来，我们就可以看到，剩下的两个积中只有一个是必要的。因此，\\(\\overline{w}z + wy\\overline{z} + w\\overline{x}y\\) 或者 \\(\\overline{w}z + wy\\overline{z} + \\overline{x}yz\\) 都可以被看作最后答案。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.445,
                0.326,
                0.496,
                0.34
            ],
            "angle": 0,
            "content": "表7"
        },
        {
            "type": "table",
            "bbox": [
                0.046,
                0.343,
                0.894,
                0.449
            ],
            "angle": 0,
            "content": "<table><tr><td></td><td>\\( wxy\\overline{z} \\)</td><td>\\( w\\overline{x}yz \\)</td><td>\\( \\overline{wxyz} \\)</td><td>\\( w\\overline{x}y\\overline{z} \\)</td><td>\\( \\overline{wxy}\\overline{z} \\)</td><td>\\( \\overline{w}\\overline{x}\\overline{y}z \\)</td><td>\\( \\overline{w}\\overline{x}\\overline{y}\\overline{z} \\)</td></tr><tr><td>\\( \\overline{w}z \\)</td><td></td><td></td><td>✘</td><td></td><td>✘</td><td>✘</td><td>✘</td></tr><tr><td>\\( wy\\overline{z} \\)</td><td>✘</td><td></td><td></td><td>✘</td><td></td><td></td><td></td></tr><tr><td>\\( w\\overline{x}y \\)</td><td></td><td>✘</td><td></td><td>✘</td><td></td><td></td><td></td></tr><tr><td>\\( \\overline{x}yz \\)</td><td></td><td>✘</td><td></td><td></td><td></td><td>✘</td><td></td></tr></table>"
        },
        {
            "type": "title",
            "bbox": [
                0.047,
                0.474,
                0.094,
                0.489
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.494,
                0.545,
                0.508
            ],
            "angle": 0,
            "content": "1. a) 画出二变元函数的卡诺图，并在表示 \\( \\overline{xy} \\) 的方格中放置 1。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.512,
                0.472,
                0.527
            ],
            "angle": 0,
            "content": "b)与上述方格相邻的方格所表示的极小项是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.531,
                0.434,
                0.545
            ],
            "angle": 0,
            "content": "2. 寻找下列每个卡诺图所表示的积之和展开式。"
        },
        {
            "type": "image",
            "bbox": [
                0.069,
                0.548,
                0.185,
                0.616
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.269,
                0.548,
                0.393,
                0.617
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.483,
                0.548,
                0.603,
                0.617
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.621,
                0.434,
                0.636
            ],
            "angle": 0,
            "content": "3. 画出下列两个变元的积之和展开式的卡诺图："
        },
        {
            "type": "text",
            "bbox": [
                0.069,
                0.64,
                0.117,
                0.654
            ],
            "angle": 0,
            "content": "a) \\(x\\overline{y}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.261,
                0.64,
                0.348,
                0.654
            ],
            "angle": 0,
            "content": "b) \\(xy + \\overline{x}\\overline{y}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.456,
                0.64,
                0.625,
                0.655
            ],
            "angle": 0,
            "content": "c) \\(xy + x\\overline{y} + \\overline{x}y + \\overline{x}\\overline{y}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.658,
                0.823,
                0.673
            ],
            "angle": 0,
            "content": "4. 用卡诺图找出下列关于变元 \\(x\\) 和 \\(y\\) 的布尔函数的极小展开式，且此展开式具有积之和的形式。"
        },
        {
            "type": "text",
            "bbox": [
                0.069,
                0.677,
                0.157,
                0.691
            ],
            "angle": 0,
            "content": "a) \\(\\overline{x} y + \\overline{x}\\overline{y}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.261,
                0.677,
                0.348,
                0.691
            ],
            "angle": 0,
            "content": "b) \\(xy + x\\overline{y}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.456,
                0.678,
                0.625,
                0.692
            ],
            "angle": 0,
            "content": "c) \\(xy + x\\overline{y} +\\overline{x} y + \\overline{x}\\overline{y}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.696,
                0.555,
                0.71
            ],
            "angle": 0,
            "content": "5. a) 画出三变元函数的卡诺图，并在表示 \\(\\overline{x} y\\overline{z}\\) 的方格里放置1。"
        },
        {
            "type": "text",
            "bbox": [
                0.068,
                0.714,
                0.454,
                0.728
            ],
            "angle": 0,
            "content": "b)与上述方格相邻的方格表示的极小项是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.732,
                0.6,
                0.747
            ],
            "angle": 0,
            "content": "6. 对于下列电路图，用卡诺图画出具有相同输出的更简单的电路图。"
        },
        {
            "type": "image",
            "bbox": [
                0.069,
                0.751,
                0.421,
                0.845
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.489,
                0.751,
                0.865,
                0.942
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.138,
                0.043,
                0.174,
                0.056
            ],
            "angle": 0,
            "content": "742"
        },
        {
            "type": "header",
            "bbox": [
                0.218,
                0.042,
                0.295,
                0.056
            ],
            "angle": 0,
            "content": "第12章"
        },
        {
            "type": "image",
            "bbox": [
                0.132,
                0.097,
                0.535,
                0.232
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.237,
                0.46,
                0.252
            ],
            "angle": 0,
            "content": "7. 画出下列三变元积之和展开式的卡诺图："
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.256,
                0.195,
                0.269
            ],
            "angle": 0,
            "content": "a) \\(x\\overline{y}\\overline{z}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.324,
                0.256,
                0.434,
                0.269
            ],
            "angle": 0,
            "content": "b) \\(\\overline{x} yz + \\overline{x} \\overline{y} \\overline{z}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.519,
                0.256,
                0.726,
                0.269
            ],
            "angle": 0,
            "content": "c) \\(xyz + xy\\overline{z} + \\overline{x}y\\overline{z} + \\overline{x}\\overline{y}z\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.273,
                0.955,
                0.304
            ],
            "angle": 0,
            "content": "8.构造 \\(F(x,y,z) = xz + yz + xy\\overline{z}\\) 的卡诺图。使用此卡诺图找出 \\(F(x,y,z)\\) 的隐含、素隐含和本原素隐含。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.308,
                0.955,
                0.339
            ],
            "angle": 0,
            "content": "9.构造 \\(F(x,y,z) = x\\overline{z} +xyz + y\\overline{z}\\) 的卡诺图。使用此卡诺图找出 \\(F(x,y,z)\\) 的隐含、素隐含和本原素隐含。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.343,
                0.955,
                0.375
            ],
            "angle": 0,
            "content": "10. 画一个3立方体 \\(Q_{3}\\)，用布尔变元 \\(x\\)、\\(y\\) 和 \\(z\\) 组成的极小项标记每一个顶点，这些项与顶点表示的比特串关联。对这些变元中的每一个字面值，指出表示这个字面值且是 \\(Q_{3}\\) 的子图的2立方体 \\(Q_{2}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.378,
                0.955,
                0.428
            ],
            "angle": 0,
            "content": "11. 画一个4立方体 \\(Q_{4}\\)，用布尔变元 \\(w\\)、\\(x\\)、\\(y\\) 和 \\(z\\) 组成的极小项标记每一个顶点，这些项与顶点表示的比特串关联。对这些变元中的每一个字面值，指出哪个3立方体 \\(Q_{3}\\) 表示这个字面值且是 \\(Q_{4}\\) 的子图。指出哪个2立方体 \\(Q_{2}\\) 表示积 \\(wz\\)、\\(\\overline{x}y\\) 和 \\(\\overline{y}z\\) 且是 \\(Q_{4}\\) 的子图。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.431,
                0.925,
                0.446
            ],
            "angle": 0,
            "content": "12. 用卡诺图找出下列关于变元 \\(x\\)、\\(y\\) 和 \\(z\\) 的函数的一个极小展开式，且此展开式具有积之和的形式。"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.45,
                0.246,
                0.464
            ],
            "angle": 0,
            "content": "a) \\(\\overline{x} yz + \\overline{x}\\overline{y} z\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.52,
                0.45,
                0.726,
                0.464
            ],
            "angle": 0,
            "content": "b) \\(xyz + xy\\overline{z} +\\overline{x} yz + \\overline{x} y\\overline{z}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.468,
                0.408,
                0.481
            ],
            "angle": 0,
            "content": "c) \\(xy\\overline{z} +x\\overline{y} z + x\\overline{y}\\overline{z} +\\overline{x} yz + \\overline{x}\\overline{y} z\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.52,
                0.468,
                0.841,
                0.481
            ],
            "angle": 0,
            "content": "d) \\(xyz + x\\overline{y} z + x\\overline{y}\\overline{z} +\\overline{x} xyz + \\overline{x} y\\overline{z} +\\overline{x}\\overline{y}\\overline{z}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.485,
                0.66,
                0.499
            ],
            "angle": 0,
            "content": "13. a) 画出四变元函数的卡诺图，并在 \\(\\overline{w}xy\\) 所表示的方格里填入 1。"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.502,
                0.527,
                0.516
            ],
            "angle": 0,
            "content": "b)与上述方格相邻的方格表示的极小项是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.52,
                0.955,
                0.534
            ],
            "angle": 0,
            "content": "14. 用卡诺图找出下列关于变元 \\( w \\)、\\( x \\)、\\( y \\) 和 \\( z \\) 的函数的一个极小展开式，且此展开式具有积之和的形式。"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.538,
                0.488,
                0.551
            ],
            "angle": 0,
            "content": "a) \\(wxyz + wx\\overline{y}z + wx\\overline{y}\\overline{z} + w\\overline{x}y\\overline{z} + w\\overline{x}\\overline{y}z\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.555,
                0.556,
                0.568
            ],
            "angle": 0,
            "content": "b) \\(wxy\\overline{z} +wx\\overline{y} z + w\\overline{x} yz + \\overline{w} x\\overline{y} z + \\overline{w}\\overline{x} y\\overline{z} +\\overline{w}\\overline{x}\\overline{y} z\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.573,
                0.698,
                0.586
            ],
            "angle": 0,
            "content": "c) \\(wxyz + wxy\\overline{z} +wx\\overline{y} z + w\\overline{x}\\overline{y} z + w\\overline{x}\\overline{y}\\overline{z} +\\overline{w} x\\overline{y} z + \\overline{w}\\overline{x} y\\overline{z} +\\overline{w}\\overline{x}\\overline{y} z\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.591,
                0.752,
                0.604
            ],
            "angle": 0,
            "content": "d) \\(wxyz + wxy\\overline{z} +wx\\overline{y} z + w\\overline{x} yz + w\\overline{x} y\\overline{z} +\\overline{w} xyz + \\overline{w}\\overline{x} yz + \\overline{w}\\overline{x} y\\overline{z}\\)"
        },
        {
            "type": "list",
            "bbox": [
                0.14,
                0.538,
                0.752,
                0.604
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.608,
                0.655,
                0.622
            ],
            "angle": 0,
            "content": "15. 在表示五变元布尔函数的卡诺图中，找出对应于下列积的方格。"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.627,
                0.236,
                0.64
            ],
            "angle": 0,
            "content": "a) \\(x_{1}x_{2}x_{3}x_{4}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.326,
                0.627,
                0.4,
                0.64
            ],
            "angle": 0,
            "content": "b) \\(\\overline{x}_1x_3x_5\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.521,
                0.628,
                0.575,
                0.639
            ],
            "angle": 0,
            "content": "c) \\(x_{2}x_{4}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.645,
                0.204,
                0.657
            ],
            "angle": 0,
            "content": "d) \\(\\overline{x}_3\\overline{x}_4\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.326,
                0.645,
                0.361,
                0.657
            ],
            "angle": 0,
            "content": "e) \\(x_{3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.521,
                0.645,
                0.556,
                0.656
            ],
            "angle": 0,
            "content": "f) \\(\\overline{x}_5\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.661,
                0.955,
                0.692
            ],
            "angle": 0,
            "content": "16. 在六变元布尔函数的卡诺图中，表示 \\(x_{1}\\) 、 \\(\\overline{x}_1x_6\\) 、 \\(\\overline{x}_1x_2\\overline{x}_6\\) 、 \\(x_{2}x_{3}x_{4}x_{5}\\) 和 \\(x_{1}\\) \\(\\overline{x}_2x_4\\overline{x}_5\\) 分别需要多少方格？"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.696,
                0.472,
                0.71
            ],
            "angle": 0,
            "content": "17. a)六变元函数的卡诺图具有多少个方格？"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.714,
                0.805,
                0.728
            ],
            "angle": 0,
            "content": "b)在六变元函数的卡诺图中，对于任意给定的一个方格，有多少个方格与之相邻？"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.731,
                0.955,
                0.781
            ],
            "angle": 0,
            "content": "18. 证明：在五变元布尔函数的卡诺图中，两个极小项恰在一个字面值处不同当且仅当表示这些极小项的方格相邻，或者顶行和底行的方格相邻，第1列和第8列的方格相邻，第1列和第4列，第2列和第7列，第3列和第6列，第5列和第8列的方格相邻。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.784,
                0.955,
                0.834
            ],
            "angle": 0,
            "content": "19. 在六变元布尔函数的 \\(4 \\times 16\\) 卡诺图中，若用格雷码 1111、1110、1010、1011、1001、1000、0000、0001、0011、0010、0110、0111、0101、0100、1100、1101 标记列，用 11、10、00、01 标记行，则哪些行和列应当相邻才可使得恰在一个字面值处不同的极小项的方格相邻？"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.837,
                0.955,
                0.87
            ],
            "angle": 0,
            "content": "* 20. 用卡诺图找出下列函数的极小展开式，使得此展开式具有积之和的形式，这些函数满足其输入为十进制数字的二进制编码，其输出为1当且仅当对应于输入的数为"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.873,
                0.202,
                0.887
            ],
            "angle": 0,
            "content": "a)奇数"
        },
        {
            "type": "text",
            "bbox": [
                0.326,
                0.874,
                0.458,
                0.887
            ],
            "angle": 0,
            "content": "b)不可由3整除"
        },
        {
            "type": "text",
            "bbox": [
                0.522,
                0.874,
                0.657,
                0.887
            ],
            "angle": 0,
            "content": "c) 不是 4、5 或 6"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.89,
                0.955,
                0.923
            ],
            "angle": 0,
            "content": "* 21. 假设一个委员会中有 5 个成员，其中的施密斯和琼斯的投票总与马库斯的投票相反。试用这个投票关系设计一个电路，实现此委员会的多数表决器。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.926,
                0.571,
                0.94
            ],
            "angle": 0,
            "content": "22. 使用奎因-莫可拉斯基法化简例3中的积之和展开式。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.668,
                0.036,
                0.778,
                0.051
            ],
            "angle": 0,
            "content": "布尔代数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.825,
                0.037,
                0.86,
                0.05
            ],
            "angle": 0,
            "content": "743"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.092,
                0.53,
                0.106
            ],
            "angle": 0,
            "content": "23. 使用奎因-莫可拉斯基法化简练习12中的积之和展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.11,
                0.503,
                0.124
            ],
            "angle": 0,
            "content": "24. 使用奎因-莫可拉斯基法化简例 4 中的积之和展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.128,
                0.53,
                0.142
            ],
            "angle": 0,
            "content": "25. 使用奎因-莫可拉斯基法化简练习14中的积之和展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.027,
                0.145,
                0.888,
                0.177
            ],
            "angle": 0,
            "content": "* 26. 试解释怎么用卡诺图方法简化3个变元的和之积展开式。[提示：用0来标记展开式的极大项，然后构造极大项的块。]"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.18,
                0.799,
                0.195
            ],
            "angle": 0,
            "content": "27. 用练习26的方法化简和之积展开式 \\((x + y + z)(x + y + \\overline{z})(x + \\overline{y} + \\overline{z})(x + \\overline{y} + z)(\\overline{x} + y + z)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.027,
                0.198,
                0.503,
                0.212
            ],
            "angle": 0,
            "content": "* 28. 在圆环面上画出4个变元的16个极极小项的卡诺图。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.216,
                0.888,
                0.248
            ],
            "angle": 0,
            "content": "29. 用或门、与门和反相器构造一个电路，使得当输入的十进制数字可以被3整除时输出1，否则输出0。其中输入的十进制数字是二进制编码的十进制展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.251,
                0.832,
                0.266
            ],
            "angle": 0,
            "content": "对于练习 \\(30\\sim 32\\) ，在所给的卡诺图中， \\(d\\) 表示无须在意的条件。试找出它们的极小积之和展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.269,
                0.07,
                0.281
            ],
            "angle": 0,
            "content": "30."
        },
        {
            "type": "image",
            "bbox": [
                0.074,
                0.269,
                0.216,
                0.36
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.306,
                0.27,
                0.331,
                0.281
            ],
            "angle": 0,
            "content": "31."
        },
        {
            "type": "image",
            "bbox": [
                0.336,
                0.269,
                0.48,
                0.36
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.569,
                0.27,
                0.595,
                0.281
            ],
            "angle": 0,
            "content": "32."
        },
        {
            "type": "image",
            "bbox": [
                0.599,
                0.269,
                0.743,
                0.36
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.364,
                0.889,
                0.396
            ],
            "angle": 0,
            "content": "33. 证明：\\(k\\) 个字面值的积对应于 \\(n\\) 立方体 \\(Q_{n}\\) 的 \\(2^{n - k}\\) 维子立方体，其中立方体的顶点对应于标识顶点的比特串表示的极小项，如10.2节例8的描述。"
        },
        {
            "type": "title",
            "bbox": [
                0.043,
                0.411,
                0.231,
                0.43
            ],
            "angle": 0,
            "content": "关键术语和结论"
        },
        {
            "type": "title",
            "bbox": [
                0.043,
                0.439,
                0.091,
                0.455
            ],
            "angle": 0,
            "content": "术语"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.459,
                0.458,
                0.473
            ],
            "angle": 0,
            "content": "布尔变元（Boolean variable）：只取0或1值的变元。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.477,
                0.832,
                0.491
            ],
            "angle": 0,
            "content": "\\(\\overline{x} (x\\) 的补，complement of \\(x\\) ）：一个表达式，当 \\(x\\) 取值0时，它取值1；当 \\(x\\) 取值1时，它取值0。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.495,
                0.889,
                0.526
            ],
            "angle": 0,
            "content": "\\(x \\cdot y\\) (或 \\(xy\\)) (\\(x\\) 与 \\(y\\) 的布尔积或合取，Boolean product or conjunction of \\(x\\) and \\(y\\)): 一个表达式，当 \\(x\\) 和 \\(y\\) 都取值 1 时，它取值 1；否则取值 0。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.53,
                0.888,
                0.561
            ],
            "angle": 0,
            "content": "\\(x + y(x\\) 与 \\(y\\) 的布尔和或析取，Boolean sum or disjunction of \\(x\\) and \\(y)\\) ：一个表达式，当 \\(x\\) 或 \\(y\\) 取值1时，或者当 \\(x\\) 和 \\(y\\) 都取值1时，它取值1；否则取值0。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.565,
                0.889,
                0.598
            ],
            "angle": 0,
            "content": "布尔表达式（Boolean expressions）：如下递归得到的表达式：0，1，\\(x_{1}\\)，\\(\\cdots\\)，\\(x_{n}\\) 是布尔表达式；且如果 \\(E_{1}\\) 和 \\(E_{2}\\) 是布尔表达式，则 \\(\\overline{E_1}\\)、\\((E_1 + E_2)\\) 和 \\((E_1E_2)\\) 也是布尔表达式。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.602,
                0.807,
                0.616
            ],
            "angle": 0,
            "content": "布尔表达式的对偶（dual of a Boolean expression）：通过交换十号和·号、0 和 1 得到的表达式。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.62,
                0.71,
                0.634
            ],
            "angle": 0,
            "content": "\\(n\\) 元布尔函数(Boolean function of degree \\(n\\)): 从 \\(B^n\\) 到 \\(B\\) 的函数, 其中 \\(B = \\{0,1\\}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.637,
                0.889,
                0.669
            ],
            "angle": 0,
            "content": "布尔代数(Boolean algebra)：具有两个二元运算 \\(\\vee\\) 和 \\(\\wedge\\) 、元素0和1、一元补运算-的集合，它满足同一律、补律、结合律、交换律和分配律。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.673,
                0.66,
                0.687
            ],
            "angle": 0,
            "content": "布尔变元 \\(x\\) 的字面值(literal of the Boolean variable \\(x\\)): 或者为 \\(x\\), 或者为 \\(\\overline{x}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.69,
                0.882,
                0.705
            ],
            "angle": 0,
            "content": "\\(x_{1}, x_{2}, \\cdots, x_{n}\\) 的极小项（mintern of \\(x_{1}, x_{2}, \\cdots, x_{n}\\)）：布尔积 \\(y_{1}y_{2}\\cdots y_{n}\\)，其中每个 \\(y_{i}\\) 或为 \\(x_{i}\\) 或为 \\(\\overline{x}_{i}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.708,
                0.889,
                0.739
            ],
            "angle": 0,
            "content": "积之和展开式（或析取范式，sum-of-products expansion or disjunctive normal form）：形如极小项之析取的布尔函数的表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.743,
                0.888,
                0.774
            ],
            "angle": 0,
            "content": "函数完备的(functionally complete)：布尔运算的一个集合称为是函数完备的，如果每个布尔函数都能由这些布尔运算表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.779,
                0.867,
                0.794
            ],
            "angle": 0,
            "content": "\\(x|y\\) (或 \\(x \\text{NAND} y, x|y \\text{ or } x \\text{NAND} y\\)): 一个表达式, 当 \\(x\\) 和 \\(y\\) 都取值 1 时, 它取值 0; 否则取值 1。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.797,
                0.889,
                0.829
            ],
            "angle": 0,
            "content": "\\(x\\downarrow y\\) （或 \\(x\\) NOR \\(y\\) ， \\(x\\downarrow y\\) ，or \\(x\\) NOR \\(y\\) ）：一个表达式，当 \\(x\\) 或 \\(y\\) 取值1时，或 \\(x\\) 和 \\(y\\) 都取值1时，它取值0；否则取值1。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.833,
                0.652,
                0.847
            ],
            "angle": 0,
            "content": "反相器(inverter)：一种装置，它以布尔变元的值作为输入，产生输入的补。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.851,
                0.767,
                0.865
            ],
            "angle": 0,
            "content": "或门(OR gate)：一种装置，它以两个或更多布尔变元的值作为输入，输出它们的布尔和。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.869,
                0.781,
                0.883
            ],
            "angle": 0,
            "content": "与门(AND gate)：一种装置，它以两个或更多布尔变元的值作为输入，输出它们的布尔积。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.887,
                0.762,
                0.9
            ],
            "angle": 0,
            "content": "半加法器（half adder）：一种电路，它将两个二进制数字相加，产生一个和位与一个进位。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.904,
                0.832,
                0.918
            ],
            "angle": 0,
            "content": "全加法器(full adder)：一种电路，它将两个二进制数字及一个进位相加，产生一个和与一个进位。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.922,
                0.889,
                0.936
            ],
            "angle": 0,
            "content": "\\(n\\) 个变元的卡诺图(K-map for \\(n\\) variables)：被分成 \\(2^{n}\\) 多个方格的矩形，每个方格表示这些变元的一个极"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.142,
                0.036,
                0.177,
                0.049
            ],
            "angle": 0,
            "content": "744"
        },
        {
            "type": "header",
            "bbox": [
                0.223,
                0.034,
                0.298,
                0.049
            ],
            "angle": 0,
            "content": "第12章"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.091,
                0.2,
                0.105
            ],
            "angle": 0,
            "content": "小项。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.109,
                0.959,
                0.141
            ],
            "angle": 0,
            "content": "布尔函数的最小化(minimization of a Boolean function)：把布尔函数表示为积之和，其中包含的积最少，而且这些积包含的字面值也最少，是此函数的所有积之和表示中包含字面值最少的。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.143,
                0.959,
                0.176
            ],
            "angle": 0,
            "content": "布尔函数的隐含(implicit of a Boolean function)：满足下述条件的字面值积：如果字面值积为1，那么布尔函数的值为1。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.178,
                0.96,
                0.211
            ],
            "angle": 0,
            "content": "布尔函数的素隐含（prime implicant of a Boolean function）：布尔函数的隐含字面值积，而且删除一个字面值之后得到字面值积不再是此函数的隐含。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.214,
                0.96,
                0.246
            ],
            "angle": 0,
            "content": "布尔函数的本原素隐含(essential prime implicant of a Boolean function)：布尔函数的素隐含，而且必须包括在这个函数的最小化中。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.249,
                0.912,
                0.264
            ],
            "angle": 0,
            "content": "无须在意的条件（don't care condition）：电路的一组输入值，电路中不可能也不会出现这样的输入。"
        },
        {
            "type": "title",
            "bbox": [
                0.114,
                0.275,
                0.163,
                0.291
            ],
            "angle": 0,
            "content": "结论"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.295,
                0.445,
                0.309
            ],
            "angle": 0,
            "content": "布尔代数中的恒等式（见12.1节的表5）。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.312,
                0.848,
                0.327
            ],
            "angle": 0,
            "content": "对于布尔表达式表示的布尔函数间的任意等式，如将等式的两边取对偶，则等式依然成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.331,
                0.443,
                0.345
            ],
            "angle": 0,
            "content": "每个布尔函数都可由积之和展开式表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.348,
                0.43,
                0.362
            ],
            "angle": 0,
            "content": "集合 \\(\\{+, -\\}\\) 和 \\(\\{\\cdot, -\\}\\) 都是函数完备的。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.366,
                0.38,
                0.381
            ],
            "angle": 0,
            "content": "集合 \\(\\{\\downarrow\\}\\) 和 \\(\\{||\\}\\) 都是函数完备的。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.385,
                0.386,
                0.399
            ],
            "angle": 0,
            "content": "使用卡诺图来极小化布尔表达式。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.403,
                0.487,
                0.417
            ],
            "angle": 0,
            "content": "使用奎因-莫可拉斯基法来极小化布尔表达式。"
        },
        {
            "type": "title",
            "bbox": [
                0.116,
                0.432,
                0.199,
                0.451
            ],
            "angle": 0,
            "content": "复习题"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.459,
                0.354,
                0.472
            ],
            "angle": 0,
            "content": "1. 给出 \\( n \\) 元布尔函数的定义。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.476,
                0.338,
                0.489
            ],
            "angle": 0,
            "content": "2. 有多少个2元布尔函数？"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.494,
                0.41,
                0.507
            ],
            "angle": 0,
            "content": "3. 给出布尔表达式集合的递归定义。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.511,
                0.374,
                0.524
            ],
            "angle": 0,
            "content": "4. a) 什么是布尔表达式的对偶？"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.529,
                0.688,
                0.542
            ],
            "angle": 0,
            "content": "b) 什么是对偶原理？怎么应用它找到关于布尔表达式的新的恒等式？"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.546,
                0.521,
                0.559
            ],
            "angle": 0,
            "content": "5. 试解释怎么构造一个布尔函数的积之和展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.564,
                0.577,
                0.577
            ],
            "angle": 0,
            "content": "6. a) “由运算符构成的集合是函数完备的”是什么含义？"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.582,
                0.411,
                0.594
            ],
            "angle": 0,
            "content": "b)集合 \\(\\{+\\) ，·}是函数完备的吗？"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.599,
                0.503,
                0.612
            ],
            "angle": 0,
            "content": "c)有没有单运算符构成的集合是函数完备的？"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.616,
                0.761,
                0.63
            ],
            "angle": 0,
            "content": "7. 试解释怎么用或门、与门和反相器构造一个电路，它用两个开关控制一盏灯。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.635,
                0.485,
                0.648
            ],
            "angle": 0,
            "content": "8. 用或门、与门和反相器构造一个半加法器。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.652,
                0.801,
                0.665
            ],
            "angle": 0,
            "content": "9.是否有这样一种逻辑门，用它可以构造或门、与门和反相器所能构造的所有电路？"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.67,
                0.623,
                0.683
            ],
            "angle": 0,
            "content": "10. a)解释怎么用卡诺图来化简3个布尔变元的积之和展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.687,
                0.652,
                0.702
            ],
            "angle": 0,
            "content": "b) 用卡诺图化简积之和展开式 \\(xyz + x\\overline{y}z + x\\overline{y}\\overline{z} + \\overline{x}yz + \\overline{x}\\overline{y}\\overline{z}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.705,
                0.623,
                0.718
            ],
            "angle": 0,
            "content": "11. a)解释怎么用卡诺图来化简4个布尔变元的积之和展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.722,
                0.394,
                0.735
            ],
            "angle": 0,
            "content": "b)用卡诺图化简积之和展开式"
        },
        {
            "type": "equation",
            "bbox": [
                0.147,
                0.74,
                0.742,
                0.754
            ],
            "angle": 0,
            "content": "\\[\nw x y z + w x y \\bar {z} + w x \\bar {y} z + w x \\bar {y} \\bar {z} + w \\bar {x} y z + w \\bar {x} \\bar {y} z + \\bar {w} x y z + \\bar {w} \\bar {x} y z + \\bar {w} \\bar {x} y \\bar {z}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.758,
                0.367,
                0.771
            ],
            "angle": 0,
            "content": "12. a) 什么是无须在意的条件？"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.774,
                0.965,
                0.807
            ],
            "angle": 0,
            "content": "b) 试解释怎么用无须在意的条件由或门、与门和反相器构造这样一个电路，当十进制数字大于等于6时输出1，当这个数字小于6时输出0。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.81,
                0.632,
                0.824
            ],
            "angle": 0,
            "content": "13. a) 试解释怎么用奎因-莫克拉斯基方法来化简积之和展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.828,
                0.569,
                0.842
            ],
            "angle": 0,
            "content": "b)用这个方法化简 \\(xy\\overline{z} +x\\overline{y}\\overline{z} +\\overline{x} y\\overline{z} +\\overline{x}\\overline{y} z + \\overline{x}\\overline{y}\\overline{z}\\)"
        },
        {
            "type": "title",
            "bbox": [
                0.117,
                0.857,
                0.225,
                0.875
            ],
            "angle": 0,
            "content": "补充练习"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.883,
                0.518,
                0.897
            ],
            "angle": 0,
            "content": "1. 对于布尔变元 \\(x\\) 、 \\(y\\) 和 \\(z\\) 的哪些值使下式成立？"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.901,
                0.278,
                0.915
            ],
            "angle": 0,
            "content": "a) \\(x + y + z = xyz\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.333,
                0.902,
                0.488,
                0.915
            ],
            "angle": 0,
            "content": "b) \\(x(y + z) = x + yz\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.527,
                0.902,
                0.673,
                0.915
            ],
            "angle": 0,
            "content": "c) \\(\\overline{x}\\overline{y}\\overline{z} = x + y + z\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.918,
                0.89,
                0.933
            ],
            "angle": 0,
            "content": "2. 设 \\( x \\) 和 \\( y \\) 属于 \\(\\{0, 1\\}\\) 。如果存在 \\(\\{0, 1\\}\\) 中的值 \\( z \\) 使得下式之一成立，能否得到 \\( x = y \\) 的结论？"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.701,
                0.038,
                0.811,
                0.053
            ],
            "angle": 0,
            "content": "布尔代数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.857,
                0.04,
                0.892,
                0.053
            ],
            "angle": 0,
            "content": "745"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.095,
                0.177,
                0.11
            ],
            "angle": 0,
            "content": "a) \\( xz = yz \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.286,
                0.095,
                0.405,
                0.11
            ],
            "angle": 0,
            "content": "b) \\(x + z = y + z\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.483,
                0.095,
                0.615,
                0.11
            ],
            "angle": 0,
            "content": "c) \\(x\\oplus z = y\\oplus z\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.113,
                0.215,
                0.128
            ],
            "angle": 0,
            "content": "d) \\(x\\downarrow z = y\\downarrow z\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.288,
                0.113,
                0.39,
                0.129
            ],
            "angle": 0,
            "content": "e) \\(x|z = y|z\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.132,
                0.655,
                0.147
            ],
            "angle": 0,
            "content": "布尔函数 \\(F\\) 称为是自对偶的当且仅当 \\(F(x_{1},\\dots ,x_{n}) = \\overline{F(\\overline{x}_{1},\\dots,\\overline{x}_{n})}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.072,
                0.151,
                0.316,
                0.165
            ],
            "angle": 0,
            "content": "3. 下列函数哪些是自对偶的？"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.168,
                0.22,
                0.182
            ],
            "angle": 0,
            "content": "a) \\(F(x,y) = x\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.483,
                0.168,
                0.66,
                0.183
            ],
            "angle": 0,
            "content": "b) \\(F(x,y) = xy + \\overline{x}\\overline{y}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.187,
                0.246,
                0.201
            ],
            "angle": 0,
            "content": "c) \\(F(x,y) = x + y\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.483,
                0.187,
                0.654,
                0.201
            ],
            "angle": 0,
            "content": "d) \\(F(x,y) = xy + \\overline{x} y\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.071,
                0.204,
                0.443,
                0.218
            ],
            "angle": 0,
            "content": "4. 试给出一个三变元自对偶布尔函数的例子。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.222,
                0.39,
                0.236
            ],
            "angle": 0,
            "content": "*5. 有多少个 \\( n \\) 元布尔函数是自对偶的？"
        },
        {
            "type": "text",
            "bbox": [
                0.071,
                0.24,
                0.921,
                0.272
            ],
            "angle": 0,
            "content": "在 \\(n\\) 元布尔函数构成的集合上，定义关系 \\(\\leqslant\\) 使得，\\(F \\leqslant G\\) 当且仅当若 \\(F(x_{1}, x_{2}, \\dots, x_{n}) = 1\\) 就有 \\(G(x_{1}, x_{2}, \\dots, x_{n}) = 1\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.071,
                0.276,
                0.469,
                0.29
            ],
            "angle": 0,
            "content": "6. 对于下列函数对，确定是否有 \\( F \\leqslant G \\) 或 \\( G \\leqslant F \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.294,
                0.367,
                0.309
            ],
            "angle": 0,
            "content": "a) \\(F(x,y) = x\\) ， \\(G(x,y) = x + y\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.483,
                0.294,
                0.763,
                0.309
            ],
            "angle": 0,
            "content": "b) \\(F(x,y) = x + y,G(x,y) = xy\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.312,
                0.367,
                0.327
            ],
            "angle": 0,
            "content": "c) \\(F(x,y) = \\overline{x}\\) ， \\(G(x,y) = x + y\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.072,
                0.33,
                0.375,
                0.343
            ],
            "angle": 0,
            "content": "7. 设 \\(F\\) 和 \\(G\\) 是 \\(n\\) 元布尔函数，证明："
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.347,
                0.195,
                0.361
            ],
            "angle": 0,
            "content": "a) \\(F\\leqslant F + G\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.329,
                0.347,
                0.407,
                0.361
            ],
            "angle": 0,
            "content": "b) \\(FG\\leqslant F\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.071,
                0.365,
                0.731,
                0.379
            ],
            "angle": 0,
            "content": "8. 设 \\(F\\) 、 \\(G\\) 和 \\(H\\) 都是 \\(n\\) 元布尔函数。证明： \\(F + G \\leqslant H\\) 当且仅当 \\(F \\leqslant H\\) 且 \\(G \\leqslant H\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.383,
                0.536,
                0.397
            ],
            "angle": 0,
            "content": "* 9. 证明：≤关系是 \\( n \\) 元布尔函数集合上的一个偏序关系。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.401,
                0.898,
                0.415
            ],
            "angle": 0,
            "content": "* 10. 画出由 16 个 2 元布尔函数（如 12.1 节表 3 所示）组成的集合在偏序 \\(\\leqslant\\) 下的哈斯图（Hasse diagram）。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.419,
                0.748,
                0.433
            ],
            "angle": 0,
            "content": "* 11. 对于下列每个等式，或者证明其为恒等式，或者找到变元的一组值使之不成立。"
        },
        {
            "type": "list",
            "bbox": [
                0.058,
                0.383,
                0.898,
                0.433
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.437,
                0.295,
                0.453
            ],
            "angle": 0,
            "content": "a) \\(x|(y|z) = (x|y)|z\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.457,
                0.364,
                0.471
            ],
            "angle": 0,
            "content": "b) \\(x\\downarrow (y\\downarrow z) = (x\\downarrow y)\\downarrow (x\\downarrow z)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.475,
                0.351,
                0.491
            ],
            "angle": 0,
            "content": "c) \\(x\\downarrow (y|z) = (x\\downarrow y)\\mid (x\\downarrow z)\\)"
        },
        {
            "type": "list",
            "bbox": [
                0.105,
                0.437,
                0.364,
                0.491
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.495,
                0.566,
                0.509
            ],
            "angle": 0,
            "content": "定义布尔运算符 \\(\\odot\\) ： \\(1\\odot 1 = 1\\) ， \\(1\\odot 0 = 0\\) ， \\(0\\odot 1 = 0\\) ， \\(0\\odot 0 = 1\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.074,
                0.513,
                0.283,
                0.527
            ],
            "angle": 0,
            "content": "12. 证明 \\(x \\odot y = xy + \\overline{x} \\overline{y}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.074,
                0.53,
                0.284,
                0.545
            ],
            "angle": 0,
            "content": "13. 证明 \\(x \\odot y = \\overline{(x \\oplus y)}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.074,
                0.548,
                0.284,
                0.562
            ],
            "angle": 0,
            "content": "14. 证明下列各等式成立。"
        },
        {
            "type": "list",
            "bbox": [
                0.074,
                0.513,
                0.284,
                0.562
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.567,
                0.195,
                0.579
            ],
            "angle": 0,
            "content": "a) \\(x\\odot x = 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.329,
                0.567,
                0.417,
                0.579
            ],
            "angle": 0,
            "content": "b) \\(x\\odot \\overline{x} = 0\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.551,
                0.567,
                0.668,
                0.58
            ],
            "angle": 0,
            "content": "c) \\(x\\odot y = y\\odot x\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.074,
                0.584,
                0.397,
                0.598
            ],
            "angle": 0,
            "content": "15. \\((x\\odot y)\\odot z = x\\odot (y\\odot z)\\) 是否总成立？"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.602,
                0.378,
                0.616
            ],
            "angle": 0,
            "content": "* 16. 确定集合 \\(\\{\\odot\\}\\) 是不是函数完备的。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.62,
                0.921,
                0.634
            ],
            "angle": 0,
            "content": "* 17. 在 16 个两变元 \\( x \\) 和 \\( y \\) 的布尔函数中，有多少个能够用下列运算符、变元 \\( x \\) 和 \\( y \\) 以及值 0 和 1 来表示？"
        },
        {
            "type": "list",
            "bbox": [
                0.06,
                0.584,
                0.921,
                0.634
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.638,
                0.159,
                0.652
            ],
            "angle": 0,
            "content": "a）{"
        },
        {
            "type": "text",
            "bbox": [
                0.329,
                0.638,
                0.385,
                0.651
            ],
            "angle": 0,
            "content": "b）{·}"
        },
        {
            "type": "text",
            "bbox": [
                0.551,
                0.638,
                0.605,
                0.651
            ],
            "angle": 0,
            "content": "c）{+}"
        },
        {
            "type": "text",
            "bbox": [
                0.743,
                0.638,
                0.836,
                0.651
            ],
            "angle": 0,
            "content": "d）{·，+}"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.656,
                0.571,
                0.67
            ],
            "angle": 0,
            "content": "异或门(XOR gate)的记号如下，它从 \\(x\\) 和 \\(y\\) 产生输出 \\(x \\oplus y\\)。"
        },
        {
            "type": "image",
            "bbox": [
                0.382,
                0.672,
                0.616,
                0.705
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.074,
                0.708,
                0.34,
                0.722
            ],
            "angle": 0,
            "content": "18. 确定下列电路 a 和 b 的输出。"
        },
        {
            "type": "image",
            "bbox": [
                0.107,
                0.725,
                0.501,
                0.8
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.508,
                0.725,
                0.92,
                0.868
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.87,
                0.921,
                0.903
            ],
            "angle": 0,
            "content": "19. 如果除了或门、与门和反相器之外，还可以使用异或门，说明怎么用比 12.3 节图 8 中所用的更少的门来构造一个半加法器。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.906,
                0.922,
                0.938
            ],
            "angle": 0,
            "content": "20. 试设计一个电路来确定，在一个四人委员会中，是否有三人或更多的人就某事投了赞成票，其中的每个人用一个开关来投票。"
        },
        {
            "type": "list",
            "bbox": [
                0.073,
                0.87,
                0.922,
                0.938
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.122,
                0.037,
                0.159,
                0.052
            ],
            "angle": 0,
            "content": "746"
        },
        {
            "type": "header",
            "bbox": [
                0.204,
                0.036,
                0.28,
                0.052
            ],
            "angle": 0,
            "content": "第12章"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.093,
                0.942,
                0.16
            ],
            "angle": 0,
            "content": "给定布尔变元 \\(x_{1}\\) ， \\(x_{2}\\) ，…， \\(x_{n}\\) 的一组输入值，阈值门产生输出 \\(y\\) ，其中 \\(y\\) 为0或1。每个阈值门都有一个阈值 \\(T\\) 以及一组权 \\(\\omega_{1},\\omega_{2},\\dots ,\\omega_{n}\\) ，其中 \\(T\\) 和 \\(\\omega_{1},\\omega_{2},\\dots ,\\omega_{n}\\) 都是实数。阈值门的输出 \\(y\\) 是1当且仅当 \\(\\omega_{1}x_{1} + \\omega_{2}x_{2} + \\dots +\\omega_{n}x_{n}\\geqslant T\\) 。具有阈值 \\(T\\) 和权 \\(\\omega_{1},\\omega_{2},\\dots ,\\omega_{n}\\) 的阈值门如下图所示。阈值门对于神经生理学和人工智能的建模都非常有用。"
        },
        {
            "type": "image",
            "bbox": [
                0.371,
                0.164,
                0.667,
                0.312
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.314,
                0.79,
                0.33
            ],
            "angle": 0,
            "content": "21. 阈值门表示了一个布尔函数。试找出由下面阈值门表示的布尔函数的布尔表达式。"
        },
        {
            "type": "image",
            "bbox": [
                0.367,
                0.332,
                0.675,
                0.445
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.448,
                0.77,
                0.464
            ],
            "angle": 0,
            "content": "22. 能够由阈值门表示的布尔函数称为阈值函数。证明下列每个函数都是阈值函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.467,
                0.223,
                0.481
            ],
            "angle": 0,
            "content": "a) \\(F(x) = \\overline{x}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.349,
                0.467,
                0.501,
                0.481
            ],
            "angle": 0,
            "content": "b) \\(F(x,y) = x + y\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.591,
                0.467,
                0.721,
                0.481
            ],
            "angle": 0,
            "content": "c) \\(F(x,y) = xy\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.485,
                0.28,
                0.499
            ],
            "angle": 0,
            "content": "d) \\(F(x,y) = x\\mid y\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.349,
                0.485,
                0.5,
                0.499
            ],
            "angle": 0,
            "content": "e) \\(F(x,y) = x\\downarrow y\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.591,
                0.485,
                0.774,
                0.499
            ],
            "angle": 0,
            "content": "f) \\(F(x,y,z) = x + yz\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.503,
                0.379,
                0.517
            ],
            "angle": 0,
            "content": "g)F(w，x，y，z）=w+xy+z"
        },
        {
            "type": "text",
            "bbox": [
                0.591,
                0.503,
                0.835,
                0.517
            ],
            "angle": 0,
            "content": "h) \\(F(w,x,y,z) = wxz + x\\bar{y}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.52,
                0.451,
                0.535
            ],
            "angle": 0,
            "content": "* 23. 证明: \\( F(x, y) = x \\oplus y \\) 不是阈值函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.537,
                0.523,
                0.552
            ],
            "angle": 0,
            "content": "* 24. 证明: \\( F(w, x, y, z) = wx + yz \\) 不是阈值函数。"
        },
        {
            "type": "list",
            "bbox": [
                0.081,
                0.52,
                0.523,
                0.552
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.097,
                0.567,
                0.232,
                0.586
            ],
            "angle": 0,
            "content": "计算机课题"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.593,
                0.333,
                0.608
            ],
            "angle": 0,
            "content": "按给定的输入和输出写程序。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.612,
                0.742,
                0.627
            ],
            "angle": 0,
            "content": "1. 给定两个布尔变元 \\(x\\) 和 \\(y\\) 的值，计算 \\(x + y, xy, x \\oplus y, x \\mid y\\) 和 \\(x \\downarrow y\\) 的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.631,
                0.521,
                0.645
            ],
            "angle": 0,
            "content": "2.构造一个表，列出所有256个3元布尔函数的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.649,
                0.798,
                0.663
            ],
            "angle": 0,
            "content": "3. 给定一个 \\(n\\) 元布尔函数的所有值，其中 \\(n\\) 是正整数，构造这个函数的积之和展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.666,
                0.609,
                0.68
            ],
            "angle": 0,
            "content": "4. 给定一个布尔函数值的列表，只用运算·和表示这个函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.684,
                0.609,
                0.698
            ],
            "angle": 0,
            "content": "5. 给定一个布尔函数值的列表，只用运算 \\(+\\) 和 \\(-\\) 表示这个函数。"
        },
        {
            "type": "list",
            "bbox": [
                0.094,
                0.612,
                0.798,
                0.698
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.703,
                0.571,
                0.717
            ],
            "angle": 0,
            "content": "*6. 给定一个布尔函数值的列表，只用运算 | 表示这个函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.722,
                0.576,
                0.736
            ],
            "angle": 0,
            "content": "*7. 给定一个布尔函数值的列表，只用运算 \\(\\downarrow\\) 表示这个函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.74,
                0.54,
                0.754
            ],
            "angle": 0,
            "content": "8. 给定一个3元布尔函数值的列表，构造它的卡诺图。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.757,
                0.54,
                0.771
            ],
            "angle": 0,
            "content": "9. 给定一个 4 元布尔函数值的列表，构造它的卡诺图。"
        },
        {
            "type": "list",
            "bbox": [
                0.094,
                0.74,
                0.54,
                0.771
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.07,
                0.775,
                0.836,
                0.789
            ],
            "angle": 0,
            "content": "**10. 给定一个布尔函数值的列表，用奎因-莫可拉斯基方法寻找这个函数的极小积之和表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.793,
                0.882,
                0.807
            ],
            "angle": 0,
            "content": "11. 对于一个阈值门和 \\( n \\) 个布尔变元的值作为输入，给定它的阈值和一组权，确定这个门的输出。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.811,
                0.661,
                0.825
            ],
            "angle": 0,
            "content": "12. 给定一个正整数，构造一个 \\(n\\) 元随机布尔表达式，且为析取范式。"
        },
        {
            "type": "list",
            "bbox": [
                0.095,
                0.793,
                0.882,
                0.825
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.097,
                0.84,
                0.232,
                0.859
            ],
            "angle": 0,
            "content": "计算和探索"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.866,
                0.519,
                0.881
            ],
            "angle": 0,
            "content": "用一个计算程序或你自己编写的程序做下列的练习。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.884,
                0.428,
                0.898
            ],
            "angle": 0,
            "content": "1. 计算7、8、9、10元布尔函数的个数。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.902,
                0.317,
                0.916
            ],
            "angle": 0,
            "content": "2.构造3元布尔函数的表。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.92,
                0.317,
                0.934
            ],
            "angle": 0,
            "content": "3.构造4元布尔函数的表。"
        },
        {
            "type": "list",
            "bbox": [
                0.096,
                0.884,
                0.428,
                0.934
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.685,
                0.037,
                0.796,
                0.052
            ],
            "angle": 0,
            "content": "布尔代数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.842,
                0.037,
                0.879,
                0.05
            ],
            "angle": 0,
            "content": "747"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.093,
                0.906,
                0.125
            ],
            "angle": 0,
            "content": "4. 将每个不同的三元布尔表达式表示成仅含与非运算符的析取范式，所使用的与非运算符越少越好。所需与非运算符的最大数量是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.128,
                0.906,
                0.16
            ],
            "angle": 0,
            "content": "5. 将每个不同的布尔表达式表示成含有 4 个变元和仅含或非运算符的析取范式，所使用的或非运算符越少越好。所需或非运算符的最大数量是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.164,
                0.906,
                0.196
            ],
            "angle": 0,
            "content": "6.随机生成10个不同的四变元布尔表达式，判断使用奎因-莫可拉斯基方法简化它们所需的平均步骤数。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.199,
                0.906,
                0.232
            ],
            "angle": 0,
            "content": "7. 随机生成10个不同的五变元布尔表达式，判断使用奎因-莫可拉斯基方法简化它们所需的平均步骤数。"
        },
        {
            "type": "list",
            "bbox": [
                0.057,
                0.093,
                0.906,
                0.232
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.06,
                0.246,
                0.17,
                0.266
            ],
            "angle": 0,
            "content": "写作课题"
        },
        {
            "type": "title",
            "bbox": [
                0.059,
                0.273,
                0.407,
                0.287
            ],
            "angle": 0,
            "content": "用本教材以外的资料按下列要求写成论文。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.291,
                0.906,
                0.323
            ],
            "angle": 0,
            "content": "1. 描述一些早期设计的、用来解逻辑问题的机器，如印刷示范器（Stanhope Demonstrator）、杰文(Jevons)的逻辑机以及马昆德机器(Marquand Machine)。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.326,
                0.708,
                0.34
            ],
            "angle": 0,
            "content": "2. 解释组合电路与顺序电路之间的差别，然后解释怎么用触发器构造顺序电路。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.344,
                0.835,
                0.358
            ],
            "angle": 0,
            "content": "3. 定义移位寄存器，且讨论怎么使用移位寄存器。说明怎么用触发器和逻辑门构造移位寄存器。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.362,
                0.336,
                0.375
            ],
            "angle": 0,
            "content": "4. 说明怎么用逻辑门构造乘法器。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.379,
                0.687,
                0.393
            ],
            "angle": 0,
            "content": "5. 找出逻辑门的物理构造。讨论在构造电路时，是否要用到与非门和或非门。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.397,
                0.447,
                0.411
            ],
            "angle": 0,
            "content": "6. 解释怎么用相关性记号描述复杂的开关电路。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.415,
                0.354,
                0.429
            ],
            "angle": 0,
            "content": "7. 描述怎么用乘法器构造开关电路。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.433,
                0.724,
                0.447
            ],
            "angle": 0,
            "content": "8. 以用阈值门构造半加法器和全加法器为例，解释用阈值门构造开关电路的优点。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.451,
                0.595,
                0.464
            ],
            "angle": 0,
            "content": "9. 描述无危险开关电路的概念，并给出一些设计这种电路的原则。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.468,
                0.401,
                0.482
            ],
            "angle": 0,
            "content": "10. 解释怎么用卡诺图将六元函数极小化。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.486,
                0.906,
                0.518
            ],
            "angle": 0,
            "content": "11. 讨论用于极小化布尔函数的新方法（如Espresso方法）的思想。解释怎么用这些方法来解决高达25元的布尔函数最小化问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.521,
                0.826,
                0.535
            ],
            "angle": 0,
            "content": "12. 描述 \\( n \\) 元布尔函数的函数分解的含义。讨论将布尔函数分解为元数更少的布尔函数的过程。"
        },
        {
            "type": "list",
            "bbox": [
                0.058,
                0.291,
                0.906,
                0.535
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.108,
                0.092,
                0.195,
                0.11
            ],
            "angle": 0,
            "content": "第13章"
        },
        {
            "type": "header",
            "bbox": [
                0.107,
                0.115,
                0.397,
                0.127
            ],
            "angle": 0,
            "content": "Discrete Mathematics and Its Applications, 8E"
        },
        {
            "type": "title",
            "bbox": [
                0.101,
                0.136,
                0.283,
                0.163
            ],
            "angle": 0,
            "content": "计算模型"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.212,
                0.945,
                0.267
            ],
            "angle": 0,
            "content": "计算机能够执行许多任务。提出一个任务后就存在两个问题：第一，它能否由计算机来完成？一旦知道这个问题的答案是肯定的，就会问第二个问题，怎么执行这个任务？计算模型就是用来帮助回答这两个问题的。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.269,
                0.945,
                0.362
            ],
            "angle": 0,
            "content": "下面将讨论三种类型的计算模型：文法、有限状态机和图灵机。文法是用来产生一种语言中的词，并且确定一个词是否属于一个语言。文法产生的形式语言不仅可以作为自然语言的模型，如英语，还可以作为程序设计语言的模型，如Pascal、Fortran、Prolog、C和Java。特别是，文法在编译器的理论和构造中极为重要。在20世纪50年代，美国语言学家诺姆·乔姆斯基(Noam Chomsky)首先使用了下面将要讨论的文法。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.363,
                0.945,
                0.515
            ],
            "angle": 0,
            "content": "在建模中，使用着各种类型的有限状态机。每个有限状态机都有一个状态集合（包含初始状态）和一个输入字母表，还有一个转移函数（它对每个由状态和输入构成的对，指定下一个状态）。有限状态机的状态使得它具有有限的存储能力。有些有限状态机对每个转移产生一个输出符号。这类机器可以用作许多种机器的模型，如自动售货机、延迟机、二进制数加法器和语言识别器。我们还将讨论没有输出但具有终结状态的有限状态机，这样的机器广泛用于语言的识别，它们所识别的字符串是能使自动机从初始状态运行到终结状态的字符串。文法和有限状态机的概念具有紧密的联系，我们将要刻画有限状态机所能识别的集合的特征，并且证明这些集合恰恰就是某种类型文法所产生的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.516,
                0.945,
                0.59
            ],
            "angle": 0,
            "content": "最后将介绍图灵机的概念。我们将说明怎么用图灵机来识别集合，还要说明怎么用图灵机来计算数论函数。最后讨论丘奇-图灵理论：每个有效的计算都可由图灵机来完成。我们将解释如何使用图灵机研究求解某类问题的难度，特别是我们将描述如何使用图灵机将问题分类成理论可实现的和不可实现的，以及可解的和不可解的。"
        },
        {
            "type": "title",
            "bbox": [
                0.101,
                0.605,
                0.312,
                0.624
            ],
            "angle": 0,
            "content": "13.1 语言和文法"
        },
        {
            "type": "title",
            "bbox": [
                0.101,
                0.633,
                0.235,
                0.649
            ],
            "angle": 0,
            "content": "13.1.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.652,
                0.945,
                0.782
            ],
            "angle": 0,
            "content": "英语中，单词能以各种方式进行组合，单词的哪些组合可以构成有效的句子是由英语的语法确定的。例如：the frog writes neatly(青蛙的字写得很匀称)是一个有效的句子，因为它是由一个名词短语 the frog 接一个动词短语 writes neatly 构成的，其中名词短语 the frog 是由冠词 the 和名词 frog 组成的，动词短语 writes neatly 是由动词 writes 和副词 neatly 组成的。我们并不在意这是一个毫无意义的句子，因为我们只关心句子的语法，或者说形式，而不在意它的语义，或者说含义。我们也要指出，词的组合 swims quickly mathematics 不是有效的句子，因为它不符合英语的语法规则。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.784,
                0.945,
                0.859
            ],
            "angle": 0,
            "content": "自然语言（即口语），如英语、法语、德语或西班牙语，都极为复杂。事实上，对于一种自然语言，看起来不大可能说出它的所有语法规则。将一种语言自动翻译成另一种语言的研究引出了形式语言的概念。与自然语言不同，形式语言是由一组意义明确的语法规则定义的，语法规则不仅对于语言学和自然语言的研究十分重要，而且对于程序设计语言的研究也很重要。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.86,
                0.945,
                0.935
            ],
            "angle": 0,
            "content": "我们要用文法描述形式语言的句子。在程序设计语言的应用中，经常出现两类问题：1)怎么能够确定一组单词是否组合成了形式语言的一个有效句子？2)怎么才能产生形式语言的一个有效句子。使用文法可以帮助求解这两类问题。在给出文法的技术定义之前，先描述文法的一个例子，这个例子产生英语的一个子集。此英语子集是用下列规则定义的，这些规则描述怎么"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.698,
                0.035,
                0.811,
                0.051
            ],
            "angle": 0,
            "content": "计算模型"
        },
        {
            "type": "page_number",
            "bbox": [
                0.856,
                0.037,
                0.892,
                0.05
            ],
            "angle": 0,
            "content": "749"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.092,
                0.352,
                0.108
            ],
            "angle": 0,
            "content": "产生有效的句子。这些规则是："
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.112,
                0.577,
                0.125
            ],
            "angle": 0,
            "content": "1)句子是由一个名词短语后接一个动词短语形成的；"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.131,
                0.668,
                0.144
            ],
            "angle": 0,
            "content": "2)名词短语由一个冠词接一个形容词再接一个名词组成，或者"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.15,
                0.475,
                0.163
            ],
            "angle": 0,
            "content": "3)名词短语由一个冠词接一个名词组成；"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.169,
                0.526,
                0.182
            ],
            "angle": 0,
            "content": "4)动词短语由一个动词接一个副词组成，或者"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.188,
                0.372,
                0.201
            ],
            "angle": 0,
            "content": "5)动词短语由一个动词组成："
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.208,
                0.274,
                0.22
            ],
            "angle": 0,
            "content": "6)冠词是a，或者"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.227,
                0.24,
                0.24
            ],
            "angle": 0,
            "content": "7)冠词是 the;"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.246,
                0.327,
                0.259
            ],
            "angle": 0,
            "content": "8)形容词是 large, 或者"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.265,
                0.294,
                0.278
            ],
            "angle": 0,
            "content": "9)形容词是 hungry;"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.284,
                0.326,
                0.297
            ],
            "angle": 0,
            "content": "10)名词是 rabbit, 或者"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.304,
                0.345,
                0.316
            ],
            "angle": 0,
            "content": "11)名词是 mathematician;"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.323,
                0.308,
                0.335
            ],
            "angle": 0,
            "content": "12)动词是 eats, 或者"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.342,
                0.263,
                0.355
            ],
            "angle": 0,
            "content": "13)动词是 hops;"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.361,
                0.335,
                0.374
            ],
            "angle": 0,
            "content": "14)副词是quickly，或者"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.38,
                0.276,
                0.392
            ],
            "angle": 0,
            "content": "15)副词是 wildly。"
        },
        {
            "type": "list",
            "bbox": [
                0.111,
                0.112,
                0.668,
                0.392
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.398,
                0.922,
                0.434
            ],
            "angle": 0,
            "content": "从这些规则出发，使用一系列替代直到不能再应用规则，就能形成一个有效的句子。例如，沿着下列替代序列就能得到一个有效句子："
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.438,
                0.16,
                0.452
            ],
            "angle": 0,
            "content": "句子"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.457,
                0.302,
                0.469
            ],
            "angle": 0,
            "content": "名词短语 动词短语"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.476,
                0.405,
                0.489
            ],
            "angle": 0,
            "content": "冠词 形容词 名词 动词短语"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.495,
                0.425,
                0.508
            ],
            "angle": 0,
            "content": "冠词 形容词 名词 动词 副词"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.514,
                0.395,
                0.527
            ],
            "angle": 0,
            "content": "the形容词 名词 动词 副词"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.533,
                0.362,
                0.546
            ],
            "angle": 0,
            "content": "the large 名词 动词 副词"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.553,
                0.338,
                0.565
            ],
            "angle": 0,
            "content": "the large rabbit 动词副词"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.572,
                0.343,
                0.584
            ],
            "angle": 0,
            "content": "the large rabbit hops 副词"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.591,
                0.367,
                0.604
            ],
            "angle": 0,
            "content": "the large rabbit hops quickly"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.609,
                0.922,
                0.644
            ],
            "angle": 0,
            "content": "容易看出，其他的有效句子是：a hungry mathematician eats wildly, a large mathematician hops, the rabbit eats quickly 等。也可以看出，the quickly eats mathematican 不是有效句子。"
        },
        {
            "type": "title",
            "bbox": [
                0.076,
                0.656,
                0.304,
                0.672
            ],
            "angle": 0,
            "content": "13.1.2 短语结构文法"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.676,
                0.56,
                0.692
            ],
            "angle": 0,
            "content": "在给出文法的形式定义之前，先引入一个小术语。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.701,
                0.912,
                0.756
            ],
            "angle": 0,
            "content": "定义1 词汇表(或字母表) \\(V\\) 是由称为符号的元素构成的一个有限的非空集合。 \\(V\\) 上的一个词(或句子)是由 \\(V\\) 中元素组成的有限长度的字符串。空串(或零串)是不包含任何符号的字符串，记为 \\(\\lambda\\) 。 \\(V\\) 上所有词的集合记为 \\(V^{*}\\) 。 \\(V\\) 上的一个语言是 \\(V^{*}\\) 的一个子集。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.766,
                0.922,
                0.802
            ],
            "angle": 0,
            "content": "注意，空串 \\(\\lambda\\) 是不包含任何符号的串。它不同于空集 \\(\\varnothing\\) 。因此 \\(\\{\\lambda\\}\\) 是仅包含一个字符串的集合，此字符串为空串。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.805,
                0.924,
                0.936
            ],
            "angle": 0,
            "content": "可以用多种方式来定义语言。一种方式是列出语言中的所有词；还有一种方式是给出一些标准，使得在这个语言中的每个词，都必须满足这些标准。本节将描述另一种定义语言的重要方式：使用文法，如使用本节引言中给出的规则集合。为了产生词，文法提供一个由各种类型符号组成的集合和一个由规则组成的集合。更确切地说，文法有一个词汇表 \\(V\\) ， \\(V\\) 是一个由符号组成的集合，语言中的成分就是由这些符号导出的。词汇表中的某些元素不能由其他符号替换，这些元素称为终结符；词汇表中的其他元素可以用其他符号替换，它们称为非终结符。终结符和非终结符集合通常分别记为 \\(T\\) 和 \\(N\\) 。在本节引言所给的例子中，终结符集是{a，the,"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.109,
                0.037,
                0.146,
                0.051
            ],
            "angle": 0,
            "content": "750"
        },
        {
            "type": "header",
            "bbox": [
                0.19,
                0.036,
                0.267,
                0.051
            ],
            "angle": 0,
            "content": "第13章"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.092,
                0.932,
                0.224
            ],
            "angle": 0,
            "content": "rabbit, mathematician, hops, eats, quickly, wildly}, 非终结符集是{句子, 名词短语, 动词短语, 形容词, 冠词, 名词, 动词, 副词}。词汇表中有一个称为起始符的特殊元素, 记为 \\(S\\), 我们总是从这个特殊元素开始定义其他符号。在引言的例子中, 起始符是句子。由词汇表 \\(V\\) 中元素构成的所有串的集合记为 \\(V^{*}\\), 指明 \\(V^{*}\\) 中的字符串能被什么样的字符串替代的规则称为文法的产生式, 指明 \\(z_{0}\\) 可以替换为 \\(z_{1}\\) 的产生式记为 \\(z_{0} \\rightarrow z_{1}\\) 。在本节引言所给的文法中, 我们列举了所有产生式。使用刚才定义的记号, 其中第一个产生式为句子 \\(\\rightarrow\\) 名词短语动词短语。我们在定义2中总结这些术语。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.23,
                0.926,
                0.288
            ],
            "angle": 0,
            "content": "定义2 一个短语结构文法 \\(G = (V, T, S, P)\\) 由下列四部分组成：词汇表 \\(V\\)，由 \\(V\\) 的所有终结符组成的 \\(V\\) 的子集 \\(T\\)，\\(V\\) 的起始符 \\(S\\)，以及产生式集合 \\(P\\)。集合 \\(V - T\\) 记为 \\(N\\)，\\(N\\) 中的元素称为非终结符。\\(P\\) 中的每个产生式的左边必须至少包含一个非终结符。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.298,
                0.931,
                0.337
            ],
            "angle": 0,
            "content": "例1设 \\(G = (V,T,S,P)\\) ，其中 \\(V = \\{a,b,A,B,S\\}\\) ， \\(T = \\{a,b\\}\\) ， \\(S\\) 是起始符， \\(P =\\) \\(\\{S\\to ABA,a\\to BB,B\\to ab,AB\\to b\\}\\) 。则 \\(G\\) 是一个短语结构文法的例子。"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.341,
                0.571,
                0.356
            ],
            "angle": 0,
            "content": "我们对短语结构文法的产生式所产生的词感兴趣。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.365,
                0.926,
                0.449
            ],
            "angle": 0,
            "content": "定义3设 \\(G = (V,T,S,P)\\) 是一个短语结构文法， \\(\\omega_0 = lz_0r\\) （即 \\(l\\) 、 \\(z_{0}\\) 和 \\(r\\) 的连接）和\\(\\varpi_{1} = lz_{1}r\\) 是 \\(V\\) 上的字符串。若 \\(z_0\\rightarrow z_1\\) 是 \\(G\\) 的一个产生式，则称由 \\(\\mathfrak{w}_0\\) 可直接派生 \\(\\varpi_{1}\\) ，记为 \\(\\varpi_0\\) \\(\\Rightarrow w_{1}\\) 。如果 \\(V\\) 上的字符串 \\(\\varpi_0\\) ， \\(\\varpi_{1}\\) ，…， \\(\\varpi_{n}(n\\geqslant 0)\\) 满足 \\(\\varpi_0\\Rightarrow \\varpi_1\\) ， \\(\\varpi_{1}\\Rightarrow \\varpi_{2}\\) ，…， \\(\\varpi_{n - 1}\\Rightarrow \\varpi_n\\) 则称由 \\(\\varpi_0\\) 可派生 \\(\\varpi_{n}\\) ，记为 \\(\\varpi_0\\Rightarrow \\varpi_n\\) 。由 \\(\\varpi_0\\) 得到 \\(\\varpi_{n}\\) 的序列称为派生。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.46,
                0.932,
                0.519
            ],
            "angle": 0,
            "content": "例2 在例1的文法中，由字符串 \\(ABa\\) 可直接派生 \\(Aaba\\) ，因为 \\(B \\rightarrow ab\\) 是此文法中的一个产生式。由字符串 \\(ABa\\) 可派生 \\(abababa\\) ，因为接连使用产生式 \\(B \\rightarrow ab\\) 、 \\(A \\rightarrow BB\\) 、 \\(B \\rightarrow ab\\) 和 \\(B \\rightarrow ab\\) ，可得"
        },
        {
            "type": "equation",
            "bbox": [
                0.328,
                0.521,
                0.688,
                0.537
            ],
            "angle": 0,
            "content": "\\[\nA B a \\Rightarrow A a b a \\Rightarrow B B a b a \\Rightarrow B a b a b a \\Rightarrow a b a b a b a\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.546,
                0.922,
                0.583
            ],
            "angle": 0,
            "content": "定义4 设 \\(G = (V, T, S, P)\\) 是短语结构文法，由 \\(G\\) 生成的语言（或 \\(G\\) 的语言）是起始符 \\(S\\) 能够派生的所有终结符串构成的集合，记为 \\(L(G)\\) 。即"
        },
        {
            "type": "equation",
            "bbox": [
                0.398,
                0.587,
                0.617,
                0.605
            ],
            "angle": 0,
            "content": "\\[\nL (G) = \\{w \\in T ^ {*} \\mid S \\stackrel {\\bullet} {\\Rightarrow} w \\}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.614,
                0.633,
                0.631
            ],
            "angle": 0,
            "content": "在例3和例4中，我们寻找短语结构文法所生成的语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.636,
                0.932,
                0.674
            ],
            "angle": 0,
            "content": "例3设 \\(G\\) 是一个文法，其词汇表为 \\(V = \\{S,A,a,b\\}\\) ，终结符集 \\(T = \\{a,b\\}\\) ，起始符为\\(S\\) ，产生式为 \\(P = \\{S\\to aA,S\\to b,A\\to aa\\}\\) 。求这个文法产生的语言 \\(L(G)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.677,
                0.934,
                0.713
            ],
            "angle": 0,
            "content": "解 使用产生式 \\( S \\rightarrow aA \\)，可以从起始符 \\( S \\) 派生 \\( aA \\)，还可用产生式 \\( S \\rightarrow b \\) 派生 \\( b \\) 。使用产生式 \\( A \\rightarrow aa \\)，可以从 \\( aA \\) 派生 \\( aaa \\) 。没有其他的词还能派生，故 \\( L(G) = \\{b, aaa\\} \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.718,
                0.932,
                0.757
            ],
            "angle": 0,
            "content": "例4设 \\(G\\) 是一个文法，其词汇表为 \\(V = \\{S,0,1\\}\\) ，终结符集 \\(T = \\{0,1\\}\\) ，起始符为 \\(S\\) 产生式为 \\(P = \\{S\\to 11S,S\\to 0\\}\\) 。求这个文法产生的语言 \\(L(G)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.759,
                0.934,
                0.871
            ],
            "angle": 0,
            "content": "解分别使用 \\(S\\rightarrow 0\\) 和 \\(S\\rightarrow 11S\\) ，可以从 \\(S\\) 派生出0和 \\(11S_{\\circ}\\) 从11S可以派生出110和\\(1111S_{\\circ}\\) 从1111S可以派生出11110和111111S。在派生过程的每一步，或者在串的末尾加两个1，或者在串的末尾加0后终止派生。总之， \\(L(G) = \\{0,110,11110,111110,\\dots \\}\\) ，即\\(L(G)\\) 是如下串的集合；开始是偶数个1，最后是一个0。这个结论可用如下的归纳假设证明：使用 \\(n\\) 次产生式之后，所生成的终结符串只能是这样的字符串：先是 \\(n - 1\\) 个11的连接，后面跟一个0（留作练习）。"
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.874,
                0.934,
                0.91
            ],
            "angle": 0,
            "content": "经常出现的问题是要构造一个文法来生成一个给定的语言。例5、例6和例7描述这类问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.914,
                0.715,
                0.932
            ],
            "angle": 0,
            "content": "例5 给出生成集合 \\(\\{0^n 1^n | n = 0, 1, 2, \\dots\\}\\) 的一个短语结构文法。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.701,
                0.037,
                0.811,
                0.053
            ],
            "angle": 0,
            "content": "计算模型"
        },
        {
            "type": "page_number",
            "bbox": [
                0.858,
                0.038,
                0.892,
                0.052
            ],
            "angle": 0,
            "content": "751"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.093,
                0.924,
                0.168
            ],
            "angle": 0,
            "content": "解此集合中的元素是这样的字符串：先是一串0，后跟含同样多个1的串。可以用两个产生式来生成所有这些字符串（包括空串），第一个产生式对语言中的字符串不断地产生更长的字符串，方法是在字符串前面加一个0，末尾加一个1；第二个产生式以空串来替代 \\(S\\) 。所求的文法是 \\(G = (V, T, S, P)\\) ，其中 \\(V = \\{0, 1, S\\}\\) ，终结符集 \\(T = \\{0, 1\\}\\) ，起始符为 \\(S\\) ，产生式为"
        },
        {
            "type": "equation",
            "bbox": [
                0.463,
                0.171,
                0.531,
                0.185
            ],
            "angle": 0,
            "content": "\\[\nS \\rightarrow 0 S 1\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.464,
                0.19,
                0.51,
                0.204
            ],
            "angle": 0,
            "content": "\\[\nS \\rightarrow \\lambda\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.208,
                0.581,
                0.224
            ],
            "angle": 0,
            "content": "此文法能够生成所给集合的证明作为练习留给读者。"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.227,
                0.923,
                0.263
            ],
            "angle": 0,
            "content": "例5讨论的是如下字符串的集合：前面是一串0，后面跟一串1，其中0的个数和1的个数相同。例6还是讨论这样的串，但0的个数与1的个数不一定相同。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.268,
                0.725,
                0.286
            ],
            "angle": 0,
            "content": "例6 给出生成集合 \\(\\{0^m 1^n | m\\) 和 \\(n\\) 为非负整数\\}的一个短语结构文法。"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.291,
                0.923,
                0.327
            ],
            "angle": 0,
            "content": "解下面构造生成这个集合的两个文法 \\(G_{1}\\) 和 \\(G_{2}\\) 。这也说明两个文法可能生成相同的语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.075,
                0.33,
                0.924,
                0.384
            ],
            "angle": 0,
            "content": "文法 \\(G_{1}\\) 的字母表 \\(V = \\{S,0,1\\}\\)，终结符集 \\(T = \\{0,1\\}\\)，产生式为 \\(S\\rightarrow 0S\\)、\\(S\\rightarrow S1\\) 和 \\(S\\rightarrow \\lambda\\)。\\(G_{1}\\) 能生成所给集合，因为应用第一个产生式 \\(m\\) 次就在字符串的前面增加了 \\(m\\) 个0，应用第二个产生式 \\(n\\) 次就在字符串的后增加了 \\(n\\) 个1。详细证明留给读者。"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.387,
                0.923,
                0.423
            ],
            "angle": 0,
            "content": "文法 \\(G_{2}\\) 的字母表 \\(V = \\{S, A, 0, 1\\}\\)，终结符集 \\(T = \\{0, 1\\}\\)，产生式为 \\(S \\rightarrow 0S\\)、\\(S \\rightarrow 1A\\)、\\(S \\rightarrow 1\\)、\\(A \\rightarrow 1A\\)、\\(A \\rightarrow 1\\) 和 \\(S \\rightarrow \\lambda\\)。该文法也能生成所给集合的详细证明留作练习。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.425,
                0.916,
                0.443
            ],
            "angle": 0,
            "content": "有时候，一些很容易描述的集合不得不用非常复杂的文法来生成，例7就是这样一个例子。"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.447,
                0.924,
                0.544
            ],
            "angle": 0,
            "content": "例7 生成集合 \\(\\{0^n1^n2^n\\mid n = 0,1,2,3,\\dots \\}\\) 的一个文法是： \\(G = \\{V,T,S,P\\}\\) ，其中 \\(V =\\) \\(\\{0,1,2,S,A,B,C\\}\\) ，终结符集 \\(T = \\{0,1,2\\}\\) ，起始符为 \\(S\\) ，产生式有 \\(S\\rightarrow C\\) 、 \\(C\\rightarrow 0CAB\\) 产\\(S\\to \\lambda ,BA\\to AB,0A\\to 01,1A\\to 11,1B\\to 12,2B\\to 22.\\) 。此命题的正确性证明留给读者作为练习（见练习12）。在某种意义下，此文法是生成这个语言的最简单类型的文法，在本节后面部分会讲清楚。"
        },
        {
            "type": "title",
            "bbox": [
                0.078,
                0.554,
                0.373,
                0.572
            ],
            "angle": 0,
            "content": "13.1.3 短语结构文法的类型"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.574,
                0.924,
                0.629
            ],
            "angle": 0,
            "content": "短语结构文法可以根据其产生式的类型来分类。下面我们来描述诺姆·乔姆斯基引入的分类方法。在13.4节将会看到，以这种方法定义的不同语言类型与不同的计算机器模型识别的语言类相对应。"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.632,
                0.924,
                0.745
            ],
            "angle": 0,
            "content": "0型文法对其产生式没有限制。1型文法只有两种形式的产生式：一种是 \\(w_{1}\\rightarrow w_{2}\\) 形式的产生式，其中 \\(w_{1} = lAr\\) 和 \\(w_{2} = lwr\\) ， \\(A\\) 是一个非终结符， \\(l\\) 和 \\(r\\) 是0个或多个终结符或非终结符构成的串， \\(\\mathcal{W}\\) 是终结符或非终结符构成的非空串。它还可以有产生式 \\(S\\to \\lambda\\) ，但 \\(S\\) 不能出现在任何其他产生式的右边。2型文法只有形如 \\(w_{1}\\rightarrow w_{2}\\) 的产生式，其中 \\(\\varpi_{1}\\) 是一个单个的非终结符的符号。3型文法只有形如 \\(w_{1}\\rightarrow w_{2}\\) 的产生式，同时满足 \\(w_{1} = A\\) 且 \\(w_{2} = aB\\) 或 \\(w_{2} = a\\) ，其中 \\(A\\) 和 \\(B\\) 是非终结符， \\(a\\) 是终结符，或者满足 \\(w_{1} = S\\) ， \\(w_{2} = \\lambda\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.748,
                0.924,
                0.861
            ],
            "angle": 0,
            "content": "2型文法又称为上下文无关文法，因为出现在一个产生式左侧的非终结符可以被一个字符串替换，而不管此字符串中的符号是什么。2型文法生成的语言称为上下文无关语言。当一个文法具有形如 \\( l\\omega_{1}r \\rightarrow l\\omega_{2}r \\) （而不是形如 \\( \\omega_{1} \\rightarrow \\omega_{2} \\) ）的产生式时，这样的文法称为1型文法或上下文有关文法，因为只有当 \\( \\omega_{1} \\) 被字符串 \\( l \\) 和 \\( r \\) 包围时，才能替换为 \\( \\omega_{2} \\) 。1型文法生成的语言称为上下文有关语言。3型文法又称为正则文法。正则文法生成的语言称为是正则的。13.4节讨论正则语言和有限状态机之间的关系。"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.863,
                0.924,
                0.938
            ],
            "angle": 0,
            "content": "在已经定义的四种文法中，上下文有关文法的定义最复杂。有时，这些文法可以用一种不同的方式来定义。在形如 \\(w_{1} \\rightarrow w_{2}\\) 的产生式中，如果 \\(w_{1}\\) 的长度小于等于 \\(w_{2}\\)，称这个产生式是非缔约的。根据所定义的上下文有关文法的特征，每个1型文法的产生式，除了产生式 \\(S \\rightarrow \\lambda\\)（如果它存在），都是非缔约的。这表明在上下文有关语言的派生中字符串的长度是非递减的，"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.12,
                0.038,
                0.156,
                0.051
            ],
            "angle": 0,
            "content": "752"
        },
        {
            "type": "header",
            "bbox": [
                0.201,
                0.036,
                0.277,
                0.052
            ],
            "angle": 0,
            "content": "第13章"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.093,
                0.941,
                0.185
            ],
            "angle": 0,
            "content": "除非使用了 \\(S \\rightarrow \\lambda\\) 。这就意味着空串属于某个上下文有关文法生成的语言的唯一途径就是产生式 \\(S \\rightarrow \\lambda\\) 是文法的一部分。上下文有关文法定义的另外一种方式就是确定所有的产生式都是非缔约的。具有这种性质的文法称为是非缔约的或者单调的。非缔约文法与上下文有关文法是不同的。然而，这两类文法又是紧密相关的。除了非缔约文法不能生成任何包含空串 \\(\\lambda\\) 的语言外，它们可以定义相同的语言集合。"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.016,
                0.188,
                0.077,
                0.204
            ],
            "angle": 0,
            "content": "Extra Examples"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.191,
                0.941,
                0.229
            ],
            "angle": 0,
            "content": "例8 由例6可知， \\(\\{0^{m}1^{n}|m,n = 0,1,2,\\dots \\}\\) 是正则语言，因为它是由正则文法生成的，即由例6的文法 \\(G_{2}\\) 生成的。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.232,
                0.941,
                0.306
            ],
            "angle": 0,
            "content": "上下文无关文法和正则文法在编程语言中起着重要的作用。上下文无关文法可以用于定义几乎所有编程语言的语法，这些语法强得足以定义大多数的语言。而且，可以设计出有效的算法来确定是否可以以及如何生成一个字符串。正则文法则用于搜索特定模式的文本和进行词法分析，词法分析过程将输入流转变为标记流以供语法分析器使用。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.311,
                0.94,
                0.35
            ],
            "angle": 0,
            "content": "例9 由例5可知， \\(\\{0^{n}1^{n}|n = 0,1,2,\\dots \\}\\) 是上下文无关语言，因为这个文法的产生式为\\(S\\to 0S1\\) 和 \\(S\\rightarrow \\lambda\\) 。在13.4节中我们将证明它不是正则语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.354,
                0.94,
                0.393
            ],
            "angle": 0,
            "content": "例10 集合 \\(\\{0^{n}1^{n}2^{n}|n = 0,1,2,3,\\dots \\}\\) 是上下文有关语言，因为它是由例7中的1型文法生成的。但它不是2型语言（如本章补充练习中的练习28所证）。"
        },
        {
            "type": "text",
            "bbox": [
                0.13,
                0.396,
                0.604,
                0.412
            ],
            "angle": 0,
            "content": "表13-1概括了用来对短语结构文法进行分类的术语。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.44,
                0.424,
                0.591,
                0.437
            ],
            "angle": 0,
            "content": "表 1 文法的类型"
        },
        {
            "type": "table",
            "bbox": [
                0.092,
                0.44,
                0.941,
                0.531
            ],
            "angle": 0,
            "content": "<table><tr><td>类型</td><td>对产生式 \\( {w}_{1} \\rightarrow  {w}_{2} \\) 的限制</td><td>类型</td><td>对产生式 \\( {w}_{1} \\rightarrow  {w}_{2} \\) 的限制</td></tr><tr><td>0</td><td>无限制</td><td>2</td><td>\\( {w}_{1} = A \\) ,其中 \\( A \\) 是非终结符</td></tr><tr><td>1</td><td>\\( {w}_{1} = {lAr} \\) 和 \\( {w}_{2} = {lwr} \\) ,其中 \\( A \\in  N;l,r \\) , \\( w \\in  {\\left( N \\cup  T\\right) }^{ * } \\) 且 \\( w \\neq  \\lambda \\) ; 或者, \\( {w}_{1} = S \\) 和 \\( {w}_{2} = \\lambda \\) , 只要 \\( S \\) 不在另一个产生式的右边</td><td>3</td><td>\\( {w}_{1} = A \\) 和 \\( {w}_{2} = {aB} \\) 或 \\( {w}_{2} = a \\) ,其中 \\( A \\in  N \\) , \\( B \\in  N \\) 和 \\( a \\in  T \\) ,或 \\( {w}_{1} = S \\) 且 \\( {w}_{2} = \\lambda \\)</td></tr></table>"
        },
        {
            "type": "title",
            "bbox": [
                0.092,
                0.553,
                0.254,
                0.57
            ],
            "angle": 0,
            "content": "13.1.4 派生树"
        },
        {
            "type": "text",
            "bbox": [
                0.13,
                0.573,
                0.94,
                0.59
            ],
            "angle": 0,
            "content": "对上下文无关文法生成的语言，其派生可以用有序根树表示成图形，这样的树称为派生树"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.591,
                0.569,
                0.684
            ],
            "angle": 0,
            "content": "或语法分析树。树根表示起始符，树的内部结点表示在派生过程中产生的非终结符，树的叶结点表示终结符。如果在派生过程中，用到了产生式 \\(A \\rightarrow w\\) 其中 \\(\\varpi\\) 是一个词，则表示 \\(A\\) 的结点就有一些子结点，它们表示 \\(\\varpi\\) 中的每一个符号，并且从左到右排列。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.688,
                0.568,
                0.726
            ],
            "angle": 0,
            "content": "例11 对于本节引言所给的例子，构造派生 the hungry rabbit eats quickly 的派生树。"
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.729,
                0.352,
                0.744
            ],
            "angle": 0,
            "content": "解 派生树如图1所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.748,
                0.568,
                0.764
            ],
            "angle": 0,
            "content": "在许多应用中，都会遇到这样的问题：确定一"
        },
        {
            "type": "image",
            "bbox": [
                0.582,
                0.596,
                0.944,
                0.753
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.705,
                0.759,
                0.818,
                0.774
            ],
            "angle": 0,
            "content": "图1 派生树"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.092,
                0.772,
                0.163,
                0.794
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.097,
                0.806,
                0.235,
                0.914
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.094,
                0.918,
                0.241,
                0.938
            ],
            "angle": 0,
            "content": "\\(\\langle \\widehat{\\mathbb{C}}\\rangle\\) SASCHA SCHUERMANN/ AFP/Reuters Images"
        },
        {
            "type": "text",
            "bbox": [
                0.251,
                0.806,
                0.941,
                0.91
            ],
            "angle": 0,
            "content": "艾弗拉姆·诺姆·乔姆斯基(Avram Noam Chomsky，1928—）乔姆斯基出生在费城。他的父亲是一位希伯来语的学者。乔姆斯基在宾夕法尼亚大学获得语言学学士、硕士和博士学位。\\(1950\\sim 1951\\) 年，他在宾夕法尼亚大学任教。1955年受聘于麻省理工学院，开始执教法语和德语。乔姆斯基现今被授予麻省理工学院外国语和语言学的费拉雷·华德教授衔。他因在语言学方面的杰出贡献（包括对语法的研究）而闻名于世。此外，乔姆斯基还因对政治的直言不讳而知名于世。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.668,
                0.033,
                0.778,
                0.048
            ],
            "angle": 0,
            "content": "计算模型"
        },
        {
            "type": "page_number",
            "bbox": [
                0.825,
                0.034,
                0.86,
                0.048
            ],
            "angle": 0,
            "content": "753"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.089,
                0.892,
                0.126
            ],
            "angle": 0,
            "content": "个串是否在一个上下文无关文法生成的语言中，例如编译器的构造。例12指出了解决这样问题的两个方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.13,
                0.892,
                0.17
            ],
            "angle": 0,
            "content": "例12 确定词 \\(cbab\\) 是否在文法 \\(G = \\{V, T, S, P\\}\\) 生成的语言中，其中，\\(V = \\{a, b, c, A, B, C, S\\}\\)，\\(T = \\{a, b, c\\}\\)，\\(S\\) 为起始符，产生式为"
        },
        {
            "type": "equation",
            "bbox": [
                0.163,
                0.174,
                0.231,
                0.304
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} S \\rightarrow A B \\\\ A \\rightarrow C a \\\\ B \\rightarrow B a \\\\ B \\rightarrow C b \\\\ B \\rightarrow b \\\\ C \\rightarrow c b \\\\ C \\rightarrow b \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.309,
                0.892,
                0.346
            ],
            "angle": 0,
            "content": "解 解决这个问题的一种办法是：从 \\(S\\) 出发，用一系列产生式试着派生出 \\(cbab\\)。因为只有一个产生式的左边是 \\(S\\)，所以必须从 \\(S \\Rightarrow AB\\) 开始。下一步，用左边是 \\(A\\) 的唯一产生式 \\(A \\rightarrow Ca\\) 得"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.369,
                0.087,
                0.387
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.045,
                0.404,
                0.184,
                0.516
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.045,
                0.519,
                0.185,
                0.529
            ],
            "angle": 0,
            "content": "Courtesy of Louis Bachrach"
        },
        {
            "type": "text",
            "bbox": [
                0.2,
                0.403,
                0.892,
                0.543
            ],
            "angle": 0,
            "content": "约翰·巴克斯(John Backus，1924—2007）巴克斯出生在费城，在特拉华州的威明顿市长大。他中学就读于希尔中学，但他并不是个好学生，也不爱学习，所以每年都需要参加暑期学校。他非常喜欢在新罕布什尔度过暑假，因为在这里参加暑期学校的同时还有很多诸如冲浪类的课外活动，让他开心不已。他央求他的父亲同意他在弗吉尼亚大学学习化学专业，但他很快发现化学并不适合自己，于是1943年他放弃了学业选择了参军。在军队，他接受了医疗训练，并在军队的附属医院的神经外科病房工作了一段时间。极具讽刺的是，没过多久，巴克斯就被诊断出了头盖骨上长了一个肿瘤，最后用一块金属板将其治愈。他在军队的从医经历促使他去医院院继续深造，但9个"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.545,
                0.893,
                0.721
            ],
            "angle": 0,
            "content": "月之后他再次选择了放弃，因为他实在无法忍受大量的需要死记硬背的医学知识。在医学院退学之后，他参加了一个培训无线电技术员的学校，因为他想制造一个自己的高保真度接收机。这个学校的一个老师看到了巴克斯的潜力，于是让他帮忙完成一篇需要发表的文章中的一些数学运算题。这一次，巴克斯终于发现了他真正的兴趣点：数学及其应用。于是他申请了哥伦比亚大学，并最终获得理学学士和数学硕士学位。1950年，巴斯克加入IBM，成了一名程序设计员。他参与了IBM早期的两种计算机的设计与开发。1954年到1958年，他带领IBM的一个小组开发了FORTRAN。1958年，他成为IBM沃森研究中心的一员。他同时也是程序设计语言ALGOL设计委员会的一员。正是在该语言的设计过程中，他使用了现今叫作巴克斯-诺尔范式的方法来描述此语言的句法。后来，巴克斯从事集合簇的数学研究和函数型程序设计的研究。1963年他成为IBM的特别会员，1974年他获美国国家科学奖，并在3年后荣获美国计算机协会颁发的具有崇高声誉的图灵奖。"
        },
        {
            "type": "image",
            "bbox": [
                0.047,
                0.743,
                0.185,
                0.856
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.045,
                0.859,
                0.162,
                0.879
            ],
            "angle": 0,
            "content": "Heidelberg Laureate Forum Foundation"
        },
        {
            "type": "text",
            "bbox": [
                0.2,
                0.743,
                0.892,
                0.882
            ],
            "angle": 0,
            "content": "彼得·诺尔(Peter Naur, 1928-2016) 诺尔生于哥本哈根附近的腓特烈斯贝。孩提时代，诺尔就对天文学很感兴趣。他不局限于观察天体，还计算彗星和小行星的轨道。诺尔就读于哥本哈根大学，并于1949年获得学位。\\(1950\\sim 1951\\) 年，他在剑桥大学进修，在此期间他用早期的计算机来计算彗星和行星的运动。回到丹麦后，他虽然继续从事天文学的研究，但也并没放弃对计算机的喜爱。1955年，他作为顾问参与了丹麦第一台计算机的研发工作。1959年，诺尔放弃天文学转而进行计算的研究，并将其作为专职工作。作为一名专职计算机科学家，他的第一项工作就是是参加程序设计语言ALGOL的开发。\\(1960\\sim 1967\\) 年，他继续从事ALGOL和COBOL编译器的研究。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.885,
                0.892,
                0.937
            ],
            "angle": 0,
            "content": "1969年，他成为哥本哈根大学的计算机科学专业的教授，专攻程序设计方法学的研究。他的研究兴趣包括计算机程序的设计、结构和执行。诺尔可谓是软件构架和软件工程领域的先驱。他并不认同计算机编程属于数学的一个分支这一观点，他更倾向于把它归为计算机科学的一部分。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.135,
                0.036,
                0.172,
                0.049
            ],
            "angle": 0,
            "content": "754"
        },
        {
            "type": "header",
            "bbox": [
                0.216,
                0.034,
                0.292,
                0.05
            ],
            "angle": 0,
            "content": "第13章"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.091,
                0.955,
                0.145
            ],
            "angle": 0,
            "content": "到 \\(S \\Rightarrow AB \\Rightarrow CaB\\) 。因为 \\(cbab\\) 以符号 \\(cb\\) 开始，所以我们使用产生式 \\(C \\rightarrow cb\\) ，这样就得到了 \\(S \\Rightarrow AB \\Rightarrow CaB \\Rightarrow cbaB\\) 。最后，使用产生式 \\(B \\rightarrow b\\) 就可得到 \\(S \\Rightarrow AB \\Rightarrow CaB \\Rightarrow cbaB \\Rightarrow cbab\\) 。这种方法称为自顶向下的语法分析，因为它从起始符号开始，一个接一个地用产生式来处理。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.148,
                0.955,
                0.221
            ],
            "angle": 0,
            "content": "解决这个问题的另一个办法称为自底向上的语法分析。这种办法从后向前处理。因为 \\(cbab\\) 是需要派生的字符串，所以可以使用产生式 \\(C \\rightarrow cb\\) ，从而得到 \\(Cab \\Rightarrow cbab\\) 。再使用产生式 \\(A \\rightarrow Ca\\) 得到 \\(Ab \\Rightarrow Cab \\Rightarrow cbab\\) 。由产生式 \\(B \\rightarrow b\\) 可得 \\(AB \\Rightarrow Ab \\Rightarrow Cab \\Rightarrow cbab\\) 。最后再用产生式 \\(S \\rightarrow AB\\) 就可得到 \\(cbab\\) 的一个完整的派生 \\(S \\Rightarrow AB \\Rightarrow Ab \\Rightarrow Cab \\Rightarrow cbab\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.224,
                0.955,
                0.298
            ],
            "angle": 0,
            "content": "例12给出了自顶向下和自底向上解析问题的方法。这两种方法都很容易解决这个问题。但是，解析问题很有挑战性。也就是说，确定字符串是否在由上下文无关语法生成的语言中很具挑战性。因为解析非常重要，研究者对自顶向下和自底向上的解析设计了很多策略和算法。这些算法超出了本书的范围，感兴趣的读者可参考[ahlaseul06]。"
        },
        {
            "type": "title",
            "bbox": [
                0.109,
                0.308,
                0.369,
                0.324
            ],
            "angle": 0,
            "content": "13.1.5 巴克斯-诺尔范式"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.328,
                0.955,
                0.496
            ],
            "angle": 0,
            "content": "有时候还用另一个方法来表示2型文法，这就是巴克斯-诺尔范式（BNF），这个方法是根据约翰·巴克斯和彼得·诺尔命名的。约翰·巴克斯是它的发明人，彼得·诺尔则改进了它，并将之应用于程序设计语言ALGOL的规范说明中。（奇怪的是，在大约2500年前，与巴克斯-诺尔范式非常相似的一个记法用来表示梵语文法。）巴克斯-诺尔范式已用来对许多程序设计语言（包括Java)的语法规则进行规范说明。在2型文法中，产生式的左边都是单个非终结符。在巴克斯-诺尔范式中，将左边是同一个非终结符的所有产生式合并成一个式子，而不是将这些产生式都列出来。我们还用符号 \\(\\coloneqq\\) 代替 \\(\\rightarrow\\) ，将非终结符用 \\(< >\\) 括起来，并在一个式子里列出所有这些产生式的右边，用竖线将这些产生式分开。例如，产生式 \\(A\\to Aa\\) 、 \\(A\\to a\\) 、 \\(A\\to AB\\) 可以合并成 \\(\\langle A\\rangle \\coloneqq \\langle A\\rangle a|a|\\langle A\\rangle \\langle B\\rangle\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.498,
                0.955,
                0.534
            ],
            "angle": 0,
            "content": "例13给出了如何用巴克斯-诺尔范式来描述编程语言的语法。本例来自于巴克斯-诺尔范式在ALGOL60中的使用。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.538,
                0.955,
                0.577
            ],
            "angle": 0,
            "content": "例13 在ALGOL60中，标识符（如同变量这样的实体的名字）由字母和数字组成，且必须以字母开头。我们可以用巴克斯-诺尔范式描述可用的标识符集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.58,
                0.648,
                0.596
            ],
            "angle": 0,
            "content": "<标识符>：=<字母><标识符><字母><标识符><数字>"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.599,
                0.682,
                0.616
            ],
            "angle": 0,
            "content": "（字母） \\(\\because = a\\mid b\\mid \\dots \\mid y\\mid z\\) （省略号表示包括全部26个字母）"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.619,
                0.473,
                0.635
            ],
            "angle": 0,
            "content": "<数字>： \\(= 0\\mid 1\\mid 2\\mid 3\\mid 4\\mid 5\\mid 6\\mid 7\\mid 8\\mid 9\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.638,
                0.955,
                0.71
            ],
            "angle": 0,
            "content": "例如，我们可以如下生成有效的标识符 \\(\\mathrm{x99a}\\) ：用第一条规则将<标识符>替换成<标识符><字母>，用第二条规则得到<标识符>a，两次使用第一条规则得到<标识符><数字><数字>a，两次使用第三条规则得到<标识符>99a，再用第一条规则得到<字母>99a，最后用第二条规则得到\\(\\mathrm{x99a}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.716,
                0.873,
                0.734
            ],
            "angle": 0,
            "content": "例14本节引言描述了英语的一个子集，其对应文法的巴克斯-诺尔范式是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.738,
                0.481,
                0.754
            ],
            "angle": 0,
            "content": "解这个文法的巴克斯-诺尔范式是："
        },
        {
            "type": "text",
            "bbox": [
                0.19,
                0.758,
                0.5,
                0.772
            ],
            "angle": 0,
            "content": "<句子>： \\(= \\langle\\) 名词短语 \\(\\rangle\\) <动词短语>"
        },
        {
            "type": "text",
            "bbox": [
                0.19,
                0.777,
                0.677,
                0.792
            ],
            "angle": 0,
            "content": "<名词短语>：=<冠词><形容词><名词><冠词><名词>"
        },
        {
            "type": "text",
            "bbox": [
                0.19,
                0.796,
                0.534,
                0.811
            ],
            "angle": 0,
            "content": "（动词短语）：=（动词）<副词>|<动词>"
        },
        {
            "type": "text",
            "bbox": [
                0.191,
                0.816,
                0.347,
                0.83
            ],
            "angle": 0,
            "content": "<冠词>：=a|the"
        },
        {
            "type": "text",
            "bbox": [
                0.191,
                0.835,
                0.434,
                0.85
            ],
            "angle": 0,
            "content": "<形容词>：=large|hungry"
        },
        {
            "type": "text",
            "bbox": [
                0.191,
                0.854,
                0.484,
                0.869
            ],
            "angle": 0,
            "content": "<名词>： \\(\\equiv\\) rabbit|mathematician"
        },
        {
            "type": "text",
            "bbox": [
                0.191,
                0.874,
                0.384,
                0.889
            ],
            "angle": 0,
            "content": "<动词>：=eats|hops"
        },
        {
            "type": "text",
            "bbox": [
                0.191,
                0.893,
                0.423,
                0.908
            ],
            "angle": 0,
            "content": "<副词>： \\(=\\) quickly|wildly"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.914,
                0.955,
                0.932
            ],
            "angle": 0,
            "content": "例15 给出带符号十进制整数的产生式的巴克斯-诺尔范式（带符号整数是非负整数前面加"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.031,
                0.331,
                0.092,
                0.343
            ],
            "angle": 0,
            "content": "Links"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.685,
                0.035,
                0.796,
                0.051
            ],
            "angle": 0,
            "content": "计算模型"
        },
        {
            "type": "page_number",
            "bbox": [
                0.842,
                0.036,
                0.876,
                0.049
            ],
            "angle": 0,
            "content": "755"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.092,
                0.245,
                0.107
            ],
            "angle": 0,
            "content": "上一个加号或减号）。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.111,
                0.595,
                0.127
            ],
            "angle": 0,
            "content": "解 一个产生带符号整数的文法的巴克斯-诺尔范式为："
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.13,
                0.431,
                0.146
            ],
            "angle": 0,
            "content": "<带符号整数>：=<符号><整数>"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.149,
                0.3,
                0.165
            ],
            "angle": 0,
            "content": "<符号>：=十一"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.169,
                0.443,
                0.185
            ],
            "angle": 0,
            "content": "<整数>：=〈数字〉|〈数字〉〈整数〉"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.188,
                0.463,
                0.205
            ],
            "angle": 0,
            "content": "<数字>：=0|1|2|3|4|5|6|7|8|9"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.208,
                0.908,
                0.263
            ],
            "angle": 0,
            "content": "具有多种扩展的巴克斯-诺尔范式广泛用于定义编程语言（如Java和LISP）、数据库语言（如SQL)和标记语言(如XML)的语法。一些常用的描述编程语言的巴克斯-诺尔范式在本节练习34的导语中有介绍。"
        },
        {
            "type": "title",
            "bbox": [
                0.06,
                0.274,
                0.106,
                0.29
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.294,
                0.908,
                0.344
            ],
            "angle": 0,
            "content": "练习 \\(1\\sim 3\\) 中的文法是：起始符为句子，终结符集 \\(T = \\{\\text{the, sleepy, happy, tortoise, hare, passes, runs, quickly, slowly}\\}\\)，非终结符集 \\(N = \\{\\text{名词短语，及物动词短语，不及物动词短语，冠词，形容词，名词，动词，副词}\\}\\)，产生式为"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.348,
                0.49,
                0.362
            ],
            "angle": 0,
            "content": "句子 \\(\\rightarrow\\) 名词短语 及物动词短语 名词短语"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.366,
                0.414,
                0.379
            ],
            "angle": 0,
            "content": "句子 \\(\\rightarrow\\) 名词短语 不及物动词短语"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.384,
                0.396,
                0.397
            ],
            "angle": 0,
            "content": "名词短语 \\(\\rightarrow\\) 冠词 形容词 名词"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.402,
                0.322,
                0.415
            ],
            "angle": 0,
            "content": "名词短语 \\(\\rightarrow\\) 冠词 名词"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.42,
                0.34,
                0.433
            ],
            "angle": 0,
            "content": "及物动词短语 \\(\\rightarrow\\) 及物动词"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.438,
                0.432,
                0.451
            ],
            "angle": 0,
            "content": "不及物动词短语 \\(\\rightarrow\\) 不及物动词 副词"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.456,
                0.377,
                0.469
            ],
            "angle": 0,
            "content": "不及物动词短语 \\(\\rightarrow\\) 不及物动词"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.474,
                0.218,
                0.487
            ],
            "angle": 0,
            "content": "冠词 \\(\\rightarrow\\) the"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.492,
                0.26,
                0.506
            ],
            "angle": 0,
            "content": "形容词 \\(\\rightarrow\\) sleepy"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.51,
                0.259,
                0.524
            ],
            "angle": 0,
            "content": "形容词→happy"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.528,
                0.253,
                0.541
            ],
            "angle": 0,
            "content": "名词 \\(\\rightarrow\\) tortoise"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.545,
                0.227,
                0.558
            ],
            "angle": 0,
            "content": "名词 \\(\\rightarrow\\) hare"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.563,
                0.28,
                0.577
            ],
            "angle": 0,
            "content": "及物动词 \\(\\rightarrow\\) passes"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.581,
                0.284,
                0.594
            ],
            "angle": 0,
            "content": "不及物动词 \\(\\rightarrow\\) runs"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.599,
                0.25,
                0.612
            ],
            "angle": 0,
            "content": "副词 \\(\\rightarrow\\) quickly"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.617,
                0.244,
                0.63
            ],
            "angle": 0,
            "content": "副词 \\(\\rightarrow\\) slowly"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.634,
                0.467,
                0.649
            ],
            "angle": 0,
            "content": "1. 用产生式集合证明下列每个句子都是有效句子："
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.653,
                0.264,
                0.667
            ],
            "angle": 0,
            "content": "a) the happy hare runs"
        },
        {
            "type": "text",
            "bbox": [
                0.461,
                0.653,
                0.73,
                0.667
            ],
            "angle": 0,
            "content": "b) the sleepy tortoise runs quickly"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.67,
                0.32,
                0.684
            ],
            "angle": 0,
            "content": "c) the tortoise passes the hare"
        },
        {
            "type": "text",
            "bbox": [
                0.461,
                0.67,
                0.805,
                0.684
            ],
            "angle": 0,
            "content": "d) the sleepy hare passes the happy tortoise"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.688,
                0.504,
                0.702
            ],
            "angle": 0,
            "content": "2. 除了练习1中的有效句子外，再给出五个有效句子。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.706,
                0.52,
                0.72
            ],
            "angle": 0,
            "content": "3. 证明：the hare runs the sleepy tortoise 不是有效句子。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.723,
                0.908,
                0.756
            ],
            "angle": 0,
            "content": "4. 令 \\(G = (V, T, S, P)\\) 是短语结构文法，并且有 \\(V = \\{0, 1, A, S\\}\\)，\\(T = \\{0, 1\\}\\)。产生式集合包含 \\(S \\rightarrow 1S, S \\rightarrow 00A\\)，\\(A \\rightarrow 0A\\) 以及 \\(A \\rightarrow 0\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.759,
                0.385,
                0.773
            ],
            "angle": 0,
            "content": "a) 证明 111000 属于由 \\(G\\) 生成的语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.777,
                0.395,
                0.792
            ],
            "angle": 0,
            "content": "b) 证明 11001 不属于由 \\(G\\) 生成的语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.795,
                0.304,
                0.81
            ],
            "angle": 0,
            "content": "c)由 \\(G\\) 生成的语言是什么？"
        },
        {
            "type": "list",
            "bbox": [
                0.082,
                0.759,
                0.395,
                0.81
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.813,
                0.908,
                0.845
            ],
            "angle": 0,
            "content": "5. 令 \\(G = (V, T, S, P)\\) 是短语结构文法，并且有 \\(V = \\{0, 1, A, B, S\\}\\)，\\(T = \\{0, 1\\}\\)。产生式集合包含 \\(S \\rightarrow 0A\\)，\\(S \\rightarrow 1A\\)，\\(A \\rightarrow 0B\\)，\\(B \\rightarrow 1A\\) 以及 \\(B \\rightarrow 1\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.849,
                0.377,
                0.863
            ],
            "angle": 0,
            "content": "a) 证明 10101 属于由 \\(G\\) 生成的语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.867,
                0.396,
                0.881
            ],
            "angle": 0,
            "content": "b) 证明 10110 不属于由 \\(G\\) 生成的语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.885,
                0.304,
                0.899
            ],
            "angle": 0,
            "content": "c)由 \\(G\\) 生成的语言是什么？"
        },
        {
            "type": "list",
            "bbox": [
                0.082,
                0.849,
                0.396,
                0.899
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.902,
                0.91,
                0.935
            ],
            "angle": 0,
            "content": "* 6. 设 \\( V = \\{ S, A, B, a, b \\} \\)，\\( T = \\{ a, b \\} \\)。当产生式集合为下列情形之一时，求文法 \\( \\{ V, T, S, P \\} \\) 生成的语言。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.131,
                0.035,
                0.167,
                0.048
            ],
            "angle": 0,
            "content": "756"
        },
        {
            "type": "header",
            "bbox": [
                0.212,
                0.034,
                0.288,
                0.049
            ],
            "angle": 0,
            "content": "第13章"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.091,
                0.343,
                0.104
            ],
            "angle": 0,
            "content": "a) \\(S\\to AB\\) ， \\(A\\to ab\\) ， \\(B\\to bb_{\\circ}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.124,
                0.109,
                0.408,
                0.122
            ],
            "angle": 0,
            "content": "b) \\(S \\rightarrow AB\\) ， \\(S \\rightarrow aA\\) ， \\(A \\rightarrow a\\) ， \\(B \\rightarrow ba\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.124,
                0.127,
                0.482,
                0.139
            ],
            "angle": 0,
            "content": "c) \\(S \\rightarrow AB\\) ， \\(S \\rightarrow AA\\) ， \\(A \\rightarrow aB\\) ， \\(A \\rightarrow ab\\) ， \\(B \\rightarrow b\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.124,
                0.144,
                0.551,
                0.157
            ],
            "angle": 0,
            "content": "d) \\(S \\rightarrow AA\\) ， \\(S \\rightarrow B\\) ， \\(A \\rightarrow a a A\\) ， \\(A \\rightarrow a a\\) ， \\(B \\rightarrow b B\\) ， \\(B \\rightarrow b\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.124,
                0.162,
                0.486,
                0.175
            ],
            "angle": 0,
            "content": "e) \\(S \\rightarrow AB\\) ， \\(A \\rightarrow aAb\\) ， \\(B \\rightarrow bBa\\) ， \\(A \\rightarrow \\lambda\\) ， \\(B \\rightarrow \\lambda\\) 。"
        },
        {
            "type": "list",
            "bbox": [
                0.123,
                0.091,
                0.551,
                0.175
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.179,
                0.423,
                0.193
            ],
            "angle": 0,
            "content": "7. 用例5所给的文法构造 \\(0^{3}1^{3}\\) 的派生。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.197,
                0.591,
                0.212
            ],
            "angle": 0,
            "content": "8. 证明：例5所给的文法生成集合 \\(\\{0^n 1^n \\mid n = 0, 1, 2, \\dots\\}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.216,
                0.451,
                0.23
            ],
            "angle": 0,
            "content": "9. a) 用例6中的文法 \\(G_{1}\\) 构造 \\(0^{2}1^{4}\\) 的派生。"
        },
        {
            "type": "text",
            "bbox": [
                0.124,
                0.235,
                0.451,
                0.248
            ],
            "angle": 0,
            "content": "b)用例6中的文法 \\(G_{2}\\) 构造 \\(0^{2}1^{4}\\) 的派生。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.253,
                0.664,
                0.269
            ],
            "angle": 0,
            "content": "10. a) 证明：例6中的文法 \\(G_{1}\\) 生成集合 \\(\\{0^{m}1^{n}\\mid m,n = 0,1,2,\\dots \\}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.272,
                0.491,
                0.287
            ],
            "angle": 0,
            "content": "b) 证明：例 6 中的文法 \\( G_{2} \\) 生成同一个集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.291,
                0.449,
                0.305
            ],
            "angle": 0,
            "content": "11. 用例7所给的文法构造 \\(0^{2}1^{2}2^{2}\\) 的派生。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.309,
                0.617,
                0.324
            ],
            "angle": 0,
            "content": "* 12. 证明：例7所给的文法生成集合 \\(\\{0^n 1^n 2^n | n = 0, 1, 2, \\dots\\}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.328,
                0.37,
                0.342
            ],
            "angle": 0,
            "content": "13. 求下列语言的短语结构文法："
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.345,
                0.395,
                0.36
            ],
            "angle": 0,
            "content": "a)包含比特串0、1、11的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.363,
                0.37,
                0.377
            ],
            "angle": 0,
            "content": "b)只包含1的比特串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.381,
                0.46,
                0.395
            ],
            "angle": 0,
            "content": "c) 以 0 开始，以 1 结束的比特串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.399,
                0.461,
                0.413
            ],
            "angle": 0,
            "content": "d)由0后面跟偶数个1的比特串的集合。"
        },
        {
            "type": "list",
            "bbox": [
                0.132,
                0.345,
                0.461,
                0.413
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.416,
                0.37,
                0.431
            ],
            "angle": 0,
            "content": "14. 求下列语言的短语结构文法。"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.434,
                0.432,
                0.448
            ],
            "angle": 0,
            "content": "a)包含比特串10、01和101的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.452,
                0.619,
                0.466
            ],
            "angle": 0,
            "content": "b)以00开始，以一个或更多个1作为结束的比特串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.47,
                0.517,
                0.484
            ],
            "angle": 0,
            "content": "c)包含偶数个1最后跟一个0的比特串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.487,
                0.767,
                0.501
            ],
            "angle": 0,
            "content": "d)既不含有两个连续的0，也不含有两个连续的1，这样的比特串构成的集合。"
        },
        {
            "type": "list",
            "bbox": [
                0.132,
                0.434,
                0.767,
                0.501
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.505,
                0.37,
                0.519
            ],
            "angle": 0,
            "content": "* 15. 求下列语言的短语结构文法："
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.523,
                0.517,
                0.537
            ],
            "angle": 0,
            "content": "a)包含偶数个0但没有1的所有比特串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.541,
                0.499,
                0.554
            ],
            "angle": 0,
            "content": "b) 由1后面跟奇数个0的所有比特串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.558,
                0.535,
                0.572
            ],
            "angle": 0,
            "content": "c)包含偶数个0和偶数个1的所有比特串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.576,
                0.545,
                0.59
            ],
            "angle": 0,
            "content": "d)包含10个以上0但没有1的所有比特串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.593,
                0.571,
                0.607
            ],
            "angle": 0,
            "content": "e)所包含0的个数多于1的个数的所有比特串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.611,
                0.517,
                0.626
            ],
            "angle": 0,
            "content": "f)包含相同个数的0和1的所有比特串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.629,
                0.517,
                0.643
            ],
            "angle": 0,
            "content": "g)包含不同个数的0和1的所有比特串的集合。"
        },
        {
            "type": "list",
            "bbox": [
                0.133,
                0.523,
                0.571,
                0.643
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.647,
                0.426,
                0.661
            ],
            "angle": 0,
            "content": "16. 构造生成下列集合的短语结构文法。"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.664,
                0.24,
                0.68
            ],
            "angle": 0,
            "content": "a) \\(\\{1^n\\mid n\\geqslant 0\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.369,
                0.665,
                0.482,
                0.68
            ],
            "angle": 0,
            "content": "b) \\(\\{10^{n} \\mid n \\geqslant 0\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.684,
                0.267,
                0.7
            ],
            "angle": 0,
            "content": "c) \\(\\{(11)^n\\mid n\\geqslant 0\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.704,
                0.426,
                0.718
            ],
            "angle": 0,
            "content": "17. 构造生成下列集合的短语结构文法。"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.721,
                0.241,
                0.737
            ],
            "angle": 0,
            "content": "a) \\(\\{0^n\\mid n\\geqslant 0\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.369,
                0.722,
                0.482,
                0.737
            ],
            "angle": 0,
            "content": "b) \\(\\{1^n 0\\mid n\\geqslant 0\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.741,
                0.276,
                0.756
            ],
            "angle": 0,
            "content": "\\(c)\\{(000)^n\\mid n\\geqslant 0\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.761,
                0.426,
                0.775
            ],
            "angle": 0,
            "content": "18. 构造生成下列集合的短语结构文法。"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.779,
                0.254,
                0.794
            ],
            "angle": 0,
            "content": "a) \\(\\{01^{2n} \\mid n \\geqslant 0\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.369,
                0.798,
                0.578,
                0.814
            ],
            "angle": 0,
            "content": "c) \\(\\{0^n 1^m 0^n \\mid m \\geqslant 0\\) 且 \\(n \\geqslant 0\\}\\)"
        },
        {
            "type": "list",
            "bbox": [
                0.135,
                0.779,
                0.254,
                0.814
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.818,
                0.582,
                0.885
            ],
            "angle": 0,
            "content": "19. 设 \\(V = \\{S, A, B, a, b\\}\\), \\(T = \\{a, b\\}\\) 。若产生式集 \\(P\\) 为下列集合时，问文法 \\(G = (V, T, S, P)\\) 是否为0型但不是1型文法？是否为1型但不是2型文法？或者是否为2型但不是3型文法？"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.889,
                0.358,
                0.903
            ],
            "angle": 0,
            "content": "a) \\(S \\rightarrow aAB\\) ， \\(A \\rightarrow Bb\\) ， \\(B \\rightarrow \\lambda\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.906,
                0.337,
                0.92
            ],
            "angle": 0,
            "content": "b) \\(S \\rightarrow aA\\) ， \\(A \\rightarrow a\\) ， \\(A \\rightarrow b\\) 。"
        },
        {
            "type": "list",
            "bbox": [
                0.135,
                0.889,
                0.358,
                0.92
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.593,
                0.525,
                0.955,
                0.932
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.686,
                0.041,
                0.796,
                0.056
            ],
            "angle": 0,
            "content": "计算模型"
        },
        {
            "type": "page_number",
            "bbox": [
                0.844,
                0.043,
                0.879,
                0.055
            ],
            "angle": 0,
            "content": "757"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.099,
                0.258,
                0.112
            ],
            "angle": 0,
            "content": "c) \\(S \\rightarrow A B a, A B \\rightarrow a\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.117,
                0.331,
                0.129
            ],
            "angle": 0,
            "content": "d) \\(S \\rightarrow ABA\\), \\(A \\rightarrow aB\\), \\(B \\rightarrow ab\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.135,
                0.294,
                0.147
            ],
            "angle": 0,
            "content": "e) \\(S \\to bA\\) ， \\(A \\to B\\) ， \\(B \\to a\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.152,
                0.375,
                0.164
            ],
            "angle": 0,
            "content": "f) \\(S \\to aA\\), \\(aA \\to B\\), \\(B \\to aA\\), \\(A \\to b\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.17,
                0.288,
                0.183
            ],
            "angle": 0,
            "content": "g) \\(S \\rightarrow bA\\) ， \\(A \\rightarrow b\\) ， \\(S \\rightarrow \\lambda\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.188,
                0.336,
                0.2
            ],
            "angle": 0,
            "content": "h) \\(S\\to AB\\) ， \\(B\\to aAb\\) ， \\(aAb\\to b_{\\circ}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.205,
                0.357,
                0.218
            ],
            "angle": 0,
            "content": "i) \\(S \\rightarrow aA\\) ， \\(A \\rightarrow bB\\) ， \\(B \\rightarrow b\\) ， \\(B \\rightarrow \\lambda\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.223,
                0.283,
                0.236
            ],
            "angle": 0,
            "content": "j) \\(S\\to A\\) ， \\(A\\to B\\) ， \\(B\\to \\lambda_{\\circ}\\)"
        },
        {
            "type": "list",
            "bbox": [
                0.091,
                0.099,
                0.375,
                0.236
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.241,
                0.909,
                0.273
            ],
            "angle": 0,
            "content": "20.回文是从前向后读和从后向前读都一样的字符串，也就是对于串w，有 \\( w = w^R \\)，其中 \\( w^R \\) 是字符串w的逆。试求一个上下文无关的文法，使得其生成的集合是字母表{0，1}上的所有回文。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.277,
                0.907,
                0.309
            ],
            "angle": 0,
            "content": "* 21. 设 \\(G_{1}\\) 和 \\(G_{2}\\) 是两个上下文无关的文法，它们生成的语言分别为 \\(L(G_{1})\\) 和 \\(L(G_{2})\\) 。试证：对于下列每个集合，都有一个上下文无关文法生成下列集合："
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.313,
                0.233,
                0.326
            ],
            "angle": 0,
            "content": "a) \\(L(G_{1})\\bigcup L(G_{2})\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.361,
                0.313,
                0.481,
                0.326
            ],
            "angle": 0,
            "content": "b) \\( L(G_{1})L(G_{2}) \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.61,
                0.313,
                0.688,
                0.326
            ],
            "angle": 0,
            "content": "c) \\( L(G_{1})^{*} \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.33,
                0.458,
                0.344
            ],
            "angle": 0,
            "content": "22. 求用右面的两个图中的派生树构造的字符串。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.348,
                0.328,
                0.362
            ],
            "angle": 0,
            "content": "23. 构造练习1中句子的派生树。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.366,
                0.909,
                0.397
            ],
            "angle": 0,
            "content": "24. 设 \\(G\\) 是一个文法，其中 \\(V = \\{a, b, c, S\\}\\)，\\(T = \\{a, b, c\\}\\)，起始符号为 \\(S\\)，产生式为 \\(S \\rightarrow abS\\)、\\(S \\rightarrow bcS\\)、\\(S \\rightarrow bbS\\)、\\(S \\rightarrow a\\)、\\(S \\rightarrow cb\\)。构造下列字符串的派生树。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.402,
                0.156,
                0.414
            ],
            "angle": 0,
            "content": "a)bcbbaa"
        },
        {
            "type": "text",
            "bbox": [
                0.361,
                0.402,
                0.439,
                0.414
            ],
            "angle": 0,
            "content": "b) bbbcbba"
        },
        {
            "type": "text",
            "bbox": [
                0.61,
                0.402,
                0.711,
                0.414
            ],
            "angle": 0,
            "content": "c)bcabbbbcb"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.419,
                0.874,
                0.434
            ],
            "angle": 0,
            "content": "* 25. 对于下列每个字符串，用自顶向下的语法分析方法，确定其是否属于例12中的文法生成的语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.438,
                0.15,
                0.45
            ],
            "angle": 0,
            "content": "a) baba"
        },
        {
            "type": "text",
            "bbox": [
                0.361,
                0.438,
                0.418,
                0.45
            ],
            "angle": 0,
            "content": "b)abab"
        },
        {
            "type": "text",
            "bbox": [
                0.61,
                0.438,
                0.672,
                0.45
            ],
            "angle": 0,
            "content": "c)cbaba"
        },
        {
            "type": "text",
            "bbox": [
                0.817,
                0.438,
                0.888,
                0.45
            ],
            "angle": 0,
            "content": "d)bbbcba"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.455,
                0.901,
                0.469
            ],
            "angle": 0,
            "content": "* 26. 对于练习 25 中的字符串，用自底向上的语法分析方法，确定其是否属于例 12 中的文法生成的语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.473,
                0.425,
                0.487
            ],
            "angle": 0,
            "content": "27. 用例15所给的文法构造一109的派生树。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.491,
                0.745,
                0.505
            ],
            "angle": 0,
            "content": "28. a) 如果一个文法的产生式由下列巴克斯-诺尔范式给出，那么这些产生式是什么？"
        },
        {
            "type": "list",
            "bbox": [
                0.047,
                0.455,
                0.901,
                0.505
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.51,
                0.328,
                0.524
            ],
            "angle": 0,
            "content": "<表达式 \\(\\text{一} =\\) （（表达式））"
        },
        {
            "type": "text",
            "bbox": [
                0.232,
                0.529,
                0.41,
                0.544
            ],
            "angle": 0,
            "content": "（表达式）+（表达式）"
        },
        {
            "type": "text",
            "bbox": [
                0.232,
                0.549,
                0.41,
                0.564
            ],
            "angle": 0,
            "content": "<表达式 \\(\\text{一} ^ { \\text{一} }\\) 表达式>"
        },
        {
            "type": "text",
            "bbox": [
                0.234,
                0.569,
                0.29,
                0.582
            ],
            "angle": 0,
            "content": "<变元>"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.586,
                0.242,
                0.602
            ],
            "angle": 0,
            "content": "（变元） \\(\\because = x\\mid y\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.606,
                0.383,
                0.62
            ],
            "angle": 0,
            "content": "b)求此文法中 \\((x*y) + x\\) 的派生树。"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.624,
                0.911,
                0.674
            ],
            "angle": 0,
            "content": "29. a)构造一个短语结构文法，使其生成如下所有带符号的十进制数：这些数由符号（+或一）、非负整数和十进制小数三部分构成，且十进制小数部分或者是空串，或者是小数点后面跟一个正整数，其中，整数的开始部分允许有0。"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.678,
                0.393,
                0.691
            ],
            "angle": 0,
            "content": "b)给出这个文法的巴克斯-诺尔范式。"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.696,
                0.369,
                0.709
            ],
            "angle": 0,
            "content": "c)构造此文法中一31.4的派生树。"
        },
        {
            "type": "list",
            "bbox": [
                0.093,
                0.678,
                0.393,
                0.709
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.713,
                0.91,
                0.745
            ],
            "angle": 0,
            "content": "30. a)构造一个短语结构文法，使其生成所有形如 \\(a / b\\) 的分数构成的集合，其中 \\(a\\) 为带符号的十进制数，\\(b\\) 是正整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.749,
                0.393,
                0.762
            ],
            "angle": 0,
            "content": "b)给出这个文法的巴克斯-诺尔范式。"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.767,
                0.388,
                0.78
            ],
            "angle": 0,
            "content": "c)构造此文法中 \\(+311 / 17\\) 的派生树。"
        },
        {
            "type": "list",
            "bbox": [
                0.093,
                0.749,
                0.393,
                0.78
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.784,
                0.653,
                0.798
            ],
            "angle": 0,
            "content": "31. 对于包含如下内容的标识符，给出其巴克斯-诺尔范式的产生式规则。"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.803,
                0.292,
                0.816
            ],
            "angle": 0,
            "content": "a)一个或多个小写字母。"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.82,
                0.367,
                0.834
            ],
            "angle": 0,
            "content": "b)至少3个但至多6个小写字母。"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.838,
                0.462,
                0.851
            ],
            "angle": 0,
            "content": "c) \\(1\\sim 6\\) 个大写或小写字母并以大写字母开头。"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.856,
                0.83,
                0.869
            ],
            "angle": 0,
            "content": "d)一个小写字母，后跟一个数字或下划线，后跟三四个字母数字字符（大小写字母和数字）。"
        },
        {
            "type": "list",
            "bbox": [
                0.093,
                0.803,
                0.83,
                0.869
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.873,
                0.91,
                0.906
            ],
            "angle": 0,
            "content": "32. 给出如下人名的巴克斯-诺尔范式产生式规则，人名包含：“名”，它是一个仅有首字母大写的字母串；“中间名”；“姓”，它可以是任意字母串。"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.909,
                0.91,
                0.941
            ],
            "angle": 0,
            "content": "33. 给出生成 C 语言中所有标识符的巴克斯-诺尔范式产生式规则。在 C 语言中，标识符以一个字母或下划线开始，后跟一或多个小写字母、大写字母、下划线和数字。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.139,
                0.042,
                0.175,
                0.057
            ],
            "angle": 0,
            "content": "758"
        },
        {
            "type": "header",
            "bbox": [
                0.22,
                0.041,
                0.297,
                0.057
            ],
            "angle": 0,
            "content": "第13章"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.098,
                0.957,
                0.166
            ],
            "angle": 0,
            "content": "巴克斯-诺尔范式的一些扩展常用于定义短语结构文法。在其中的一种扩展中，问号（?）表明其左边的符号或括号中的一组符号可以出现零次或一次（即它是可选的），星号（*）表明其左边的符号可出现零次或多次，加号（+）表明其左边的符号可出现一次或多次。这些扩展均为扩展的巴克斯-诺尔范式（EBNF）的一部分，符号？、*和+称为元字符。在EBNF中，用于表示非终结符的括号通常不显示。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.17,
                0.528,
                0.184
            ],
            "angle": 0,
            "content": "34. 描述由下列 EBNF 产生式集合定义的串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.188,
                0.331,
                0.203
            ],
            "angle": 0,
            "content": "a) string::=L+D?L+"
        },
        {
            "type": "text",
            "bbox": [
                0.477,
                0.188,
                0.697,
                0.203
            ],
            "angle": 0,
            "content": "b) string::=sign D + |D+"
        },
        {
            "type": "equation",
            "bbox": [
                0.162,
                0.207,
                0.262,
                0.223
            ],
            "angle": 0,
            "content": "\\[\nL \\because = a | b | c\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.495,
                0.208,
                0.616,
                0.223
            ],
            "angle": 0,
            "content": "\\[\ns i g n: := + \\mid -\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.162,
                0.228,
                0.245,
                0.242
            ],
            "angle": 0,
            "content": "\\[\nD \\because = 0 \\mid 1\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.497,
                0.228,
                0.756,
                0.243
            ],
            "angle": 0,
            "content": "\\[\nD \\because = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.248,
                0.362,
                0.261
            ],
            "angle": 0,
            "content": "c) string::=L*(D+)?L*"
        },
        {
            "type": "equation",
            "bbox": [
                0.162,
                0.266,
                0.245,
                0.28
            ],
            "angle": 0,
            "content": "\\[\nL \\because = x \\mid y\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.162,
                0.286,
                0.244,
                0.299
            ],
            "angle": 0,
            "content": "\\[\nD \\because = 0 \\mid 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.304,
                0.957,
                0.355
            ],
            "angle": 0,
            "content": "35. 给出生成下述十进制数的扩展的巴克斯-诺尔范式的产生式规则，此十进制数由可选的符号、非负整数和小数部分组成，小数部分或者为空串，或者为小数点后加一个可选的正整数，这个正整数前可能带有若干个零。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.357,
                0.957,
                0.408
            ],
            "angle": 0,
            "content": "36. 如果三明治由下列东西组成：底部的一片面包；芥末或蛋黄酱；生菜（可选）；一片西红柿（可选）；一片或多片火鸡肉、鸡肉或烤牛肉（任意组合）；一些奶酪（可选）；顶部的一片面包。给出其扩展的巴克斯-诺尔范式的产生式规则。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.411,
                0.592,
                0.426
            ],
            "angle": 0,
            "content": "37. 给出 C 语言中标识符的 EBNF 产生式规则（见练习 33）。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.429,
                0.803,
                0.444
            ],
            "angle": 0,
            "content": "38. 描述如何将文法的扩展的巴克斯-诺尔范式产生式转换成巴克斯-诺尔范式产生式。"
        },
        {
            "type": "list",
            "bbox": [
                0.108,
                0.304,
                0.957,
                0.444
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.447,
                0.758,
                0.462
            ],
            "angle": 0,
            "content": "下面给出的是在后缀(或逆波兰)记法中描述表达式语法的巴克斯-诺尔范式。"
        },
        {
            "type": "equation",
            "bbox": [
                0.143,
                0.466,
                0.571,
                0.58
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} \\langle e x p r e s s i o n \\rangle : := \\langle t e r m \\rangle | \\langle t e r m \\rangle \\langle t e r m \\rangle \\langle a d d O p e r a t o r \\rangle \\\\ \\langle \\text {a d d O p e r a t o r} \\rangle : := + | - \\\\ \\langle t e r m \\rangle : := \\langle f a c t o r \\rangle | \\langle f a c t o r \\rangle \\langle f a c t o r \\rangle \\langle m u l O p e r a t o r \\rangle \\\\ \\langle m u l O p e r a t o r \\rangle : := * / \\\\ \\langle f a c t o r \\rangle : := \\langle i d e n t i f i e r \\rangle | \\langle e x p r e s s i o n \\rangle \\\\ \\langle \\text {i d e n t i f i e r} \\rangle : := a | b | \\dots | z \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.584,
                0.767,
                0.599
            ],
            "angle": 0,
            "content": "39. 对下列字符串，判断其是否由后缀记法的文法生成。如果是，给出生成步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.603,
                0.225,
                0.616
            ],
            "angle": 0,
            "content": "a) \\( abc * + \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.391,
                0.603,
                0.467,
                0.616
            ],
            "angle": 0,
            "content": "b) \\(xy + +\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.635,
                0.604,
                0.715,
                0.616
            ],
            "angle": 0,
            "content": "c)xy-z\\*"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.621,
                0.255,
                0.634
            ],
            "angle": 0,
            "content": "d) \\(wxyz - * /\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.391,
                0.622,
                0.47,
                0.633
            ],
            "angle": 0,
            "content": "e)ade- \\(\\text{一} _ { \\text{一} }\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.638,
                0.957,
                0.67
            ],
            "angle": 0,
            "content": "40. 用巴克斯-诺尔范式描述中缀记法中表达式的语法，其中运算符和标识符与练习39前的导言中后缀表达式的BNF相同，但对用作因子的表达式必须加括号。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.673,
                0.85,
                0.688
            ],
            "angle": 0,
            "content": "41. 对下列字符串，判断其是否由练习 40 中的中缀表达式文法生成。若是，给出生成步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.692,
                0.233,
                0.706
            ],
            "angle": 0,
            "content": "a) \\(x + y + z\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.391,
                0.692,
                0.484,
                0.706
            ],
            "angle": 0,
            "content": "b) \\(a / b + c / d\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.635,
                0.693,
                0.742,
                0.706
            ],
            "angle": 0,
            "content": "c) \\(m*(n + p)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.71,
                0.284,
                0.724
            ],
            "angle": 0,
            "content": "\\(\\mathbf{d}) + m - n + p - q\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.391,
                0.71,
                0.544,
                0.724
            ],
            "angle": 0,
            "content": "e \\((m + n)*(p - q)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.727,
                0.957,
                0.76
            ],
            "angle": 0,
            "content": "42. 设 \\(G\\) 是一个文法，\\(R\\) 是一个关系，有序对 \\((w_0, w_1) \\in R\\) 当且仅当 \\(w_1\\) 可以从 \\(w_0\\) 在 \\(G\\) 中直接派生出来。求 \\(R\\) 的自反传递闭包。"
        },
        {
            "type": "title",
            "bbox": [
                0.111,
                0.777,
                0.434,
                0.797
            ],
            "angle": 0,
            "content": "13.2 带输出的有限状态机"
        },
        {
            "type": "title",
            "bbox": [
                0.111,
                0.808,
                0.251,
                0.825
            ],
            "angle": 0,
            "content": "13.2.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.829,
                0.96,
                0.94
            ],
            "angle": 0,
            "content": "许多种机器，包括计算机的某些部件，都可以用有限状态机作为模型。经常用来作为模型的有限状态机也有多种形式，但所有这些形式都包括一个有限的状态集合（其中有一个指定的初始状态）、一个输入字母表和一个转移函数（对每个由状态和输入构成的对指定下一个状态）。有限状态机广泛应用于计算机科学和数据网络中。例如，有限状态机是许多程序的基础，如拼写检查、语法检查、索引或搜索大的文本、语音识别、采用XML和HTML等标记语言转换文本，以及规范计算机如何通信的网络协议。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.692,
                0.031,
                0.802,
                0.047
            ],
            "angle": 0,
            "content": "计算模型"
        },
        {
            "type": "page_number",
            "bbox": [
                0.849,
                0.033,
                0.884,
                0.047
            ],
            "angle": 0,
            "content": "759"
        },
        {
            "type": "text",
            "bbox": [
                0.069,
                0.088,
                0.911,
                0.123
            ],
            "angle": 0,
            "content": "本节将研究产生输出的有限状态机。我们将介绍如何使用有限状态机为机器建模，包括自动售货机、输入延迟机、整数加法器以及判断比特串是否包含指定模式的机器。"
        },
        {
            "type": "text",
            "bbox": [
                0.068,
                0.126,
                0.914,
                0.219
            ],
            "angle": 0,
            "content": "在给出形式化定义之前，先说明怎么建立自动售货机的模型。自动售货机可以接受5分、1角和25分硬币。如果将30分或更多硬币投到机器里，则机器立刻退出超过30分的部分。如果顾客投放了30分且超出部分已被退还，则顾客可以按橙色按钮得到一罐橘子汁，或者按红色按钮得到一罐苹果汁。可以如下描述这个机器是怎么工作的：详细描述它的状态，且说明它在接受输入后怎么改变状态，还要说明对输入和当前状态的各种组合所产生的输出。"
        },
        {
            "type": "text",
            "bbox": [
                0.068,
                0.221,
                0.915,
                0.277
            ],
            "angle": 0,
            "content": "这个机器可能处于7种不同状态 \\(s_i (i = 0, 1, 2, \\dots, 6)\\)，其中状态 \\(s_i\\) 指机器已经收集了5i分。机器以表示收集了0分的状态 \\(s_0\\) 开始。输入可能是：5分、1角、25分、橙色钮(O)或红色钮(R)。输出可能是：空(n)、5分、1角、15分、20分、25分、一罐橘子汁或一罐苹果汁。"
        },
        {
            "type": "text",
            "bbox": [
                0.068,
                0.278,
                0.915,
                0.372
            ],
            "angle": 0,
            "content": "本例子将说明此机器的模型是怎么工作的。假设一个学生先投入了1角，又投入了25分，得到了5分的找赎，然后按橙色按钮就得到一罐橘子汁。机器从状态 \\(s_0\\) 开始。它的第一个输入是10分，这就将机器的状态改变为 \\(s_2\\) ，但没有输出。第二个输入是25分，这将状态从 \\(s_2\\) 改变为 \\(s_6\\) ，并返回5分作为输出。下一个输入是橙色按钮，它将状态从 \\(s_6\\) 改回到 \\(s_0\\) （因为机器返回到初始状态），并送出一罐橘子汁作为输出。"
        },
        {
            "type": "text",
            "bbox": [
                0.069,
                0.373,
                0.913,
                0.41
            ],
            "angle": 0,
            "content": "可以将机器的所有这些状态变化和输出用一个表来表示。为此，对状态和输入的每个组合，我们都需要指明下一个状态和产生的输出。表1对每对状态和输入都指明了转移和输出。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.38,
                0.42,
                0.6,
                0.435
            ],
            "angle": 0,
            "content": "表 1 自动售货机的状态表"
        },
        {
            "type": "table",
            "bbox": [
                0.069,
                0.437,
                0.915,
                0.589
            ],
            "angle": 0,
            "content": "<table><tr><td rowspan=\"3\">状态</td><td colspan=\"5\">下一个状态</td><td colspan=\"5\">输出</td></tr><tr><td colspan=\"5\">输入</td><td colspan=\"5\">输入</td></tr><tr><td>5</td><td>10</td><td>25</td><td>O</td><td>R</td><td>5</td><td>10</td><td>25</td><td>O</td><td>R</td></tr><tr><td>s0</td><td>s1</td><td>s2</td><td>s5</td><td>s0</td><td>s0</td><td>n</td><td>n</td><td>n</td><td>n</td><td>n</td></tr><tr><td>s1</td><td>s2</td><td>s3</td><td>s6</td><td>s1</td><td>s1</td><td>n</td><td>n</td><td>n</td><td>n</td><td>n</td></tr><tr><td>s2</td><td>s3</td><td>s4</td><td>s6</td><td>s2</td><td>s2</td><td>n</td><td>n</td><td>5</td><td>n</td><td>n</td></tr><tr><td>s3</td><td>s4</td><td>s5</td><td>s6</td><td>s3</td><td>s3</td><td>n</td><td>n</td><td>10</td><td>n</td><td>n</td></tr><tr><td>s4</td><td>s5</td><td>s6</td><td>s6</td><td>s4</td><td>s4</td><td>n</td><td>n</td><td>15</td><td>n</td><td>n</td></tr><tr><td>s5</td><td>s6</td><td>s6</td><td>s6</td><td>s5</td><td>s5</td><td>n</td><td>5</td><td>20</td><td>n</td><td>n</td></tr><tr><td>s6</td><td>s6</td><td>s6</td><td>s6</td><td>s0</td><td>s0</td><td>5</td><td>10</td><td>25</td><td>OJ</td><td>AJ</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.069,
                0.603,
                0.913,
                0.639
            ],
            "angle": 0,
            "content": "说明机器动作的另一个方法是使用边带有标号的有向图，其中状态表示为小圈，边表示转移，并用输入和转移产生的输出对边进行标号。自动售货机的有向图如图1所示。"
        },
        {
            "type": "image",
            "bbox": [
                0.099,
                0.642,
                0.887,
                0.86
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.418,
                0.863,
                0.565,
                0.879
            ],
            "angle": 0,
            "content": "图1自动售货机"
        },
        {
            "type": "title",
            "bbox": [
                0.07,
                0.897,
                0.364,
                0.914
            ],
            "angle": 0,
            "content": "13.2.2 带输出的有限状态机"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.917,
                0.512,
                0.934
            ],
            "angle": 0,
            "content": "现在给出带输出的有限状态机的形式化定义。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.115,
                0.035,
                0.151,
                0.048
            ],
            "angle": 0,
            "content": "760"
        },
        {
            "type": "header",
            "bbox": [
                0.196,
                0.033,
                0.272,
                0.049
            ],
            "angle": 0,
            "content": "第13章"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.095,
                0.925,
                0.173
            ],
            "angle": 0,
            "content": "定义1 有限状态机 \\(M = (S, I, O, f, g, s_0)\\) 由如下部分组成：一个有限的状态集合 \\(S\\)；一个有限的输入字母表 \\(I\\)；一个有限的输出字母表 \\(O\\)；一个转移函数 \\(f, f\\) 为每个状态和输入对指派一个新状态；一个输出函数 \\(g, g\\) 为每个状态和输入对指派一个输出；还有一个初始状态 \\(s_0\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.181,
                0.931,
                0.218
            ],
            "angle": 0,
            "content": "设 \\(M = (S, I, O, f, g, s_0)\\) 是一个有限状态机。可以用状态表来表示状态函数 \\(f\\) 和输出函数 \\(g\\) 的值。在本节引言中，我们已经构造了自动售货机的状态表。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.223,
                0.931,
                0.262
            ],
            "angle": 0,
            "content": "例1 表2中的状态表描述了一个有限状态机，其中 \\( S = \\{s_0, s_1, s_2, s_3\\} \\) 、 \\( I = \\{0, 1\\} \\) 、 \\( O = \\{0, 1\\} \\) 。转移函数 \\( f \\) 的值在前两列给出，输出函数 \\( g \\) 的值在后两列给出。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.265,
                0.931,
                0.302
            ],
            "angle": 0,
            "content": "表示有限状态机的另一种方法是状态图，这是一个边带有标号的有向图。在这个图中，状态由圈表示，转移由带输入和输出对标号的箭头表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.306,
                0.605,
                0.324
            ],
            "angle": 0,
            "content": "例2 构造状态表如表2所示的有限状态机的状态图。"
        },
        {
            "type": "text",
            "bbox": [
                0.129,
                0.329,
                0.451,
                0.346
            ],
            "angle": 0,
            "content": "解 这个机器的状态图如图2所示。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.266,
                0.349,
                0.317,
                0.362
            ],
            "angle": 0,
            "content": "表2"
        },
        {
            "type": "table",
            "bbox": [
                0.125,
                0.366,
                0.459,
                0.522
            ],
            "angle": 0,
            "content": "<table><tr><td rowspan=\"3\">状态</td><td colspan=\"2\">f</td><td colspan=\"2\">g</td></tr><tr><td colspan=\"2\">输入</td><td colspan=\"2\">输入</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>s0</td><td>s1</td><td>s0</td><td>1</td><td>0</td></tr><tr><td>s1</td><td>s3</td><td>s0</td><td>1</td><td>1</td></tr><tr><td>s2</td><td>s1</td><td>s2</td><td>0</td><td>1</td></tr><tr><td>s3</td><td>s2</td><td>s1</td><td>0</td><td>0</td></tr></table>"
        },
        {
            "type": "image",
            "bbox": [
                0.545,
                0.35,
                0.89,
                0.506
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.56,
                0.51,
                0.875,
                0.527
            ],
            "angle": 0,
            "content": "图2表2所示的有限状态机的状态图"
        },
        {
            "type": "text",
            "bbox": [
                0.129,
                0.541,
                0.628,
                0.559
            ],
            "angle": 0,
            "content": "例3 构造如图3中状态图所示的有限状态机的状态表。"
        },
        {
            "type": "text",
            "bbox": [
                0.129,
                0.564,
                0.451,
                0.581
            ],
            "angle": 0,
            "content": "解 这个机器的状态表如表3所示。"
        },
        {
            "type": "image",
            "bbox": [
                0.141,
                0.589,
                0.593,
                0.759
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.293,
                0.765,
                0.441,
                0.781
            ],
            "angle": 0,
            "content": "图3 有限状态机"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.746,
                0.588,
                0.797,
                0.602
            ],
            "angle": 0,
            "content": "表3"
        },
        {
            "type": "table",
            "bbox": [
                0.639,
                0.604,
                0.905,
                0.781
            ],
            "angle": 0,
            "content": "<table><tr><td rowspan=\"3\">状态</td><td colspan=\"2\">f</td><td colspan=\"2\">g</td></tr><tr><td colspan=\"2\">输入</td><td colspan=\"2\">输入</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>s0</td><td>s1</td><td>s3</td><td>1</td><td>0</td></tr><tr><td>s1</td><td>s1</td><td>s2</td><td>1</td><td>1</td></tr><tr><td>s2</td><td>s3</td><td>s4</td><td>0</td><td>0</td></tr><tr><td>s3</td><td>s1</td><td>s0</td><td>0</td><td>0</td></tr><tr><td>s4</td><td>s3</td><td>s4</td><td>0</td><td>0</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.797,
                0.937,
                0.852
            ],
            "angle": 0,
            "content": "一个输入字符串使初始状态经历一系列状态，这些状态都是由转移函数确定的。当我们（从左向右）一个符号一个符号地读输入字符串时，每个输入符号都使机器从一个状态变为另一个状态。因为每个转移产生一个输出，所以一个输入字符串产生一个输出字符串。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.855,
                0.939,
                0.933
            ],
            "angle": 0,
            "content": "设输入字符串为 \\(x = x_{1}x_{2}\\dots x_{k}\\) 。读这个输入使得机器从状态 \\(s_0\\) 变为状态 \\(s_1\\) ，其中 \\(s_1 = f(s_0,x_1)\\) 然后变为状态 \\(s_2\\) ，其中 \\(s_2 = f(s_1,x_2)\\) ，以此类推，对于 \\(j = 1,2,\\dots ,k\\) ， \\(s_j = f(s_{j - 1},x_j)\\) ，最后，以状态 \\(s_k = f(s_{k - 1},x_k)\\) 结束。这个转移序列就产生了输出字符串 \\(y = y_{1}y_{2}\\dots y_{k}\\) ，其中 \\(y_{1} = g(s_{0},x_{1})\\) 是对应于从 \\(s_0\\) 到 \\(s_1\\) 的转移的输出， \\(y_{2} = g(s_{1},x_{2})\\) 是对应于从 \\(s_1\\) 到 \\(s_2\\) 的转移的输出，等等。一般地，"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.679,
                0.036,
                0.789,
                0.052
            ],
            "angle": 0,
            "content": "计算模型"
        },
        {
            "type": "page_number",
            "bbox": [
                0.836,
                0.037,
                0.871,
                0.052
            ],
            "angle": 0,
            "content": "761"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.092,
                0.901,
                0.129
            ],
            "angle": 0,
            "content": "\\(y_{j} = g(s_{j - 1},x_{j}), j = 1,2,\\dots ,k.\\) 。这样，我们可以将输出函数 \\(g\\) 的定义扩展到输入字符串，即定义 \\(g(x) = y\\) ，其中 \\(y\\) 是对应于输入字符串 \\(x\\) 的输出。在许多应用中，这个记法都很有用。"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.133,
                0.826,
                0.152
            ],
            "angle": 0,
            "content": "例4 对于图3表示的有限状态机，求其对输入字符串101011生成的输出字符串。"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.155,
                0.603,
                0.173
            ],
            "angle": 0,
            "content": "解 输出是001000。状态和输出的逐次变化如表4所示。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.452,
                0.184,
                0.502,
                0.198
            ],
            "angle": 0,
            "content": "表4"
        },
        {
            "type": "table",
            "bbox": [
                0.053,
                0.2,
                0.902,
                0.262
            ],
            "angle": 0,
            "content": "<table><tr><td>输入</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>—</td></tr><tr><td>状态</td><td>s0</td><td>s3</td><td>s1</td><td>s2</td><td>s3</td><td>s0</td><td>s3</td></tr><tr><td>输出</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>—</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.276,
                0.901,
                0.332
            ],
            "angle": 0,
            "content": "我们现在来看几个有限状态机的有用例子。例5、例6和例7表示了内存容量受限的有限状态机的状态。这些状态用来记住机器读取的符号的属性。然而，由于状态数有限，所以有限状态机不能用于一些重要的目的。这一点会在13.4节中讲到。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.336,
                0.901,
                0.395
            ],
            "angle": 0,
            "content": "例5 单位延迟机是许多电子装置中的一个重要部件，它将输入字符串延迟一定的时间量后输出。怎么构造一个有限状态机使其将输入字符串延迟一个单位时间呢？即，对于输入的比特串 \\(x_{1}x_{2}\\dots x_{k}\\)，怎么才能输出比特串 \\(0x_{1}x_{2}\\dots x_{k - 1}\\)？"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.397,
                0.901,
                0.512
            ],
            "angle": 0,
            "content": "解 可以如下构造一个延迟机：它有两种可能的输入，即0和1；它还必须有一个初始状态 \\( s_0 \\) 。因为它还要记住前一个输入是0还是1，所以它还需要另外两个状态 \\( s_1 \\) 和 \\( s_2 \\)，使得如果前一个输入是1，则机器处于状态 \\( s_1 \\)，如果前一个输入是0，则机器处于状态 \\( s_2 \\) 。从 \\( s_0 \\) 出发的第一个转移产生输出0，从 \\( s_1 \\) 出发的每个转移都产生输出1，从 \\( s_2 \\) 出发的每个转移都产生输出0。则对应于输入字符串 \\( x_1x_2\\dots x_k \\) 的输出是这样的一个字符串：从0开始，后面跟 \\( x_1 \\)，再跟 \\( x_2 \\)，…，最后以 \\( x_{k-1} \\) 结束。这个机器的状态图如4所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.516,
                0.836,
                0.534
            ],
            "angle": 0,
            "content": "例6 试构造一个有限状态机，使其利用正整数的二进制展开式将两个正整数相加。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.538,
                0.901,
                0.614
            ],
            "angle": 0,
            "content": "解 按如下过程将 \\((x_{n}\\dots x_{1}x_{0})_{2}\\) 和 \\((y_{n}\\dots y_{1}y_{0})_{2}\\) 相加（如4.2节所描述）：首先，将 \\(x_0\\) 和 \\(y_{0}\\) 相加，产生和 \\(z_{0}\\) 与进位 \\(c_{0}\\)，且此进位要么是0，要么是1；然后将 \\(x_{1},y_{1}\\) 连同进位 \\(c_{0}\\) 一起相加，产生和 \\(z_{1}\\) 与进位 \\(c_{1}\\)；将这个过程一直进行下去；第 \\(n\\) 步将 \\(x_{n},y_{n}\\) 连同前一个进位 \\(c_{n - 1}\\) 一起相加，产生和 \\(z_{n}\\) 与进位 \\(c_{n}\\)，\\(c_{n}\\) 也就是和 \\(z_{n + 1}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.616,
                0.901,
                0.672
            ],
            "angle": 0,
            "content": "只用两个状态就能构造执行这个加法的有限状态机。为了简单起见，假设两个初始位 \\(x_{n}\\) 和 \\(y_{n}\\) 都是0（否则，必须对和 \\(z_{n + 1}\\) 做特殊安排）。我们用初始状态 \\(s_0\\) 表示前一个进位是0（或者是最右边位的加法），用另一个状态 \\(s_1\\) 表示前一个进位是1。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.674,
                0.901,
                0.769
            ],
            "angle": 0,
            "content": "因为这个机器的输入是一对二进制数，所以只有4种可能的输入。这4种可能的输入为：00（两位都是0）、01（第一位为0，第二位为1）、10（第一位为1，第二位为0）和11（两位都是1）。转移和输出是根据下面两个因素来构造的：一个是输入所表示的两位的和，另一个是状态所表示的进位。例如，当机器处于状态 \\( s_1 \\) 且所接受的输入是01时，则下一个状态是 \\( s_1 \\) 且输出是0，因为所产生的和是 \\( 0 + 1 + 1 = (10)_2 \\) 。此机器的状态图如图5所示。"
        },
        {
            "type": "image",
            "bbox": [
                0.166,
                0.774,
                0.358,
                0.884
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.186,
                0.891,
                0.334,
                0.906
            ],
            "angle": 0,
            "content": "图4 单位延迟机"
        },
        {
            "type": "image",
            "bbox": [
                0.578,
                0.778,
                0.814,
                0.884
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.583,
                0.891,
                0.807,
                0.907
            ],
            "angle": 0,
            "content": "图5 做加法的有限状态机"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.916,
                0.901,
                0.934
            ],
            "angle": 0,
            "content": "例7 在某种编码方法中，当一个信息中出现了3个连续的1时，信息接收器就知道已经"
        },
        {
            "type": "image",
            "bbox": [
                0.915,
                0.539,
                0.946,
                0.565
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.133,
                0.039,
                0.17,
                0.053
            ],
            "angle": 0,
            "content": "762"
        },
        {
            "type": "header",
            "bbox": [
                0.215,
                0.038,
                0.291,
                0.053
            ],
            "angle": 0,
            "content": "第13章"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.095,
                0.951,
                0.129
            ],
            "angle": 0,
            "content": "发生了一个传送错误。试构造一个有限状态机，使得它输出1当且仅当它所接收的最后3位都是1。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.133,
                0.951,
                0.187
            ],
            "angle": 0,
            "content": "解 这个机器需要3个状态。初始状态 \\( s_0 \\) 记住前一个不是1的输入值（如果存在）；状态 \\( s_1 \\) 记住前一个是1，但再前一个输入（如果存在）不是1的输入值；状态 \\( s_2 \\) 记住前两个都是1的输入值。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.19,
                0.951,
                0.206
            ],
            "angle": 0,
            "content": "输入一个1将状态 \\(s_0\\) 变为 \\(s_1\\) ，因为机器现在读到的是单个的1，而不是两个连续的1；它"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.209,
                0.529,
                0.376
            ],
            "angle": 0,
            "content": "将 \\(s_1\\) 变为 \\(s_2\\) ，因为它现在读到了两个连续的1；它还将 \\(s_2\\) 变为 \\(s_2\\) 本身，当它已经至少读到了两个连续的1。输入一个0将每个状态都变为 \\(s_0\\) ，因为这打断了任何由连续1构成的字符串。如果现在机器所读的是1，则由 \\(s_2\\) 到 \\(s_2\\) 自身的转移所产生的输出为1，因为此状态与输入的组合表明机器已经读到了3个连续的1。其他情形的输出都是0。此机器的状态图如图6所示。"
        },
        {
            "type": "image",
            "bbox": [
                0.545,
                0.213,
                0.954,
                0.33
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.551,
                0.339,
                0.945,
                0.371
            ],
            "angle": 0,
            "content": "图6一个有限状态机，它输出1当且仅当所读的输入串以111结尾"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.381,
                0.951,
                0.416
            ],
            "angle": 0,
            "content": "例7所构造的有限状态机的最终输出是1，当且仅当输入字符串以111作为结束。因此，我们说有限状态机能够识别以111作为结束的字符串。这就引出定义2。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.426,
                0.945,
                0.482
            ],
            "angle": 0,
            "content": "定义2 令 \\(M = (S, I, O, f, g, s_0)\\) 是一个有限状态机，并且 \\(L \\subseteq I^*\\)，那么当输入串 \\(x \\in L\\)，并且当且仅当 \\(x\\) 作为 \\(M\\) 的输入，\\(M\\) 的最后一个输出位是1时，我们说有限状态机 \\(M\\) 能够识别（或接受）\\(L\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.491,
                0.953,
                0.603
            ],
            "angle": 0,
            "content": "有限状态机的类型 为了建立计算机的模型，人们开发了许多种不同的有限状态机。本节给出了一类有限状态机的定义，在这种类型的机器中，输出与状态之间的转移相对应，这种类型的机器称为米兰机（Mealy machine），因为它是由米兰(G.H.Mealy)在1955年首先研究的。还有另外一类重要的带输出的有限状态机，其输出仅仅由状态确定，这种类型的有限状态机称为摩尔机(Moore machine)，因为它是摩尔(E.F.Moore)在1956年提出的。本节结尾有一系列练习讨论摩尔机。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.606,
                0.953,
                0.68
            ],
            "angle": 0,
            "content": "例7说明了怎么用米兰机来识别语言。然而，我们通常用另一种不带输出的有限状态机来识别语言。不带输出的有限状态机也称为有限状态自动机，它有一个由终结状态组成的集合，它识别一个字符串当且仅当该字符串能够将初始状态变为一个终结状态。13.3节将讨论这种类型的有限状态机。"
        },
        {
            "type": "title",
            "bbox": [
                0.106,
                0.692,
                0.154,
                0.707
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.711,
                0.496,
                0.726
            ],
            "angle": 0,
            "content": "1. 画出具有下列状态表的有限状态机的状态图。"
        },
        {
            "type": "text",
            "bbox": [
                0.129,
                0.731,
                0.15,
                0.743
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "table",
            "bbox": [
                0.151,
                0.764,
                0.321,
                0.87
            ],
            "angle": 0,
            "content": "<table><tr><td></td><td></td><td></td></tr><tr><td>输入</td><td>输入</td><td></td></tr><tr><td>0 1</td><td>0 1</td><td></td></tr><tr><td>s0 s1 s2</td><td>s1 s0 s2</td><td>0 1 0 1</td></tr><tr><td>s0 s1</td><td>s0 s1</td><td>0 0</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.426,
                0.731,
                0.446,
                0.743
            ],
            "angle": 0,
            "content": "b)"
        },
        {
            "type": "table",
            "bbox": [
                0.446,
                0.756,
                0.614,
                0.879
            ],
            "angle": 0,
            "content": "<table><tr><td rowspan=\"3\">状态</td><td colspan=\"2\">f</td><td colspan=\"2\">g</td></tr><tr><td colspan=\"2\">输入</td><td colspan=\"2\">输入</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>s0</td><td>s1</td><td>s0</td><td>0</td><td>0</td></tr><tr><td>s1</td><td>s2</td><td>s0</td><td>1</td><td>1</td></tr><tr><td>s2</td><td>s0</td><td>s3</td><td>0</td><td>1</td></tr><tr><td>s3</td><td>s1</td><td>s2</td><td>1</td><td>0</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.724,
                0.731,
                0.742,
                0.743
            ],
            "angle": 0,
            "content": "c)"
        },
        {
            "type": "table",
            "bbox": [
                0.749,
                0.747,
                0.917,
                0.887
            ],
            "angle": 0,
            "content": "<table><tr><td rowspan=\"3\">状态</td><td colspan=\"2\">f</td><td colspan=\"2\">g</td></tr><tr><td colspan=\"2\">输入</td><td colspan=\"2\">输入</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>s0</td><td>s0</td><td>s4</td><td>1</td><td>1</td></tr><tr><td>s1</td><td>s0</td><td>s3</td><td>0</td><td>1</td></tr><tr><td>s2</td><td>s0</td><td>s2</td><td>0</td><td>0</td></tr><tr><td>s3</td><td>s1</td><td>s1</td><td>1</td><td>1</td></tr><tr><td>s4</td><td>s1</td><td>s0</td><td>1</td><td>0</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.903,
                0.495,
                0.918
            ],
            "angle": 0,
            "content": "2. 给出具有下列状态图的有限状态机的状态表。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.693,
                0.034,
                0.803,
                0.05
            ],
            "angle": 0,
            "content": "计算模型"
        },
        {
            "type": "page_number",
            "bbox": [
                0.849,
                0.036,
                0.884,
                0.049
            ],
            "angle": 0,
            "content": "763"
        },
        {
            "type": "image",
            "bbox": [
                0.088,
                0.09,
                0.379,
                0.216
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.496,
                0.09,
                0.754,
                0.222
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.088,
                0.23,
                0.414,
                0.352
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.36,
                0.695,
                0.374
            ],
            "angle": 0,
            "content": "3. 对于具有下列状态表的有限状态机，确定输入字符串 01110 所产生的输出："
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.378,
                0.171,
                0.392
            ],
            "angle": 0,
            "content": "a)练习1a"
        },
        {
            "type": "text",
            "bbox": [
                0.333,
                0.378,
                0.416,
                0.392
            ],
            "angle": 0,
            "content": "b)练习1b"
        },
        {
            "type": "text",
            "bbox": [
                0.561,
                0.378,
                0.641,
                0.392
            ],
            "angle": 0,
            "content": "c)练习1c"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.396,
                0.695,
                0.41
            ],
            "angle": 0,
            "content": "4. 对于具有下列状态图的有限状态机，确定输入字符串10001所产生的输出："
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.414,
                0.171,
                0.428
            ],
            "angle": 0,
            "content": "a)练习2a"
        },
        {
            "type": "text",
            "bbox": [
                0.333,
                0.414,
                0.416,
                0.428
            ],
            "angle": 0,
            "content": "b)练习2b"
        },
        {
            "type": "text",
            "bbox": [
                0.561,
                0.414,
                0.641,
                0.428
            ],
            "angle": 0,
            "content": "c)练习2c"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.432,
                0.676,
                0.446
            ],
            "angle": 0,
            "content": "5. 在例2所给的有限状态机中，对于下列每个输入字符串，试确定其输出。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.451,
                0.147,
                0.464
            ],
            "angle": 0,
            "content": "a)0111"
        },
        {
            "type": "text",
            "bbox": [
                0.333,
                0.451,
                0.427,
                0.463
            ],
            "angle": 0,
            "content": "b)11011011"
        },
        {
            "type": "text",
            "bbox": [
                0.561,
                0.451,
                0.681,
                0.463
            ],
            "angle": 0,
            "content": "c)01010101010"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.468,
                0.676,
                0.482
            ],
            "angle": 0,
            "content": "6. 在例3所给的有限状态机中，对于下列每个输入字符串，试确定其输出。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.487,
                0.147,
                0.499
            ],
            "angle": 0,
            "content": "a)0000"
        },
        {
            "type": "text",
            "bbox": [
                0.333,
                0.487,
                0.411,
                0.5
            ],
            "angle": 0,
            "content": "b)101010"
        },
        {
            "type": "text",
            "bbox": [
                0.561,
                0.487,
                0.681,
                0.5
            ],
            "angle": 0,
            "content": "c)11011100010"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.504,
                0.915,
                0.554
            ],
            "angle": 0,
            "content": "7. 试构造一个有限状态机作为下列饮料机的模型：饮料机接受5分、1角和25分的硬币，一直到接受了35分钱币时才开始找回零钱，退出超过35分的所有钱币。然后顾客就可以按某些按钮，得到一听可乐，或一瓶软饮料，或一瓶姜汁啤酒。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.558,
                0.915,
                0.626
            ],
            "angle": 0,
            "content": "8. 试构造一个有限状态机作为下列售报机的模型：它有一个门，此门只在下列两种情形下才可打开：一是放入了3个1角硬币（和任意数量的其他硬币）；二是放入了一个25分的硬币和一个5分的硬币（和任意数量的其他硬币）。一旦门能够被打开，顾客就打开门，取出一份报纸，再关上门。不管塞进去多少额外的钱币，机器都不找回零钱。下一个顾客重新开始时也不能使用上一位多余的钱。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.63,
                0.649,
                0.644
            ],
            "angle": 0,
            "content": "9.构造一个有限状态机，将输入延迟两位，且以00作为输出的头两位。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.649,
                0.89,
                0.662
            ],
            "angle": 0,
            "content": "10.构造一个有限状态机，对输入字符串每隔一位改变一次值，且从第二位开始。但保持其他位不变。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.666,
                0.915,
                0.698
            ],
            "angle": 0,
            "content": "11. 构造一个有限状态机来模拟计算机的登录过程：用户首先输入用户标识码，然后输入口令；用户标识码和口令分别被看作一个输入；如果输入的口令不对，则要求用户重新输入用户标识码。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.703,
                0.915,
                0.751
            ],
            "angle": 0,
            "content": "12. 构造一个有限状态机来模拟组合锁，此锁包含数 1 到 40，只有在输入正确的组合时才能被打开，正确组合是：10 次右，8 次左，37 次右。每个输入都是“一个数、旋转方向、在此方向旋转锁的次数”构成的三元组。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.757,
                0.915,
                0.788
            ],
            "angle": 0,
            "content": "13. 构造一个有限状态机来模拟下列道路收费机：放入25分钱币之后此机器将打开一个门。可以使用面额为5分、1角和25分的硬币。不找零钱，多于25分的超额部分也不提供下一位驾驶者使用。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.793,
                0.915,
                0.842
            ],
            "angle": 0,
            "content": "14. 构造一个有限状态机模拟自动出纳机（ATM）的密码登录过程：用户输入一个4位数的字符串，一次输入一个数字。如果用户正确输入这4个数字的口令，ATM显示欢迎界面。当用户输入不正确时，ATM提示用户密码输入错误。如果用户输入错误密码3次，账户就被锁定。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.847,
                0.915,
                0.897
            ],
            "angle": 0,
            "content": "15. 构造一个有限状态机来模拟有一定限制的电话交换系统，发送到网络的电话号码要求是以0、911和1开头，后跟以212、800、866、877和888开始的10位电话号码。所有其他数字串都被系统锁定，并且用户会听到一个报错信息。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.902,
                0.861,
                0.915
            ],
            "angle": 0,
            "content": "16.构造一个有限状态机，当读取的输入符号所代表的数能够被3整除时，输出1；否则，输出0。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.919,
                0.915,
                0.933
            ],
            "angle": 0,
            "content": "17. 构造一个有限状态机，确定在输入字符串中当前所读取的最后一个符号是否为 1，且倒数第三个符号"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.115,
                0.036,
                0.151,
                0.05
            ],
            "angle": 0,
            "content": "764"
        },
        {
            "type": "header",
            "bbox": [
                0.197,
                0.035,
                0.274,
                0.051
            ],
            "angle": 0,
            "content": "第13章"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.092,
                0.202,
                0.106
            ],
            "angle": 0,
            "content": "是否为0。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.11,
                0.904,
                0.124
            ],
            "angle": 0,
            "content": "18. 构造一个有限状态机，确定到目前为止所读取的输入字符串中，其结尾是否有至少 5 个连续的 1。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.128,
                0.932,
                0.16
            ],
            "angle": 0,
            "content": "19. 构造一个有限状态机，确定到目前为止所读取的输入中，其最后的 8 个字符是否为 computer。输入可能是任意的英文字母。"
        },
        {
            "type": "list",
            "bbox": [
                0.085,
                0.11,
                0.932,
                0.16
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.163,
                0.934,
                0.249
            ],
            "angle": 0,
            "content": "摩尔机 \\(M = (S, I, O, f, g, s_0)\\) 由下列6部分构成：有限状态集 \\(S\\)；输入字母表 \\(I\\)；输出字母表 \\(O\\)；转移函数 \\(f\\)，它将每个由状态和输入组成的对映射为下一个状态；输出函数 \\(g\\)，它对每个状态指定一个输出；初始状态 \\(s_0\\)。摩尔机可以用状态表来表示，也可以用状态图来表示。状态表列出对应于每个状态和输入对的转移，以及对每个状态的输出。状态图画出状态、状态之间的转移以及状态的输出。在状态图中，转移用标记着输入的箭头表示，输出写在状态的旁边。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.254,
                0.503,
                0.267
            ],
            "angle": 0,
            "content": "20. 构造具有右表所示的状态表的摩尔机的状态图。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.271,
                0.934,
                0.303
            ],
            "angle": 0,
            "content": "21. 构造具有右表所示的状态图的摩尔机的状态表。对每个输入字符串，摩尔机都产生一个输出字符串。特别地，对应于输入字符串 \\(a_1a_2\\dots a_k\\) 的输出是 \\(g(s_0)g(s_1)\\dots g(s_k)\\)，其中 \\(s_i = f(s_{i - 1},a_i), i = 1,2,\\dots ,k\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.307,
                0.697,
                0.321
            ],
            "angle": 0,
            "content": "22. 对于下列每个输入字符串，求练习 20 中的摩尔机所生成的输出字符串。"
        },
        {
            "type": "list",
            "bbox": [
                0.085,
                0.254,
                0.934,
                0.321
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.326,
                0.177,
                0.339
            ],
            "angle": 0,
            "content": "a)0101"
        },
        {
            "type": "text",
            "bbox": [
                0.354,
                0.326,
                0.421,
                0.339
            ],
            "angle": 0,
            "content": "b)11111"
        },
        {
            "type": "text",
            "bbox": [
                0.582,
                0.326,
                0.702,
                0.339
            ],
            "angle": 0,
            "content": "c)11101110111"
        },
        {
            "type": "table",
            "bbox": [
                0.15,
                0.353,
                0.447,
                0.493
            ],
            "angle": 0,
            "content": "<table><tr><td rowspan=\"3\">状态</td><td colspan=\"2\">f</td><td rowspan=\"3\">g</td></tr><tr><td colspan=\"2\">输入</td></tr><tr><td>0</td><td>1</td></tr><tr><td>s0</td><td>s0</td><td>s2</td><td>0</td></tr><tr><td>s1</td><td>s3</td><td>s0</td><td>1</td></tr><tr><td>s2</td><td>s2</td><td>s1</td><td>1</td></tr><tr><td>s3</td><td>s2</td><td>s0</td><td>1</td></tr></table>"
        },
        {
            "type": "image",
            "bbox": [
                0.542,
                0.345,
                0.767,
                0.493
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.509,
                0.761,
                0.523
            ],
            "angle": 0,
            "content": "23. 对于练习 22 中的每个输入字符串，求练习 21 中的摩尔机所生成的输出字符串。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.527,
                0.72,
                0.541
            ],
            "angle": 0,
            "content": "24. 构造一个摩尔机，只要读取的输入符号的个数能够被 4 整除时，就输出 1。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.544,
                0.934,
                0.576
            ],
            "angle": 0,
            "content": "25. 构造一个摩尔机，使其能够判断输入字符串是包含偶数个1还是奇数个1。如果输入字符串中有偶数个1，则输出1；如果输入字符串中有奇数个1，则输出0。"
        },
        {
            "type": "list",
            "bbox": [
                0.085,
                0.509,
                0.934,
                0.576
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.089,
                0.592,
                0.436,
                0.612
            ],
            "angle": 0,
            "content": "13.3 不带输出的有限状态机"
        },
        {
            "type": "title",
            "bbox": [
                0.09,
                0.619,
                0.228,
                0.636
            ],
            "angle": 0,
            "content": "13.3.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.64,
                0.935,
                0.732
            ],
            "angle": 0,
            "content": "有限状态机的最重要应用之一是语言识别。在设计和构造程序设计语言的编译器时，这个应用起着根本性的作用。在13.2节中，我们说明了可以用带输出的有限状态机来识别语言，方法是当读取的输入字符串在语言中时输出1，否则输出0。但是，还有一些其他类型的有限状态机，它们是为识别语言而专门设计的。这些机器不产生输出，但有终结状态。一个串能被它识别，当且仅当它把初始状态转变为终结状态之一。"
        },
        {
            "type": "title",
            "bbox": [
                0.09,
                0.743,
                0.273,
                0.76
            ],
            "angle": 0,
            "content": "13.3.2 串的集合"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.764,
                0.934,
                0.799
            ],
            "angle": 0,
            "content": "在讨论不带输出的有限状态机之前，先介绍一些关于串的集合的重要背景材料。这里定义的运算将广泛用于有限状态机识别语言的讨论中。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.808,
                0.926,
                0.845
            ],
            "angle": 0,
            "content": "定义1 设 \\(V\\) 是一个词汇表，\\(A\\)、\\(B\\) 是 \\(V^{*}\\) 的子集。\\(A\\) 和 \\(B\\) 的连接是所有形如 \\(xy\\) 的串构成的集合，记为 \\(AB\\)，其中 \\(x\\) 是 \\(A\\) 中的串，\\(y\\) 是 \\(B\\) 中的串。"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.856,
                0.64,
                0.874
            ],
            "angle": 0,
            "content": "例1设 \\(A = \\{0,11\\}\\) ， \\(B = \\{1,10,110\\}\\) 。求AB和BA。"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.88,
                0.591,
                0.894
            ],
            "angle": 0,
            "content": "解 集合 \\(AB\\) 包括所有 \\(A\\) 中串和 \\(B\\) 中串的连接，故"
        },
        {
            "type": "equation",
            "bbox": [
                0.317,
                0.899,
                0.707,
                0.914
            ],
            "angle": 0,
            "content": "\\[\nA B = \\{0 1, 0 1 0, 0 1 1 0, 1 1 1, 1 1 1 0, 1 1 1 1 0 \\}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.917,
                0.51,
                0.933
            ],
            "angle": 0,
            "content": "集合 \\(BA\\) 包括所有 \\(B\\) 中串和 \\(A\\) 中串的连接，故"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.682,
                0.032,
                0.792,
                0.049
            ],
            "angle": 0,
            "content": "计算模型"
        },
        {
            "type": "page_number",
            "bbox": [
                0.838,
                0.034,
                0.874,
                0.047
            ],
            "angle": 0,
            "content": "765"
        },
        {
            "type": "equation",
            "bbox": [
                0.283,
                0.089,
                0.674,
                0.105
            ],
            "angle": 0,
            "content": "\\[\nB A = \\{1 0, 1 1 1, 1 0 0, 1 0 1 1, 1 1 0 0, 1 1 0 1 1 \\}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.108,
                0.807,
                0.125
            ],
            "angle": 0,
            "content": "注意，如例1所示，对于字母表 \\(V\\) 和 \\(V^{*}\\) 的子集 \\(A\\) 与 \\(B\\) ， \\(AB = BA\\) 不一定成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.128,
                0.814,
                0.144
            ],
            "angle": 0,
            "content": "由两个串集合的连接的定义还可以定义 \\(A^n (n = 0,1,2,\\dots)\\) 。其递归定义如下："
        },
        {
            "type": "equation",
            "bbox": [
                0.365,
                0.147,
                0.444,
                0.163
            ],
            "angle": 0,
            "content": "\\[\nA ^ {0} = \\{\\lambda \\}\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.366,
                0.166,
                0.632,
                0.182
            ],
            "angle": 0,
            "content": "\\[\nA ^ {n + 1} = A ^ {n} A, n = 0, 1, 2, \\dots\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.188,
                0.569,
                0.205
            ],
            "angle": 0,
            "content": "例2设 \\(A = \\{1,00\\}\\) 。当 \\(n = 0\\) ，1，2，3时，求 \\(A^n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.211,
                0.905,
                0.266
            ],
            "angle": 0,
            "content": "解 易知，\\(A^0 = \\{\\lambda\\}\\)，\\(A^1 = A^0 A = \\{\\lambda\\} A = \\{1, 00\\}\\)。为求 \\(A^2\\)，取 \\(A\\) 中元素对的连接。从而 \\(A^2 = \\{11, 100, 001, 0000\\}\\)。为求 \\(A^3\\)，取 \\(A^2\\) 和 \\(A\\) 中的元素进行连接，由此得到 \\(A^3 = \\{111, 1100, 1001, 10000, 0011, 00100, 00001, 000000\\}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.275,
                0.896,
                0.334
            ],
            "angle": 0,
            "content": "定义2 设 \\(A\\) 是 \\(V^{*}\\) 的一个子集。\\(A\\) 的克莱因闭包是 \\(A\\) 中任意多个串的连接组成的集合，记为 \\(A^{*}\\)，即 \\(A^{*} = \\bigcup_{k=0}^{\\infty} A^{k}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.344,
                0.631,
                0.362
            ],
            "angle": 0,
            "content": "例3 求集合 \\(A = \\{0\\}\\)，\\(B = \\{0, 1\\}\\)，\\(C = \\{11\\}\\) 的克莱因闭包。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.368,
                0.906,
                0.444
            ],
            "angle": 0,
            "content": "解 \\(A\\) 的克莱因闭包是0与自己的任意多次连接，故 \\(A^{*} = \\{0^{n}|n = 0,1,2,\\dots \\}\\) 。 \\(B\\) 的克莱因闭包是任意多个串的连接，但这些串只能是0或1，因此这个闭包是字母表 \\(V = \\{0,1\\}\\) 上的所有串，即 \\(B^{*} = V^{*}\\) 。最后， \\(C\\) 的克莱因闭包是11与自己的任意多次连接，所以 \\(C^*\\) 是由偶数个1组成的串的集合，即 \\(C^* = \\{1^{2n}|n = 0,1,2,\\dots \\}\\) □"
        },
        {
            "type": "title",
            "bbox": [
                0.056,
                0.454,
                0.308,
                0.472
            ],
            "angle": 0,
            "content": "13.3.3 有限状态自动机"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.475,
                0.906,
                0.549
            ],
            "angle": 0,
            "content": "现在给出不带输出的有限状态机的定义，这样的机器也叫作有限状态自动机（finite-state automata），这也是在本节中将使用的术语。（注意：automata 的单数形式是 automaton。）这些机器与 13.2 节中研究的有限状态机不同，它们不产生输出，但它们有一个终结状态集合。我们将看到，它们识别将初始状态变为终结状态的字符串。"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.557,
                0.898,
                0.634
            ],
            "angle": 0,
            "content": "定义3 有限状态自动机 \\(M = (S, I, f, s_0, F)\\) 由下列五部分组成：一个有限的状态集合 \\(S\\)；一个有限的输入字母表 \\(I\\)；一个转移函数 \\(f\\)，\\(f\\) 为每个状态和输入对指派下一个状态（因此有 \\(f: S \\times I \\rightarrow S\\)）；一个初始状态或起始状态 \\(s_0\\)；一个由终结状态（或可接受状态）构成的 \\(S\\) 的子集 \\(F\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.643,
                0.852,
                0.66
            ],
            "angle": 0,
            "content": "有限状态自动机也可用状态表或状态图来表示。在状态图中，终结状态用双圈表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.665,
                0.905,
                0.704
            ],
            "angle": 0,
            "content": "例4构造有限状态自动机 \\(M = (S,I,f,s_0,F)\\) 的状态图，其中 \\(S = \\{s_0,s_1,s_2,s_3\\}\\) \\(I = \\{0,1\\}\\) ， \\(F = (s_0,s_3)\\) ，转移函数 \\(f\\) 如表1所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.707,
                0.905,
                0.741
            ],
            "angle": 0,
            "content": "解所求的状态图如图1所示。注意，输入0和1都将 \\(s_2\\) 变为 \\(s_0\\) ，所以从 \\(s_2\\) 到 \\(s_0\\) 的边上有0和1。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.243,
                0.74,
                0.294,
                0.754
            ],
            "angle": 0,
            "content": "表1"
        },
        {
            "type": "table",
            "bbox": [
                0.122,
                0.756,
                0.418,
                0.884
            ],
            "angle": 0,
            "content": "<table><tr><td rowspan=\"3\">状态</td><td colspan=\"2\">f</td></tr><tr><td colspan=\"2\">输入</td></tr><tr><td>0</td><td>1</td></tr><tr><td>s0</td><td>s0</td><td>s1</td></tr><tr><td>s1</td><td>s0</td><td>s2</td></tr><tr><td>s2</td><td>s0</td><td>s0</td></tr><tr><td>s3</td><td>s2</td><td>s1</td></tr></table>"
        },
        {
            "type": "image",
            "bbox": [
                0.511,
                0.741,
                0.848,
                0.869
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.528,
                0.872,
                0.828,
                0.887
            ],
            "angle": 0,
            "content": "图1 一个有限状态自动机的状态图"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.896,
                0.906,
                0.934
            ],
            "angle": 0,
            "content": "转移函数的扩展 有限状态自动机 \\(M = (S, I, f, s_0, F)\\) 的转移函数可以进行扩展，使其对所有状态与串的对都有值，也就是说，\\(f\\) 可以被扩展成这样一个函数 \\(f: S \\times I^* \\to S\\)。设 \\(x =\\)"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.13,
                0.035,
                0.167,
                0.048
            ],
            "angle": 0,
            "content": "766"
        },
        {
            "type": "header",
            "bbox": [
                0.211,
                0.034,
                0.288,
                0.049
            ],
            "angle": 0,
            "content": "第13章"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.09,
                0.951,
                0.166
            ],
            "angle": 0,
            "content": "\\(x_{1}x_{2}\\dots x_{k}\\) 是 \\(I^{*}\\) 中的一个串，则状态 \\(f(s_{1},x)\\) 是这样得到的：从状态 \\(s_1\\) 开始，从左到右连续地使用 \\(\\mathcal{X}\\) 中的每个符号。从 \\(s_1\\) 进入状态 \\(s_2 = f(s_1,x_1)\\) ，然后进入状态 \\(s_3 = f(s_2,x_2)\\) ，以此类推，直到 \\(f(s_{1},x) = f(s_{k},x_{k})\\) 。形式上，可以通过如下公式递归地为确定性的有限状态机 \\(M = (S,\\) \\(I\\) ， \\(f\\) ， \\(s_0\\) ， \\(F\\) )定义其扩展状态转移函数 \\(f\\) ："
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.17,
                0.621,
                0.185
            ],
            "angle": 0,
            "content": "1)对于状态集合 \\(S\\) 中的每一个状态 \\(s\\) ，有 \\(f(s,\\lambda) = s\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.19,
                0.742,
                0.205
            ],
            "angle": 0,
            "content": "2)对于所有的 \\(s\\in S\\) ， \\(x\\in I^{*}\\) ， \\(a\\in I\\) ，有 \\(f(s,xa) = f(f(s,x),a)\\) 。"
        },
        {
            "type": "list",
            "bbox": [
                0.139,
                0.17,
                0.742,
                0.205
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.209,
                0.949,
                0.246
            ],
            "angle": 0,
            "content": "可以使用结构化归纳和递归定义来证明扩展转移函数的这个性质。例如，在练习15中要求证明对于状态集合 \\(S\\) 中的每一个状态 \\(s\\) ， \\(x\\) 和 \\(y\\) 是 \\(I^{*}\\) 中的字符串，有"
        },
        {
            "type": "equation",
            "bbox": [
                0.402,
                0.25,
                0.649,
                0.267
            ],
            "angle": 0,
            "content": "\\[\nf (s, x y) = f (f (s, x), y)\n\\]"
        },
        {
            "type": "title",
            "bbox": [
                0.102,
                0.277,
                0.421,
                0.294
            ],
            "angle": 0,
            "content": "13.3.4 有限状态机的语言识别"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.298,
                0.876,
                0.315
            ],
            "angle": 0,
            "content": "现在定义一些术语，这些术语将用于研究有限状态自动机对某些串的集合的识别。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.323,
                0.941,
                0.402
            ],
            "angle": 0,
            "content": "定义4 称串 \\(x\\) 可以被机器 \\(M = (S, I, f, s_0, F)\\) 识别或接受，如果 \\(x\\) 将初始状态变为一个终结状态，即 \\(f(s_0, x)\\) 是 \\(F\\) 中的一个状态。机器 \\(M\\) 识别（或接受）的语言是 \\(M\\) 识别的所有串的集合，记为 \\(L(M)\\) 。如果两个有限状态自动机识别相同的语言，则称它们是等价的。"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.411,
                0.589,
                0.428
            ],
            "angle": 0,
            "content": "在例5中将求几个有限状态自动机所识别的语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.434,
                0.741,
                0.451
            ],
            "angle": 0,
            "content": "例5 求图2表示的有限状态自动机 \\(M_{1}\\) 、 \\(M_{2}\\) 和 \\(M_{3}\\) 所识别的语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.457,
                0.949,
                0.493
            ],
            "angle": 0,
            "content": "解 \\(M_{1}\\) 只有一个终结状态 \\(s_0\\) ，而将 \\(s_0\\) 变为自身的串是由0个、1个或更多连续1组成的串。所以 \\(L(M_{1}) = \\{1^{n}|n = 0,1,2,\\dots \\}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.497,
                0.891,
                0.513
            ],
            "angle": 0,
            "content": "\\(M_2\\) 只有一个终结状态 \\(s_2\\) ，而将 \\(s_0\\) 变为 \\(s_2\\) 的串只有1和01，所以 \\(L(M_2) = \\{1, 01\\}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.517,
                0.949,
                0.593
            ],
            "angle": 0,
            "content": "\\(M_{3}\\) 的终结状态有 \\(s_0\\) 和 \\(s_3\\) ，将 \\(s_0\\) 变为自身的串有 \\(\\lambda ,0,00,000,\\dots\\) ，即由零个以上（包括零个)连续的0构成的串。将 \\(s_0\\) 变为 \\(s_3\\) 的串只有这样的串：开头是零个以上(包括零个)连续的0构成的串，接着是10，然后是任意的串。故 \\(L(M_{3}) = \\{0^{n},0^{n}10x\\mid n = 0,1,2,\\dots ,x\\) 是任意的串}。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.597,
                0.95,
                0.693
            ],
            "angle": 0,
            "content": "设计有限状态自动机 我们经常可以构造一个有限状态自动机，通过仔细添加状态和转移，决定哪些状态是最终状态，使得这个有限状态自动机可以识别给定字符串。当根据需要，包含一些能够记录输入字符串的某些性质的状态时，就提供了一个带有有限存储的有限状态自动机。例6和例7这两个例子给我们说明了一些技术，可以通过使用这些技术来构造能够识别特定类型串的有限状态自动机。"
        },
        {
            "type": "title",
            "bbox": [
                0.101,
                0.735,
                0.172,
                0.754
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.75,
                0.951,
                0.935
            ],
            "angle": 0,
            "content": "斯蒂芬·科尔·克莱因(Stephen Cole Kleene，1909—1994）克莱因生于美国康涅狄格州的哈特福德。他的母亲艾丽丝·莉娜·科尔(Alice Lena Cole)是一位诗人，他的父亲古斯塔夫·阿道夫·克莱因(Gustav Adolph Kleene)是一位经济学教授。克莱因曾就读于艾摩斯特学院，1934年，他在普林斯顿大学获博士学位，导师是著名的逻辑学家丘奇（Alonzo Church）。1935年，克莱因成为威斯康星大学的教员，除了几次短暂的离开(包括去普林斯顿高等研究所)外，他一直在那里任教。第二次世界大战期间，他成为美国海军预备役军官学校的航海教师，后来他成为海军研究实验室的主任。克莱通过研究可计算性和可判定性问题，对递归函数论做出了重要贡献，并且证明了自动机理论中的一个中心结果。他曾担任威斯康星大学的数学研究中心的代理主任和文理学院的院长。他还曾学习过博物学，并发现了一族以前没记载过的蝴蝶，因此这族蝴蝶便以他的名字命名。他还是一位狂热的徒步旅行和登山爱好者。此外，克莱因还很擅长讲些奇闻轶事，他的大嗓门在几间办公室之外都能听到。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.685,
                0.039,
                0.796,
                0.055
            ],
            "angle": 0,
            "content": "计算模型"
        },
        {
            "type": "page_number",
            "bbox": [
                0.841,
                0.041,
                0.877,
                0.054
            ],
            "angle": 0,
            "content": "767"
        },
        {
            "type": "image",
            "bbox": [
                0.189,
                0.099,
                0.775,
                0.497
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.369,
                0.507,
                0.595,
                0.523
            ],
            "angle": 0,
            "content": "图2 一些有限状态自动机"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.535,
                0.72,
                0.552
            ],
            "angle": 0,
            "content": "例6 构造确定性的有限状态自动机，使得它可以识别如下这些语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.558,
                0.449,
                0.573
            ],
            "angle": 0,
            "content": "(a) 以两个0作为开始的比特串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.578,
                0.431,
                0.592
            ],
            "angle": 0,
            "content": "(b) 包含两个连续 0 的比特串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.597,
                0.449,
                0.611
            ],
            "angle": 0,
            "content": "(c)不包含两个连续0的比特串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.616,
                0.45,
                0.631
            ],
            "angle": 0,
            "content": "(d) 以两个 0 作为结束的比特串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.636,
                0.429,
                0.65
            ],
            "angle": 0,
            "content": "(e)至少包含两个0的比特串的集合。"
        },
        {
            "type": "list",
            "bbox": [
                0.099,
                0.558,
                0.45,
                0.65
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.654,
                0.908,
                0.766
            ],
            "angle": 0,
            "content": "解 (a) 我们的目标是构造一个确定性的有限状态自动机，使得该自动机能够识别以两个 0 作为开头的比特串的集合。除了初始状态 \\( s_0 \\) 外，还包含一个非终结状态 \\( s_1 \\) 。如果第一位是 0，则状态从 \\( s_0 \\) 变成 \\( s_1 \\) 。然后，添加一个终结状态 \\( s_2 \\)；如果第二位是 0，则从 \\( s_1 \\) 变成 \\( s_2 \\) 。当到达状态 \\( s_2 \\) 时，就可以确定输入字符串的前两位是 0，因此无论后续字符串的内容是什么（如果有），状态将保持 \\( s_2 \\) 不变。读者可以验证，图 3a 所示的有限状态自动机可以识别以两个 0 开始的比特串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.769,
                0.907,
                0.881
            ],
            "angle": 0,
            "content": "(b)我们的目标是构造一个确定性的有限状态自动机，使得该自动机能够识别包含着两个连续0的比特串的集合。除了初始状态 \\(s_0\\) 外，还包含一个非终结状态 \\(s_1\\) 。通过状态 \\(s_1\\) ，将会告知我们最后的输入位是0，而且，不论该位的前一位是1，或该位是输入字符串的第一位。还包含一个终结状态 \\(s_2\\) ，当0后的输入仍是0时，将从 \\(s_1\\) 跳转到 \\(s_2\\) 。如果在输入字符串中有0后紧接着的是1（在找到连续的两个0之前），那么将跳转到状态 \\(s_0\\) ，并且重新开始寻找连续的0。读者可以验证图3b所示的有限状态自动机可以识别包含两个连续0的比特串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.885,
                0.909,
                0.939
            ],
            "angle": 0,
            "content": "(c)我们的目标是构造一个确定性的有限状态自动机，该自动机能够识别不包含两个连续0的比特串的集合。除了初始状态 \\(s_0\\) 外，该状态也是终结状态，还包含一个终结状态 \\(s_1\\) 。当0是第一个输入字符时，状态从 \\(s_0\\) 跳转到 \\(s_1\\) 。当输入字符是1时，状态跳转或者停留在 \\(s_0\\) 。添加一"
        },
        {
            "type": "list",
            "bbox": [
                0.056,
                0.769,
                0.909,
                0.939
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.919,
                0.534,
                0.981,
                0.551
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.126,
                0.043,
                0.161,
                0.056
            ],
            "angle": 0,
            "content": "768"
        },
        {
            "type": "header",
            "bbox": [
                0.207,
                0.042,
                0.282,
                0.057
            ],
            "angle": 0,
            "content": "第13章"
        },
        {
            "type": "image",
            "bbox": [
                0.095,
                0.099,
                0.949,
                0.442
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.307,
                0.45,
                0.737,
                0.465
            ],
            "angle": 0,
            "content": "图3识别例6中的语言的确定性的有限状态自动机"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.476,
                0.946,
                0.55
            ],
            "angle": 0,
            "content": "个状态 \\(s_2\\) ，当输入字符是0时，状态从 \\(s_1\\) 跳转到 \\(s_2\\) 。当状态到达 \\(s_2\\) 时，就表示已经遇到了两个连续的0。一旦到达状态 \\(s_2\\) ，就在此停留并保持不变。这个状态不是终结状态。读者可以自行验证图3c所示的有限状态自动机能够识别不包含两个连续0的输入字符串的集合。[聪明的读者将会注意到本例构造的有限状态自动机与(b)部分构造的自动机之间的关系。参见练习39。]"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.552,
                0.946,
                0.685
            ],
            "angle": 0,
            "content": "(d)我们的目标是构造一个确定性的有限状态自动机，该自动机能够识别以两个连续0作为结束的比特串的集合。除了初始状态 \\(s_0\\) 外，还包含一个非终结状态 \\(s_1\\) 。如果第一位是0，则跳转到状态 \\(s_1\\) 。还包含一个终结状态 \\(s_2\\) 。如果0之后的输入字符仍然是0，状态将从 \\(s_1\\) 跳转到\\(s_2\\) 。如果在0之后的输入仍然是0，则保持状态 \\(s_2\\) 不变，原因是最后输入的两个字符仍然是0。如果此时状态是 \\(s_2\\) ，当输入位是1时，将跳转回状态 \\(s_0\\) ，然后重新开始搜索连续0的出现。如果此时状态是 \\(s_1\\) ，当下一个输入位是1时，也将跳转到状态 \\(s_0\\) 。读者可以自行验证图3d所示的有限状态自动机能够识别以两个连续0作为结束的输入字符串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.687,
                0.946,
                0.821
            ],
            "angle": 0,
            "content": "(e)我们的目标是构造一个确定性的有限状态自动机，该自动机能够识包含两个0的比特串的集合。除了初始状态 \\(s_0\\) 外，还包含一个非终结状态 \\(s_1\\) 。状态将一直保持在 \\(s_0\\) ，直到输入0。当输入字符串中遇到第一个0时，状态跳转到 \\(s_1\\) 。添加一个终结状态 \\(s_2\\) ，一旦在输入字符串中遇到第二个0，将从状态 \\(s_1\\) 跳转到 \\(s_2\\) 。无论何时遇到输入字符为1时，保持原状态不变。一旦到达状态 \\(s_2\\) ，将保持不变。状态 \\(s_1\\) 和状态 \\(s_2\\) 分别用来告诉我们已经在输入字符串中遇到1个或2个0。读者可以自行验证图3e所示的有限状态自动机能够识别包含两个0的输入字符串。"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.825,
                0.945,
                0.864
            ],
            "angle": 0,
            "content": "例7构造一个确定性的有限状态自动机，使得该自动机能够识别包含奇数个1，并且以至少两个连续0作结束的比特串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.866,
                0.945,
                0.921
            ],
            "angle": 0,
            "content": "解我们可以构造一个确定性的有限状态自动机，通过添加状态记录输入字符串中1的个数的奇偶性，以及是否在输入字符串的尾部遇到0个、1个或者至少2个0，使得该自动机可以识别某种类型的比特串。"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.923,
                0.946,
                0.94
            ],
            "angle": 0,
            "content": "可以通过初始状态 \\(s_0\\) 来告诉我们目前输入的比特串包含偶数个1，并且不以0作为结束"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.678,
                0.038,
                0.792,
                0.053
            ],
            "angle": 0,
            "content": "计算模型"
        },
        {
            "type": "page_number",
            "bbox": [
                0.836,
                0.039,
                0.871,
                0.052
            ],
            "angle": 0,
            "content": "769"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.094,
                0.901,
                0.186
            ],
            "angle": 0,
            "content": "（空串或者以1作为结束）。除了初始状态外，还包含其他5个状态。当输入比特串包含偶数个1且以1个0作为结束时，状态跳转到 \\(s_1\\) ；当包含偶数个1且以至少两个0作为结束时，状态跳转到 \\(s_2\\) ；当包含奇数个1且不以0作为结束时，状态跳转到 \\(s_3\\) ；当包含奇数个1且以1个0作为结束时，状态跳转到 \\(s_4\\) ；当包含奇数个1且以两个0个作为结束时，状态跳转到 \\(s_5\\) ，同时\\(s_5\\) 也是一个终结状态。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.19,
                0.901,
                0.224
            ],
            "angle": 0,
            "content": "读者可以自行验证图4所示的有限状态自动机能够识别包含奇数个1且以至少两个连续0作为结束的比特串的集合。"
        },
        {
            "type": "image",
            "bbox": [
                0.052,
                0.23,
                0.904,
                0.423
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.208,
                0.432,
                0.744,
                0.463
            ],
            "angle": 0,
            "content": "图4确定性的有限状态自动机，该自动机能够识别包含奇数个1且以至少两个0结束的比特串的集合"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.475,
                0.901,
                0.51
            ],
            "angle": 0,
            "content": "等价的有限状态自动机 在定义4中，我们定义当两个有限状态自动机能够识别相同的语言时，它们是等价的。例8给出了两个等价的确定性的有限状态自动机的例子。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.516,
                0.623,
                0.532
            ],
            "angle": 0,
            "content": "例8 证明图5所示的有限状态自动机 \\(M_0\\) 和 \\(M_{1}\\) 是等价的。"
        },
        {
            "type": "image",
            "bbox": [
                0.243,
                0.547,
                0.709,
                0.841
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.313,
                0.855,
                0.637,
                0.87
            ],
            "angle": 0,
            "content": "图5 \\(M_0\\) 和 \\(M_{1}\\) 是等价有限状态自动机"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.882,
                0.901,
                0.937
            ],
            "angle": 0,
            "content": "解对于可以被 \\(M_0\\) 识别的字符串 \\(x\\) ， \\(x\\) 必须从状态 \\(s_0\\) 跳转终结状态 \\(s_1\\) 或者终结状态 \\(s_4\\) 。唯一能从状态 \\(s_0\\) 跳转到 \\(s_1\\) 的就是字符串1。能从状态 \\(s_0\\) 跳转到 \\(s_4\\) 的是以0作为开始的字符串，该字符串首先从 \\(s_0\\) 跳转到 \\(s_2\\) ，后跟0个或者多个0，保持状态 \\(s_2\\) 不变，然后跟一个1，状态从"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.121,
                0.038,
                0.156,
                0.051
            ],
            "angle": 0,
            "content": "770"
        },
        {
            "type": "header",
            "bbox": [
                0.201,
                0.037,
                0.277,
                0.052
            ],
            "angle": 0,
            "content": "第13章"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.094,
                0.938,
                0.149
            ],
            "angle": 0,
            "content": "\\(s_2\\) 跳转到 \\(s_4\\) 。除了以上这些字符串外，所有其他的字符串都使状态从 \\(s_0\\) 跳转到非终结状态（留给读者详细地填补这些内容）。因此我们可以得出结论，自动机 \\(M_0\\) 所识别的语言 \\(L(M_0)\\) 的形式是 0 个或多个 0 后跟一个 1 的字符串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.153,
                0.938,
                0.248
            ],
            "angle": 0,
            "content": "对于可以被 \\(M_{1}\\) 识别的字符串 \\(x\\)，\\(x\\) 必须使状态能从 \\(s_{0}\\) 跳转到终结状态 \\(s_{1}\\)。因此，能被识别的字符串 \\(x\\) 的形式是以若干个 0 作为开始，这样会保持状态 \\(s_{0}\\) 不变，后接 1 个 1，跳转到终结状态 \\(s_{1}\\)。全是由 0 组成的比特串是不会被识别的，因为它只能使我们保持状态 \\(s_{0}\\) 不变，但 \\(s_{0}\\) 是非终结状态。1 后紧接着是一个 0 的比特串也不会被识别，因为它会跳转到一个非终结状态 \\(s_{2}\\)。因此，结果就是 \\(L(M_{1})\\) 与 \\(L(M_{0})\\) 相同。可以得出结论 \\(M_{0}\\) 与 \\(M_{1}\\) 是等价的。"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.252,
                0.938,
                0.287
            ],
            "angle": 0,
            "content": "注意有限状态自动机 \\(M_{1}\\) 只有3个状态。能识别出0个或多个0后紧接着1这样的比特串的自动机不会少于3个状态(参见练习37)。"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.291,
                0.938,
                0.365
            ],
            "angle": 0,
            "content": "正如例8所说明的，某个有限状态自动机可能比它等价的自动机具有更多的状态。实际上，构造用来识别某种语言的有限状态自动机的算法可能会比需要的状态多。使用不必要的大型有限状态自动机来识别语言会使硬件和软件应用效率较低，并且代价较高。当有限状态自动机用于编译程序时，该问题随之而来，编译程序用于将源程序翻译为计算机能够识别的目标程序。"
        },
        {
            "type": "title",
            "bbox": [
                0.092,
                0.374,
                0.162,
                0.394
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.093,
                0.408,
                0.236,
                0.515
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.093,
                0.518,
                0.225,
                0.529
            ],
            "angle": 0,
            "content": "\\(\\langle \\widehat{\\mathbb{C}}\\rangle\\) Bettmann/Getty Images"
        },
        {
            "type": "text",
            "bbox": [
                0.253,
                0.408,
                0.938,
                0.528
            ],
            "angle": 0,
            "content": "葛丽丝·穆雷·霍普(Grace Brewster Murray Hopper，1906—1992）1906年，葛丽丝·霍普出生于纽约。她自幼就对事物是如何运行的有着浓厚的兴趣。在她7岁的时候，她就把家里的闹钟拆了，以探寻它运作的机制。她对数学的热爱很大程度上是受到了她母亲的影响。在那个女性被禁止学习的时代，她的母亲获得特批学习过几何学（但不是代数和三角函数）。霍普的父亲对她的影响也很大。她的父亲是一个成功的保险经纪人，殊不知这样的一个成功人士，曾经因为循环系统出了问题而失去了双腿。他鼓励孩子们不管任何事情，只要她们用心去做，就一定能取得成"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.531,
                0.938,
                0.617
            ],
            "angle": 0,
            "content": "功。他也一直激励霍普接受更高的教育，而不仅仅像大多数女性那样平淡无奇地度过一生。霍普的父母尽全力让她接受最好的教育，于是她在纽约上了私立的小学和中学。1924年她考入瓦萨学院学习数学和物理，1928年她大学毕业。接着，她在耶鲁大学攻读数学专业的硕士学位并于1930年毕业。同年，霍普嫁给了在纽约商学院任教的一名英语老师，但婚姻并没有持续太久两人就离婚了。1931年至1943年，霍普在瓦萨学院担任数学系教授，1934年她获得了耶鲁大学的博士学位。"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.619,
                0.938,
                0.759
            ],
            "angle": 0,
            "content": "珍珠港事件后，出生于军人世家的霍普毅然决定辞去她的教师工作而加入了美国海军。为了顺利入伍，霍普需要一个特殊的许可证才能让她彻底脱离数学专业教授的位置。1943年，她宣誓加入海军预备役部队，并在海军女子学校接受训练。之后，霍普被分配到了哈佛大学的海军军械实验室工作，主要为世界第一台大规模自动测序的数字计算机编程，这台计算机用来帮助海军火炮在多变的天气中准确地瞄准方位。人们认为霍普是“漏洞”（bug）（多指硬件出故障）这个词语的创造者，但事实上，早在霍普去哈佛大学之前，这个词就已经被人使用了。但霍普和她的编程团队发现了计算机硬件中继上的一个缺陷，这也是致使系统停止运行的原因。这个有名的“缺陷”被记载到了实验室图书中。于是，在20世纪50年代，霍普发明一个新词“调试”（debug)表示去除程序中错误。"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.761,
                0.938,
                0.883
            ],
            "angle": 0,
            "content": "1946年，美国海军告知霍普年纪太大而不能继续服现役，于是她选择继续留在哈佛大学进行民用研究。1949年，她离开哈佛大学加入了“埃克特-莫克利”计算机公司，帮助开发第一台商用计算机，即通用自动计算机(UNIVAC)。霍普在这里工作了很长时间，直到雷明顿兰德公司接手该公司并与斯派里公司合并后，她才离开了这个公司。霍普一直非常看好计算机无穷的潜能，她深知只要编程和应用上做得好，计算机终将被广泛使用。特别是编程的语言，她认为可以用英语写，而不一定局限于计算机指令。为了实现这一目标，她开发了第一台编译器，并在1952年发表了第一篇关于编译器研究的论文。霍普也被称作“面向商业的通用语言(COBOL)之母”，她的员工借助他们早期的工作基础构建了面向COBLO的基本语言设计框架。"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.885,
                0.938,
                0.936
            ],
            "angle": 0,
            "content": "1966年，霍普正式从海军预备役部队退休。然而，仅仅7个月之后，海军部队重新召回她，令其协助高级海军计算机语言的标准化制定工作。1983年，霍尔被总统亲自授予海军准将军衔，两年后，提升为海军少将。霍普退休的时候已经80岁高龄了，美国海军为其在宪法号帆船护卫舰上举行了退休仪式。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.678,
                0.032,
                0.789,
                0.048
            ],
            "angle": 0,
            "content": "计算模型"
        },
        {
            "type": "page_number",
            "bbox": [
                0.835,
                0.034,
                0.87,
                0.047
            ],
            "angle": 0,
            "content": "771"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.089,
                0.901,
                0.201
            ],
            "angle": 0,
            "content": "练习 \\(58\\sim 61\\) 研究了一个过程，如何用最少的状态构造一个有限状态自动机使之等价于一个给定的有限状态自动机。这个方法称为自动机简化。在练习中描述的这个过程，通过把状态用状态的等价类来替换，减少了状态的数量。如果对每个输入字符串都能使两个状态跳转到终结状态，或者都使这两个状态跳转到某个非终结状态，那么则称这两个状态是等价的。在自动机简化过程开始前，从开始状态使用任何输入都不可达的状态首先被删除，删除这些状态不会改变其识别的语言。"
        },
        {
            "type": "title",
            "bbox": [
                0.053,
                0.21,
                0.417,
                0.227
            ],
            "angle": 0,
            "content": "13.3.5 非确定性的有限状态自动机"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.23,
                0.901,
                0.303
            ],
            "angle": 0,
            "content": "到目前为止所讨论的有限状态自动机都是确定性的，因为对每对状态和输入值，转移函数只给出唯一的下一个状态。还有一种重要的有限状态自动机，它对每对输入值和状态，有多个可能的下一个状态，这样的机器称为非确定性的。非确定性的有限状态自动机在判断哪些语言可以由有限状态自动机识别中非常重要。"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.311,
                0.893,
                0.368
            ],
            "angle": 0,
            "content": "定义5 非确定性的有限状态自动机 \\(M = (S, I, f, s_0, F)\\) 由下列五部分组成：一个状态的集合 \\(S\\)；一个输入字母表 \\(I\\)；一个转移函数 \\(f\\)，\\(f\\) 为每个状态和输入对指派一个状态集合（因此有 \\(f: S \\times I \\to P(S)\\)）；一个初始状态 \\(s_0\\)；还有一个由终结状态构成的 \\(S\\) 的子集 \\(F\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.376,
                0.902,
                0.431
            ],
            "angle": 0,
            "content": "非确定性的有限状态自动机也可用状态表和状态图来表示。在状态表中，对每对状态和输入值，列出所有可能的下一个状态。在状态图中，从一个状态到每个可能的下一个状态，都画一条边，这条边的标号是导致这个转移的一个或多个输入。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.435,
                0.885,
                0.452
            ],
            "angle": 0,
            "content": "例9求状态表如表2所示的非确定性的有限状态自动机的状态图。终结状态为 \\(s_2\\) 和 \\(s_3\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.457,
                0.437,
                0.473
            ],
            "angle": 0,
            "content": "解 这个自动机的状态图如图6所示。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.233,
                0.481,
                0.283,
                0.495
            ],
            "angle": 0,
            "content": "表2"
        },
        {
            "type": "table",
            "bbox": [
                0.072,
                0.497,
                0.446,
                0.653
            ],
            "angle": 0,
            "content": "<table><tr><td rowspan=\"3\">状态</td><td colspan=\"2\">f</td></tr><tr><td colspan=\"2\">输入</td></tr><tr><td>0</td><td>1</td></tr><tr><td>s0</td><td>s0,s1</td><td>s3</td></tr><tr><td>s1</td><td>s0</td><td>s1,s3</td></tr><tr><td>s2</td><td></td><td>s0,s2</td></tr><tr><td>s3</td><td>s0,s1,s2</td><td>s1</td></tr></table>"
        },
        {
            "type": "image",
            "bbox": [
                0.553,
                0.477,
                0.871,
                0.636
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.516,
                0.641,
                0.908,
                0.657
            ],
            "angle": 0,
            "content": "图6 状态表为表2的非确定性的有限状态自动机"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.671,
                0.707,
                0.688
            ],
            "angle": 0,
            "content": "例10 求状态图如图7所示的非确定性的有限状态自动机的状态表。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.694,
                0.439,
                0.709
            ],
            "angle": 0,
            "content": "解 这个自动机的状态表如表3所示。"
        },
        {
            "type": "image",
            "bbox": [
                0.08,
                0.717,
                0.494,
                0.879
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.128,
                0.887,
                0.443,
                0.902
            ],
            "angle": 0,
            "content": "图7 一个非确定性的有限状态自动机"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.714,
                0.712,
                0.766,
                0.726
            ],
            "angle": 0,
            "content": "表3"
        },
        {
            "type": "table",
            "bbox": [
                0.576,
                0.728,
                0.903,
                0.896
            ],
            "angle": 0,
            "content": "<table><tr><td rowspan=\"3\">状态</td><td colspan=\"2\">f</td></tr><tr><td colspan=\"2\">输入</td></tr><tr><td>0</td><td>1</td></tr><tr><td>s0</td><td>s0,s2</td><td>s1</td></tr><tr><td>s1</td><td>s3</td><td>s4</td></tr><tr><td>s2</td><td></td><td>s4</td></tr><tr><td>s3</td><td>s3</td><td></td></tr><tr><td>s4</td><td>s3</td><td>s3</td></tr></table>"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.13,
                0.036,
                0.167,
                0.049
            ],
            "angle": 0,
            "content": "772"
        },
        {
            "type": "header",
            "bbox": [
                0.211,
                0.034,
                0.288,
                0.05
            ],
            "angle": 0,
            "content": "第13章"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.091,
                0.951,
                0.206
            ],
            "angle": 0,
            "content": "非确定性的有限状态自动机怎么识别串 \\(x = x_{1}x_{2}\\dots x_{k}\\) 呢？第一个输入符号 \\(x_{1}\\) 将初始状态\\(s_0\\) 变为状态集合 \\(S_{1}\\) 。下一个输入符号 \\(x_{2}\\) 将 \\(s_1\\) 中的每个状态都变为一个状态集合。设 \\(s_2\\) 是这些集合的并集。将这个过程继续下去，在某个步骤中，对上一个步骤产生的每个状态和当前的输入符号都要求其产生的所有状态。使用 \\(\\mathcal{X}\\) 从 \\(s_0\\) 所能得到的状态中，如果有一个终结状态，我们就识别或接受串 \\(x\\) 。非确定性的有限状态自动机所识别的语言是这个自动机所识别的所有串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.211,
                0.714,
                0.228
            ],
            "angle": 0,
            "content": "例11 求图7所示的非确定性的有限状态自动机所识别的语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.234,
                0.951,
                0.329
            ],
            "angle": 0,
            "content": "解 因为 \\(s_0\\) 是终结状态，当输入是 0 时，有从 \\(s_0\\) 到自身的转移，所以此机器识别所有零个或更多个连续的 0 组成的串。因为 \\(s_4\\) 也是终结状态，所以对于任何串，若以此串作为输入时从 \\(s_0\\) 所能达到的状态集中包含 \\(s_4\\)，则此串就能被识别。这样的串只有：零个或更多个连续的 0 和后面跟 01 或 11 组成的串。因为 \\(s_0\\) 和 \\(s_4\\) 是仅有的终结状态，所以此机器识别的语言为 \\(\\{0^n, 0^n01, 0^n11 | n \\geqslant 0\\}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.333,
                0.95,
                0.389
            ],
            "angle": 0,
            "content": "一个重要的事实是，非确定性的有限状态自动机所能识别的语言也能被确定性的有限状态自动机所识别。在13.4节中，我们将利用这个事实确定有限状态自动机能够识别哪些语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.398,
                0.941,
                0.436
            ],
            "angle": 0,
            "content": "定理1 如果语言 \\(L\\) 可以由非确定性的有限状态自动机 \\(M_0\\) 所识别，则 \\(L\\) 也可以由一个确定性的有限状态自动机 \\(M_1\\) 来识别。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.446,
                0.95,
                0.501
            ],
            "angle": 0,
            "content": "证明我们将描述怎样从非确定性的有限状态自动机 \\(M_0\\) 构造识别 \\(L\\) 的确定性的有限状态自动机 \\(M_{1}\\) 。 \\(M_{1}\\) 的每个状态都由 \\(M_0\\) 的状态集的一个子集构成， \\(M_{1}\\) 的初始状态是 \\(\\{s_0\\}\\) ，即 \\(M_{1}\\) 的初始状态是 \\(M_0\\) 的初始状态构成的集合。 \\(M_{1}\\) 的输入集合与 \\(M_0\\) 的输入集合相同。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.504,
                0.951,
                0.619
            ],
            "angle": 0,
            "content": "对于 \\(M_{1}\\) 的一个给定状态 \\(\\{s_{i_1}, s_{i_2}, \\dots, s_{i_k}\\}\\)，输入字符串 \\(x\\) 将这个状态变为这个集合中元素的下一个状态构成的集合的并，即集合 \\(f(s_{i_1}, x)\\)，\\(f(s_{i_2}, x)\\)，\\(\\dots\\)，\\(f(s_{i_k}, x)\\) 的并。\\(M_{1}\\) 的状态是 \\(S\\) 的所有子集的集合，这里 \\(S\\) 是 \\(M_{0}\\) 的状态集，从 \\(s_0\\) 开始，以此方式求得。（如果此非确定性的机器有 \\(n\\) 个状态，则确定性的机器就有 \\(2^n\\) 个状态，因为所有子集都可以作为状态，包括空集，尽管实际使用的状态却很少。）如果 \\(M_{0}\\) 的一个子状态集含有终结状态，则它就是 \\(M_{1}\\) 的终结状态。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.622,
                0.951,
                0.735
            ],
            "angle": 0,
            "content": "假设一个输入字符串可以由 \\(M_0\\) 识别，则用这个串从 \\(s_0\\) 出发可以到达的状态中有一个终结状态（读者应能对这一点做归纳证明）。这意味着，在 \\(M_1\\) 中，这个串能将 \\(\\{s_0\\}\\) 引导至这样一个状态集，它是 \\(M_0\\) 的状态集的一个子集且包含一个终结状态。这个子集是 \\(M_1\\) 的一个终结状态，所以这个串也能由 \\(M_1\\) 识别。而且，如果一个输入字符串不能由 \\(M_0\\) 识别，则它也就不能导致 \\(M_0\\) 中的任何终结状态。（读者应该能够给出它的详细证明。）因此这个输入字符串也不可能由 \\(\\{s_0\\}\\) 导致 \\(M_1\\) 中的一个终结状态。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.74,
                0.951,
                0.779
            ],
            "angle": 0,
            "content": "例12 求一个确定性的有限状态自动机，能与例10中的非确定性的有限状态自动机识别相同的语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.782,
                0.953,
                0.934
            ],
            "angle": 0,
            "content": "解所求的确定性的有限状态自动机如图8所示，它是根据例10中的非确定性的有限状态自动机构造的。此确定性的自动机的状态是那个非确定性的机器的状态集的子集。对于一个输入符号，一个子集的下一个状态是这样的集合：它由这个子集中的元素在那个非确定性的机器中的所有下一个状态所构成。例如，对于输入0， \\(\\{s_0\\}\\) 转为 \\(\\{s_0,s_2\\}\\) ，因为在那个非确定性的机器中， \\(s_0\\) 有到它自己和 \\(s_2\\) 的转移；集合 \\(\\{s_0,s_2\\}\\) 对输入1转为 \\(\\{s_1,s_4\\}\\) ，因为在那个非确定性的机器中，对输入1， \\(s_0\\) 只转为 \\(s_1\\) ， \\(s_2\\) 只转为 \\(s_4\\) ；集合 \\(\\{s_1,s_4\\}\\) 对输入0转为 \\(\\{s_3\\}\\) ，因为在那个非确定性的机器中，对输入0， \\(s_1\\) 和 \\(s_4\\) 都只转为 \\(s_3\\) 。所有以这种方法得到的子集都包括在这个确定性的有限状态机器中。注意，空集也是这个机器的一个状态，因为它是 \\(\\{s_3\\}\\) 对输"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.685,
                0.04,
                0.796,
                0.056
            ],
            "angle": 0,
            "content": "计算模型"
        },
        {
            "type": "page_number",
            "bbox": [
                0.842,
                0.042,
                0.878,
                0.055
            ],
            "angle": 0,
            "content": "773"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.097,
                0.906,
                0.133
            ],
            "angle": 0,
            "content": "入1的所有下一个状态构成的子集。初始状态是 \\(\\{s_0\\}\\)，终结状态是那些包含 \\(s_0\\) 或 \\(s_4\\) 的状态的集合。"
        },
        {
            "type": "image",
            "bbox": [
                0.227,
                0.138,
                0.739,
                0.312
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.171,
                0.318,
                0.793,
                0.334
            ],
            "angle": 0,
            "content": "图8与例10中非确定性的有限状态自动机等价的确定性的有限状态自动机"
        },
        {
            "type": "title",
            "bbox": [
                0.059,
                0.353,
                0.107,
                0.368
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.372,
                0.446,
                0.386
            ],
            "angle": 0,
            "content": "1. 设 \\(A = \\{0, 11\\}\\), \\(B = \\{00, 01\\}\\), 求下列集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.39,
                0.131,
                0.404
            ],
            "angle": 0,
            "content": "a)AB"
        },
        {
            "type": "text",
            "bbox": [
                0.301,
                0.39,
                0.35,
                0.403
            ],
            "angle": 0,
            "content": "b)BA"
        },
        {
            "type": "text",
            "bbox": [
                0.522,
                0.39,
                0.562,
                0.403
            ],
            "angle": 0,
            "content": "c) \\(A^2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.736,
                0.39,
                0.776,
                0.403
            ],
            "angle": 0,
            "content": "d) \\(B^3\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.408,
                0.482,
                0.422
            ],
            "angle": 0,
            "content": "2. 设 \\(A\\) 是字符串的一个集合。证明 \\(A\\varnothing = \\varnothing A = \\varnothing\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.426,
                0.772,
                0.439
            ],
            "angle": 0,
            "content": "3. 求所有字符串的集合对 \\(A\\) 和 \\(B\\) ，使得 \\(AB = \\{10, 111, 1010, 1000, 10111, 101000\\}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.444,
                0.242,
                0.457
            ],
            "angle": 0,
            "content": "4. 证明下列等式成立。"
        },
        {
            "type": "list",
            "bbox": [
                0.057,
                0.408,
                0.772,
                0.457
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.461,
                0.187,
                0.475
            ],
            "angle": 0,
            "content": "a) \\(\\{\\lambda\\}^* = \\{\\lambda\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.521,
                0.461,
                0.845,
                0.475
            ],
            "angle": 0,
            "content": "b)对任意字符串的集合 \\(A\\) ， \\((A^{*})^{*} = A^{*}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.479,
                0.402,
                0.493
            ],
            "angle": 0,
            "content": "5. 对于下列集合 \\(A\\) ，描述集合 \\(A^{*}\\) 的元素。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.497,
                0.139,
                0.51
            ],
            "angle": 0,
            "content": "a) \\(\\{10\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.301,
                0.497,
                0.367,
                0.51
            ],
            "angle": 0,
            "content": "b) {111}"
        },
        {
            "type": "text",
            "bbox": [
                0.522,
                0.497,
                0.605,
                0.51
            ],
            "angle": 0,
            "content": "c) \\(\\{0, 01\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.736,
                0.497,
                0.829,
                0.51
            ],
            "angle": 0,
            "content": "d）{1，101}"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.515,
                0.634,
                0.529
            ],
            "angle": 0,
            "content": "6. 设 \\(V\\) 是一个字母表，\\(A\\) 和 \\(B\\) 是 \\(V^{*}\\) 的子集。证明：\\(\\left|AB\\right|\\leqslant A\\left|\\left|B\\right|\\right.\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.534,
                0.657,
                0.547
            ],
            "angle": 0,
            "content": "7. 设 \\(V\\) 是一个字母表，\\(A\\) 和 \\(B\\) 是 \\(V^{*}\\) 的子集，且 \\(A \\subseteq B\\)。证明：\\(A^{*} \\subseteq B^{*}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.552,
                0.572,
                0.565
            ],
            "angle": 0,
            "content": "8. 设 \\(V\\) 是一个字母表，\\(A\\) 是 \\(V^{*}\\) 的子集。证明或反证下列命题。"
        },
        {
            "type": "list",
            "bbox": [
                0.057,
                0.515,
                0.657,
                0.565
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.569,
                0.156,
                0.582
            ],
            "angle": 0,
            "content": "a) \\(A\\subseteq A^2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.301,
                0.569,
                0.5,
                0.582
            ],
            "angle": 0,
            "content": "b)如果 \\(A = A^2\\) ，则 \\(\\lambda \\in A\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.523,
                0.569,
                0.615,
                0.582
            ],
            "angle": 0,
            "content": "c) \\(A\\{\\lambda \\} = A\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.083,
                0.588,
                0.202,
                0.6
            ],
            "angle": 0,
            "content": "d) \\((A^{*})^{*} = A^{*}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.302,
                0.588,
                0.401,
                0.6
            ],
            "angle": 0,
            "content": "e) \\(A^{*}A = A^{*}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.523,
                0.587,
                0.651,
                0.602
            ],
            "angle": 0,
            "content": "f) \\( |A^n| = |A|^n \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.607,
                0.386,
                0.62
            ],
            "angle": 0,
            "content": "9. 确定下列集合是否包含字符串 11101。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.625,
                0.167,
                0.638
            ],
            "angle": 0,
            "content": "a) \\(\\{0,1\\}^{*}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.302,
                0.625,
                0.441,
                0.638
            ],
            "angle": 0,
            "content": "b) \\(\\{1\\}^{*}\\{0\\}^{*}\\{1\\}^{*}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.524,
                0.625,
                0.655,
                0.638
            ],
            "angle": 0,
            "content": "c) \\(\\{11\\} \\{0\\}^{*}\\{01\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.083,
                0.643,
                0.2,
                0.655
            ],
            "angle": 0,
            "content": "d) \\(\\{11\\}^{*}\\{01\\}^{*}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.303,
                0.643,
                0.456,
                0.655
            ],
            "angle": 0,
            "content": "e){111} \\*{01}\\*{1}"
        },
        {
            "type": "text",
            "bbox": [
                0.524,
                0.643,
                0.686,
                0.655
            ],
            "angle": 0,
            "content": "f）{11，0} {00，101}"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.66,
                0.395,
                0.674
            ],
            "angle": 0,
            "content": "10. 确定下列集合是否包含字符串 01001。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.678,
                0.177,
                0.691
            ],
            "angle": 0,
            "content": "a) \\(\\{0,1\\}^{*}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.303,
                0.678,
                0.437,
                0.691
            ],
            "angle": 0,
            "content": "b) \\(\\{0\\}^{*}\\{10\\} \\{1\\}^{*}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.524,
                0.678,
                0.668,
                0.691
            ],
            "angle": 0,
            "content": "c) \\(\\{010\\}^{*}\\{0\\}^{*}\\{1\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.696,
                0.276,
                0.708
            ],
            "angle": 0,
            "content": "d){010，011}{00，01}"
        },
        {
            "type": "text",
            "bbox": [
                0.304,
                0.696,
                0.434,
                0.708
            ],
            "angle": 0,
            "content": "e) \\(\\{00\\} \\{0\\}^{*}\\{01\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.524,
                0.696,
                0.636,
                0.709
            ],
            "angle": 0,
            "content": "f) \\(\\{01\\}^{*}\\{01\\}^{*}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.713,
                0.586,
                0.727
            ],
            "angle": 0,
            "content": "11. 确定下列字符串是否可由图 1 中的确定性的有限自动机识别。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.731,
                0.14,
                0.743
            ],
            "angle": 0,
            "content": "a)111"
        },
        {
            "type": "text",
            "bbox": [
                0.304,
                0.731,
                0.359,
                0.743
            ],
            "angle": 0,
            "content": "b)0011"
        },
        {
            "type": "text",
            "bbox": [
                0.524,
                0.731,
                0.606,
                0.743
            ],
            "angle": 0,
            "content": "c)1010111"
        },
        {
            "type": "text",
            "bbox": [
                0.738,
                0.731,
                0.839,
                0.743
            ],
            "angle": 0,
            "content": "d)011011011"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.749,
                0.623,
                0.762
            ],
            "angle": 0,
            "content": "12. 确定下列字符串能否由图 1 中的确定性的有限状态自动机所识别。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.766,
                0.141,
                0.778
            ],
            "angle": 0,
            "content": "a)010"
        },
        {
            "type": "text",
            "bbox": [
                0.304,
                0.767,
                0.36,
                0.778
            ],
            "angle": 0,
            "content": "b)1101"
        },
        {
            "type": "text",
            "bbox": [
                0.524,
                0.767,
                0.607,
                0.778
            ],
            "angle": 0,
            "content": "c)1111110"
        },
        {
            "type": "text",
            "bbox": [
                0.738,
                0.767,
                0.841,
                0.778
            ],
            "angle": 0,
            "content": "d)010101010"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.783,
                0.882,
                0.797
            ],
            "angle": 0,
            "content": "13. 对于下列每个集合，确定其中的每个字符串是否都能由图 1 中的确定性的有限状态自动机所识别。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.802,
                0.15,
                0.814
            ],
            "angle": 0,
            "content": "a) \\(\\{0\\}^{*}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.304,
                0.802,
                0.387,
                0.815
            ],
            "angle": 0,
            "content": "b) \\(\\{0\\} \\{0\\}^*\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.524,
                0.802,
                0.606,
                0.815
            ],
            "angle": 0,
            "content": "c) \\(\\{1\\} \\{0\\}^{*}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.82,
                0.159,
                0.832
            ],
            "angle": 0,
            "content": "d) \\(\\{01\\}^{*}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.304,
                0.82,
                0.398,
                0.833
            ],
            "angle": 0,
            "content": "e) \\(\\{0\\}^{*}\\{1\\}^{*}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.524,
                0.82,
                0.633,
                0.833
            ],
            "angle": 0,
            "content": "f) \\(\\{1\\} \\{0, 1\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.837,
                0.906,
                0.887
            ],
            "angle": 0,
            "content": "14. 证明：如果 \\( M = \\{S, I, f, s_0, F\\} \\) 是一个确定性的有限状态自动机，并且当 \\( s \\in S \\)，输入字符串 \\( x \\in I^* \\) 时，有 \\( f(s, x) = s \\)，则对于每个非负整数 \\( n \\)，有 \\( f(s, x^n) = s \\)。（这里，\\( x^n \\) 指的是字符串 \\( x \\) 的 \\( n \\) 个副本的连接，是在 5.3 节练习 37 中递归定义的。）"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.89,
                0.906,
                0.923
            ],
            "angle": 0,
            "content": "15. 给定一个确定性的有限状态机 \\(M = (S, I, f, s_0, F)\\)，使用结构归纳和扩展转移函数 \\(f\\) 的递归定义来证明：对于所有的状态 \\(s \\in S\\)，输入字符串 \\(x \\in I^*\\)，\\(y \\in I^*\\)，有 \\(f(s, xy) = f(f(s, x), y)\\)。"
        },
        {
            "type": "list",
            "bbox": [
                0.06,
                0.837,
                0.906,
                0.923
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.926,
                0.619,
                0.94
            ],
            "angle": 0,
            "content": "在练习 \\(16\\sim 22\\) 中，求所给的确定性的有限状态自动机所识别的语言。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.123,
                0.042,
                0.159,
                0.056
            ],
            "angle": 0,
            "content": "774"
        },
        {
            "type": "header",
            "bbox": [
                0.203,
                0.041,
                0.28,
                0.057
            ],
            "angle": 0,
            "content": "第13章"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.099,
                0.121,
                0.111
            ],
            "angle": 0,
            "content": "16."
        },
        {
            "type": "image",
            "bbox": [
                0.126,
                0.102,
                0.484,
                0.201
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.521,
                0.099,
                0.545,
                0.111
            ],
            "angle": 0,
            "content": "17."
        },
        {
            "type": "image",
            "bbox": [
                0.55,
                0.102,
                0.932,
                0.174
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.216,
                0.121,
                0.228
            ],
            "angle": 0,
            "content": "18."
        },
        {
            "type": "image",
            "bbox": [
                0.126,
                0.216,
                0.504,
                0.322
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.522,
                0.216,
                0.546,
                0.228
            ],
            "angle": 0,
            "content": "19."
        },
        {
            "type": "image",
            "bbox": [
                0.551,
                0.216,
                0.928,
                0.318
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.337,
                0.121,
                0.349
            ],
            "angle": 0,
            "content": "20."
        },
        {
            "type": "image",
            "bbox": [
                0.126,
                0.336,
                0.528,
                0.434
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.45,
                0.121,
                0.462
            ],
            "angle": 0,
            "content": "21."
        },
        {
            "type": "image",
            "bbox": [
                0.126,
                0.45,
                0.569,
                0.623
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.638,
                0.121,
                0.65
            ],
            "angle": 0,
            "content": "22."
        },
        {
            "type": "image",
            "bbox": [
                0.126,
                0.638,
                0.567,
                0.784
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.802,
                0.796,
                0.816
            ],
            "angle": 0,
            "content": "23. 构造一个确定性的有限状态自动机，它能识别以01开始的所有比特串构成的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.82,
                0.796,
                0.833
            ],
            "angle": 0,
            "content": "24. 构造一个确定性的有限状态自动机，它能识别以10结束的所有比特串构成的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.838,
                0.841,
                0.851
            ],
            "angle": 0,
            "content": "25.构造一个确定性的有限状态自动机，它能识别包含字符串101的所有比特串构成的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.856,
                0.861,
                0.868
            ],
            "angle": 0,
            "content": "26.构造一个确定性的有限状态自动机，它能识别不包含3个连续0的所有比特串构成的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.873,
                0.841,
                0.886
            ],
            "angle": 0,
            "content": "27. 构造一个确定性的有限状态自动机，它能识别恰好包含3个0的所有比特串构成的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.891,
                0.841,
                0.904
            ],
            "angle": 0,
            "content": "28. 构造一个确定性的有限状态自动机，它能识别至少包含3个0的所有比特串构成的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.909,
                0.841,
                0.922
            ],
            "angle": 0,
            "content": "29. 构造一个确定性的有限状态自动机，它能识别包含3个连续1的所有比特串构成的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.927,
                0.832,
                0.939
            ],
            "angle": 0,
            "content": "30.构造一个确定性的有限状态自动机，它能识别以0或11开始的所有比特串构成的集合。"
        },
        {
            "type": "list",
            "bbox": [
                0.095,
                0.802,
                0.861,
                0.939
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.691,
                0.031,
                0.8,
                0.047
            ],
            "angle": 0,
            "content": "计算模型"
        },
        {
            "type": "page_number",
            "bbox": [
                0.848,
                0.033,
                0.883,
                0.047
            ],
            "angle": 0,
            "content": "775"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.089,
                0.823,
                0.104
            ],
            "angle": 0,
            "content": "31. 构造一个确定性的有限状态自动机，它能识别以 11 开始和结束的所有比特串构成的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.108,
                0.795,
                0.123
            ],
            "angle": 0,
            "content": "32. 构造一个确定性的有限状态自动机，它能识别包含偶数个1的所有比特串构成的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.127,
                0.795,
                0.142
            ],
            "angle": 0,
            "content": "33. 构造一个确定性的有限状态自动机，它能识别包含奇数个0的所有比特串构成的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.146,
                0.882,
                0.161
            ],
            "angle": 0,
            "content": "34. 构造一个确定性的有限状态自动机，它能识别包含偶数个0，奇数个1的所有比特串构成的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.165,
                0.851,
                0.18
            ],
            "angle": 0,
            "content": "35. 构造一个确定性的有限状态自动机，它能识别包含 0 后接奇数个 1 的所有比特串构成的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.184,
                0.882,
                0.199
            ],
            "angle": 0,
            "content": "36. 构造一个确定性的有限状态自动机，它能识别包含偶数个 1，奇数个 0 的所有比特串构成的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.203,
                0.911,
                0.237
            ],
            "angle": 0,
            "content": "37. 构造一个确定性的有限状态自动机，它能识别包含1个或多个1，并且以0作结束的所有比特串构成的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.241,
                0.882,
                0.256
            ],
            "angle": 0,
            "content": "38. 构造一个确定性的有限状态自动机，它能识别包含偶数个1，偶数个0的所有比特串构成的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.261,
                0.704,
                0.275
            ],
            "angle": 0,
            "content": "39. 如何改造有限状态自动机 \\(M\\) ，使经过改变的自动机能识别集合 \\(I^{*} - L(M)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.279,
                0.84,
                0.294
            ],
            "angle": 0,
            "content": "40. 使用练习39和例6构造的有限状态自动机来求能识别如下集合的确定性的有限状态自动机。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.299,
                0.461,
                0.313
            ],
            "angle": 0,
            "content": "a)不以两个0作为开始的比特串构成的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.318,
                0.461,
                0.332
            ],
            "angle": 0,
            "content": "b)不以两个0作为结束的比特串构成的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.337,
                0.677,
                0.351
            ],
            "angle": 0,
            "content": "c)包含至多一个0的比特串构成的集合（也就是说，不包含至少两个0）。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.356,
                0.911,
                0.39
            ],
            "angle": 0,
            "content": "41. 使用练习39叙述的方法以及练习25构造的有限状态自动机，求能识别不包含字符串101的比特串构成集合的确定性的有限状态自动机。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.394,
                0.911,
                0.428
            ],
            "angle": 0,
            "content": "42. 使用练习39叙述的方法以及练习29构造的有限状态自动机，求能识别不包含3个连续1的所有比特串构成集合的确定性的有限状态自动机。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.433,
                0.642,
                0.447
            ],
            "angle": 0,
            "content": "在练习 \\(43\\sim 49\\) 中，求所给的非确定性的有限状态自动机所识别的语言。"
        },
        {
            "type": "image",
            "bbox": [
                0.065,
                0.451,
                0.414,
                0.526
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.491,
                0.451,
                0.884,
                0.525
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.067,
                0.538,
                0.455,
                0.644
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.491,
                0.538,
                0.841,
                0.613
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.067,
                0.658,
                0.51,
                0.752
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.067,
                0.766,
                0.551,
                0.921
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.116,
                0.034,
                0.152,
                0.047
            ],
            "angle": 0,
            "content": "776"
        },
        {
            "type": "header",
            "bbox": [
                0.197,
                0.032,
                0.274,
                0.049
            ],
            "angle": 0,
            "content": "第13章"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.09,
                0.114,
                0.102
            ],
            "angle": 0,
            "content": "49."
        },
        {
            "type": "image",
            "bbox": [
                0.119,
                0.095,
                0.577,
                0.263
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.271,
                0.921,
                0.286
            ],
            "angle": 0,
            "content": "50. 求一个确定性的有限状态自动机，它能与练习43中的非确定性的有限状态自动机识别相同的语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.289,
                0.921,
                0.304
            ],
            "angle": 0,
            "content": "51. 求一个确定性的有限状态自动机，它能与练习44中的非确定性的有限状态自动机识别相同的语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.306,
                0.921,
                0.322
            ],
            "angle": 0,
            "content": "52. 求一个确定性的有限状态自动机，它能与练习45中的非确定性的有限状态自动机识别相同的语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.324,
                0.921,
                0.34
            ],
            "angle": 0,
            "content": "53. 求一个确定性的有限状态自动机，它能与练习46中的非确定性的有限状态自动机识别相同的语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.342,
                0.921,
                0.357
            ],
            "angle": 0,
            "content": "54. 求一个确定性的有限状态自动机，它能与练习 47 中的非确定性的有限状态自动机识别相同的语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.36,
                0.636,
                0.375
            ],
            "angle": 0,
            "content": "55. 对于下列每个集合，分别求识别它的确定性的有限状态自动机。"
        },
        {
            "type": "list",
            "bbox": [
                0.085,
                0.271,
                0.921,
                0.375
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.378,
                0.171,
                0.393
            ],
            "angle": 0,
            "content": "a) \\(\\{0\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.277,
                0.379,
                0.362,
                0.393
            ],
            "angle": 0,
            "content": "b) \\(\\{1, 00\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.47,
                0.378,
                0.667,
                0.394
            ],
            "angle": 0,
            "content": "c) \\(\\{1^n\\mid n = 2,3,4,\\dots \\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.397,
                0.936,
                0.43
            ],
            "angle": 0,
            "content": "56. 对于练习 55 中的每种语言，分别求识别它的非确定性的有限状态自动机，并且，如果可能，使之所具有的状态比你在练习 55 中所给的确定性的有限状态自动机更少。"
        },
        {
            "type": "text",
            "bbox": [
                0.074,
                0.433,
                0.856,
                0.448
            ],
            "angle": 0,
            "content": "* 57. 对于由个数相同的 0 和 1 组成的字符串构成的集合，证明没有有限状态自动机能够识别它。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.451,
                0.938,
                0.555
            ],
            "angle": 0,
            "content": "在练习 \\(58\\sim 62\\) 中，我们介绍了一种技术，该技术能使用最少可能状态数构造一个与给定的确定性的有限状态自动机等价的确定性的有限状态自动机。假设 \\(M = (S,I,f,s_0,F)\\) 是一个有限状态自动机，\\(k\\) 为非负整数。令 \\(R_{k}\\) 是自动机 \\(M\\) 的状态集合 \\(S\\) 上的关系，当且仅当对于每个输入字符串 \\(x\\) 满足 \\(l(x)\\leqslant k\\) 时 \\((l(x)\\) 表示字符串 \\(x\\) 的长度)，且当 \\(f(s,x)\\) 和 \\(f(t,x)\\) 同为终结状态或同为非终结状态时，有 \\(sR_{k}t\\) 。而且，令 \\(R_{*}\\) 是自动机 \\(M\\) 的状态集合 \\(S\\) 上的关系，对于每个输入字符串 \\(x\\) ，无论其长度为多少，当且仅当 \\(f(s,x)\\) 和 \\(f(t,x)\\) 同为终结状态或非终结状态时，有 \\(sR_{*}t\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.074,
                0.557,
                0.926,
                0.573
            ],
            "angle": 0,
            "content": "* 58. a) 证明：对于每个非负整数 \\(k\\)，\\(R_{k}\\) 是 \\(S\\) 上的等价关系。我们说如果 \\(sR_{k}t\\)，则状态 \\(s\\) 和 \\(t\\) 是 \\(k\\) 等价的。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.575,
                0.753,
                0.59
            ],
            "angle": 0,
            "content": "b) 证明：\\(R_*\\) 是 \\(S\\) 上的等价关系。我们说如果 \\(sR_*t\\)，则状态 \\(s\\) 和 \\(t\\) 是 \\(*\\) 等价的。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.593,
                0.936,
                0.626
            ],
            "angle": 0,
            "content": "c) 证明：如果状态 \\(s\\) 和 \\(t\\) 是自动机 \\(M\\) 的两个 \\(k\\) 等价状态，其中 \\(k\\) 是正整数，则 \\(s\\) 和 \\(k\\) 也是 \\((k - 1)\\) 等价的。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.629,
                0.936,
                0.662
            ],
            "angle": 0,
            "content": "d) 证明：如果 \\(k\\) 是正整数，则 \\(R_{k}\\) 的等价类是 \\(R_{k-1}\\) 等价类的细分。（集合划分的细分在9.5节练习49中的前导文中定义。）"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.665,
                0.733,
                0.679
            ],
            "angle": 0,
            "content": "e)证明：对于每个非负整数 \\(k\\) ，如果 \\(s\\) 和 \\(t\\) 是 \\(k\\) 等价的，则它们是 \\(\\divideontimes\\) 等价的。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.682,
                0.736,
                0.697
            ],
            "angle": 0,
            "content": "f) 证明：在给定的 \\(R\\)，等价类中，所有状态都是终结状态或都不是终结状态。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.7,
                0.859,
                0.715
            ],
            "angle": 0,
            "content": "g)证明：如果 \\(s\\) 和 \\(t\\) 是 \\(R_{*}\\) 等价的，则对于所有的 \\(a\\in I\\) ， \\(f(s,a)\\) 和 \\(f(t,a)\\) 也是 \\(R_{*}\\) 等价的。"
        },
        {
            "type": "text",
            "bbox": [
                0.074,
                0.717,
                0.936,
                0.75
            ],
            "angle": 0,
            "content": "*59. 证明：存在非负整数 \\(n\\)，使得自动机 \\(M\\) 的 \\(n\\) 等价类集合与 \\((n + 1)\\) 等价类集合是相同的。然后证明：对于该整数 \\(n\\)，自动机 \\(M\\) 的 \\(n\\) 等价类集合与 * 等价类集合等价。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.753,
                0.938,
                0.807
            ],
            "angle": 0,
            "content": "确定性的有限状态自动机 \\(M = (S, I, f, s_0, F)\\) 的商自动机是有限状态自动机 \\((\\overline{S}, I, \\overline{f}, [s_0]_{R_*}, \\overline{F})\\) 其中状态集合 \\(\\overline{S}\\) 是 \\(S\\) 的 * 等价类，对 \\(\\overline{M}\\) 的所有状态 \\([s]_{R_*}\\) 和输入符号 \\(a \\in I\\) ，转移函数 \\(\\overline{f}\\) 通过 \\(\\overline{f}([s]_{R_*}, a) = [f(s, a)]_{R_*}\\) 来定义，\\(\\overline{F}\\) 是包含自动机 \\(M\\) 的终结状态的 \\(R_*\\) 等价类的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.074,
                0.81,
                0.936,
                0.843
            ],
            "angle": 0,
            "content": "* 60. a) 证明：状态 \\(s\\) 和 \\(t\\) 是 0 等价的，当且仅当 \\(s\\) 和 \\(t\\) 要么都是终结状态，要么都不是终结状态。由此得出自动机 \\(\\overline{M}\\) 的每个终结状态，即 \\(R_{\\star}\\) 等价类，只包含自动机 \\(M\\) 的终结状态。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.845,
                0.936,
                0.878
            ],
            "angle": 0,
            "content": "b) 证明：如果 \\(k\\) 是正整数，状态 \\(s\\) 和 \\(t\\) 是 \\(k\\) 等价的，当且仅当对于所有的输入字符 \\(a \\in I\\)、\\(f(s, a)\\) 和 \\(f(t, a)\\) 是 \\((k-1)\\) 等价的。由此得出转移函数 \\(\\overline{f}\\) 是定义良好的。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.881,
                0.567,
                0.896
            ],
            "angle": 0,
            "content": "c)描述一个用来构造有限自动机 \\(M\\) 的商自动机的过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.899,
                0.797,
                0.913
            ],
            "angle": 0,
            "content": "**61. a) 证明：如果 \\(M\\) 是一个有限状态自动机，那么其商自动机能与 \\(M\\) 识别相同的语言。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.916,
                0.936,
                0.932
            ],
            "angle": 0,
            "content": "b)证明：如果 \\(M\\) 是一个有限状态自动机并且具有以下性质，对于自动机 \\(M\\) 的每个状态 \\(s\\) ，都有一个"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.673,
                0.035,
                0.784,
                0.052
            ],
            "angle": 0,
            "content": "计算模型"
        },
        {
            "type": "page_number",
            "bbox": [
                0.83,
                0.037,
                0.867,
                0.05
            ],
            "angle": 0,
            "content": "777"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.092,
                0.894,
                0.125
            ],
            "angle": 0,
            "content": "字符串 \\(x \\in I^{*}\\)，使得 \\(f(s_{0}, x) = s\\)，那么商自动机的状态数是与 \\(M\\) 等价的任何一个有限状态自动机的状态数的最小值。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.128,
                0.47,
                0.143
            ],
            "angle": 0,
            "content": "62. 回答关于下图所示的有限状态自动机 \\(M\\) 的问题。"
        },
        {
            "type": "image",
            "bbox": [
                0.256,
                0.152,
                0.691,
                0.312
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.314,
                0.621,
                0.328
            ],
            "angle": 0,
            "content": "a)当 \\(k = 0\\) ，1，2，3时，求 \\(M\\) 的 \\(k\\) 等价类，同时求 \\(M\\) 的 \\(\\ast\\) 等价类。"
        },
        {
            "type": "text",
            "bbox": [
                0.079,
                0.332,
                0.341,
                0.347
            ],
            "angle": 0,
            "content": "b)构造自动机 \\(M\\) 的商自动机 \\(\\overline{M}\\)"
        },
        {
            "type": "title",
            "bbox": [
                0.05,
                0.361,
                0.262,
                0.38
            ],
            "angle": 0,
            "content": "13.4 语言的识别"
        },
        {
            "type": "title",
            "bbox": [
                0.05,
                0.389,
                0.186,
                0.405
            ],
            "angle": 0,
            "content": "13.4.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.409,
                0.896,
                0.54
            ],
            "angle": 0,
            "content": "我们已经知道，有限状态自动机可以用作语言识别器。那么这些机器能识别什么样的集合呢？这个问题虽然看起来极为困难，但能被有限状态自动机所识别的语言有一个简单特征。这个问题由美国数学家斯蒂芬·克莱因(Stephen Kleene)于1956年首先解决。他证明了一个集合能够被一个有限状态自动机识别当且仅当这个集合是以任意顺序通过对空集、空串和单字符串的连接、并或克莱因闭包构造出来。以这种方法构造出来的集合称为正则集合。在13.1节中我们定义了正则文法。从名称上可以想到，有限状态自动机所识别的正则集合与正则文法之间具有某种联系。特别是，一个集合是正则的当且仅当它可以由一个正则文法生成。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.543,
                0.896,
                0.634
            ],
            "angle": 0,
            "content": "有一些集合不能由任何有限状态自动机识别，我们将给出这样一个集合。在本节的最后我们将简要讨论一些更强大的计算模型，如下推自动机和图灵机。正则集合是从空集、只含空串的集合、只含单字符的集合开始，以任意顺序通过连接、并和克莱因闭包运算形成的集合。我们将看到，正则集合是有限状态自动机识别的语言。为了定义正则集合，首先要定义正则表达式。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.644,
                0.517,
                0.661
            ],
            "angle": 0,
            "content": "定义1 集合 \\(I\\) 上的正则表达式的递归定义为："
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.664,
                0.338,
                0.68
            ],
            "angle": 0,
            "content": "符号 \\(\\varnothing\\) 是一个正则表达式；"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.683,
                0.338,
                0.699
            ],
            "angle": 0,
            "content": "符号 \\(\\lambda\\) 是一个正则表达式；"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.702,
                0.473,
                0.718
            ],
            "angle": 0,
            "content": "若 \\(x \\in I\\) 时，则符号 \\(x\\) 是一个正则表达式；"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.721,
                0.724,
                0.737
            ],
            "angle": 0,
            "content": "当 \\(A\\) 、 \\(\\pmb{B}\\) 是正则表达式时，符号 \\((AB)\\) 、 \\((A\\bigcup B)\\) 和 \\(A^*\\) 都是正则表达式。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.747,
                0.553,
                0.763
            ],
            "angle": 0,
            "content": "每个正则表达式都表示一个由下列规则定义的集合："
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.767,
                0.411,
                0.782
            ],
            "angle": 0,
            "content": "\\(\\varnothing\\) 表示空集，即没有字符串的集合；"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.786,
                0.414,
                0.801
            ],
            "angle": 0,
            "content": "\\(\\lambda\\) 表示集合 \\(\\{\\lambda\\}\\)，即空串组成的集合；"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.805,
                0.561,
                0.821
            ],
            "angle": 0,
            "content": "\\(x\\) 表示集合 \\(\\{x\\}\\) ，它只包含单个符号 \\(x\\) 组成的字符串；"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.824,
                0.42,
                0.839
            ],
            "angle": 0,
            "content": "\\((AB)\\) 表示 \\(\\mathbf{A}\\) 和 \\(\\pmb{B}\\) 代表的集合的连接；"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.843,
                0.42,
                0.858
            ],
            "angle": 0,
            "content": "\\((A \\cup B)\\) 表示 \\(A\\) 和 \\(B\\) 代表的集合的并；"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.862,
                0.419,
                0.877
            ],
            "angle": 0,
            "content": "\\(\\mathbf{A}^{*}\\) 表示 \\(\\mathbf{A}\\) 代表的集合的克莱因闭包。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.881,
                0.896,
                0.935
            ],
            "angle": 0,
            "content": "正则表达式表示的集合称为正则集合。今后，正则集合可由正则表达式来描述，所以，当我们提到正则集合 \\(A\\) 时，指的是此正则表达式 \\(A\\) 表示的集合。注意，在不必要时，我们将去掉正则表达式外面的括号。"
        }
    ]
]