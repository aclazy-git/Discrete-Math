[
    [
        {
            "type": "page_number",
            "bbox": [
                0.146,
                0.044,
                0.18,
                0.057
            ],
            "angle": 0,
            "content": "178"
        },
        {
            "type": "header",
            "bbox": [
                0.227,
                0.043,
                0.29,
                0.057
            ],
            "angle": 0,
            "content": "第3章"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.099,
                0.965,
                0.173
            ],
            "angle": 0,
            "content": "出最优解。在开始证明之前，我们证明存在一组硬币使得收银员算法（算法7）不一定得出使用尽可能少的硬币找零方案。例如，如果只有25美分、10美分和1美分硬币（而无5美分硬币）可用，则此收银员算法会用6枚硬币找30美分零钱（1个25美分和5个1美分硬币），而本来可以只用3个硬币，即3个10美分硬币的。"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.18,
                0.956,
                0.256
            ],
            "angle": 0,
            "content": "引理1 如果 \\(n\\) 是正整数，则用25美分、10美分、5美分和1美分，并用尽可能少的硬币找 \\(n\\) 美分零钱中，至多有2个10美分、至多有1个5美分、至多有4个1美分硬币，并且不可能同时有2个10美分和1个5美分硬币。用10美分、5美分和1美分硬币找的零钱总额不会超过24美分。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.263,
                0.964,
                0.395
            ],
            "angle": 0,
            "content": "证明 用反证法证明。我们要证明如果用到了超过指定数目的各种类型的硬币，就可以用等值的数目更少的硬币来替换。注意如果有3个10美分硬币，就可以换成1个25美分和1个5美分硬币；如果有2个5美分硬币，就可以换成1个10美分硬币；如果有5个1美分硬币，就可以换成1个5美分硬币；如果有2个10美分和1个5美分硬币，就可以换成1个25美分硬币。因为至多可以有2个10美分、1个5美分和4个1美分硬币，而不能同时有2个10美分和1个5美分硬币，所以当用尽可能少的硬币找 \\(n\\) 美分零钱时，24美分就是用10美分、5美分和1美分硬币能找的最多的钱。"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.402,
                0.954,
                0.44
            ],
            "angle": 0,
            "content": "定理1如果只用25美分、10美分、5美分和1美分硬币，收银员算法（算法7）总是产生硬币数量最少的找零方案。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.447,
                0.964,
                0.56
            ],
            "angle": 0,
            "content": "证明 用反证法证明。假设存在正整数 \\(n\\)，使得有办法将25美分、10美分、5美分和1美分硬币用少于贪婪算法所求出的硬币去找 \\(n\\) 美分零钱。首先注意，在这种找 \\(n\\) 美分零钱的最优方式中使用25美分硬币的个数 \\(q'\\)，一定等于贪婪算法所用25美分硬币的个数 \\(q\\)。为说明这一点，注意贪婪算法使用尽可能多的25美分硬币，所以 \\(q' \\leq q\\)。但是 \\(q'\\) 也不能小于 \\(q\\)。假如 \\(q'\\) 小于 \\(q\\)，需要在这种最优方式中用10美分、5美分和1美分硬币至少找出25美分零钱。而根据引理1，这是不可能的。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.561,
                0.964,
                0.655
            ],
            "angle": 0,
            "content": "由于在找零钱的这两种方式中一定有同样多的25美分硬币，所以在这两种方式中10美分、5美分和1美分硬币的总值一定相等，并且这些硬币的总值不超过24美分。10美分硬币的个数一定相等，因为贪婪算法使用尽可能多的10美分硬币。而根据引理1，当使用尽可能少的硬币找零钱时，至多使用1个5分硬币和4个1分硬币，所以在找零钱的最优方式中也使用尽可能多的10美分硬币。类似地，5美分硬币的个数相等；最终，1美分的个数相等。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.656,
                0.963,
                0.692
            ],
            "angle": 0,
            "content": "贪婪算法根据某一条件在每一步都做出最佳选择。下面的例子表明在多个条件中选择哪一个也可能是难以确定的。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.696,
                0.963,
                0.773
            ],
            "angle": 0,
            "content": "例7 假设我们有一组讲座，并预设了开始和结束时间。假设讲座一旦开始就会持续到结束为止、两个讲座不能同时进行、一个讲座可以在另一个讲座结束时开始，请设计一个贪婪算法能够在一个演讲厅里安排尽可能多的讲座。假设讲座 \\(j\\) 的开始时间为 \\(s_j\\)（这里 \\(s\\) 是指开始），结束时间为 \\(e_j\\)（这里 \\(e\\) 是指结束）。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.774,
                0.963,
                0.849
            ],
            "angle": 0,
            "content": "解 要采用贪婪算法来安排最多的讲座，即一个最优调度，我们需要确定在每一步如何选择增加哪个讲座。有很多准则可以用来在每一步选择一个讲座，这里我们选择那些与已选讲座没有重叠的讲座。比如，我们可以以最早开始时间为序来增加讲座，也可以以最短讲座时间为序来增加讲座，也可以以最早结束时间为序来增加讲座，或者可以用其他的准则。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.85,
                0.963,
                0.943
            ],
            "angle": 0,
            "content": "我们选择来考虑这些可能的准则。假设我们增加那个与已选讲座相容的讲座中开始时间最早的讲座。我们可以构造一个反例来证明这样的算法并非总是产生最优调度。例如，假定有三个讲座：第一个讲座上午8点开始中午12点结束，第二个讲座上午9点开始上午10点结束，而第三个讲座上午11点开始中午12点结束。我们首先选择第一个讲座，因为它开始得最早。但是一旦我们选择了第一个讲座，就不能选第二个或第三个讲座了，因为它们和第一个讲座有"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.697,
                0.037,
                0.787,
                0.052
            ],
            "angle": 0,
            "content": "算法"
        },
        {
            "type": "page_number",
            "bbox": [
                0.832,
                0.038,
                0.868,
                0.052
            ],
            "angle": 0,
            "content": "179"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.093,
                0.896,
                0.128
            ],
            "angle": 0,
            "content": "重叠。故该贪婪算法只选了一个讲座。这不是最优的，因为我们可以安排第二个和第三个讲座，这两个没有重叠。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.13,
                0.897,
                0.262
            ],
            "angle": 0,
            "content": "现在假设我们增加那个与已选讲座相容的讲座中持续时间最短的讲座。我们依然可以找到一个反例来证明这样的算法并非总是产生最优调度。为此，假定有三个讲座：第一个讲座上午8点开始上午9点15分结束，第二个讲座上午9点开始上午10点结束，而第三个讲座上午9点45分开始上午11点结束。我们选择第二个讲座，因为它是最短的只需要一小时。一旦我们选择了第二个讲座，就不能选第一个或第三个讲座了，因为没有一个和第二个讲座是不重叠的。故该贪婪算法只选了一个讲座。可是有可能选择两个讲座的，第一个和第三个讲座，这两个没有重叠。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.263,
                0.897,
                0.339
            ],
            "angle": 0,
            "content": "然后，可以证明如果我们在每一步选择那个与已选讲座相容的讲座中结束时间最早的讲座，我们就能安排最多的讲座。我们将在第5章用数学归纳法来证明它。我们要做的第一步是根据结束时间的升序来对讲座进行排序。排序后对讲座重新编号使得 \\(e_1 \\leqslant e_2 \\leqslant \\dots \\leqslant e_n\\) 。这样的贪婪算法如算法8所示。"
        },
        {
            "type": "title",
            "bbox": [
                0.063,
                0.355,
                0.302,
                0.371
            ],
            "angle": 0,
            "content": "算法8 安排讲座的贪婪算法"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.374,
                0.78,
                0.407
            ],
            "angle": 0,
            "content": "procedure schedule \\((s_1\\leqslant s_2\\leqslant \\dots \\leqslant s_n\\) ：讲座的开始时间， \\(e_1\\leqslant e_2\\leqslant \\dots \\leqslant e_n\\) ：讲座的结束时间）根据结束时间对讲座排序，重新编号使得 \\(e_1\\leqslant e_2\\leqslant \\dots \\leqslant e_n\\)"
        },
        {
            "type": "equation",
            "bbox": [
                0.063,
                0.41,
                0.127,
                0.425
            ],
            "angle": 0,
            "content": "\\[\nS := \\varnothing\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.063,
                0.429,
                0.184,
                0.442
            ],
            "angle": 0,
            "content": "\\[\nf o r j := 1 t o n\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.446,
                0.29,
                0.46
            ],
            "angle": 0,
            "content": "if 讲座 \\(j\\) 与 \\(S\\) 相容 then"
        },
        {
            "type": "equation",
            "bbox": [
                0.158,
                0.464,
                0.306,
                0.478
            ],
            "angle": 0,
            "content": "\\[\nS := S \\cup \\{\\text {讲 座} j \\}\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.063,
                0.482,
                0.33,
                0.496
            ],
            "angle": 0,
            "content": "\\[\n\\text {r e t u r n} S \\{S \\text {是 已 安 排 讲 座 的 集 合} \\}\n\\]"
        },
        {
            "type": "title",
            "bbox": [
                0.05,
                0.523,
                0.219,
                0.539
            ],
            "angle": 0,
            "content": "3.1.6 停机问题"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.543,
                0.897,
                0.674
            ],
            "angle": 0,
            "content": "现在我们来描述计算机科学中非常有名的一个定理的证明。我们将要证明存在这样一个问题，它不能用任何过程求解。即我们要证明存在不可解问题。我们要研究的问题是停机问题（halting problem）。它询问是否存在一个过程(procedure)能做这件事：该过程以一个计算机程序以及该程序的一个输入作为输入，并判断该程序在给定输入运行时是否最终能停止。显然，如果真的存在，有这样一个过程是非常方便的。在编写或者调试程序的时候，能够判断一个程序是否进入无限循环是非常有帮助的。然而，1936年图灵证明这样的过程是不存在的（参见13.4节他的传记）。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.675,
                0.894,
                0.749
            ],
            "angle": 0,
            "content": "在给出停机问题是不可解的证明之前，首先要知道我们不能简单地运行一个程序并观察它在做什么来确定是否能够结束。如果程序结束，就有了解；但是如果过了任意某个固定长度的时间段后程序还在运行，我们就不知道是否它永不停机，或者仅仅是我们等待它停止的时间不够长。毕竟，设计一个仅在10亿年后才会终止的程序并不难。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.751,
                0.894,
                0.807
            ],
            "angle": 0,
            "content": "我们将描述图灵停机问题是不可解的证明，这是一个采用反证法的证明。（读者应该注意到我们的证明并不是完全严格的，因为我们还没有明确地定义什么是一个过程。因此，需要图灵机的概念作为补充。图灵机的概念会在13.5节引入。）"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.808,
                0.894,
                0.882
            ],
            "angle": 0,
            "content": "证明 假设停机问题有一个解，一个称为 \\(H(P, I)\\) 的过程。过程 \\(H(P, I)\\) 有两个输入项，一个是程序 \\(P\\) ，另一个是程序 \\(P\\) 的一个输入 \\(I\\) 。如果 \\(H\\) 判定 \\(P\\) 在给定输入 \\(I\\) 时能终止，则 \\(H(P, I)\\) 将产生字符串“停机”作为输出。反之，\\(H(P, I)\\) 将产生字符串“无限循环”作为输出。现在我们将导出一个矛盾。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.884,
                0.894,
                0.94
            ],
            "angle": 0,
            "content": "编写一个过程的时候，它本身就表达为一个由字符构成的串，该串可以解释为一个比特序列。这意味着一个程序本身就可以当作数据使用。因此，一个程序可以作为另一个程序的输入，甚至是自身的输入。这样， \\(H\\) 可以将一个程序 \\(P\\) 作为它的两个输入，即一个程序和该程"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.906,
                0.546,
                0.947,
                0.561
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.907,
                0.809,
                0.937,
                0.835
            ],
            "angle": 0,
            "content": "2"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.137,
                0.039,
                0.172,
                0.052
            ],
            "angle": 0,
            "content": "180"
        },
        {
            "type": "header",
            "bbox": [
                0.218,
                0.038,
                0.282,
                0.053
            ],
            "angle": 0,
            "content": "第3章"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.095,
                0.823,
                0.11
            ],
            "angle": 0,
            "content": "序的输入。 \\(H\\) 应该可以判断当 \\(P\\) 给定其自身的副本作为输入时， \\(P\\) 是否会停机。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.115,
                0.954,
                0.187
            ],
            "angle": 0,
            "content": "为了证明不存在过程 \\(H\\) 能够求解停机问题，我们构造一个简单过程 \\(K(P)\\)，它的工作原理如下，并利用 \\(H(P, P)\\) 的输出。如果 \\(H(P, P)\\) 的输出是“无限循环”，即 \\(P\\) 在自身作为输入时会无限循环，那么让 \\(K(P)\\) 停机。如果 \\(H(P, P)\\) 的输出是“停机”，即 \\(P\\) 在自身作为输入时会停机，那么让 \\(K(P)\\) 无限循环。即，\\(K(P)\\) 做出和 \\(H(P, P)\\) 的输出相反结果（如图3所示）。"
        },
        {
            "type": "image",
            "bbox": [
                0.191,
                0.197,
                0.857,
                0.298
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.422,
                0.307,
                0.645,
                0.322
            ],
            "angle": 0,
            "content": "图3 证明停机问题不可解"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.333,
                0.957,
                0.427
            ],
            "angle": 0,
            "content": "现在假设把 \\(K\\) 作为 \\(K\\) 的输入。需要注意，如果 \\(H(K, K)\\) 的输出是“无限循环”，那么根据 \\(K\\) 的定义可以得出 \\(K(K)\\) 停机。这意味着由 \\(H\\) 的定义，\\(H(K, K)\\) 的输出是“停机”，这是一个矛盾。否则，如果 \\(H(K, K)\\) 的输出是“停机”，那么根据 \\(K\\) 的定义 \\(K(K)\\) 会无限循环，这意味着由 \\(H\\) 的定义，\\(H(K, K)\\) 的输出是“无限循环”。这也是一个矛盾。这样，\\(H\\) 并不总能给出正确的答案。因此，没有这样的过程能解决停机问题。"
        },
        {
            "type": "title",
            "bbox": [
                0.112,
                0.437,
                0.16,
                0.452
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.457,
                0.783,
                0.47
            ],
            "angle": 0,
            "content": "1. 列出算法 1 在列表 1, 8, 12, 9, 11, 2, 14, 5, 10, 4 中找最大值的所有步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.475,
                0.722,
                0.488
            ],
            "angle": 0,
            "content": "2. 判断下列过程具有和缺乏在正文中（算法1之后）所描述的哪些算法特征。"
        },
        {
            "type": "list",
            "bbox": [
                0.111,
                0.457,
                0.783,
                0.488
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.493,
                0.389,
                0.507
            ],
            "angle": 0,
            "content": "a) procedure double(n: 正整数)"
        },
        {
            "type": "code",
            "bbox": [
                0.153,
                0.511,
                0.242,
                0.541
            ],
            "angle": 0,
            "content": "while \\(n > 0\\) \\(n:=2n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.547,
                0.383,
                0.56
            ],
            "angle": 0,
            "content": "b) procedure divide(n: 正整数)"
        },
        {
            "type": "code",
            "bbox": [
                0.155,
                0.565,
                0.249,
                0.58
            ],
            "angle": 0,
            "content": "while \\(n\\geqslant 0\\)"
        },
        {
            "type": "code",
            "bbox": [
                0.175,
                0.584,
                0.252,
                0.597
            ],
            "angle": 0,
            "content": "\\(m:=1/n\\)"
        },
        {
            "type": "code",
            "bbox": [
                0.175,
                0.602,
                0.255,
                0.613
            ],
            "angle": 0,
            "content": "\\(n:=n-1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.137,
                0.619,
                0.37,
                0.632
            ],
            "angle": 0,
            "content": "c) procedure sum(n: 正整数)"
        },
        {
            "type": "code",
            "bbox": [
                0.155,
                0.638,
                0.23,
                0.65
            ],
            "angle": 0,
            "content": "sum \\(\\coloneqq 0\\)"
        },
        {
            "type": "code",
            "bbox": [
                0.155,
                0.655,
                0.248,
                0.668
            ],
            "angle": 0,
            "content": "while \\(i <   10\\)"
        },
        {
            "type": "code",
            "bbox": [
                0.175,
                0.673,
                0.298,
                0.686
            ],
            "angle": 0,
            "content": "\\(\\mathrm{sum}:= \\mathrm{sum} + i\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.137,
                0.691,
                0.399,
                0.704
            ],
            "angle": 0,
            "content": "d) procedure choose(a, b: 整数)"
        },
        {
            "type": "code",
            "bbox": [
                0.156,
                0.709,
                0.248,
                0.721
            ],
            "angle": 0,
            "content": "\\(x\\coloneqq a\\) 或 \\(b\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.726,
                0.466,
                0.739
            ],
            "angle": 0,
            "content": "3. 设计一个求列表中所有整数之和的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.744,
                0.961,
                0.775
            ],
            "angle": 0,
            "content": "4. 描述一个算法，以 \\( n \\) 个整数的列表作为输入，求出列表中相邻整数后一个数减去前一个数的最大差值作为输出。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.78,
                0.961,
                0.811
            ],
            "angle": 0,
            "content": "5.描述一个算法，以 \\(n\\) 个按非递减序排列的整数的列表作为输入，求出所有出现两次以上的值的列表。（一列整数是非递减序的，如果列表中的每个整数至少和列表中前一项一样大）"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.816,
                0.725,
                0.829
            ],
            "angle": 0,
            "content": "6. 描述一个算法，以 \\( n \\) 个整数的列表作为输入，求出列表中负整数的个数。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.834,
                0.961,
                0.864
            ],
            "angle": 0,
            "content": "7. 描述一个算法，以 \\( n \\) 个整数的列表作为输入，求出列表中最后一个偶数的位置，或者如果列表中没有偶数就返回0。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.869,
                0.961,
                0.9
            ],
            "angle": 0,
            "content": "8. 描述一个算法，以 \\( n \\) 个不同整数的列表作为输入，求出列表中最大偶数的位置，或者如果列表中没有偶数就返回0。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.905,
                0.961,
                0.935
            ],
            "angle": 0,
            "content": "9.回文(palindrome)是从前向后读和从后向前读都一样的串。描述一个判定 \\(n\\) 个字符的串是否为回文的算法。"
        },
        {
            "type": "list",
            "bbox": [
                0.113,
                0.726,
                0.961,
                0.935
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.691,
                0.041,
                0.78,
                0.057
            ],
            "angle": 0,
            "content": "算法"
        },
        {
            "type": "page_number",
            "bbox": [
                0.827,
                0.043,
                0.86,
                0.056
            ],
            "angle": 0,
            "content": "181"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.098,
                0.892,
                0.132
            ],
            "angle": 0,
            "content": "10. 设计计算 \\(x^n\\) 的算法，其中 \\(x\\) 是实数，\\(n\\) 是整数。[提示：首先给出一个 \\(n\\) 为非负整数时从 1 开始不断乘以 \\(x\\) 来计算 \\(x^n\\) 的过程。然后扩展这一过程利用 \\(x^{-n} = 1 / x^n\\) 的事实来计算当 \\(n\\) 为负数时的 \\(x^n\\)。]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.134,
                0.836,
                0.149
            ],
            "angle": 0,
            "content": "11. 描述一个交换变量 \\(x\\) 和 \\(y\\) 值的算法，只许使用赋值。至少需要多少个赋值语句才能完成交换？"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.151,
                0.892,
                0.184
            ],
            "angle": 0,
            "content": "12. 描述一个只使用赋值语句实现用三元组 \\((y, z, x)\\) 来代替 \\((x, y, z)\\) 的算法。最少需要多少个赋值语句？"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.187,
                0.698,
                0.202
            ],
            "angle": 0,
            "content": "13. 列出在序列 1, 3, 4, 5, 6, 8, 9, 11 中搜索 9 的所有步骤，使用的算法是："
        },
        {
            "type": "text",
            "bbox": [
                0.077,
                0.204,
                0.174,
                0.219
            ],
            "angle": 0,
            "content": "a)线性搜索"
        },
        {
            "type": "text",
            "bbox": [
                0.484,
                0.204,
                0.581,
                0.219
            ],
            "angle": 0,
            "content": "b)二分搜索"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.222,
                0.747,
                0.237
            ],
            "angle": 0,
            "content": "14. 给定练习 13 给出的序列，列出采用线性搜索和二分搜索时搜索 7 使用的所有步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.24,
                0.78,
                0.255
            ],
            "angle": 0,
            "content": "15. 描述一个算法，把整数 \\( x \\) 插入到按递增序排列的整数表 \\( a_1, a_2, \\dots, a_n \\) 中合适的位置。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.257,
                0.481,
                0.272
            ],
            "angle": 0,
            "content": "16. 描述一个求自然数的有限序列中最小整数的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.275,
                0.887,
                0.29
            ],
            "angle": 0,
            "content": "17. 描述一个算法，求整数的有限列表中最大元素首次出现的位置，其中列表中的整数不一定互不相同。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.293,
                0.887,
                0.308
            ],
            "angle": 0,
            "content": "18. 描述一个算法，求整数的有限列表中最小元素最后出现的位置，其中列表中的整数不一定互不相同。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.31,
                0.894,
                0.361
            ],
            "angle": 0,
            "content": "19. 描述一个算法，计算由三个整数构成的集合的最大值、中间值、平均值和最小值。（整数集合的中间值（median）是把这些整数按增序排列时中间元素的值。整数集合的平均值（mean）是这些整数之和除以整数个数。）"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.363,
                0.518,
                0.378
            ],
            "angle": 0,
            "content": "20. 描述一个求整数的有限序列中最大和最小整数的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.381,
                0.555,
                0.395
            ],
            "angle": 0,
            "content": "21. 描述一个算法，把任意长度整数序列的头三项排成递增序。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.398,
                0.894,
                0.431
            ],
            "angle": 0,
            "content": "22. 描述一个算法，求英文句子中最长的单词（这里句子是指符号的序列，符号可以是一个字母或者一个空格，句子可以被分隔成交替的单词和空格）。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.434,
                0.852,
                0.449
            ],
            "angle": 0,
            "content": "23. 描述一个算法，判断从一个整数的有限集合到另一个整数的有限集合的一个函数是否是映上的。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.452,
                0.76,
                0.466
            ],
            "angle": 0,
            "content": "24. 描述一个算法，判断从一个有限集合到另一个有限集合的一个函数是否是一对一的。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.469,
                0.755,
                0.484
            ],
            "angle": 0,
            "content": "25. 描述一个算法，逐一检查比特串中每比特是否为 1，数一数其中为 1 的比特的个数。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.487,
                0.894,
                0.519
            ],
            "angle": 0,
            "content": "26. 改动算法3使得二分搜索过程在算法的每一阶段都比较 \\(x\\) 和 \\(a_{m}\\)，并且如果 \\(x = a_{m}\\) 则算法终止。算法的这个版本有何优越之处？"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.522,
                0.894,
                0.555
            ],
            "angle": 0,
            "content": "27. 三分搜索算法是在递增序整数表中通过连续地把表分成大小相等（或尽可能接近相等）的三个子表，并将搜索限制在一个合适的子表中的方法来定位一个元素。描述这一算法的步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.557,
                0.894,
                0.59
            ],
            "angle": 0,
            "content": "28. 描述在递增序整数表中通过连续地把表分成大小相等（或尽可能接近相等）的四个子表，并将搜索限制在一个合适的子表中的方法来定位一个元素的算法步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.592,
                0.894,
                0.625
            ],
            "angle": 0,
            "content": "在一个元素列表中，同一个元素可能出现多次。这样一个列表的众数(mode)是一个其出现次数不少于其他元素的元素。当有多个元素都出现最大次数时，一个列表就有多个众数。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.628,
                0.894,
                0.661
            ],
            "angle": 0,
            "content": "29. 设计一个算法，求非递减序整数表的一个众数。（一列整数是非递减序的，如果列表中的每个整数至少和列表中前一项一样大。）"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.663,
                0.894,
                0.696
            ],
            "angle": 0,
            "content": "30. 设计一个算法，求非递减序整数表的所有众数（一列整数是非递减序的，如果列表中的每个整数至少和列表中前一项一样大）。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.699,
                0.894,
                0.731
            ],
            "angle": 0,
            "content": "31. 两个字符串被称为易位词（anagram），如果这两个字符串可以通过重新排列其字符相互转换。试用下列方法设计一个算法来判断两个字符串是否是易位词。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.734,
                0.446,
                0.749
            ],
            "angle": 0,
            "content": "a)首先找出每个字符在字符串中出现的频率。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.752,
                0.392,
                0.767
            ],
            "angle": 0,
            "content": "b)首先对两个字符串的字符进行排序。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.769,
                0.655,
                0.784
            ],
            "angle": 0,
            "content": "32. 给定 \\(n\\) 个实数 \\(x_{1}, x_{2}, \\cdots, x_{n}\\)，试用下列方法找出最靠近的两个实数。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.787,
                0.428,
                0.802
            ],
            "angle": 0,
            "content": "a)用蛮力算法找出每一对实数之间的距离。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.805,
                0.54,
                0.82
            ],
            "angle": 0,
            "content": "b)对实数进行排序，并计算最少数量的距离来求解问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.822,
                0.69,
                0.837
            ],
            "angle": 0,
            "content": "33. 设计一个算法，求整数序列中第一个与序列中排在它前面的某项相等的项。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.84,
                0.671,
                0.855
            ],
            "angle": 0,
            "content": "34. 设计一个算法，找出整数有限序列中所有那些大于它前面各项之和的项。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.858,
                0.597,
                0.873
            ],
            "angle": 0,
            "content": "35. 设计一个算法，求正整数序列中第一个小于其紧挨着前项的项。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.875,
                0.637,
                0.89
            ],
            "angle": 0,
            "content": "36. 用冒泡排序来排序 6, 2, 3, 1, 5, 4, 说明在每一步所获得的列表。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.893,
                0.611,
                0.908
            ],
            "angle": 0,
            "content": "37. 用冒泡排序来排序3，1，5，7，4，说明在每一步所获得的列表。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.911,
                0.645,
                0.926
            ],
            "angle": 0,
            "content": "38. 用冒泡排序来排序 \\(d, f, k, m, a, b\\) ，说明在每一步所获得的列表。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.928,
                0.82,
                0.943
            ],
            "angle": 0,
            "content": "* 39.改编冒泡排序算法使得当不再需要交换时算法停止。用伪代码描述这个更有效的算法版本。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.141,
                0.046,
                0.178,
                0.06
            ],
            "angle": 0,
            "content": "182"
        },
        {
            "type": "header",
            "bbox": [
                0.222,
                0.045,
                0.288,
                0.06
            ],
            "angle": 0,
            "content": "第3章"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.102,
                0.684,
                0.116
            ],
            "angle": 0,
            "content": "40. 用插入排序来排序练习36中的列表，说明在每一步所获得的列表。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.12,
                0.684,
                0.134
            ],
            "angle": 0,
            "content": "41. 用插入排序来排序练习37中的列表，说明在每一步所获得的列表。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.138,
                0.684,
                0.151
            ],
            "angle": 0,
            "content": "42. 用插入排序来排序练习38中的列表，说明在每一步所获得的列表。"
        },
        {
            "type": "list",
            "bbox": [
                0.11,
                0.102,
                0.684,
                0.151
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.057,
                0.155,
                0.097,
                0.172
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.155,
                0.957,
                0.187
            ],
            "angle": 0,
            "content": "选择排序（selection sort）首先找出列表中的最小元素。把这个元素移到前面。然后找出剩余元素里的最小元素并且把它放到第二个位置。重复这个过程，直到整个列表都已经排好序为止。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.19,
                0.397,
                0.204
            ],
            "angle": 0,
            "content": "43. 用选择排序来排列下面的列表。"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.208,
                0.286,
                0.221
            ],
            "angle": 0,
            "content": "a)3，5，4，1，2"
        },
        {
            "type": "text",
            "bbox": [
                0.551,
                0.208,
                0.692,
                0.221
            ],
            "angle": 0,
            "content": "b)5，4，3，2，1"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.226,
                0.284,
                0.238
            ],
            "angle": 0,
            "content": "c)1，2，3，4，5"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.243,
                0.377,
                0.256
            ],
            "angle": 0,
            "content": "44. 用伪代码写出选择排序算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.26,
                0.841,
                0.274
            ],
            "angle": 0,
            "content": "45. 描述一个基于线性搜索的算法，确定在已经排序的列表中插入一个新元素的正确位置。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.278,
                0.84,
                0.292
            ],
            "angle": 0,
            "content": "46. 描述一个基于二分搜索的算法，确定在已经排序的列表中插入一个新元素的正确位置。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.296,
                0.584,
                0.31
            ],
            "angle": 0,
            "content": "47. 用插入排序对列表1，2，…， \\(n\\) 排序需要多少次比较？"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.314,
                0.639,
                0.327
            ],
            "angle": 0,
            "content": "48. 用插入排序对列表 \\( n \\)，\\( n - 1 \\)，…，2，1 排序需要多少次比较？"
        },
        {
            "type": "list",
            "bbox": [
                0.108,
                0.26,
                0.841,
                0.327
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.331,
                0.956,
                0.362
            ],
            "angle": 0,
            "content": "二分插入排序是插入排序的一个变体，使用二分搜索技术（参见练习46）而非线性搜索技术，把第 \\(i\\) 个元素插入到已经排序的元素中的正确位置。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.366,
                0.738,
                0.38
            ],
            "angle": 0,
            "content": "49. 列出二分插入排序对列表3，2，4，5，1，6进行排序时使用的所有步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.384,
                0.885,
                0.398
            ],
            "angle": 0,
            "content": "50. 比较插入排序和二分插入排序对列表7，4，3，8，1，5，4，2进行排序时所用的比较次数。"
        },
        {
            "type": "list",
            "bbox": [
                0.108,
                0.366,
                0.885,
                0.398
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.401,
                0.416,
                0.415
            ],
            "angle": 0,
            "content": "*51. 用伪代码写出二分插入排序算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.419,
                0.956,
                0.45
            ],
            "angle": 0,
            "content": "52. a) 设计插入排序的一个变体，用线性搜索技术把第 \\(j\\) 个元素插入正确位置，即首先将它与第 \\(j-1\\) 个元素比较，然后如有必要再与第 \\(j-2\\) 个元素比较，依次进行下去。"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.454,
                0.473,
                0.468
            ],
            "angle": 0,
            "content": "b)用你的算法来排序3，2，4，5，1，6。"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.472,
                0.361,
                0.486
            ],
            "angle": 0,
            "content": "c)用这个算法求解练习47。"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.49,
                0.363,
                0.503
            ],
            "angle": 0,
            "content": "d)用这个算法求解练习48。"
        },
        {
            "type": "list",
            "bbox": [
                0.14,
                0.454,
                0.473,
                0.503
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.507,
                0.868,
                0.521
            ],
            "angle": 0,
            "content": "53. 当一个元素列表接近于正确顺序时，采用插入排序或者练习 52 描述的变体，哪一种更好？"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.525,
                0.782,
                0.539
            ],
            "angle": 0,
            "content": "54. 列出朴素字符串匹配器在文本 COVFFE中寻找模式 FE 的所有出现时的步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.542,
                0.816,
                0.556
            ],
            "angle": 0,
            "content": "55. 列出朴素字符串匹配器在文本TACAGACG中寻找模式ACG的所有出现时的步骤。"
        },
        {
            "type": "list",
            "bbox": [
                0.108,
                0.507,
                0.868,
                0.556
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.56,
                0.755,
                0.574
            ],
            "angle": 0,
            "content": "56. 采用收银员算法，用25美分、10美分、5美分和1美分硬币找出下列零钱："
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.578,
                0.223,
                0.592
            ],
            "angle": 0,
            "content": "a)87美分"
        },
        {
            "type": "text",
            "bbox": [
                0.551,
                0.579,
                0.63,
                0.591
            ],
            "angle": 0,
            "content": "b)49美分"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.596,
                0.222,
                0.608
            ],
            "angle": 0,
            "content": "c)99美分"
        },
        {
            "type": "text",
            "bbox": [
                0.55,
                0.596,
                0.63,
                0.608
            ],
            "angle": 0,
            "content": "d)33美分"
        },
        {
            "type": "list",
            "bbox": [
                0.14,
                0.578,
                0.63,
                0.608
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.613,
                0.755,
                0.627
            ],
            "angle": 0,
            "content": "57. 采用收银员算法，用25美分、10美分、5美分和1美分硬币找出下列零钱："
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.631,
                0.223,
                0.644
            ],
            "angle": 0,
            "content": "a)51美分"
        },
        {
            "type": "text",
            "bbox": [
                0.551,
                0.631,
                0.63,
                0.644
            ],
            "angle": 0,
            "content": "b)69美分"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.649,
                0.222,
                0.661
            ],
            "angle": 0,
            "content": "c)76美分"
        },
        {
            "type": "text",
            "bbox": [
                0.55,
                0.649,
                0.63,
                0.661
            ],
            "angle": 0,
            "content": "d)60美分"
        },
        {
            "type": "list",
            "bbox": [
                0.14,
                0.631,
                0.63,
                0.661
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.665,
                0.956,
                0.697
            ],
            "angle": 0,
            "content": "58. 采用收银员算法，用25美分、10美分和1美分（但是无5美分）硬币找出练习56中的各种零钱。对于哪些零钱数，贪婪算法使用尽可能少的这些面值的硬币？"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.7,
                0.956,
                0.732
            ],
            "angle": 0,
            "content": "59. 采用收银员算法，用25美分、10美分和1美分（但是无5美分）硬币找出练习57中的各种零钱。对于哪些零钱数，贪婪算法使用尽可能少的这些面值的硬币？"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.736,
                0.956,
                0.768
            ],
            "angle": 0,
            "content": "60. 证明如果有面值12美分的硬币，则用25美分、12美分、10美分、5美分和1美分硬币的收银员算法，不一定总是用最少的硬币数找零钱。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.771,
                0.956,
                0.82
            ],
            "angle": 0,
            "content": "61. 用算法7从一组候选演讲中选择以便在报告厅安排尽可能多的演讲。假设这些演讲的开始和结束时间(均为上午)是：9:00和9:45；9:30和10:00；9:50和10:15；10:00和10:30；10:10和10:25；10:30和10:55；10:15和10:45；10:30和11:00；10:45和11:30；10:55和11:25；11:00和11:15。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.824,
                0.956,
                0.856
            ],
            "angle": 0,
            "content": "62. 证明在解决报告厅安排一组演讲(如例7所示)的贪婪算法中，如果在每一步都选择一个与其他演讲冲突最少的演讲，则不一定产生最优解。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.86,
                0.955,
                0.891
            ],
            "angle": 0,
            "content": "* 63. a) 设计一个贪婪算法，给定每个讲座的开始时间和结束时间，确定容纳 \\( n \\) 个讲座所需要的最少的报告厅数目。"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.894,
                0.356,
                0.908
            ],
            "angle": 0,
            "content": "b) 证明你的算法是最优的。"
        },
        {
            "type": "list",
            "bbox": [
                0.095,
                0.665,
                0.956,
                0.908
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.052,
                0.912,
                0.096,
                0.928
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.912,
                0.956,
                0.944
            ],
            "angle": 0,
            "content": "假设有 \\(s\\) 位男士 \\(m_{1}\\) ， \\(m_{2}\\) ，…， \\(m_{s}\\) 和 \\(s\\) 位女士 \\(\\omega_{1}\\) ， \\(\\omega_{2}\\) ，…， \\(\\omega_{s}\\) 。我们希望为每人匹配一位异性。再者，假设每人按自己的偏爱程度对异性进行排序，不允许并列。我们称将一组异性结为夫妇的一个匹配是稳"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.695,
                0.034,
                0.785,
                0.049
            ],
            "angle": 0,
            "content": "算法"
        },
        {
            "type": "page_number",
            "bbox": [
                0.832,
                0.036,
                0.866,
                0.048
            ],
            "angle": 0,
            "content": "183"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.09,
                0.893,
                0.123
            ],
            "angle": 0,
            "content": "定的(stable)，如果不能找到这样一对没有匹配的男士 \\(m\\) 和女士 \\(\\omega\\)，使得 \\(m\\) 喜欢 \\(\\omega\\) 胜过喜欢他被指派的伴侣，同时 \\(\\omega\\) 喜欢 \\(m\\) 胜过喜欢她被指派的伴侣。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.126,
                0.894,
                0.195
            ],
            "angle": 0,
            "content": "64. 假设有三位男士 \\(m_{1}\\) 、 \\(m_{2}\\) 和 \\(m_{3}\\) ，三位女士 \\(\\varpi_{1}\\) 、 \\(\\varpi_{2}\\) 和 \\(\\varpi_{3}\\) 。再者，假设男士对三位女士的喜欢程度由高到低的排序是： \\(m_{1}:w_{3},w_{1},w_{2};m_{2}:w_{1},w_{2},w_{3};m_{3}:w_{2},w_{3},w_{1}\\) ；而女士对三位男士的喜欢程度由高到低的排序是： \\(\\varpi_{1}:m_{1},m_{2},m_{3};\\varpi_{2}:m_{2},m_{1},m_{3};\\varpi_{3}:m_{3},m_{2},m_{1}\\) 。对于构成三对夫妇的所有六种可能的每一种情况，判断该匹配是否是稳定的。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.198,
                0.894,
                0.322
            ],
            "angle": 0,
            "content": "延迟接受算法(deferred acceptance algorithm)也称为Gale-Shapley算法，可以用来构造稳定的男女匹配。在这个算法中，一种性别的人是求婚者，另一种性别的人是被求婚者。该算法使用了一系列回合，在每个回合，前一轮的求婚中被拒绝的求婚者向他(她)最喜欢的、还没有拒绝过他(她)的被求婚者求婚。被求婚者会拒绝所有的求婚，除了在这轮或之前回合中来求婚的所有求婚者中排名最靠前的那位之外。这位排名最前的求婚者的求婚维持待定，并且会在以后的某个回合中被拒绝，如果在那个回合中有一位更有魅力的求婚者来求婚。当每个求婚者都恰有一个待定的求婚时一系列回合结束，此时所有待定的求婚都被接受。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.325,
                0.312,
                0.34
            ],
            "angle": 0,
            "content": "65. 用伪代码写出延迟接受算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.343,
                0.293,
                0.358
            ],
            "angle": 0,
            "content": "66. 证明延迟接受算法可终止。"
        },
        {
            "type": "text",
            "bbox": [
                0.035,
                0.361,
                0.515,
                0.376
            ],
            "angle": 0,
            "content": "* 67. 证明延迟接受算法终止时总可以产生一个稳定的匹配。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.379,
                0.894,
                0.485
            ],
            "angle": 0,
            "content": "序列的一个元素如果重复出现超过序列的一半，则称为多数元素(majority element)。Boyer-Moore多数投票算法(以Robert Boyer和J.Strother Moore命名)用于寻找一个序列中的多数元素(如果存在)。算法维护一个初始值为0的计数器和一个没有初始值的临时候选多数元素。算法依次处理序列元素。处理第一个元素时，该元素即成为候选多数元素，并置计数器为1。然后，依次处理剩余的元素，如果计数器是0，则该元素成为候选多数元素并置计数器为1，而当计数器非0时，根据该元素是否等于当前的候选值，计数器递增(加1)或递减(减1)。所有项都处理完成后，候选值即为多数元素(如果存在)。"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.488,
                0.478,
                0.503
            ],
            "angle": 0,
            "content": "68. a) 试解释为什么一个序列最多只有一个多数元素。"
        },
        {
            "type": "text",
            "bbox": [
                0.074,
                0.506,
                0.682,
                0.521
            ],
            "angle": 0,
            "content": "b)给定序列2，1，3，3，2，3，试列出Boyer-Moore多数投票算法的步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.074,
                0.524,
                0.438,
                0.539
            ],
            "angle": 0,
            "content": "c)用伪代码描述Boyer-Moore多数投票算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.074,
                0.542,
                0.734,
                0.557
            ],
            "angle": 0,
            "content": "d)试解释你如何确定Boyer-Moore算法产生的候选多数元素确实是一个多数元素。"
        },
        {
            "type": "list",
            "bbox": [
                0.074,
                0.506,
                0.734,
                0.557
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.033,
                0.56,
                0.66,
                0.575
            ],
            "angle": 0,
            "content": "* 69. a) 证明 Boyer-Moore 多数投票算法的输出是序列的多数元素（如果存在）。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.578,
                0.888,
                0.61
            ],
            "angle": 0,
            "content": "b) 证明或反驳即使多数元素不存在，Boyer-Moore 多数投票算法的候选多数元素也是一个众数，即出现次数最多的元素。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.614,
                0.708,
                0.629
            ],
            "angle": 0,
            "content": "70. 证明判断一个程序在给定一个输入时总会输出数字“1”这个问题是不可解的。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.632,
                0.888,
                0.665
            ],
            "angle": 0,
            "content": "71. 证明如下问题是可解的。给定两个程序以及它们的输入，并且已知其中恰有一个会终止，判断哪一个程序会终止。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.668,
                0.623,
                0.683
            ],
            "angle": 0,
            "content": "72. 证明判定一个特定程序给定特定输入时是否会停机的问题是可解的。"
        },
        {
            "type": "list",
            "bbox": [
                0.043,
                0.614,
                0.888,
                0.683
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.043,
                0.698,
                0.245,
                0.717
            ],
            "angle": 0,
            "content": "3.2 函数的增长"
        },
        {
            "type": "title",
            "bbox": [
                0.043,
                0.726,
                0.171,
                0.741
            ],
            "angle": 0,
            "content": "3.2.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.746,
                0.892,
                0.936
            ],
            "angle": 0,
            "content": "3.1节我们讨论了算法的概念。介绍了解决各种问题的算法，包括在列表中搜索元素和对列表进行排序。在3.3节我们将研究这些算法使用的操作步数。特别是，我们要估算线性搜索和二分搜索算法在 \\(n\\) 个元素的序列中搜索元素时所要用的比较次数。还要估算冒泡排序和插入排序对 \\(n\\) 个元素的列表进行排序时所要用的比较次数。解决一个问题所需的时间不仅仅取决于所用的操作步数。这个时间还取决于用于运行实现一个算法的程序的硬件和软件。但是，当我们更改用于实现算法的硬件和软件时，可以通过给先前估算所需时间乘以一个常数来精确地估算求解规模为 \\(n\\) 的问题所需的时间。例如，在一台超级计算机上求解规模为 \\(n\\) 的问题可能比在一台个人计算机上快100万倍。而这100万的因子并不取决于 \\(n\\) （也许会有一点点的依赖关系）。使用本节介绍的大 \\(O\\) 记号（big-O notation）有一个好处，就是可以估算一个函数的增长而不用担心常数因子或低阶项。这意味着使用大 \\(O\\) 记号不用担心实现算法所用的硬件和软件。另外，使"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.137,
                0.038,
                0.172,
                0.052
            ],
            "angle": 0,
            "content": "184"
        },
        {
            "type": "header",
            "bbox": [
                0.218,
                0.037,
                0.284,
                0.052
            ],
            "angle": 0,
            "content": "第3章"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.094,
                0.926,
                0.11
            ],
            "angle": 0,
            "content": "用大 \\(O\\) 记号时我们可以假设算法中使用的不同操作都花费相等的时间，这大大简化了分析。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.113,
                0.957,
                0.224
            ],
            "angle": 0,
            "content": "大 \\(O\\) 记号广泛用于估算当输入增长时一个算法所用的操作的数量。借助于这个记号，就能够判定当输入规模增大时用一个特定算法来求解该问题是否实际可行。另外，使用大 \\(O\\) 记号，可以比较两个算法以判断当输入规模增大时哪个算法更有效。例如，如果求解一个问题我们有两个法，一个使用 \\(100n^{2} + 17n + 4\\) 步运算，另一个使用 \\(n^3\\) 步运算，那么大 \\(O\\) 记号可以帮助我们了解到当 \\(n\\) 很大时第一个算法所使用的运算会少得多，即使对于小的 \\(n\\) 值，比如 \\(n = 10\\) ，第一个算法使用的运算会比较多。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.227,
                0.957,
                0.263
            ],
            "angle": 0,
            "content": "本节介绍大 \\(O\\) 记号以及相关的大 \\(\\Omega\\) 和大 \\(\\Theta\\) 记号。我们将解释如何进行大 \\(O\\) 、大 \\(\\Omega\\) 和大 \\(\\Theta\\) 估算，并给出在算法分析中用到的一些重要函数的估算。"
        },
        {
            "type": "title",
            "bbox": [
                0.11,
                0.273,
                0.292,
                0.29
            ],
            "angle": 0,
            "content": "3.2.2 大O记号"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.294,
                0.842,
                0.31
            ],
            "angle": 0,
            "content": "函数的增长通常可以用一种专门的记号来描述。定义1描述了这样一种记号。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.319,
                0.949,
                0.354
            ],
            "angle": 0,
            "content": "定义1 令 \\(f\\) 和 \\(g\\) 为从整数集或实数集到实数集的函数。如果存在常数 \\(C\\) 和 \\(k\\) 使得只要当 \\(x > k\\) 时就有"
        },
        {
            "type": "equation",
            "bbox": [
                0.448,
                0.357,
                0.621,
                0.375
            ],
            "angle": 0,
            "content": "\\[\n| f (x) | \\leqslant C | g (x) |\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.377,
                0.756,
                0.394
            ],
            "angle": 0,
            "content": "我们就说 \\(f(x)\\) 是 \\(O(g(x))\\) 的。[这个可以读作“\\(f(x)\\) 是大 \\(Og(x)\\) 的”。]"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.403,
                0.957,
                0.437
            ],
            "angle": 0,
            "content": "评注 直觉上，\\(f(x)\\) 是 \\(O(g(x))\\) 的定义是说当 \\(x\\) 无限增长时 \\(f(x)\\) 的增长慢于 \\(g(x)\\) 的某个固定的倍数。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.441,
                0.96,
                0.496
            ],
            "angle": 0,
            "content": "大 \\(O\\) 记号定义中的常数 \\(C\\) 和 \\(k\\) 称为 \\(f(x)\\) 是 \\(O(g(x))\\) 的关系的凭证（witness）。为了建立 \\(f(x)\\) 是 \\(O(g(x))\\) ，我们只需要这一关系的一对凭证。即要证明 \\(f(x)\\) 是 \\(O(g(x))\\) 的，我们需要找出一对常数 \\(C\\) 和 \\(k\\) ，即凭证，使得只要当 \\(x > k\\) 时就有 \\(\\left|f(x)\\right|\\leqslant C\\left|g(x)\\right|\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.499,
                0.96,
                0.554
            ],
            "angle": 0,
            "content": "注意当有 \\(f(x)\\) 是 \\(O(g(x))\\) 的关系的一对凭证时，就会有无限多对凭证。要明白这一点，注意如果 \\(C\\) 和 \\(k\\) 是一对凭证，那么任意一对 \\(C'\\) 和 \\(k'\\) （其中 \\(C < C'\\) 和 \\(k < k'\\) ）也是一对凭证，因为只要当 \\(x > k' > k\\) 时就有 \\(\\left|f(x)\\right| \\leqslant C\\left|g(x)\\right| \\leqslant C'\\left|g(x)\\right|\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.556,
                0.962,
                0.649
            ],
            "angle": 0,
            "content": "大 \\(O\\) 记号的历史 大 \\(O\\) 记号在数学中已经使用了一个多世纪了。在计算机科学中则广泛用于算法分析，如3.3节将会看到的。1892年德国数学家保罗·巴赫曼(Paul Bachmann)在一本重要的数论书中首次引入大 \\(O\\) 记号。大 \\(O\\) 符号有时候也称为兰道符号，因为德国数学家埃德蒙·兰道(Edmund Landau)在他的著作中始终使用这个记号。大 \\(O\\) 记号在计算机科学界的普遍使用则归功于高德纳(Donald Knuth)，他还引入了本节稍后要定义的大 \\(\\Omega\\) 和大 \\(\\Theta\\) 记号。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.652,
                0.962,
                0.707
            ],
            "angle": 0,
            "content": "利用大 \\(O\\) 记号的定义求一对凭证的一种有用方法是先选择 \\(k\\) 的值使得当 \\(x > k\\) 时容易估算 \\(\\left|f(x)\\right|\\) 的大小，再看看能否用这个估算找出 \\(C\\) 的值使得对于 \\(x > k\\) 时有 \\(\\left|f(x)\\right| < C\\left|g(x)\\right|\\) 。这个方法如例1所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.154,
                0.711,
                0.533,
                0.729
            ],
            "angle": 0,
            "content": "例1 证明 \\( f(x) = x^{2} + 2x + 1 \\) 是 \\( O(x^{2}) \\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.734,
                0.962,
                0.769
            ],
            "angle": 0,
            "content": "解 观察到当 \\(x > 1\\) 时可以容易估算 \\(f(x)\\) 的大小，因为当 \\(x > 1\\) 时 \\(x < x^2\\) 且 \\(1 < x^2\\) 。所以当 \\(x > 1\\) 时就有"
        },
        {
            "type": "equation",
            "bbox": [
                0.358,
                0.772,
                0.719,
                0.788
            ],
            "angle": 0,
            "content": "\\[\n0 \\leqslant x ^ {2} + 2 x + 1 \\leqslant x ^ {2} + 2 x ^ {2} + x ^ {2} = 4 x ^ {2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.791,
                0.965,
                0.844
            ],
            "angle": 0,
            "content": "如图1所示。因此，可以取 \\(C = 4\\) 和 \\(k = 1\\) 作为凭证以证明 \\(f(x)\\) 是 \\(O(x^{2})\\) 。即只要当 \\(x > 1\\) 时就有 \\(f(x) = x^{2} + 2x + 1 < 4x^{2}\\) 。（注意这里不必用绝对值，因为当 \\(x\\) 为正数时等式中所有函数都是正的。）"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.848,
                0.962,
                0.883
            ],
            "angle": 0,
            "content": "换一种方式，当 \\(x > 2\\) 时我们可以估算 \\(f(x)\\) 的大小。当 \\(x > 2\\) 时 \\(2x \\leqslant x^2\\) 且 \\(1 \\leqslant x^2\\) 。于是，如果 \\(x > 2\\) ，就有"
        },
        {
            "type": "equation",
            "bbox": [
                0.364,
                0.886,
                0.715,
                0.902
            ],
            "angle": 0,
            "content": "\\[\n0 \\leqslant x ^ {2} + 2 x + 1 \\leqslant x ^ {2} + x ^ {2} + x ^ {2} = 3 x ^ {2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.905,
                0.569,
                0.921
            ],
            "angle": 0,
            "content": "所以 \\(C = 3\\) 和 \\(k = 2\\) 也是 \\(f(x)\\) 是 \\(O(x^{2})\\) 关系的凭证。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.701,
                0.038,
                0.79,
                0.053
            ],
            "angle": 0,
            "content": "算法"
        },
        {
            "type": "page_number",
            "bbox": [
                0.837,
                0.04,
                0.871,
                0.052
            ],
            "angle": 0,
            "content": "185"
        },
        {
            "type": "image",
            "bbox": [
                0.142,
                0.099,
                0.818,
                0.392
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.35,
                0.399,
                0.612,
                0.414
            ],
            "angle": 0,
            "content": "图1 函数 \\(x^{2} + 2x + 1\\) 是 \\(O(x^{2})\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.425,
                0.904,
                0.46
            ],
            "angle": 0,
            "content": "观察在“ \\(f(x)\\) 是 \\(O(x^{2})\\) ”关系中， \\(x^{2}\\) 可以被函数值大于 \\(x^{2}\\) 的任何函数替代。例如， \\(f(x)\\) 是 \\(O(x^{3})\\) ， \\(f(x)\\) 是 \\(O(x^{2} + 2x + 7)\\) ，等等。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.463,
                0.905,
                0.499
            ],
            "angle": 0,
            "content": "另外，\\(x^2\\) 是 \\(O(x^2 + 2x + 1)\\) 也成立，因为只要当 \\(x > 1\\) 时就有 \\(x^2 < x^2 + 2x + 1\\)。这意味着 \\(C = 1\\) 和 \\(k = 1\\) 是 \\(x^2\\) 是 \\(O(x^2 + 2x + 1)\\) 关系的凭证。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.502,
                0.905,
                0.537
            ],
            "angle": 0,
            "content": "注意在例1中我们有两个函数， \\(f(x) = x^{2} + 2x + 1\\) 和 \\(g(x) = x^2\\) ，使得 \\(f(x)\\) 是 \\(O(g(x))\\) 而且 \\(g(x)\\) 是 \\(O(f(x))\\) ——后一事实可以从不等式 \\(x^{2}\\leqslant x^{2} + 2x + 1\\) 得到，这个不等式对所有非负"
        },
        {
            "type": "image",
            "bbox": [
                0.059,
                0.542,
                0.125,
                0.565
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.06,
                0.579,
                0.203,
                0.692
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.06,
                0.695,
                0.192,
                0.753
            ],
            "angle": 0,
            "content": "Source: Bachmann, Paul.  \nDie Arithmetik Der Quadratischen Formen. Verlag und Druck von BG Teubner. Leipzig, Berlin. 1923"
        },
        {
            "type": "text",
            "bbox": [
                0.253,
                0.579,
                0.907,
                0.595
            ],
            "angle": 0,
            "content": "保罗·古斯塔夫·海因里斯·巴赫曼(Paul Gustav Heinrich Bachmann, 1837-1920)"
        },
        {
            "type": "text",
            "bbox": [
                0.217,
                0.597,
                0.909,
                0.755
            ],
            "angle": 0,
            "content": "是路德教牧师的儿子，继承了他父亲虔诚的生活方式和对音乐的热爱。尽管巴赫曼早期的数学学习并不顺利，但他的一位老师还是发现了他的数学才能。在瑞士从肺结核的病痛中康复以后，巴赫曼开始研究数学，首先在柏林大学，随后又到哥廷根大学，那里他听了著名数论家狄利克雷（Dirichlet）的课程。1862年在德国数论家库默尔(Kummer)指导下他获得博士学位，他的论文是关于群论的。巴赫曼先后担任布来斯劳(Breslau)大学和明斯特(Münster)大学的教授。从教授位置退休后，他继续数学写作、弹钢琴并且为报纸撰写音乐评论。巴赫曼的数学论著包括五卷本的数论结论与方法综述、两卷本的初等数论、一本关于无理数的书和一本关于费马最后定理的著名猜想的书。他在1892年的书《解析数论》(Analytische Zahlentheorie)中引入了大 \\(O\\) 记号。"
        },
        {
            "type": "image",
            "bbox": [
                0.062,
                0.777,
                0.203,
                0.888
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.06,
                0.892,
                0.192,
                0.94
            ],
            "angle": 0,
            "content": "Source: Smith Collection, Rare Book & Manuscript Library, Columbia University in the City of New York"
        },
        {
            "type": "text",
            "bbox": [
                0.217,
                0.777,
                0.91,
                0.865
            ],
            "angle": 0,
            "content": "埃德蒙·兰道（Edmund Landau，1877—1938）是一位柏林妇科医生的儿子，在柏林完成高中和大学教育。1899年在Frobenius的指导下他获得博士学位。兰道首先在柏林大学任教，后搬到哥廷根大学，那里任全职教授直到纳粹迫使他停止教学。兰道对数学的贡献主要在解析数论领域。特别是他建立了关于素数分布的一些重要结论。他撰写了三卷本的数论评注，以及关于数论和数学分析的一些书籍。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.138,
                0.038,
                0.174,
                0.051
            ],
            "angle": 0,
            "content": "186"
        },
        {
            "type": "header",
            "bbox": [
                0.219,
                0.037,
                0.284,
                0.052
            ],
            "angle": 0,
            "content": "第3章"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.093,
                0.957,
                0.129
            ],
            "angle": 0,
            "content": "实数 \\(x\\) 都成立。我们把满足上述这两个大 \\(O\\) 关系的两个函数 \\(f(x)\\) 和 \\(g(x)\\) 称为同阶的（same order）。本节后面还要讨论这个概念。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.131,
                0.957,
                0.204
            ],
            "angle": 0,
            "content": "评注 \\(f(x)\\) 是 \\(O(g(x))\\) 的事实有时写作 \\(f(x) = O(g(x))\\) 。不过这一写法中的等号并不代表真正的相等，而是告诉我们对于这些函数定义域中足够大的数而言，函数 \\(f\\) 和 \\(g\\) 的值之间有不等式成立。然而，\\(f(x) \\in O(g(x))\\) 这样的写法也是可接受的，因为 \\(O(g(x))\\) 可以表示那些是 \\(O(g(x))\\) 函数的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.207,
                0.957,
                0.261
            ],
            "angle": 0,
            "content": "当 \\(f(x)\\) 是 \\(O(g(x))\\) 的，并且对于足够大的 \\(x\\) 有函数 \\(h(x)\\) 的绝对值大于 \\(g(x)\\)，则有 \\(f(x)\\) 是 \\(O(h(x))\\) 的。换言之，在 \\(f(x)\\) 是 \\(O(g(x))\\) 的这一关系中的函数 \\(g(x)\\) 可以替换为具有更大绝对值的函数。要看清这一点，注意如果"
        },
        {
            "type": "equation",
            "bbox": [
                0.382,
                0.265,
                0.686,
                0.282
            ],
            "angle": 0,
            "content": "\\[\n\\mid f (x) \\mid \\leqslant C \\mid g (x) \\mid \\quad \\text {如 果} x > k\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.284,
                0.549,
                0.302
            ],
            "angle": 0,
            "content": "并且如果对所有 \\(x > k\\) 有 \\(\\left|h(x)\\right| > \\left|g(x)\\right|\\) ，那么"
        },
        {
            "type": "equation",
            "bbox": [
                0.382,
                0.304,
                0.686,
                0.321
            ],
            "angle": 0,
            "content": "\\[\n\\mid f (x) \\mid \\leqslant C \\mid h (x) \\mid \\quad \\text {如 果} x > k\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.324,
                0.329,
                0.34
            ],
            "angle": 0,
            "content": "故， \\(f(x)\\) 是 \\(O(h(x))\\) 的。"
        },
        {
            "type": "title",
            "bbox": [
                0.107,
                0.362,
                0.177,
                0.382
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.112,
                0.396,
                0.25,
                0.505
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.107,
                0.508,
                0.228,
                0.527
            ],
            "angle": 0,
            "content": "Courtesy of Stanford University News Service"
        },
        {
            "type": "text",
            "bbox": [
                0.265,
                0.395,
                0.957,
                0.481
            ],
            "angle": 0,
            "content": "高德纳E.克努特(Donald E. Knuth, 1938—) 高德纳在密尔沃基长大。他父亲在那里的路德高中教授簿记，并拥有一家小型的印刷厂。高德纳是个优秀的学生，多次获得学业成就奖。他以非传统的方式运用其才智，在八年级时参加拼字比赛，只用“Ziegler's Giant Bar”中的字母组合拼出4500个单词而赢得比赛。这为他的母校赢得一台电视机，并为班上每位同学赢得一根棒棒糖。"
        },
        {
            "type": "text",
            "bbox": [
                0.265,
                0.484,
                0.957,
                0.533
            ],
            "angle": 0,
            "content": "高德纳在开思理工学院（Case Institute of Technology）选择专业时做出了艰难的抉择：放弃音乐而主修物理。然后他又从物理转为数学，并在1960年获学士学位，同时由于教师们认可他的杰出成果，以特别奖的形式授予他硕士学位。在开思，他"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.536,
                0.957,
                0.587
            ],
            "angle": 0,
            "content": "管理篮球队，并用他的才能发明了一个估价每位球员价值的公式。这一新奇的方法被《新闻周刊》(Newsweek)和CBS电视网的Walter Cronkite报道。从1960年开始，高德纳在加州理工学院做研究生，并于1963年获博士学位。在这期间他还担任顾问，为不同的计算机写编译程序。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.589,
                0.957,
                0.675
            ],
            "angle": 0,
            "content": "1963年高德纳加入了加州理工学院的教师队伍，一直到1968年他担任斯坦福大学全职教授。他在1992年作为荣誉教授退休以便集中精力写作。他特别感兴趣的是为他的《计算机程序设计艺术》（The Art of Computer Programming）丛书更新旧卷并完成新卷撰写，该丛书是1962年他还是研究生时关注编译程序而开始写作的，至今已对计算机科学的发展产生了意义深远的影响。在行话中，“高德纳”就是指《计算机程序设计艺术》，也就意味着诸如数据结构和算法这一类问题的参考答案。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.678,
                0.957,
                0.729
            ],
            "angle": 0,
            "content": "高德纳是现代计算复杂度研究的奠基人。他对编译程序做出了奠基性的贡献。对数学印刷的不满激发他发明了现在广泛使用的 TeX 和 Metafont 系统。TeX 已经成为计算机排印的一个标准语言。高德纳的众多奖项中的两项是 1974 年的图灵奖和卡特总统授给他的 1979 年国家技术奖。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.731,
                0.957,
                0.8
            ],
            "angle": 0,
            "content": "高德纳为计算机科学和数学领域的众多专业期刊撰写文章。不过他的头一篇作品是1957年还是一年级新生时写的，“度量衡的Potrzebie \\(\\text{一}\\) 系统”（The Potrzebie Systems of Weights and Measures），是一个对计量系统的模仿小品。该文发表在《MAD杂志》，并多次重印。他与父亲一样是一位教堂管风琴手。他还为管风琴作曲。高德纳相信编写计算机程序也可以有审美体验，就像写诗或作曲一样。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.802,
                0.957,
                0.871
            ],
            "angle": 0,
            "content": "对第一个发现他书中的每一处错误的人，高德纳会支付2.56美元，对每个有意义的建议，他会支付0.32美元。如果你寄给他一封信指出一个错误（你只能寄普通信件，因为他已放弃阅读电子邮件），他最终会通知你，你是否是第一个告诉他这一错误的人。需要长久的耐心等待，因为他收到的邮件太多。（作者寄给高德纳一封报告错误的信，几年以后才收到回信，告知我的报告比首先报告这一错误的信晚到了好几个月。）"
        },
        {
            "type": "page_footnote",
            "bbox": [
                0.152,
                0.904,
                0.957,
                0.935
            ],
            "angle": 0,
            "content": "\\(\\ominus\\) Potrzebie一词是波兰语，意为“需要”。这里高德纳将《MAD杂志》第26卷的厚度定义为一个Potrzebie基本单位，它等于2.263348517438173216473毫米，并以此开发一套度量衡系统。——译者注"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.7,
                0.035,
                0.79,
                0.051
            ],
            "angle": 0,
            "content": "算法"
        },
        {
            "type": "page_number",
            "bbox": [
                0.836,
                0.036,
                0.872,
                0.049
            ],
            "angle": 0,
            "content": "187"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.091,
                0.899,
                0.126
            ],
            "angle": 0,
            "content": "当使用大 \\(O\\) 记号时，在 \\(f(x)\\) 是 \\(O(g(x))\\) 这一关系中函数 \\(g\\) 的选择应该尽可能的小。（有时可以从一个参考函数集合中选取，例如形为 \\(x^n\\) 的函数集，其中 \\(n\\) 为正整数。）"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.129,
                0.899,
                0.146
            ],
            "angle": 0,
            "content": "在随后的讨论中，我们几乎总是涉及只有正值的函数。在用大 \\(O\\) 对这样的函数做估算时可"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.148,
                0.435,
                0.184
            ],
            "angle": 0,
            "content": "以不必涉及绝对值。图2说明 \\(f(x)\\) 是\\(O(g(x))\\) 的关系。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.186,
                0.435,
                0.222
            ],
            "angle": 0,
            "content": "例2说明如何用大 \\(O\\) 记号来估算函数的增长。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.226,
                0.338,
                0.244
            ],
            "angle": 0,
            "content": "例2 证明 \\(7x^{2}\\) 是 \\(O(x^3)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.248,
                0.436,
                0.38
            ],
            "angle": 0,
            "content": "解注意当 \\(x > 7\\) 时，有 \\(7x^{2} < x^{3}\\) （可以在 \\(x > 7\\) 两边乘以 \\(x^{2}\\) 得出这个不等式。）因此，可以取 \\(C = 1\\) 和 \\(k = 7\\) 做凭证以证明 \\(7x^{2}\\) 是 \\(O(x^{3})\\) 这一关系。也可以换一种方法，当 \\(x > 1\\) 时，有 \\(7x^{2} < 7x^{3}\\)，于是 \\(C = 7\\) 和 \\(k = 1\\) 也可以作为 \\(7x^{2}\\) 是 \\(O(x^{3})\\) 这一关系的凭证。"
        },
        {
            "type": "image",
            "bbox": [
                0.449,
                0.153,
                0.9,
                0.356
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.558,
                0.364,
                0.788,
                0.38
            ],
            "angle": 0,
            "content": "图2 函数 \\(f(x)\\) 是 \\(O(g(x))\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.383,
                0.432,
                0.399
            ],
            "angle": 0,
            "content": "评注 在例2中，我们在大 \\(O\\) 估算中"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.402,
                0.899,
                0.437
            ],
            "angle": 0,
            "content": "没有选择 \\(x\\) 的幂次的最小可能值。注意到 \\(7x^{2}\\) 也是大 \\(Ox^{2}\\)，而 \\(x^{2}\\) 的增长要比 \\(x^{3}\\) 慢很多。事实上，\\(x^{2}\\) 是最适合用作大 \\(O\\) 估算函数的 \\(x\\) 的最小可能幂次。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.44,
                0.435,
                0.457
            ],
            "angle": 0,
            "content": "例3说明如何证明大 \\(O\\) 关系并不成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.462,
                0.338,
                0.479
            ],
            "angle": 0,
            "content": "例3 证明 \\(n^2\\) 不是 \\(O(n)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.484,
                0.899,
                0.52
            ],
            "angle": 0,
            "content": "解 要证明 \\(n^2\\) 不是 \\(O(n)\\) 的，必须证明并不存在凭证 \\(C\\) 和 \\(k\\) 使得当 \\(n > k\\) 时有 \\(n^2 \\leqslant Cn\\)。我们用矛盾证明法来证明之。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.522,
                0.899,
                0.596
            ],
            "angle": 0,
            "content": "假设存在常数 \\(C\\) 和 \\(k\\) 使得当 \\(n > k\\) 时有 \\(n^2 \\leqslant Cn\\) 。观察一下，当 \\(n > 0\\) 时，可以在不等式 \\(n^2 \\leqslant Cn\\) 两边同时除以 \\(n\\) 而得到新的不等式 \\(n \\leqslant C\\) 。可是，无论 \\(C\\) 和 \\(k\\) 取何值，不等式 \\(n \\leqslant C\\) 并不能对所有 \\(n > k\\) 的 \\(n\\) 都成立。特别是，一旦设定 \\(k\\) 值后，可以得出即使在 \\(n > k\\) 时，当 \\(n\\) 大于 \\(k\\) 和 \\(C\\) 的最大值时，\\(n \\leqslant C\\) 不能成立。这个矛盾证明了 \\(n^2\\) 不是 \\(O(n)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.601,
                0.6,
                0.619
            ],
            "angle": 0,
            "content": "例4 例2证明了 \\(7x^{2}\\) 是 \\(O(x3)\\) 的。 \\(x^{3}\\) 也是 \\(O(7x^{2})\\) 的吗？"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.623,
                0.898,
                0.659
            ],
            "angle": 0,
            "content": "解 要判定 \\(x^3\\) 是否是 \\(O(7x^2)\\) 的，需要判断是否存在凭证 \\(C\\) 和 \\(k\\) ，使得当 \\(x > k\\) 时有 \\(x^3 \\leqslant C(7x^2)\\) 。我们用矛盾证明法来证明不存在这样的凭证。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.661,
                0.899,
                0.717
            ],
            "angle": 0,
            "content": "如果 \\(C\\) 和 \\(k\\) 是凭证，则不等式 \\(x^{3} \\leqslant C(7x^{2})\\) 对于所有 \\(x > k\\) 成立。观察一下，不等式 \\(x^{3} \\leqslant C(7x^{2})\\) 等价于不等式 \\(x \\leqslant 7C\\) ，这由两边除以一个正的数量 \\(x^{2}\\) 而得到。可是，无论 \\(C\\) 怎么取值，无论 \\(k\\) 是什么，\\(x \\leqslant 7C\\) 不会对所有 \\(x > k\\) 成立，因为 \\(x\\) 可以任意大。于是 \\(x^{3}\\) 不是 \\(O(7x^{2})\\) 的。"
        },
        {
            "type": "title",
            "bbox": [
                0.051,
                0.727,
                0.387,
                0.745
            ],
            "angle": 0,
            "content": "3.2.3 一些重要函数的大 \\(O\\) 估算"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.747,
                0.899,
                0.803
            ],
            "angle": 0,
            "content": "通常用多项式来估算函数的增长。与其每当多项式出现时都要分析其增长，不如找一个总是可以估算多项式增长的结论。定理1就给出这种结论。它通过断言 \\(n\\) 次及低次多项式是\\(O(x^{n})\\) 的，从而证明多项式的首项支配着其增长。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.811,
                0.89,
                0.851
            ],
            "angle": 0,
            "content": "定理1 令 \\( f(x) = a_{n}x^{n} + a_{n - 1}x^{n - 1} + \\dots + a_{1}x + a_{0} \\)，其中 \\( a_0, a_1, \\dots, a_{n - 1}, a_n \\) 为实数。那么 \\( f(x) \\) 是 \\( O(x^n) \\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.857,
                0.628,
                0.874
            ],
            "angle": 0,
            "content": "证明 用三角不等式（参见1.8节练习9），如果 \\(x > 1\\)，就有"
        },
        {
            "type": "equation",
            "bbox": [
                0.208,
                0.878,
                0.739,
                0.934
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} | f (x) | = \\left| a _ {n} x ^ {n} + a _ {n - 1} x ^ {n - 1} + \\dots + a _ {1} x + a _ {0} \\right| \\\\ \\leqslant \\left| a _ {n} \\right| x ^ {n} + \\left| a _ {n - 1} \\right| x ^ {n - 1} + \\dots + \\left| a _ {1} \\right| x + \\left| a _ {0} \\right| \\\\ = x ^ {n} \\left(\\left| a _ {n} \\right| + \\left| a _ {n - 1} \\right| / x + \\dots + \\left| a _ {1} \\right| / x ^ {n - 1} + \\left| a _ {0} \\right| / x ^ {n}\\right) \\\\ \\end{array}\n\\]"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.143,
                0.038,
                0.178,
                0.051
            ],
            "angle": 0,
            "content": "188"
        },
        {
            "type": "header",
            "bbox": [
                0.225,
                0.037,
                0.29,
                0.052
            ],
            "angle": 0,
            "content": "第3章"
        },
        {
            "type": "equation",
            "bbox": [
                0.359,
                0.095,
                0.72,
                0.11
            ],
            "angle": 0,
            "content": "\\[\n\\leqslant x ^ {n} \\left(\\left| a _ {n} \\right| + \\left| a _ {n - 1} \\right| + \\dots + \\left| a _ {1} \\right| + \\left| a _ {0} \\right|\\right)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.113,
                0.356,
                0.129
            ],
            "angle": 0,
            "content": "这说明只要当 \\(x > 1\\) 时就有"
        },
        {
            "type": "equation",
            "bbox": [
                0.48,
                0.133,
                0.605,
                0.148
            ],
            "angle": 0,
            "content": "\\[\n\\left| f (x) \\right| \\leqslant C x ^ {n}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.151,
                0.964,
                0.187
            ],
            "angle": 0,
            "content": "其中 \\(C = |a_{n}| + |a_{n - 1}| + \\dots +|a_{0}|\\) 。故凭证 \\(C = |a_{n}| + |a_{n - 1}| + \\dots +|a_{0}|\\) 和 \\(k = 1\\) 可以证明\\(f(x)\\) 是 \\(O(x^{n})\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.159,
                0.189,
                0.624,
                0.206
            ],
            "angle": 0,
            "content": "现在举几个与定义域为正整数集的函数有关的例子。"
        },
        {
            "type": "text",
            "bbox": [
                0.159,
                0.211,
                0.58,
                0.228
            ],
            "angle": 0,
            "content": "例5 怎样用大 \\(O\\) 记号估算前 \\(n\\) 个正整数之和？"
        },
        {
            "type": "text",
            "bbox": [
                0.159,
                0.233,
                0.692,
                0.249
            ],
            "angle": 0,
            "content": "解 由于前 \\(n\\) 个正整数之和中的每个整数都不超过 \\(n\\) ，所以"
        },
        {
            "type": "equation",
            "bbox": [
                0.375,
                0.253,
                0.71,
                0.268
            ],
            "angle": 0,
            "content": "\\[\n1 + 2 + \\dots + n \\leqslant n + n + \\dots + n = n ^ {2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.271,
                0.965,
                0.306
            ],
            "angle": 0,
            "content": "由此不等式可知 \\(1 + 2 + 3 + \\dots + n\\) 是 \\(O(n^{2})\\) ，取 \\(C = 1\\) 和 \\(k = 1\\) 作为凭证即可。（本例中大 \\(O\\) 关系中的函数定义域为正整数集合。）"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.309,
                0.965,
                0.345
            ],
            "angle": 0,
            "content": "在例6中用大 \\(O\\) 估算阶乘函数及其对数函数。这些估算对分析排序过程中使用的步数有重要作用。"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.351,
                0.965,
                0.39
            ],
            "angle": 0,
            "content": "例6给出阶乘函数和阶乘函数的对数函数的大 \\(O\\) 估算，其中阶乘函数 \\(f(n) = n!\\) 的定义为：只要当 \\(n\\) 是正整数时，"
        },
        {
            "type": "equation",
            "bbox": [
                0.463,
                0.395,
                0.629,
                0.409
            ],
            "angle": 0,
            "content": "\\[\nn! = 1 \\cdot 2 \\cdot \\dots \\cdot n\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.413,
                0.281,
                0.429
            ],
            "angle": 0,
            "content": "而 \\(0! = 1\\) 。例如，"
        },
        {
            "type": "equation",
            "bbox": [
                0.219,
                0.435,
                0.872,
                0.448
            ],
            "angle": 0,
            "content": "\\[\n1! = 1, \\quad 2! = 1 \\cdot 2 = 2, \\quad 3! = 1 \\cdot 2 \\cdot 3 = 6, \\quad 4! = 1 \\cdot 2 \\cdot 3 \\cdot 4 = 2 4\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.453,
                0.427,
                0.469
            ],
            "angle": 0,
            "content": "注意函数 \\(n!\\) 增长非常迅速。例如"
        },
        {
            "type": "equation",
            "bbox": [
                0.397,
                0.474,
                0.696,
                0.488
            ],
            "angle": 0,
            "content": "\\[\n2 0! = 2 4 3 2 9 0 2 0 0 8 1 7 6 6 4 0 0 0 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.162,
                0.492,
                0.79,
                0.509
            ],
            "angle": 0,
            "content": "解. 注意到乘积中的每一项都不超过 \\(n\\) 就能得到 \\(n!\\) 的大 \\(O\\) 估算。故，"
        },
        {
            "type": "equation",
            "bbox": [
                0.452,
                0.515,
                0.642,
                0.565
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} n! = 1 \\cdot 2 \\cdot 3 \\cdot \\dots \\cdot n \\\\ \\leqslant n \\cdot n \\cdot n \\cdot \\dots \\cdot n \\\\ = n ^ {n} \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.572,
                0.969,
                0.607
            ],
            "angle": 0,
            "content": "这一不等式说明 \\(n!\\) 是 \\(O(n^{n})\\) 的，取 \\(C = 1\\) 和 \\(k = 1\\) 作为凭证即可。对用于估算 \\(n!\\) 的不等式两边同时取对数，可得"
        },
        {
            "type": "equation",
            "bbox": [
                0.438,
                0.612,
                0.66,
                0.628
            ],
            "angle": 0,
            "content": "\\[\n\\log n! \\leqslant \\log n ^ {n} = n \\log n\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.631,
                0.75,
                0.648
            ],
            "angle": 0,
            "content": "这蕴含着 \\(\\log n!\\) 是 \\(O(n\\log n)\\) 的，同样取 \\(C = 1\\) 和 \\(k = 1\\) 作为凭证即可。"
        },
        {
            "type": "text",
            "bbox": [
                0.125,
                0.653,
                0.97,
                0.692
            ],
            "angle": 0,
            "content": "例7 在5.1节我们要证明对于任一正整数 \\(n\\) 有 \\(n < 2^n\\) 。试证明该不等式蕴含 \\(n\\) 是 \\(O(2^n)\\) 的，并且用这个不等式来证明 \\(\\log n\\) 是 \\(O(n)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.125,
                0.696,
                0.971,
                0.732
            ],
            "angle": 0,
            "content": "解利用不等式 \\(n < 2^n\\) ，可以取 \\(k = C = 1\\) 作为凭证，很容易得出 \\(n\\) 是 \\(O(2^{n})\\) 的结论。注意对数函数是递增函数，只要在这一不等式两边取（以2为底）对数，可得"
        },
        {
            "type": "equation",
            "bbox": [
                0.506,
                0.735,
                0.594,
                0.751
            ],
            "angle": 0,
            "content": "\\[\n\\log n <   n\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.753,
                0.21,
                0.769
            ],
            "angle": 0,
            "content": "于是可得"
        },
        {
            "type": "equation",
            "bbox": [
                0.476,
                0.772,
                0.621,
                0.788
            ],
            "angle": 0,
            "content": "\\[\n\\log n \\text {是} O (n) \\text {的}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.791,
                0.367,
                0.807
            ],
            "angle": 0,
            "content": "（仍取 \\(k = C = 1\\) 作为凭证。）"
        },
        {
            "type": "text",
            "bbox": [
                0.168,
                0.81,
                0.86,
                0.826
            ],
            "angle": 0,
            "content": "如果取以 \\(b\\) 为底取对数，这里 \\(b\\) 不等于2，我们同样有 \\(\\log_b n\\) 是 \\(O(n)\\) 的，因为"
        },
        {
            "type": "equation",
            "bbox": [
                0.461,
                0.831,
                0.642,
                0.86
            ],
            "angle": 0,
            "content": "\\[\n\\log_ {b} n = \\frac {\\log n}{\\log b} <   \\frac {n}{\\log b}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.863,
                0.972,
                0.897
            ],
            "angle": 0,
            "content": "只要 \\(n\\) 是一个正整数。可以取 \\(C = 1 / \\log b\\) 和 \\(k = 1\\) 作为凭证。（这里用了附录二定理3的结论 \\(\\log_{b}n = \\log n / \\log b\\) 。）"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.901,
                0.972,
                0.936
            ],
            "angle": 0,
            "content": "正如前面提到的，大 \\(O\\) 符号可以用来估算用一个特定的计算机过程或算法解题时所需要的操作步数。用于估算的常用函数包括："
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.688,
                0.034,
                0.778,
                0.05
            ],
            "angle": 0,
            "content": "算法"
        },
        {
            "type": "page_number",
            "bbox": [
                0.825,
                0.036,
                0.86,
                0.048
            ],
            "angle": 0,
            "content": "189"
        },
        {
            "type": "equation",
            "bbox": [
                0.346,
                0.091,
                0.584,
                0.107
            ],
            "angle": 0,
            "content": "\\[\n1, \\log n, n, n \\log n, n ^ {2}, 2 ^ {n}, n!\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.109,
                0.443,
                0.221
            ],
            "angle": 0,
            "content": "用微积分可以证明列表中的每个函数都小于随后的函数，这里小于的含义是指一个函数与随后的函数的比值在 \\(n\\) 无限增长时趋向于0。图3展示了这些函数的图像，图中函数值的每个刻度都是前面刻度的两倍。即这个图中的纵坐标是对数坐标。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.224,
                0.444,
                0.337
            ],
            "angle": 0,
            "content": "涉及对数、幂、指数函数的大 \\(O\\) 估算我们现在给出一些有用的事实，当函数是对数函数的幂、幂函数或形如 \\(b^n\\) （这里 \\(b > 1\\) )的指数函数时，可以帮助我们判定这样一对函数之间的大 \\(O\\) 关系是否成立。其证明留作练习 \\(57\\sim 62\\) 由具有微积分知识的读者来完成。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.339,
                0.445,
                0.451
            ],
            "angle": 0,
            "content": "定理1证明了如果 \\(f(n)\\) 是 \\(d\\) 次或小于 \\(d\\) 次的多项式，则 \\(f(n)\\) 是 \\(O(n^{d})\\) 的。应用这个定理，我们可以看到如果 \\(d > c > 1\\) ，则 \\(n^c\\) 是 \\(O(n^{d})\\) 的。我们留给读者来证明其逆关系不成立。把这些事实合在一起，我们可以看到如果 \\(d > c > 1\\) ，则"
        },
        {
            "type": "image",
            "bbox": [
                0.458,
                0.113,
                0.898,
                0.41
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.524,
                0.416,
                0.826,
                0.432
            ],
            "angle": 0,
            "content": "图3 大 \\(O\\) 估算中常用函数的增长图"
        },
        {
            "type": "equation",
            "bbox": [
                0.3,
                0.455,
                0.637,
                0.472
            ],
            "angle": 0,
            "content": "\\[\nn ^ {c} \\text {是} O (n ^ {d}) \\text {的}, \\text {但 是} n ^ {d} \\text {不 是} O (n ^ {c}) \\text {的}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.476,
                0.893,
                0.512
            ],
            "angle": 0,
            "content": "在例7中我们证明了当 \\(b > 1\\) 时 \\(\\log_b n\\) 是 \\(O(n)\\) 的。更一般性地，当 \\(b > 1\\) 且 \\(c\\) 和 \\(d\\) 为正数时，我们有"
        },
        {
            "type": "equation",
            "bbox": [
                0.248,
                0.515,
                0.688,
                0.532
            ],
            "angle": 0,
            "content": "\\[\n\\left(\\log_ {b} n\\right) ^ {c} \\text {是} O \\left(n ^ {d}\\right) \\text {的 , 但 是} n ^ {d} \\text {不 是} O \\left(\\left(\\log_ {b} n\\right) ^ {c}\\right) \\text {的}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.535,
                0.893,
                0.569
            ],
            "angle": 0,
            "content": "这告诉我们当 \\(b > 1\\) 时以 \\(b\\) 为底 \\(n\\) 的对数的正数幂次是大 \\(O(n\\) 的正数幂次)，但反之则一定不成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.573,
                0.794,
                0.59
            ],
            "angle": 0,
            "content": "例7中我们还证明了 \\(n\\) 是 \\(O(2^n)\\) 的。更一般性地，当 \\(d\\) 是正数且 \\(b > 1\\) 时我们有"
        },
        {
            "type": "equation",
            "bbox": [
                0.301,
                0.593,
                0.637,
                0.609
            ],
            "angle": 0,
            "content": "\\[\nn ^ {d} \\text {是} O (b ^ {n}) \\text {的}, \\text {但 是} b ^ {n} \\text {不 是} O (n ^ {d}) \\text {的}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.613,
                0.893,
                0.649
            ],
            "angle": 0,
            "content": "这告诉我们 \\(n\\) 的每个幂次是大 \\(O\\) 底数大于1的 \\(n\\) 次指数函数，反之则不然。再者，当 \\(c > b > 1\\) 时我们有"
        },
        {
            "type": "equation",
            "bbox": [
                0.304,
                0.652,
                0.634,
                0.668
            ],
            "angle": 0,
            "content": "\\[\nb ^ {n} \\text {是} O \\left(c ^ {n}\\right) \\text {的 , 但 是} c ^ {n} \\text {不 是} O \\left(b ^ {n}\\right) \\text {的}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.672,
                0.893,
                0.707
            ],
            "angle": 0,
            "content": "这告诉我们如果两个指数函数的不同底数均大于1，则一个函数是大 \\(O\\) 另一个函数当且仅当它的底数小于等于另一个函数的底数。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.71,
                0.361,
                0.726
            ],
            "angle": 0,
            "content": "最后，注意到如果 \\(c > 1\\) ，则有"
        },
        {
            "type": "equation",
            "bbox": [
                0.304,
                0.73,
                0.634,
                0.746
            ],
            "angle": 0,
            "content": "\\[\nc ^ {n} \\text {是} O (n!) \\text {的 , 但 是} n! \\text {不 是} O (c ^ {n}) \\text {的}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.749,
                0.763,
                0.766
            ],
            "angle": 0,
            "content": "可以用这里讨论的大 \\(O\\) 估算来帮我们为不同函数的增长排序，如例8所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.772,
                0.895,
                0.812
            ],
            "angle": 0,
            "content": "例8 将函数 \\( f_{1}(n) = 8\\sqrt{n} \\)、\\( f_{2}(n) = (\\log n)^{2} \\)、\\( f_{3}(n) = 2n\\log n \\)、\\( f_{4}(n) = n! \\)、\\( f_{5}(n) = (1.1)^{n} \\) 和 \\( f_{6}(n) = n^{2} \\) 排成一列，使得每个函数是大 \\( O \\) 下一个函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.816,
                0.897,
                0.936
            ],
            "angle": 0,
            "content": "解 从本节讨论的大 \\(O\\) 估算可知，\\(f_{2}(n) = (\\log n)^{2}\\) 是这些函数中增长最慢的（因为 \\(\\log n\\) 比 \\(n\\) 的任何正幂次的增长都要慢）。接下来的三个函数依次是 \\(f_{1}(n) = 8\\sqrt{n}\\)、\\(f_{3}(n) = 2n\\log n\\) 和 \\(f_{6}(n) = n^{2}\\)（因为 \\(f_{1}(n) = 8n^{1/2}\\)，\\(f_{3}(n) = 2n\\log n\\) 是比 \\(n\\) 增长快但比 \\(n^{c}\\)（对每个 \\(c > 1\\)）慢的函数，而 \\(f_{6}(n) = n^{2}\\) 具有 \\(n^{c}\\) 这个形式，其中 \\(c = 2\\)。列表中接下来的函数是 \\(f_{5}(n) = (1.1)^{n}\\)，因为这是一个以1.1为底的指数函数。最后，\\(f_{4}(n) = n!\\) 是列表中增长最快的函数，因为 \\(f(n) = n!\\) 比 \\(n\\) 的任意指数函数增长都要快。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.143,
                0.036,
                0.178,
                0.049
            ],
            "angle": 0,
            "content": "190"
        },
        {
            "type": "header",
            "bbox": [
                0.225,
                0.035,
                0.291,
                0.05
            ],
            "angle": 0,
            "content": "第3章"
        },
        {
            "type": "title",
            "bbox": [
                0.113,
                0.1,
                0.355,
                0.116
            ],
            "angle": 0,
            "content": "3.2.4 函数组合的增长"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.12,
                0.964,
                0.174
            ],
            "angle": 0,
            "content": "许多算法都由两个或多个独立的子过程组成。计算机使用这样的算法来求解一定输入规模的问题时所需要的步数是这些过程所使用的步数之和。要用大 \\(O\\) 估算所需要的步数，就需要找出每个子过程所用步数的大 \\(O\\) 估算，然后再把这些估算组合起来。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.177,
                0.962,
                0.249
            ],
            "angle": 0,
            "content": "只要在组合不同的大 \\(O\\) 估算时细心一点，就能给出函数组合的大 \\(O\\) 估算。特别是，通常需要估算两个函数之和与之积的增长。如果已知两个函数各自的大 \\(O\\) 估算，那么能得到什么结论呢？假定 \\(f_{1}(x)\\) 是 \\(O(g_{1}(x))\\) 的而 \\(f_{2}(x)\\) 是 \\(O(g_{2}(x))\\) 的，我们来看看两个函数之和与之积会有什么样的估算。"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.253,
                0.792,
                0.269
            ],
            "angle": 0,
            "content": "由大 \\(O\\) 记号的定义可知，存在常数 \\(C_1\\) 、 \\(C_2\\) 、 \\(k_{1}\\) 和 \\(k_{2}\\) 使得当 \\(x > k_{1}\\) 时有"
        },
        {
            "type": "equation",
            "bbox": [
                0.437,
                0.271,
                0.637,
                0.289
            ],
            "angle": 0,
            "content": "\\[\n\\left| f _ {1} (x) \\right| \\leqslant C _ {1} \\left| g _ {1} (x) \\right|\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.291,
                0.259,
                0.307
            ],
            "angle": 0,
            "content": "而当 \\(x > k_{2}\\) 时有"
        },
        {
            "type": "equation",
            "bbox": [
                0.435,
                0.31,
                0.637,
                0.327
            ],
            "angle": 0,
            "content": "\\[\n\\left| f _ {2} (x) \\right| \\leqslant C _ {2} \\left| g _ {2} (x) \\right|\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.33,
                0.436,
                0.345
            ],
            "angle": 0,
            "content": "要估算 \\(f_{1}(x)\\) 与 \\(f_{2}(x)\\) 之和，请注意"
        },
        {
            "type": "equation",
            "bbox": [
                0.186,
                0.348,
                0.51,
                0.365
            ],
            "angle": 0,
            "content": "\\[\n\\left| \\left(f _ {1} + f _ {2}\\right) (x) \\right| = \\left| f _ {1} (x) + f _ {2} (x) \\right|\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.327,
                0.368,
                0.885,
                0.386
            ],
            "angle": 0,
            "content": "\\(\\leqslant |f_1(x)| + |f_2(x)|\\) 利用三角不等式 \\(|a + b|\\leqslant |a| + |b|\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.388,
                0.687,
                0.405
            ],
            "angle": 0,
            "content": "当 \\(x\\) 同时大于 \\(k_{1}\\) 和 \\(k_{2}\\) 时，从 \\(\\left|f_1(x)\\right|\\) 和 \\(\\left|f_2(x)\\right|\\) 的不等式可得："
        },
        {
            "type": "equation",
            "bbox": [
                0.326,
                0.407,
                0.745,
                0.485
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} \\left| f _ {1} (x) \\right| + \\left| f _ {2} (x) \\right| \\leqslant C _ {1} \\left| g _ {1} (x) \\right| + C _ {2} \\left| g _ {2} (x) \\right| \\\\ \\leqslant C _ {1} \\left| g (x) \\right| + C _ {2} \\left| g (x) \\right| \\\\ = \\left(C _ {1} + C _ {2}\\right) | g (x) | \\\\ = C | g (x) | \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.488,
                0.96,
                0.523
            ],
            "angle": 0,
            "content": "其中 \\(C = C_{1} + C_{2}\\) 且 \\(g(x) = \\max (|g_1(x)|, |g_2(x)|)\\) 。[这里 \\(\\max (a,b)\\) 表示 \\(a\\) 和 \\(b\\) 的最大值，即 \\(a\\) 和 \\(b\\) 中较大的一个。]"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.527,
                0.96,
                0.561
            ],
            "angle": 0,
            "content": "这一不等式表明 \\(\\left|(f_1 + f_2)(x) \\leqslant C \\mid g(x)\\right|\\) 在 \\(x > k\\) 时成立，其中 \\(k = \\max(k_1, k_2)\\)。我们把这一有用的结果表述为定理2。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.571,
                0.951,
                0.608
            ],
            "angle": 0,
            "content": "定理2 假定 \\( f_{1}(x) \\) 是 \\( O(g_{1}(x)) \\) 的，\\( f_{2}(x) \\) 是 \\( O(g_{2}(x)) \\) 的，那么 \\( (f_{1} + f_{2})(x) \\) 是 \\( O(g(x)) \\) 的，其中对所有 \\( x \\) 有 \\( g(x) = (\\max(|g_{1}(x)|, |g_{2}(x)|)) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.618,
                0.957,
                0.654
            ],
            "angle": 0,
            "content": "我们经常会用同一个函数 \\(g\\) 来给出 \\(f_{1}\\) 和 \\(f_{2}\\) 的大 \\(O\\) 估算。在此情况下，因为 \\(\\max(g_{1}(x), g_{2}(x)) = g(x)\\)，利用定理2可证明 \\((f_{1} + f_{2})(x)\\) 也是 \\(O(g(x))\\) 的。这一结论可表述为推论1。"
        },
        {
            "type": "text",
            "bbox": [
                0.159,
                0.662,
                0.892,
                0.68
            ],
            "angle": 0,
            "content": "推论1 假定 \\(f_{1}(x)\\) 和 \\(f_{2}(x)\\) 都是 \\(O(g(x))\\) 的，那么 \\((f_{1} + f_{2})(x)\\) 也是 \\(O(g(x))\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.689,
                0.932,
                0.706
            ],
            "angle": 0,
            "content": "用类似的方法可以推导出 \\(f_{1}\\) 和 \\(f_{2}\\) 乘积的大 \\(O\\) 估算。当 \\(x\\) 大于 \\(\\max (k_1,k_2)\\) 时，可得出"
        },
        {
            "type": "equation",
            "bbox": [
                0.365,
                0.708,
                0.705,
                0.785
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} \\left| \\left(f _ {1} f _ {2}\\right) (x) \\right| = \\left| f _ {1} (x) \\right| \\left| f _ {2} (x) \\right| \\\\ \\leqslant C _ {1} \\left| g _ {1} (x) \\right| C _ {2} \\left| g _ {2} (x) \\right| \\\\ \\leqslant C _ {1} C _ {2} \\left| (g _ {1} g _ {2}) (x) \\right| \\\\ \\leqslant C \\left| \\left(g _ {1} g _ {2}\\right) (x) \\right| \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.788,
                0.957,
                0.842
            ],
            "angle": 0,
            "content": "其中 \\(C = C_{1}C_{2}\\) 。从这一不等式可知 \\(f_{1}(x)f_{2}(x)\\) 是 \\(O(g_{1}g_{2})\\) 的，因为存在常数 \\(C\\) 和 \\(k\\) ，即\\(C = C_1C_2\\) 和 \\(k = \\max (k_1,k_2)\\) ，使得只要 \\(x > k\\) 时就有 \\(\\left|(f_1f_2)(x)\\right|\\leqslant C\\left|g_1(x)g_2(x)\\right|\\) 。这一结果可表述为定理3。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.851,
                0.95,
                0.888
            ],
            "angle": 0,
            "content": "定理3 假定 \\(f_{1}(x)\\) 是 \\(O(g_{1}(x))\\) 的，\\(f_{2}(x)\\) 是 \\(O(g_{2}(x))\\) 的。那么 \\((f_{1}f_{2})(x)\\) 是 \\(O(g_{1}(x))\\) 和 \\(g_{2}(x)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.898,
                0.957,
                0.934
            ],
            "angle": 0,
            "content": "用大 \\(O\\) 记号来估算函数的目的是选一个相对增长较慢且尽可能简单的函数 \\(g(x)\\)，使得 \\(f(x)\\) 是 \\(O(g(x))\\) 的。例9和例10说明了怎样利用定理2和定理3来实现这一目标。这些例子"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.694,
                0.04,
                0.783,
                0.055
            ],
            "angle": 0,
            "content": "算法"
        },
        {
            "type": "page_number",
            "bbox": [
                0.83,
                0.042,
                0.863,
                0.054
            ],
            "angle": 0,
            "content": "191"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.096,
                0.574,
                0.113
            ],
            "angle": 0,
            "content": "中的这类分析常用于分析用计算机程序解题时所需的时间。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.118,
                0.825,
                0.136
            ],
            "angle": 0,
            "content": "例9 试给出 \\( f(n) = 3n\\log (n!) + (n^{2} + 3)\\log n \\) 的大 \\( O \\) 估算，其中 \\( n \\) 是一个正整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.141,
                0.893,
                0.177
            ],
            "angle": 0,
            "content": "解 首先估算乘积 \\(3n\\log (n!)\\) 。从例6知道 \\(\\log (n!)\\) 是 \\(O(n\\log n)\\) 的。由这一估算及 \\(3n\\) 是 \\(O(n)\\) 的事实，定理3给出的估算为 \\(3n\\log (n!\\) 是 \\(O(n^{2}\\log n)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.179,
                0.894,
                0.236
            ],
            "angle": 0,
            "content": "下一步估算乘积 \\((n^{2} + 3)\\log n\\) 。因为当 \\(n > 2\\) 时 \\((n^{2} + 3) < 2n^{2}\\) 成立，则有 \\(n^2 + 3\\) 是 \\(O(n^{2})\\) 的。因此，由定理3可知 \\((n^{2} + 3)\\log n\\) 是 \\(O(n^{2}\\log n)\\) 的。用定理2把两个乘积的大 \\(O\\) 估算组合起来得 \\(f(n) = 3n\\log (n!) + (n^{2} + 3)\\log n\\) 是 \\(O(n^{2}\\log n)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.24,
                0.615,
                0.259
            ],
            "angle": 0,
            "content": "例10 试给出 \\( f(x) = (x + 1)\\log (x^2 + 1) + 3x^2 \\) 的大 \\( O \\) 估算。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.263,
                0.893,
                0.3
            ],
            "angle": 0,
            "content": "解首先找 \\((x + 1)\\log (x^2 +1)\\) 的大 \\(O\\) 估算。注意 \\((x + 1)\\) 是 \\(O(x)\\) 。另外当 \\(x > 1\\) 时\\(x^{2} + 1\\leqslant 2x^{2}\\) 。于是，如果 \\(x > 2\\) ，有"
        },
        {
            "type": "equation",
            "bbox": [
                0.173,
                0.303,
                0.767,
                0.32
            ],
            "angle": 0,
            "content": "\\[\n\\log (x ^ {2} + 1) \\leqslant \\log (2 x ^ {2}) = \\log 2 + \\log x ^ {2} = \\log 2 + 2 \\log x \\leqslant 3 \\log x\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.322,
                0.366,
                0.339
            ],
            "angle": 0,
            "content": "这说明了 \\(\\log (x^2 +1)\\) 是 \\(O(\\log x)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.341,
                0.893,
                0.379
            ],
            "angle": 0,
            "content": "从定理3可知 \\((x + 1)\\log (x^{2} + 1)\\) 是 \\(O(x\\log x)\\) 的。由于 \\(3x^{2}\\) 是 \\(O(x^{2})\\) 的，所以定理2说明\\(f(x)\\) 是 \\(O(\\max (x\\log x,x^2))\\) 的。当 \\(x > 1\\) 时，由于 \\(x\\log x\\leqslant x^2\\) ，所以有 \\(f(x)\\) 是 \\(O(x^{2})\\) 的。"
        },
        {
            "type": "title",
            "bbox": [
                0.047,
                0.389,
                0.295,
                0.406
            ],
            "angle": 0,
            "content": "3.2.5 大 \\(\\pmb{\\Omega}\\) 与大 \\(\\pmb{\\Theta}\\) 记号"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.408,
                0.894,
                0.503
            ],
            "angle": 0,
            "content": "大 \\(O\\) 记号广泛用于描述函数的增长，但它也有局限性。特别是，当 \\(f(x)\\) 是 \\(O(g(x))\\) 时，我们只有用 \\(g(x)\\) 来估算对于大 \\(x\\) 值的 \\(f(x)\\) 大小的一个上限。可是，大 \\(O\\) 记号不能提供对大 \\(x\\) 值的 \\(f(x)\\) 之大小的一个下限。为此，我们使用大 \\(\\Omega\\) 记号。当希望给出函数 \\(f(x)\\) 的相对于参照函数 \\(g(x)\\) 的上限和下限时，我们使用大 \\(\\Theta\\) 符号。大 \\(\\Omega\\) 和大 \\(\\Theta\\) 符号都是由高德纳在1970年引入的。他引入这两个符号的动机是纠正人们需要用到函数的上限和下限时对大 \\(O\\) 符号的误用。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.505,
                0.699,
                0.523
            ],
            "angle": 0,
            "content": "现在定义大 \\(\\Omega\\) 符号并解释其用法。然后，再定义大 \\(\\Theta\\) 并解释其用法。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.53,
                0.885,
                0.566
            ],
            "angle": 0,
            "content": "定义2 令 \\(f\\) 和 \\(g\\) 为从整数集合或实数集合到实数集合的函数。如果存在正常数 \\(C\\) 和 \\(k\\) 使得当 \\(x > k\\) 时有"
        },
        {
            "type": "equation",
            "bbox": [
                0.378,
                0.569,
                0.553,
                0.587
            ],
            "angle": 0,
            "content": "\\[\n\\left| f (x) \\right| \\geqslant C \\left| g (x) \\right|\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.589,
                0.603,
                0.607
            ],
            "angle": 0,
            "content": "我们说 \\(f(x)\\) 是 \\(\\Omega(g(x))\\) 的[这个读作“\\(f(x)\\) 是大 \\(\\Omega g(x)\\) 的”。]"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.615,
                0.891,
                0.652
            ],
            "angle": 0,
            "content": "在大 \\(O\\) 和大 \\(\\Omega\\) 记号之间有很强的关联。特别是 \\(f(x)\\) 是 \\(\\Omega(g(x))\\) 的当且仅当 \\(g(x)\\) 是 \\(O(f(x))\\) 的。这一事实的证明作为练习留给读者。"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.656,
                0.891,
                0.716
            ],
            "angle": 0,
            "content": "例11函数 \\(f(x) = 8x^{3} + 5x^{2} + 7\\) 是 \\(\\Omega (g(x))\\) 的，其中 \\(g(x)\\) 是函数 \\(g(x) = x^3\\) 。由于 \\(f(x) = 8x^{3} + 5x^{2} + 7\\geqslant 8x^{3}\\) 对所有正实数都成立，所以上述说法容易证明。这等价于 \\(g(x) = x^3\\) 是\\(O(8x^{3} + 5x^{2} + 7)\\) 的，只需把不等式颠倒过来写就可以直接得到这一结论。"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.718,
                0.891,
                0.812
            ],
            "angle": 0,
            "content": "通常，重要的是需要知道用诸如 \\(x^n\\) （其中 \\(n\\) 是正整数）或 \\(c^x\\) （其中 \\(c > 1\\)）这样一个相对简单的参照函数来描述一个函数增长的阶。要想知道函数增长的阶，就需要了解该函数大小的上界和下界。即给定一个函数 \\(f(x)\\)，我们需要一个参照函数 \\(g(x)\\) 使得 \\(f(x)\\) 是 \\(O(g(x))\\) 的且 \\(f(x)\\) 是 \\(\\Omega(g(x))\\) 的。下面定义的大 \\(\\Theta\\) 记号就是用来表达这两个关系，提供函数大小的一个上界和一个下界。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.821,
                0.885,
                0.879
            ],
            "angle": 0,
            "content": "定义3 令 \\( f \\) 和 \\( g \\) 为从整数集合或实数集合到实数集合的函数。如果 \\( f(x) \\) 是 \\( O(g(x)) \\) 的且 \\( f(x) \\) 是 \\( \\Omega(g(x)) \\) 的，我们就说 \\( f(x) \\) 是 \\( \\Theta(g(x)) \\) 的。当 \\( f(x) \\) 是 \\( \\Theta(g(x)) \\) 时，就说 \\( f(x) \\) 是大西塔 \\( g(x) \\) 的，即 \\( f(x) \\) 是 \\( g(x) \\) 阶的，或 \\( f(x) \\) 和 \\( g(x) \\) 是同阶的。"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.886,
                0.891,
                0.942
            ],
            "angle": 0,
            "content": "当 \\(f(x)\\) 是 \\(\\Theta(g(x))\\) 的，同样会有 \\(g(x)\\) 也是 \\(\\Theta(f(x))\\) 的。注意 \\(f(x)\\) 是 \\(\\Theta(g(x))\\) 当且仅当 \\(f(x)\\) 是 \\(O(g(x))\\) 的，\\(g(x)\\) 是 \\(O(f(x))\\) 的（见练习31）。再者，注意 \\(f(x)\\) 是 \\(\\Theta(g(x))\\) 的当且仅当存在实数 \\(C_1\\) 和 \\(C_2\\) 以及一个正实数 \\(k\\) 使得当 \\(x > k\\) 时有"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.135,
                0.039,
                0.172,
                0.053
            ],
            "angle": 0,
            "content": "192"
        },
        {
            "type": "header",
            "bbox": [
                0.216,
                0.038,
                0.282,
                0.053
            ],
            "angle": 0,
            "content": "第3章"
        },
        {
            "type": "equation",
            "bbox": [
                0.377,
                0.095,
                0.682,
                0.112
            ],
            "angle": 0,
            "content": "\\[\nC _ {1} \\left| g (x) \\right| \\leqslant \\left| f (x) \\right| \\leqslant C _ {2} \\left| g (x) \\right|\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.115,
                0.826,
                0.131
            ],
            "angle": 0,
            "content": "常量 \\(C_1\\) 、 \\(C_2\\) 及 \\(k\\) 的存在分别告诉我们 \\(f(x)\\) 是 \\(\\Omega (g(x))\\) 的和 \\(f(x)\\) 是 \\(O(g(x))\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.134,
                0.957,
                0.169
            ],
            "angle": 0,
            "content": "通常，当采用大 \\(\\Theta\\) 记号时，\\(\\Theta(g(x))\\) 中的函数 \\(g(x)\\) 是一个相对简单的参照函数，诸如 \\(x^n\\)、\\(c^x\\)、\\(\\log x\\) 等，而 \\(f(x)\\) 则相对复杂。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.174,
                0.957,
                0.213
            ],
            "angle": 0,
            "content": "例12（在例5中）已证明前 \\(n\\) 个正整数的和式是 \\(O(n^{2})\\) 。不借助于该和式的求和公式，试确定这个和式是否是 \\(n^2\\) 阶的。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.215,
                0.957,
                0.27
            ],
            "angle": 0,
            "content": "解 令 \\( f(n) = 1 + 2 + 3 + \\dots + n \\) 。由于已知 \\( f(n) \\) 是 \\( O(n^{2}) \\) 的，为证明 \\( f(n) \\) 是 \\( n^2 \\) 阶的，只需找到正整数 \\( C \\) 使得对足够大的 \\( n \\) 有 \\( f(n) > Cn^{2} \\) 。为获得这一和式的下界，可以忽略这些项中的前一半。只把大于 \\( \\lceil n / 2 \\rceil \\) 的项加起来，得"
        },
        {
            "type": "equation",
            "bbox": [
                0.324,
                0.274,
                0.746,
                0.365
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} 1 + 2 + \\dots + n \\geqslant \\lceil n / 2 \\rceil + (\\lceil n / 2 \\rceil + 1) + \\dots + n \\\\ \\geqslant \\lceil n / 2 \\rceil + \\lceil n / 2 \\rceil + \\dots + \\lceil n / 2 \\rceil \\\\ = (n - \\lceil n / 2 \\rceil + 1) \\lceil n / 2 \\rceil \\\\ \\geqslant (n / 2) (n / 2) \\\\ = n ^ {2} / 4 。 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.368,
                0.9,
                0.385
            ],
            "angle": 0,
            "content": "这说明 \\(f(n)\\) 是 \\(\\Omega (n^2)\\) 的。我们得出结论 \\(f(n)\\) 是 \\(n^2\\) 阶的，或用符号写为 \\(f(n)\\) 是 \\(\\Theta (n^{2})\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.39,
                0.957,
                0.458
            ],
            "angle": 0,
            "content": "评注 我们也可以利用2.4节的表2以及练习37b推导出的闭合公式 \\(\\sum_{i=1}^{n} n(n+1)/2\\) 来证明 \\(f(n) = \\sum_{i=1}^{n} i\\) 是 \\(\\Theta(n^2)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.462,
                0.483,
                0.479
            ],
            "angle": 0,
            "content": "例13 证明 \\(3x^{2} + 8x\\log x\\) 是 \\(\\Theta (x^2)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.484,
                0.957,
                0.519
            ],
            "angle": 0,
            "content": "解因为 \\(0 \\leqslant 8x\\log x \\leqslant 8x^{2}\\)，所以对 \\(x > 1\\) 有 \\(3x^{2} + 8x\\log x \\leqslant 11x^{2}\\)。因此，\\(3x^{2} + 8x\\log x\\) 是 \\(O(x^{2})\\) 的。显然，\\(x^{2}\\) 是 \\(O(3x^{2} + 8x\\log x)\\) 的。因此，\\(3x^{2} + 8x\\log x\\) 是 \\(\\Theta(x^{2})\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.522,
                0.957,
                0.557
            ],
            "angle": 0,
            "content": "一个有用的事实是多项式的首项决定其阶。例如，如果 \\( f(x) = 3x^{5} + x^{4} + 17x^{3} + 2 \\)，那么 \\( f(x) \\) 是 \\( x^{5} \\) 阶的。这一事实表述为定理4，其证明留作练习50。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.565,
                0.952,
                0.605
            ],
            "angle": 0,
            "content": "定理4令 \\(f(x) = a_{n}x^{n} + a_{n - 1}x^{n - 1} + \\dots +a_{1}x + a_{0}\\) ，其中 \\(a_0,a_1,\\dots ,a_n\\) 为实数且 \\(a_{n}\\neq 0\\) 。则 \\(f(x)\\) 是 \\(x^n\\) 阶的。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.615,
                0.962,
                0.654
            ],
            "angle": 0,
            "content": "例14 多项式 \\(3x^{8} + 10x^{7} + 221x^{2} + 1444\\)，\\(x^{19} - 18x^{4} - 10112\\) 和 \\(-x^{99} + 40001x^{98} + 100003x\\) 分别是 \\(x^{8}\\)、\\(x^{19}\\) 和 \\(x^{99}\\) 阶的。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.657,
                0.962,
                0.712
            ],
            "angle": 0,
            "content": "不幸的是，正如高德纳观察到的那样，大 \\(O\\) 记号常被粗心的作者和演讲者误以为其含义与大 \\(\\Theta\\) 相同。当你见到使用大 \\(O\\) 记号时就要保持警惕。近来的趋势是当需要一个函数大小的上界和下界时就采用大 \\(\\Theta\\) 记号。"
        },
        {
            "type": "title",
            "bbox": [
                0.114,
                0.723,
                0.163,
                0.738
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.742,
                0.86,
                0.759
            ],
            "angle": 0,
            "content": "在练习 \\(1\\sim 14\\) 中，要建立大 \\(O\\) 关系，找出凭证 \\(C\\) 和 \\(k\\) 使得当 \\(x > k\\) 时有 \\(\\left|f(x)\\right|\\leqslant C\\left|g(x)\\right|\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.762,
                0.401,
                0.777
            ],
            "angle": 0,
            "content": "1. 判断下列各函数是否为 \\(O(x)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.78,
                0.237,
                0.795
            ],
            "angle": 0,
            "content": "a) \\(f(x) = 10\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.532,
                0.781,
                0.659,
                0.795
            ],
            "angle": 0,
            "content": "b) \\(f(x) = 3x + 7\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.799,
                0.293,
                0.812
            ],
            "angle": 0,
            "content": "c) \\(f(x) = x^{2} + x + 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.532,
                0.799,
                0.667,
                0.812
            ],
            "angle": 0,
            "content": "d) \\( f(x) = 5\\log x \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.816,
                0.251,
                0.831
            ],
            "angle": 0,
            "content": "e) \\(f(x) = \\lfloor x\\rfloor\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.532,
                0.816,
                0.659,
                0.831
            ],
            "angle": 0,
            "content": "f) \\( f(x) = \\lceil x / 2 \\rceil \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.834,
                0.41,
                0.848
            ],
            "angle": 0,
            "content": "2. 判断下列各函数是否为 \\(O(x^{2})\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.852,
                0.285,
                0.865
            ],
            "angle": 0,
            "content": "a) \\(f(x) = 17x + 11\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.533,
                0.852,
                0.685,
                0.865
            ],
            "angle": 0,
            "content": "b) \\(f(x) = x^{2} + 1000\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.87,
                0.277,
                0.883
            ],
            "angle": 0,
            "content": "c) \\(f(x) = x\\log x\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.533,
                0.87,
                0.649,
                0.883
            ],
            "angle": 0,
            "content": "d) \\(f(x) = x^4 /2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.888,
                0.234,
                0.901
            ],
            "angle": 0,
            "content": "e) \\(f(x) = 2^{x}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.533,
                0.887,
                0.691,
                0.902
            ],
            "angle": 0,
            "content": "f) \\( f(x) = \\lfloor x \\rfloor \\cdot \\lceil x \\rceil \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.904,
                0.667,
                0.919
            ],
            "angle": 0,
            "content": "3. 用“\\(f(x)\\) 是 \\(O(g(x))\\) 的”定义证明 \\(x^4 + 9x^3 + 4x + 7\\) 是 \\(O(x^4)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.922,
                0.589,
                0.937
            ],
            "angle": 0,
            "content": "4. 用“\\(f(x)\\) 是 \\(O(g(x))\\) 的”定义证明 \\(2^x + 17\\) 是 \\(O(3^x)\\) 的。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.691,
                0.038,
                0.78,
                0.053
            ],
            "angle": 0,
            "content": "算法"
        },
        {
            "type": "page_number",
            "bbox": [
                0.827,
                0.04,
                0.86,
                0.053
            ],
            "angle": 0,
            "content": "193"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.095,
                0.329,
                0.11
            ],
            "angle": 0,
            "content": "5. 证明 \\((x^{2} + 1) / (x + 1)\\) 是 \\(O(x)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.113,
                0.339,
                0.128
            ],
            "angle": 0,
            "content": "6. 证明 \\((x^{3} + 2x) / (2x + 1)\\) 是 \\(O(x^{2})\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.131,
                0.512,
                0.146
            ],
            "angle": 0,
            "content": "7. 对下列每个函数求最小的整数 \\( n \\) 使得 \\( f(x) \\) 是 \\( O(x^n) \\) 的。"
        },
        {
            "type": "equation",
            "bbox": [
                0.068,
                0.149,
                0.258,
                0.163
            ],
            "angle": 0,
            "content": "\\[\n\\mathrm {a}) f (x) = 2 x ^ {3} + x ^ {2} \\log x\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.459,
                0.149,
                0.649,
                0.163
            ],
            "angle": 0,
            "content": "\\[\n\\mathrm {b}) f (x) = 3 x ^ {3} + (\\log x) ^ {4}\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.069,
                0.167,
                0.32,
                0.18
            ],
            "angle": 0,
            "content": "\\[\n\\mathrm {c}) f (x) = \\left(x ^ {4} + x ^ {2} + 1\\right) / \\left(x ^ {3} + 1\\right)\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.459,
                0.167,
                0.722,
                0.181
            ],
            "angle": 0,
            "content": "\\[\n\\mathrm {d}) f (x) = \\left(x ^ {4} + 5 \\log x\\right) / \\left(x ^ {4} + 1\\right)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.184,
                0.512,
                0.199
            ],
            "angle": 0,
            "content": "8. 对下列每个函数求最小的整数 \\( n \\) 使得 \\( f(x) \\) 是 \\( O(x^n) \\) 的。"
        },
        {
            "type": "equation",
            "bbox": [
                0.068,
                0.203,
                0.331,
                0.27
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} \\mathrm {a}) f (x) = 2 x ^ {2} + x ^ {3} \\log x \\\\ \\mathrm {b}) f (x) = 3 x ^ {5} + (\\log x) ^ {4} \\\\ \\mathrm {c}) f (x) = \\left(x ^ {4} + x ^ {2} + 1\\right) / \\left(x ^ {4} + 1\\right) \\\\ \\mathrm {d}) f (x) = \\left(x ^ {3} + 5 \\log x\\right) / \\left(x ^ {4} + 1\\right) \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.273,
                0.562,
                0.289
            ],
            "angle": 0,
            "content": "9. 证明 \\(x^{2} + 4x + 17\\) 是 \\(O(x^{3})\\) 的，但 \\(x^{3}\\) 不是 \\(O(x^{2} + 4x + 17)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.291,
                0.421,
                0.307
            ],
            "angle": 0,
            "content": "10. 证明 \\(x^3\\) 是 \\(O(x^4)\\) 的，但 \\(x^4\\) 不是 \\(O(x^3)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.309,
                0.549,
                0.324
            ],
            "angle": 0,
            "content": "11. 证明 \\(3x^4 + 1\\) 是 \\(O(x^4 / 2)\\) 的，而且 \\(x^4 / 2\\) 也是 \\(O(3x^4 + 1)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.327,
                0.499,
                0.342
            ],
            "angle": 0,
            "content": "12. 证明 \\(x \\log x\\) 是 \\(O(x^2)\\) 的，但 \\(x^2\\) 不是 \\(O(x \\log x)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.345,
                0.414,
                0.359
            ],
            "angle": 0,
            "content": "13. 证明 \\(2^{n}\\) 是 \\(O(3^{n})\\) 的，但 \\(3^{n}\\) 不是 \\(O(2^{n})\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.363,
                0.516,
                0.378
            ],
            "angle": 0,
            "content": "14. 对于下列每个函数 \\(g(x)\\)，判断 \\(x^3\\) 是否是 \\(O(g(x))\\) 的。"
        },
        {
            "type": "list",
            "bbox": [
                0.047,
                0.291,
                0.549,
                0.378
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "equation",
            "bbox": [
                0.078,
                0.382,
                0.174,
                0.395
            ],
            "angle": 0,
            "content": "\\[\n\\mathrm {a}) g (x) = x ^ {2}\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.461,
                0.382,
                0.558,
                0.395
            ],
            "angle": 0,
            "content": "\\[\n\\mathrm {b}) g (x) = x ^ {3}\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.08,
                0.399,
                0.21,
                0.412
            ],
            "angle": 0,
            "content": "\\[\n\\mathrm {c}) g (x) = x ^ {2} + x ^ {3}\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.461,
                0.399,
                0.594,
                0.413
            ],
            "angle": 0,
            "content": "\\[\n\\mathrm {d}) g (x) = x ^ {2} + x ^ {4}\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.08,
                0.418,
                0.172,
                0.43
            ],
            "angle": 0,
            "content": "\\[\ne) g (x) = 3 ^ {x}\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.461,
                0.418,
                0.576,
                0.431
            ],
            "angle": 0,
            "content": "\\[\nf) g (x) = x ^ {3} / 2\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.434,
                0.34,
                0.448
            ],
            "angle": 0,
            "content": "15. 试解释一个函数是 \\(O(1)\\) 的含义。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.452,
                0.485,
                0.467
            ],
            "angle": 0,
            "content": "16. 证明如果 \\( f(x) \\) 是 \\( O(x) \\) 的，那么 \\( f(x) \\) 是 \\( O(x^2) \\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.47,
                0.895,
                0.502
            ],
            "angle": 0,
            "content": "17. 假定 \\( f(x) \\)、\\( g(x) \\) 和 \\( h(x) \\) 为函数，使得 \\( f(x) \\) 是 \\( O(g(x)) \\) 的，\\( g(x) \\) 是 \\( O(h(x)) \\) 的。证明 \\( f(x) \\) 是 \\( O(h(x)) \\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.505,
                0.496,
                0.52
            ],
            "angle": 0,
            "content": "18. 令 \\(k\\) 为正整数。证明 \\(1^{k} + 2^{k} + \\dots + n^{k}\\) 是 \\(O(n^{k+1})\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.523,
                0.375,
                0.538
            ],
            "angle": 0,
            "content": "19. 判断函数 \\(2^{n+1}\\) 和 \\(2^{2n}\\) 是否是 \\(O(2^n)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.541,
                0.509,
                0.556
            ],
            "angle": 0,
            "content": "20. 判断函数 \\(\\log (n + 1)\\) 和 \\(\\log (n^2 + 1)\\) 是否是 \\(O(\\log n)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.561,
                0.895,
                0.594
            ],
            "angle": 0,
            "content": "21. 将函数 \\(\\sqrt{n}\\) 、 \\(1000\\log n\\) 、 \\(n\\log n\\) 、 \\(2n!\\) 、 \\(2^{n}\\) 、 \\(3^{n}\\) 和 \\(n^2 / 1000000\\) 排成一列使得每个函数是大 \\(O\\) 下一个函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.6,
                0.895,
                0.633
            ],
            "angle": 0,
            "content": "22. 将函数 \\((1.5)^n\\) 、 \\(n^{100}\\) 、 \\((\\log n)^3\\) 、 \\(\\sqrt{n} \\log n\\) 、 \\(10^n\\) 、 \\((n!)^2\\) 和 \\(n^{99} + n^{98}\\) 排成一列使得每个函数是大 \\(O\\) 下一个函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.636,
                0.895,
                0.669
            ],
            "angle": 0,
            "content": "23. 假设你有解决同一个问题的两个不同的算法。要解决大小为 \\( n \\) 的问题，第一个算法恰好使用了 \\( n(\\log n) \\) 步运算，而第二个算法恰好使用了 \\( n^{3/2} \\) 步运算。随着 \\( n \\) 的增长，哪个算法使用较少步运算？"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.672,
                0.895,
                0.705
            ],
            "angle": 0,
            "content": "24. 假设你有解决同一个问题的两个不同的算法。要解决大小为 \\( n \\) 的问题，第一个算法恰好使用了 \\( n^2 2^n \\) 步运算，而第二个算法恰好使用了 \\( n! \\) 步运算。随着 \\( n \\) 的增长，哪个算法使用较少步运算？"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.708,
                0.45,
                0.722
            ],
            "angle": 0,
            "content": "25. 对下列各函数给出一个尽可能好的大 \\(O\\) 估算。"
        },
        {
            "type": "list",
            "bbox": [
                0.049,
                0.452,
                0.895,
                0.722
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "equation",
            "bbox": [
                0.082,
                0.726,
                0.657,
                0.757
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} \\mathrm {a}) (n ^ {2} + 8) (n + 1) \\\\ \\mathrm {b}) (n \\log n + n ^ {2}) (n ^ {3} + 2) \\\\ \\mathrm {c}) (n! + 2 ^ {n}) (n ^ {3} + \\log (n ^ {2} + 1)) \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.761,
                0.845,
                0.776
            ],
            "angle": 0,
            "content": "26. 给出下列各函数的大 \\(O\\) 估算。在你估算 \\(f(x)\\) 是 \\(O(g(x))\\) 的时候使用一个阶最小的简单函数 \\(g\\)。"
        },
        {
            "type": "equation",
            "bbox": [
                0.085,
                0.78,
                0.498,
                0.828
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} \\mathrm {a}) (n ^ {3} + n ^ {2} \\log n) (\\log n + 1) + (1 7 \\log n + 1 9) (n ^ {3} + 2) \\\\ \\mathbf {b}) (2 ^ {n} + n ^ {2}) (n ^ {3} + 3 ^ {n}) \\\\ \\mathrm {c}) \\left(n ^ {n} + n 2 ^ {n} + 5 ^ {n}\\right) (n! + 5 ^ {n}) \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.833,
                0.846,
                0.848
            ],
            "angle": 0,
            "content": "27. 给下列各函数一个大 \\(O\\) 估算，在你估算 \\(f(x)\\) 是 \\(O(g(x))\\) 的时候使用一个阶最小的简单函数 \\(g\\)。"
        },
        {
            "type": "equation",
            "bbox": [
                0.085,
                0.851,
                0.762,
                0.885
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} \\mathrm {a}) n \\log (n ^ {2} + 1) + n ^ {2} \\log n \\\\ \\mathbf {b}) (n \\log n + 1) ^ {2} + (\\log n + 1) (n ^ {2} + 1) \\\\ \\mathrm {c}) n ^ {2 ^ {n}} + n ^ {n ^ {2}} \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.89,
                0.54,
                0.904
            ],
            "angle": 0,
            "content": "28. 对练习1中的各函数，判断它是否为 \\(\\Omega(x)\\) 的和 \\(\\Theta(x)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.908,
                0.556,
                0.922
            ],
            "angle": 0,
            "content": "29. 对练习 2 中的各函数，判断它是否为 \\(\\Omega(x^2)\\) 的和 \\(\\Theta(x^2)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.926,
                0.337,
                0.94
            ],
            "angle": 0,
            "content": "30. 证明下列函数对具有相同的阶。"
        },
        {
            "type": "list",
            "bbox": [
                0.05,
                0.89,
                0.556,
                0.94
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.14,
                0.039,
                0.176,
                0.053
            ],
            "angle": 0,
            "content": "194"
        },
        {
            "type": "header",
            "bbox": [
                0.221,
                0.038,
                0.288,
                0.053
            ],
            "angle": 0,
            "content": "第3章"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.095,
                0.245,
                0.109
            ],
            "angle": 0,
            "content": "a) \\(3x + 7\\) ， \\(x\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.527,
                0.095,
                0.669,
                0.108
            ],
            "angle": 0,
            "content": "b) \\(2x^{2} + x - 7\\) ， \\(x^{2}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.113,
                0.272,
                0.128
            ],
            "angle": 0,
            "content": "e \\(\\lfloor x + 1 / 2\\rfloor\\) ， \\(x\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.527,
                0.113,
                0.698,
                0.127
            ],
            "angle": 0,
            "content": "d) \\(\\log (x^2 +1)\\) ， \\(\\log_2x\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.132,
                0.274,
                0.145
            ],
            "angle": 0,
            "content": "e) \\(\\log_{10}x\\) ， \\(\\log_2x\\)"
        },
        {
            "type": "list",
            "bbox": [
                0.143,
                0.095,
                0.698,
                0.145
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.148,
                0.758,
                0.163
            ],
            "angle": 0,
            "content": "31. 证明 \\(f(x)\\) 是 \\(\\Theta(g(x))\\) 的当且仅当 \\(f(x)\\) 是 \\(O(g(x))\\) 的且 \\(g(x)\\) 是 \\(O(f(x))\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.166,
                0.96,
                0.198
            ],
            "angle": 0,
            "content": "32. 证明如果 \\( f(x) \\) 和 \\( g(x) \\) 是从实数集到实数集的函数，则 \\( f(x) \\) 是 \\( O(g(x)) \\) 的当且仅当 \\( g(x) \\) 是 \\( \\Omega(f(x)) \\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.201,
                0.958,
                0.235
            ],
            "angle": 0,
            "content": "33. 证明如果 \\( f(x) \\) 和 \\( g(x) \\) 是从实数集到实数集的函数，则 \\( f(x) \\) 是 \\( \\Theta(g(x)) \\) 的当且仅当存在正常数 \\( k \\)、\\( C_1 \\) 和 \\( C_2 \\) 使得当 \\( x > k \\) 时有 \\( C_1 |g(x)| \\leqslant |f(x)| \\leqslant C_2 |g(x)| \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.238,
                0.742,
                0.253
            ],
            "angle": 0,
            "content": "34. a) 找出练习 33 中要求的 \\(k\\)、\\(C_1\\) 和 \\(C_2\\) 来直接证明 \\(3x^2 + x + 1\\) 是 \\(\\Theta(3x^2)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.256,
                0.96,
                0.29
            ],
            "angle": 0,
            "content": "b)用图像表示(a)中的关系，展示函数 \\(3x^{2} + x + 1\\) ， \\(C_1\\cdot 3x^2\\) 和 \\(C_2\\cdot 3x^2\\) 的图像，并在 \\(\\mathcal{X}\\) 轴上标出 \\(k\\) 其中 \\(k\\) ， \\(C_1\\) ， \\(C_2\\) 是(a)中你用来证明 \\(3x^{2} + x + 1\\) 是 \\(\\Theta (3x^{2})\\) 的时找到的常数。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.293,
                0.96,
                0.327
            ],
            "angle": 0,
            "content": "35. 用图像表示 \\( f(x) \\) 是 \\( \\Theta(g(x)) \\) 的这一关系。画出 \\( f(x), C_1 | g(x)|, C_2 | g(x)| \\) 的图像，并在 \\( x \\) 轴上标出常数 \\( k \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.331,
                0.348,
                0.345
            ],
            "angle": 0,
            "content": "36. 解释函数为 \\(\\Omega(1)\\) 的含义。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.349,
                0.348,
                0.362
            ],
            "angle": 0,
            "content": "37. 解释函数为 \\(\\Theta(1)\\) 的含义。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.366,
                0.512,
                0.38
            ],
            "angle": 0,
            "content": "38. 给出前 \\(n\\) 个奇正整数之乘积的一个大 \\(O\\) 估算。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.384,
                0.958,
                0.416
            ],
            "angle": 0,
            "content": "39. 证明如果 \\( f \\) 和 \\( g \\) 为实数值函数使得 \\( f(x) \\) 是 \\( O(g(x)) \\) 的，则对每个正整数 \\( n \\) 有 \\( f^n(x) \\) 是 \\( O(g^n(x)) \\) 的。[注意 \\( f^n(x) = (f(x))^n \\)]"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.419,
                0.892,
                0.434
            ],
            "angle": 0,
            "content": "40. 证明对于所有实数 \\(a\\) 和 \\(b\\) 且 \\(a > 1\\) 及 \\(b > 1\\) ，如果 \\(f(x)\\) 是 \\(O(\\log_a x)\\) 的，则 \\(f(x)\\) 是 \\(O(\\log_a x)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.438,
                0.904,
                0.453
            ],
            "angle": 0,
            "content": "41. 假设 \\( f(x) \\) 是 \\( O(g(x)) \\) 的，其中 \\( f \\) 和 \\( g \\) 是无限增长函数。证明 \\( \\log |f(x)| \\) 是 \\( O(\\log |g(x)|) \\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.457,
                0.61,
                0.471
            ],
            "angle": 0,
            "content": "42. 假定 \\( f(x) \\) 是 \\( O(g(x)) \\) 的。能否推断出 \\( 2^{f(x)} \\) 是 \\( O(2^{g(x)}) \\) 的？"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.474,
                0.96,
                0.525
            ],
            "angle": 0,
            "content": "43. 令 \\( f_{1}(x) \\) 和 \\( f_{2}(x) \\) 为从实数集合到正实数集合的函数。证明如果 \\( f_{1}(x) \\) 和 \\( f_{2}(x) \\) 均为 \\( \\Theta(g(x)) \\) 的，其中 \\( g(x) \\) 是从实数集到正实数集的一个函数，则 \\( f_{1}(x) + f_{2}(x) \\) 是 \\( \\Theta(g(x)) \\) 的。如果 \\( f_{1}(x) \\) 和 \\( f_{2}(x) \\) 能取负值，这一结论还成立吗？"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.528,
                0.958,
                0.56
            ],
            "angle": 0,
            "content": "44. 假定 \\( f(x) \\) 、 \\( g(x) \\) 和 \\( h(x) \\) 是函数使得 \\( f(x) \\) 是 \\( \\Theta(g(x)) \\) 的，\\( g(x) \\) 是 \\( \\Theta(h(x)) \\) 的。证明 \\( f(x) \\) 是 \\( \\Theta(h(x)) \\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.563,
                0.958,
                0.596
            ],
            "angle": 0,
            "content": "45. 如果 \\( f_{1}(x) \\) 、 \\( f_{2}(x) \\) 为从正整数集合到正实数集合的函数，且 \\( f_{1}(x) \\) 和 \\( f_{2}(x) \\) 都是 \\( \\Theta(g(x)) \\) 的，\\( (f_{1} - f_{2})(x) \\) 是否也是 \\( \\Theta(g(x)) \\) 的？或证明它成立或给出一个反例。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.599,
                0.958,
                0.632
            ],
            "angle": 0,
            "content": "46. 证明如果 \\( f_{1}(x) \\) 和 \\( f_{2}(x) \\) 为从正整数集合到实数集合的函数，且 \\( f_{1}(\\overline{x}) \\) 是 \\( \\Theta(g_{1}(x)) \\) 的，\\( f_{2}(x) \\) 是 \\( \\Theta(g_{2}(x)) \\) 的，则 \\( (f_{1}f_{2})(x) \\) 是 \\( \\Theta((g_{1}g_{2})(x)) \\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.635,
                0.95,
                0.65
            ],
            "angle": 0,
            "content": "47. 找出从正整数集合到实数集合的函数 \\( f \\) 和 \\( g \\) 使得 \\( f(n) \\) 不是 \\( O(g(n)) \\) 的，且 \\( g(n) \\) 也不是 \\( O(f(n)) \\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.653,
                0.892,
                0.667
            ],
            "angle": 0,
            "content": "48. 用图像表示 \\( f(x) \\) 是 \\( \\Omega(g(x)) \\) 的关系。画出函数 \\( f(x) \\) 和 \\( Cg(x) \\) 的图，并在 \\( x \\) 轴上标出常数 \\( k \\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.67,
                0.958,
                0.703
            ],
            "angle": 0,
            "content": "49. 证明如果 \\( f_{1}(x) \\) 是 \\( \\Theta(g_{1}(x)) \\) 的，\\( f_{2}(x) \\) 是 \\( \\Theta(g_{2}(x)) \\) 的，且对所有实数 \\( x > 0 \\)，\\( f_{2}(x) \\neq 0 \\)，\\( g_{2}(x) \\neq 0 \\)，则 \\( (f_{1} / f_{2})(x) \\) 是 \\( \\Theta((g_{1} / g_{2})(x)) \\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.706,
                0.958,
                0.739
            ],
            "angle": 0,
            "content": "50. 证明如果 \\( f(x) = a_{n}x^{n} + a_{n - 1}x^{n - 1} + \\dots + a_{1}x + a_{0} \\)，其中 \\( a_0, a_1, \\dots, a_{n - 1} \\) 为实数，且 \\( a_{n} \\neq 0 \\)，则 \\( f(x) \\) 是 \\( \\Theta (x^n) \\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.742,
                0.958,
                0.776
            ],
            "angle": 0,
            "content": "大 \\(O\\) 、大 \\(\\Theta\\) 和大 \\(\\Omega\\) 记号可以推广到多元函数。例如，语句 \\(f(x, y)\\) 是 \\(O(g(x, y))\\) 的含义是存在常数 \\(C\\)、\\(k_{1}\\) 和 \\(k_{2}\\)，使得当 \\(x > k_{1}\\) 和 \\(y > k_{2}\\) 时有 \\(|f(x, y)| \\leqslant C |g(x, y)|\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.78,
                0.461,
                0.794
            ],
            "angle": 0,
            "content": "51. 试定义语句 \\( f(x, y) \\) 是 \\( \\Theta(g(x, y)) \\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.798,
                0.461,
                0.812
            ],
            "angle": 0,
            "content": "52. 试定义语句 \\( f(x, y) \\) 是 \\( \\Omega(g(x, y)) \\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.815,
                0.464,
                0.83
            ],
            "angle": 0,
            "content": "53. 证明 \\((x^{2} + xy + x\\log y)^{3}\\) 是 \\(O(x^{6}y^{3})\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.833,
                0.438,
                0.848
            ],
            "angle": 0,
            "content": "54. 证明 \\(x^{5}y^{3} + x^{4}y^{4} + x^{3}y^{5}\\) 是 \\(\\Omega (x^3 y^3)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.851,
                0.306,
                0.866
            ],
            "angle": 0,
            "content": "55. 证明 \\(\\lfloor xy\\rfloor\\) 是 \\(O(xy)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.869,
                0.306,
                0.883
            ],
            "angle": 0,
            "content": "56. 证明 \\(\\lfloor xy\\rfloor\\) 是 \\(\\Omega (xy)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.886,
                0.764,
                0.9
            ],
            "angle": 0,
            "content": "57.（需要微积分知识）证明如果 \\(c > d > 0\\) ，则 \\(n^d\\) 是 \\(O(n^{c})\\) 的，但 \\(n^c\\) 不是 \\(O(n^{d})\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.904,
                0.957,
                0.918
            ],
            "angle": 0,
            "content": "58. (需要微积分知识) 证明如果 \\(b > 1\\) 且 \\(c\\) 和 \\(d\\) 是正的，则 \\((\\log_b n)^c\\) 是 \\(O(n^d)\\) 的，但 \\(n^d\\) 不是 \\(O((\\log_b n)^c)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.922,
                0.829,
                0.936
            ],
            "angle": 0,
            "content": "59. (需要微积分知识) 证明如果 \\(d\\) 是正的且 \\(b > 1\\)，则 \\(n^d\\) 是 \\(O(b^n)\\) 的，但 \\(b^n\\) 不是 \\(O(n^d)\\) 的。"
        },
        {
            "type": "list",
            "bbox": [
                0.11,
                0.78,
                0.957,
                0.936
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.698,
                0.04,
                0.787,
                0.056
            ],
            "angle": 0,
            "content": "算法"
        },
        {
            "type": "page_number",
            "bbox": [
                0.834,
                0.042,
                0.868,
                0.055
            ],
            "angle": 0,
            "content": "195"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.097,
                0.701,
                0.112
            ],
            "angle": 0,
            "content": "60.（需要微积分知识）证明如果 \\(c > b > 1\\) ，则 \\(b^n\\) 是 \\(O(c^{n})\\) 的，但 \\(c^n\\) 不是 \\(O(b^{n})\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.116,
                0.68,
                0.13
            ],
            "angle": 0,
            "content": "61.（需要微积分知识）证明如果 \\(c > 1\\) ，则 \\(c^n\\) 是 \\(O(n!)\\) 的，但 \\(n!\\) 不是 \\(O(c^{n})\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.134,
                0.475,
                0.147
            ],
            "angle": 0,
            "content": "62.（需要微积分知识）证明或反驳 \\((2^{n})\\) 是 \\(O(n!\\) ）的。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.151,
                0.897,
                0.183
            ],
            "angle": 0,
            "content": "以下的问题涉及另一类渐近记号，称为小 \\(o\\) 记号。由于小 \\(o\\) 记号以极限概念为基础的，所以微积分知识是必要的。当"
        },
        {
            "type": "equation",
            "bbox": [
                0.416,
                0.187,
                0.532,
                0.214
            ],
            "angle": 0,
            "content": "\\[\n\\lim  _ {x \\rightarrow \\infty} \\frac {f (x)}{g (x)} = 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.217,
                0.553,
                0.232
            ],
            "angle": 0,
            "content": "时，我们说 \\(f(x)\\) 是 \\(o(g(x))\\) 的[读作 \\(f(x)\\) 是“小 \\(o\\) ” \\(g(x)\\) 的]。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.236,
                0.28,
                0.25
            ],
            "angle": 0,
            "content": "63.（需要微积分知识）证明："
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.254,
                0.222,
                0.269
            ],
            "angle": 0,
            "content": "a) \\(x^{2}\\) 是 \\(o(x^3)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.464,
                0.254,
                0.643,
                0.269
            ],
            "angle": 0,
            "content": "b) \\(x\\log x\\) 是 \\(o(x^{2})\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.272,
                0.221,
                0.286
            ],
            "angle": 0,
            "content": "c) \\(x^{2}\\) 是 \\(o(2^{x})\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.464,
                0.271,
                0.679,
                0.286
            ],
            "angle": 0,
            "content": "d) \\(x^{2} + x + 1\\) 不是 \\(o(x^2)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.29,
                0.232,
                0.304
            ],
            "angle": 0,
            "content": "64.（需要微积分知识）"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.307,
                0.896,
                0.339
            ],
            "angle": 0,
            "content": "a) 证明如果函数 \\( f(x) \\) 和 \\( g(x) \\) 使得 \\( f(x) \\) 是 \\( o(g(x)) \\) 的，且 \\( c \\) 为常数，则 \\( cf(x) \\) 是 \\( o(g(x)) \\) 的，其中 \\( (cf)(x) = cf(x) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.342,
                0.896,
                0.375
            ],
            "angle": 0,
            "content": "b) 证明如果 \\( f_{1}(x) \\)、\\( f_{2}(x) \\) 和 \\( g(x) \\) 是函数使得 \\( f_{1}(x) \\) 是 \\( o(g(x)) \\) 的，\\( f_{2}(x) \\) 是 \\( o(g(x)) \\) 的，则 \\( (f_{1} + f_{2})(x) \\) 是 \\( o(g(x)) \\) 的，其中 \\( (f_{1} + f_{2})(x) = f_{1}(x) + f_{2}(x) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.378,
                0.896,
                0.411
            ],
            "angle": 0,
            "content": "65.（需要微积分知识）通过画出 \\(x\\log x\\) 、 \\(x^{2}\\) 及 \\(x\\log x / x^2\\) 的图来表示 \\(x\\log x\\) 是 \\(o(x^{2})\\) 的。试解释该图是如何证明 \\(x\\log x\\) 是 \\(o(x^{2})\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.414,
                0.827,
                0.429
            ],
            "angle": 0,
            "content": "66.（需要微积分知识）用图来表示 \\(f(x)\\) 是 \\(o(g(x))\\) 的关系。画出 \\(f(x), g(x)\\) 和 \\(f(x) / g(x)\\) 的图。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.432,
                0.701,
                0.447
            ],
            "angle": 0,
            "content": "* 67.（需要微积分知识）假定 \\( f(x) \\) 是 \\( o(g(x)) \\) 的。能否由此推出 \\( 2^{f(x)} \\) 是 \\( o(2^{g(x)}) \\) 的？"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.45,
                0.814,
                0.466
            ],
            "angle": 0,
            "content": "* 68. (需要微积分知识)假定 \\( f(x) \\) 是 \\( o(g(x)) \\) 的。能否由此推出 \\( \\log |f(x)| \\) 是 \\( o(\\log |g(x)|) \\) 的？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.469,
                0.671,
                0.484
            ],
            "angle": 0,
            "content": "69.（需要微积分知识）本练习中的两部分描述了小 \\(o\\) 和大 \\(O\\) 记号之间的关系。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.487,
                0.714,
                0.502
            ],
            "angle": 0,
            "content": "a) 证明如果函数 \\( f(x) \\) 和 \\( g(x) \\) 使得 \\( f(x) \\) 是 \\( o(g(x)) \\) 的，则 \\( f(x) \\) 是 \\( O(g(x)) \\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.505,
                0.825,
                0.52
            ],
            "angle": 0,
            "content": "b) 证明如果函数 \\( f(x) \\) 和 \\( g(x) \\) 使得 \\( f(x) \\) 是 \\( O(g(x)) \\)，那么不一定能推出 \\( f(x) \\) 是 \\( o(g(x)) \\) 的。"
        },
        {
            "type": "list",
            "bbox": [
                0.081,
                0.487,
                0.825,
                0.52
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.523,
                0.896,
                0.556
            ],
            "angle": 0,
            "content": "70. (需要微积分知识) 证明如果 \\( f(x) \\) 是 \\( n \\) 阶多项式，而 \\( g(x) \\) 是 \\( m \\) 阶多项式，且 \\( m > n \\)，则 \\( f(x) \\) 是 \\( o(g(x)) \\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.558,
                0.896,
                0.591
            ],
            "angle": 0,
            "content": "71. (需要微积分知识) 证明如果 \\( f_{1}(x) \\) 是 \\( O(g(x)) \\) 的, \\( f_{2}(x) \\) 是 \\( o(g(x)) \\) 的, 那么 \\( f_{1}(x) + f_{2}(x) \\) 是 \\( O(g(x)) \\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.594,
                0.415,
                0.608
            ],
            "angle": 0,
            "content": "72.（需要微积分知识）令 \\(H_{n}\\) 为第 \\(n\\) 项调和数"
        },
        {
            "type": "list",
            "bbox": [
                0.051,
                0.523,
                0.896,
                0.608
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "equation",
            "bbox": [
                0.37,
                0.612,
                0.61,
                0.639
            ],
            "angle": 0,
            "content": "\\[\nH _ {n} = 1 + \\frac {1}{2} + \\frac {1}{3} + \\dots + \\frac {1}{n}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.643,
                0.896,
                0.677
            ],
            "angle": 0,
            "content": "证明 \\(H_{n}\\) 是 \\(O(\\log n)\\) 的。[提示：首先通过证明对 \\(j = 2,3,\\dots ,n\\) ，以 \\(j - 1\\) 到 \\(j\\) 为底，以 \\(1 / j\\) 为高的所有这些长方形的面积之和小于曲线 \\(y = 1 / x\\) 下面从2到 \\(_n\\) 的这一面积来建立不等式"
        },
        {
            "type": "equation",
            "bbox": [
                0.399,
                0.682,
                0.549,
                0.713
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {j = 2} ^ {n} \\frac {1}{j} <   \\int_ {1} ^ {n} \\frac {1}{x} d x\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.714,
                0.314,
                0.729
            ],
            "angle": 0,
            "content": "*73. 证明 \\( n \\log n \\) 是 \\( O(\\log n!) \\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.023,
                0.732,
                0.448,
                0.747
            ],
            "angle": 0,
            "content": "74. 判断 \\(\\log n!\\) 是否是 \\(\\Theta (n\\log n)\\) 的。给出理由。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.749,
                0.899,
                0.783
            ],
            "angle": 0,
            "content": "* 75. 证明：对所有 \\( n > 4 \\) 的数，有 \\( \\log n! \\) 大于 \\( (n \\log n) / 4 \\) 。[提示：从不等式 \\( n! > n(n - 1)(n - 2)\\dots \\left\\lceil n / 2 \\right\\rceil \\) 开始。]"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.785,
                0.896,
                0.819
            ],
            "angle": 0,
            "content": "令 \\(f(x)\\) 和 \\(g(x)\\) 为从实数集合到实数集合的函数。如果 \\(\\lim_{x\\to \\infty}(f(x) / g(x)) = 1\\) ，我们说 \\(f(x)\\) 和 \\(g(x)\\) 是渐近的，并写作 \\(f(x)\\sim g(x)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.821,
                0.578,
                0.836
            ],
            "angle": 0,
            "content": "76.（需要微积分知识）对下列每对函数，判断 \\(f\\) 和 \\(g\\) 是否渐近的。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.84,
                0.378,
                0.854
            ],
            "angle": 0,
            "content": "a) \\( f(x) = x^{2} + 3x + 7 \\)，\\( g(x) = x^{2} + 10 \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.857,
                0.317,
                0.871
            ],
            "angle": 0,
            "content": "b) \\( f(x) = x^{2} \\log x \\), \\( g(x) = x^{3} \\)."
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.875,
                0.489,
                0.889
            ],
            "angle": 0,
            "content": "c) \\( f(x) = x^4 + \\log (3x^8 + 7) \\), \\( g(x) = (x^2 + 17x + 3)^2 \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.892,
                0.551,
                0.906
            ],
            "angle": 0,
            "content": "d) \\(f(x) = (x^{3} + x^{2} + x + 1)^{4}\\) ， \\(g(x) = (x^4 +x^3 +x^2 +x + 1)^3\\)"
        },
        {
            "type": "list",
            "bbox": [
                0.081,
                0.84,
                0.551,
                0.906
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.91,
                0.578,
                0.925
            ],
            "angle": 0,
            "content": "77.（需要微积分知识）对下列每对函数，判断 \\(f\\) 和 \\(g\\) 是否渐近的。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.928,
                0.367,
                0.943
            ],
            "angle": 0,
            "content": "a) \\( f(x) = \\log (x^{2} + 1) \\), \\( g(x) = \\log x \\)"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.14,
                0.039,
                0.175,
                0.052
            ],
            "angle": 0,
            "content": "196"
        },
        {
            "type": "header",
            "bbox": [
                0.22,
                0.038,
                0.284,
                0.052
            ],
            "angle": 0,
            "content": "第3章"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.095,
                0.365,
                0.109
            ],
            "angle": 0,
            "content": "(b) \\(f(x) = 2^{x + 3}\\) ， \\(g(x) = 2^{x + 7}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.115,
                0.344,
                0.129
            ],
            "angle": 0,
            "content": "c) \\(f(x) = 2^{x}\\) ， \\(g(x) = 2^{x^2}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.136,
                0.403,
                0.151
            ],
            "angle": 0,
            "content": "d) \\(f(x) = 2^{x^2 + x + 1}\\), \\(g(x) = 2^{x^2 + 2x}\\)."
        },
        {
            "type": "list",
            "bbox": [
                0.145,
                0.095,
                0.403,
                0.151
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.114,
                0.167,
                0.339,
                0.186
            ],
            "angle": 0,
            "content": "3.3 算法的复杂度"
        },
        {
            "type": "title",
            "bbox": [
                0.114,
                0.195,
                0.238,
                0.21
            ],
            "angle": 0,
            "content": "3.3.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.215,
                0.956,
                0.248
            ],
            "angle": 0,
            "content": "什么情况下算法能给一个问题提供令人满意的解？首先，算法必须总是能给出正确的答案。第5章将讨论如何说明算法的正确性。其次，算法必须是有效率的。本节讨论算法的效率。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.253,
                0.958,
                0.288
            ],
            "angle": 0,
            "content": "算法的效率如何分析呢？一种度量方式是当输入值具有一定规模时，计算机按此算法解题所花的时间。第二种度量方式是输入值具有一定规模时，实现这一算法计算机需要多大内存。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.291,
                0.96,
                0.383
            ],
            "angle": 0,
            "content": "这些问题都涉及算法的计算复杂度（computational complexity）。解决特定规模的问题所需时间的分析就是算法的时间复杂度。所需计算机内存的分析就是算法的空间复杂度。在实现算法时，时间和空间复杂度的考虑都是最本质的。显然，了解算法是否能在1微秒、1分钟、还是10亿年给出答案是很重要的。类似地，必须能提供所需的内存才能解决问题，所以空间复杂度也必须加以考虑。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.386,
                0.96,
                0.422
            ],
            "angle": 0,
            "content": "空间复杂度的考虑与实现算法时使用的特定数据结构紧密相关。由于本书对数据结构不做详细讨论，所以不考虑空间复杂度。我们将注意力集中在时间复杂度上。"
        },
        {
            "type": "title",
            "bbox": [
                0.115,
                0.432,
                0.309,
                0.449
            ],
            "angle": 0,
            "content": "3.3.2 时间复杂度"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.452,
                0.96,
                0.487
            ],
            "angle": 0,
            "content": "在输入具有一定规模时，算法的时间复杂度可以用算法所需的运算次数来表示。用于度量时间复杂度的运算可以是整数比较、整数加法、整数乘法、整数除法或任何其他基本运算。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.49,
                0.962,
                0.563
            ],
            "angle": 0,
            "content": "时间复杂度用所需运算次数而不是用计算机实际使用的时间来表示，因为在执行基本运算时不同的计算机需要的时间不同。再者，把所有运算分解成计算机使用的基本位运算是相当复杂的。而且，现存最快的计算机执行基本的位运算（例如两比特的加、乘、比较或交换）的时间是 \\(10^{-11}\\) 秒(10皮秒)，但个人计算机可能需要 \\(10^{-8}\\) 秒(10纳秒)，做同样的运算时间相差1000倍。"
        },
        {
            "type": "text",
            "bbox": [
                0.158,
                0.566,
                0.948,
                0.583
            ],
            "angle": 0,
            "content": "我们用3.1节求整数有限集合中最大值的算法1来说明怎样分析一个算法的时间复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.157,
                0.588,
                0.777,
                0.605
            ],
            "angle": 0,
            "content": "例1描述3.1节求整数有限集合中最大元素的算法1的时间复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.159,
                0.61,
                0.928,
                0.626
            ],
            "angle": 0,
            "content": "解由于比较是该算法使用的基本运算，所以以比较的次数作为其时间复杂度的度量。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.629,
                0.965,
                0.779
            ],
            "angle": 0,
            "content": "要在以任意顺序列出的 \\(n\\) 个元素的集合中寻找最大元素，首先设置临时最大值等于列表中的起始项。然后在一次比较 \\(i \\leqslant n\\) 后判断还未到达列表的结尾，临时最大值与第二项比较，如果第二项大，就用第二项的值更新临时最大值。这一过程继续下去，对列表中的每一项都进行两次比较：一次 \\(i \\leqslant n\\) 判断是否未到达列表结尾，另一次 \\(\\max < a_i\\) 判断是否需要更新临时最大值。由于对从第二个到第 \\(n\\) 个元素的每一个都用两次比较，再加上一次在 \\(i = n + 1\\) 时退出循环的比较，所以当使用该算法时恰好需要 \\(2(n - 1) + 1 = 2n - 1\\) 次比较。因此，在一个 \\(n\\) 元素的集合中寻找最大值算法的时间复杂度用算法使用的比较次数来度量时为 \\(\\Theta(n)\\) 。注意对该算法而言比较的次数和特定的 \\(n\\) 个输入无关。"
        },
        {
            "type": "text",
            "bbox": [
                0.162,
                0.782,
                0.501,
                0.797
            ],
            "angle": 0,
            "content": "下面我们分析搜索算法的时间复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.159,
                0.803,
                0.713,
                0.82
            ],
            "angle": 0,
            "content": "例2 描述线性搜索算法(3.1节算法2所描述)的时间复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.825,
                0.967,
                0.937
            ],
            "angle": 0,
            "content": "解3.1节算法2所使用的比较次数将用来度量时间复杂度。该算法中循环的每一步都要做两次比较——一次 \\(i \\leqslant n\\) 判断是否已到达列表的结尾，一次 \\(x \\leqslant a_{i}\\) 比较元素 \\(x\\) 和列表中的一项。最后，还要在循环外再做一次 \\(i \\leqslant n\\) 比较。因此，如果 \\(x = a_{i}\\)，则最多需要做 \\(2i + 1\\) 次比较。当元素不在列表中时，最多需要 \\(2n + 2\\) 次比较。在这种情况下，\\(2n\\) 次比较用来判定 \\(x\\) 不是 \\(a_{i}\\)，\\(i = 1, 2, \\dots, n\\)，再加上一次比较用于退出循环和一次循环外的比较。所以当 \\(x\\) 不在列表中时，共需用 \\(2n + 2\\) 次比较。从而，在最坏情况下线性搜索需要 \\(\\Theta(n)\\) 次比较，因为 \\(2n + 2\\) 是 \\(\\Theta(n)\\) 的。"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.041,
                0.585,
                0.102,
                0.602
            ],
            "angle": 0,
            "content": "Extra Examples"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.685,
                0.038,
                0.772,
                0.053
            ],
            "angle": 0,
            "content": "算法"
        },
        {
            "type": "page_number",
            "bbox": [
                0.82,
                0.039,
                0.856,
                0.053
            ],
            "angle": 0,
            "content": "197"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.095,
                0.886,
                0.15
            ],
            "angle": 0,
            "content": "最坏情形复杂度 例2中做的这类复杂度分析是最坏情形分析。所谓一个算法的最坏情形性能，指的是该算法用于具有一定输入规模的问题时所需要的最多的运算次数。最坏情形分析告诉我们一个算法需要多少次运算就能保证给出问题的解答。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.154,
                0.887,
                0.194
            ],
            "angle": 0,
            "content": "例3 以所需的比较次数来描述二分搜索算法(3.1节算法3所描述)的时间复杂度（忽略算法循环中每次迭代计算 \\(m = \\lfloor (i + j) / 2\\rfloor\\) 所需的时间）。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.197,
                0.887,
                0.253
            ],
            "angle": 0,
            "content": "解为简化描述，假定列表 \\(a_1, a_2, \\dots, a_n\\) 中有 \\(n = 2^k\\) 个元素，其中 \\(k\\) 是非负整数。注意 \\(k = \\log n\\)。（如果列表中元素个数 \\(n\\) 不是 2 的幂次，那么该列表可以看作一个有 \\(2^{k+1}\\) 个元素的大列表的一部分，其中 \\(2^k < n < 2^{k+1}\\)。这里 \\(2^{k+1}\\) 是大于 \\(n\\) 的 2 的最小幂次。）"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.255,
                0.887,
                0.311
            ],
            "angle": 0,
            "content": "在算法的每一阶段，都要比较 \\(i\\) 和 \\(j\\) （分别是当前待搜索列表的第一项和最后项的位置）来判断待搜索列表是否包含一个以上的元素。如果 \\(i < j\\) ，则要做一次比较来判断 \\(x\\) 是否大于待搜索列表的中间元素。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.313,
                0.887,
                0.427
            ],
            "angle": 0,
            "content": "在第一阶段搜索限于含 \\(2^{k-1}\\) 个元素的列表。至此已使用了两次比较。这一过程继续下去，每一阶段都用两次比较把搜索限制在长度减半的列表中。换言之，在算法的第一阶段当列表中含 \\(2^{k}\\) 个元素时使用两次，当搜索限于含有 \\(2^{k-1}\\) 个元素的列表时再用两次比较，当搜索限于含有 \\(2^{k-2}\\) 个元素的列表时再用两次比较，等等，直到搜索局限于含有 \\(2^{1}=2\\) 个元素的列表时使用两次比较。最后，当列表中只剩一个元素时，一次比较告诉我们列表中没有其他元素，再一次比较用于判断这一项是否为 \\(x\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.429,
                0.887,
                0.542
            ],
            "angle": 0,
            "content": "因此，当待搜索列表中有 \\(2^{k}\\) 个元素时，执行一次二分搜索最多需要 \\(2k + 2 = 2\\log n + 2\\) 次比较。（如果 \\(n\\) 不是2的幂次，原始的列表可以扩展为含 \\(2^{k + 1}\\) 个项的列表，其中 \\(k = \\lfloor \\log n\\rfloor\\) ，而搜索最多需要最多 \\(2\\lfloor \\log n\\rfloor +2\\) 次比较。）因此可以得出在最坏情形下二分搜索需要 \\(O(\\log n)\\) 次比较。注意在最坏情形下二分搜索需要用到 \\(2\\log n + 2\\) 次比较。故二分搜索在最坏情形下需要\\(\\Theta (\\log n)\\) 次比较，因为 \\(2\\log n + 2 = \\Theta (\\log n)\\) 。由此分析可知在最坏的情况下，二分搜索算法比线性搜索效率高，因为由例2我们知道线性搜索算法最坏情形的时间复杂度是 \\(\\Theta (n)\\) □"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.543,
                0.887,
                0.619
            ],
            "angle": 0,
            "content": "平均情形复杂度 除最坏情形分析以外，还有另一类重要的复杂度分析称为平均情形分析。在这类分析中就是要找出求解针对一定规模的问题的所有可能的输入所用到的运算的平均数。平均情形时间复杂度分析一般比最坏情形分析复杂得多。不过，线性搜索算法的平均情形分析不难完成，如例4所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.623,
                0.892,
                0.663
            ],
            "angle": 0,
            "content": "例4 以用到的平均比较次数来描述线性搜索算法的平均情形执行性能，假定元素 \\(x\\) 在列表中并且 \\(x\\) 出现在任何位置的可能性相等。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.665,
                0.894,
                0.759
            ],
            "angle": 0,
            "content": "解 由假设整数 \\(x\\) 是列表中的整数 \\(a_{1}, a_{2}, \\cdots, a_{n}\\) 之一。如果 \\(x\\) 是列表的第一项 \\(a_{1}\\)，需要3次比较：一次 \\(i \\leqslant n\\) 判断是否已到列表结尾，一次 \\(x \\neq a_{i}\\) 比较 \\(x\\) 和第一项，再一次在循环外的比较 \\(i \\leqslant n\\)。如果 \\(x\\) 是列表的第二项 \\(a_{2}\\)，再需要2次比较，所以总共要5次比较。一般来说，如果 \\(x\\) 是列表的第 \\(i\\) 项 \\(a_{i}\\)，第 \\(i\\) 次循环的每一次都要做2次比较，外加循环外一次，所以共需要\\(2i + 1\\) 次比较。故，用到的平均比较次数等于："
        },
        {
            "type": "equation",
            "bbox": [
                0.221,
                0.762,
                0.721,
                0.793
            ],
            "angle": 0,
            "content": "\\[\n\\frac {3 + 5 + 7 + \\cdots + (2 n + 1)}{n} = \\frac {2 (1 + 2 + 3 + \\cdots + n) + n}{n}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.796,
                0.528,
                0.813
            ],
            "angle": 0,
            "content": "用2.4节表2中第二行的公式（参见2.4节练习37b），"
        },
        {
            "type": "equation",
            "bbox": [
                0.331,
                0.817,
                0.611,
                0.845
            ],
            "angle": 0,
            "content": "\\[\n1 + 2 + 3 + \\dots + n = \\frac {n (n + 1)}{2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.85,
                0.65,
                0.867
            ],
            "angle": 0,
            "content": "所以，线性搜索算法使用的平均比较次数（当已知 \\(x\\) 在列表中时）是"
        },
        {
            "type": "equation",
            "bbox": [
                0.348,
                0.869,
                0.597,
                0.9
            ],
            "angle": 0,
            "content": "\\[\n\\frac {2 [ n (n + 1) / 2 ]}{n} + 1 = n + 2\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.905,
                0.13,
                0.92
            ],
            "angle": 0,
            "content": "即 \\(\\Theta (n)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.923,
                0.897,
                0.94
            ],
            "angle": 0,
            "content": "评注 例4的分析假定 \\(x\\) 在被搜索的列表中。当 \\(x\\) 可能不在列表中时，也可以对该算法做"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.148,
                0.041,
                0.186,
                0.055
            ],
            "angle": 0,
            "content": "198"
        },
        {
            "type": "header",
            "bbox": [
                0.229,
                0.04,
                0.295,
                0.055
            ],
            "angle": 0,
            "content": "第3章"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.097,
                0.383,
                0.112
            ],
            "angle": 0,
            "content": "平均情形分析（参见练习23）。"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.116,
                0.965,
                0.15
            ],
            "angle": 0,
            "content": "评注尽管我们把判断是否到达循环结尾所需的比较也计算进来，但通常这些比较是可以不算的。从现在起我们将忽略这些比较。"
        },
        {
            "type": "text",
            "bbox": [
                0.158,
                0.153,
                0.956,
                0.169
            ],
            "angle": 0,
            "content": "两个排序算法的最坏情形复杂度 例5和例6分析冒泡排序和插入排序的最坏情形复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.158,
                0.174,
                0.741,
                0.192
            ],
            "angle": 0,
            "content": "例5 用所需比较次数来衡量冒泡排序的最坏情形复杂度是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.196,
                0.967,
                0.269
            ],
            "angle": 0,
            "content": "解 之前在3.1节例4中描述的冒泡排序通过一遍遍处理列表对该列表进行排序。在每一遍冒泡排序都连续比较相邻元素，必要时交换相邻元素。当第 \\(i\\) 遍开始时，\\(i - 1\\) 个最大的元素保证在正确位置上。在这一遍，使用了 \\(n - i\\) 次比较。因此，利用2.4节表2第二行的求和公式可得，冒泡排序对 \\(n\\) 个元素的列表进行排序时所需使用的总的比较次数是"
        },
        {
            "type": "equation",
            "bbox": [
                0.348,
                0.273,
                0.739,
                0.301
            ],
            "angle": 0,
            "content": "\\[\n(n - 1) + (n - 2) + \\dots + 2 + 1 = \\frac {(n - 1) n}{2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.306,
                0.967,
                0.361
            ],
            "angle": 0,
            "content": "注意冒泡排序总是使用这么多次的比较，因为即使在某个中间步骤列表已经完全排好了，冒泡排序仍会继续进行。因此，用比较次数来衡量时，冒泡排序使用 \\(n(n - 1) / 2\\) 次比较，所以它的最坏情形复杂度是 \\(\\Theta (n^2)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.158,
                0.366,
                0.701,
                0.383
            ],
            "angle": 0,
            "content": "例6 用比较次数来衡量插入排序的最坏情形复杂度是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.387,
                0.967,
                0.48
            ],
            "angle": 0,
            "content": "解插入排序(其描述在3.1节)把第 \\(j\\) 个元素插入到前 \\(j - 1\\) 个已排好顺序的元素中的正确位置上。插入排序用线性搜索技术来做到这一点，依次比较第 \\(j\\) 个元素与后续各项，直到找到大于或等于这个元素的一项或者比较 \\(a_{j}\\) 与它自身为止，因为 \\(a_{j}\\) 不小于它自身。于是，在最坏情形下，把第 \\(j\\) 个元素插入正确位置需要 \\(j\\) 次比较。所以，用插入排序对 \\(n\\) 个元素的列表排序时所使用总的比较次数是"
        },
        {
            "type": "equation",
            "bbox": [
                0.402,
                0.483,
                0.68,
                0.511
            ],
            "angle": 0,
            "content": "\\[\n2 + 3 + \\dots + n = \\frac {n (n + 1)}{2} - 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.516,
                0.966,
                0.57
            ],
            "angle": 0,
            "content": "以上利用了2.4节表2第二行的连续整数之和的求和公式（参见2.4节练习37b），并且注意这个和式中缺少第一项1。注意，如果较小的元素起初是在列表的尾部，则插入排序可能使用相当少的比较次数。结论是插入排序的最坏情形复杂度是 \\(\\Theta (n^2)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.572,
                0.966,
                0.627
            ],
            "angle": 0,
            "content": "在例5和例6中我们证明了冒泡排序和插入排序的最坏情形复杂度均为 \\(\\Theta (n^{2})\\) 。可是，最有效的排序算法能在 \\(O(n\\log n)\\) 时间内对 \\(n\\) 个元素进行排序，我们将用在8.3节和11.1节中的技术来证明之。从现在起我们假设对 \\(n\\) 个元素进行排序可以在 \\(O(n\\log n)\\) 时间内完成。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.63,
                0.966,
                0.703
            ],
            "angle": 0,
            "content": "你可以从很多网站上找到算法的动画演示，并能对列表同时运行不同的排序算法，进而直观地理解不同排序算法的效率。能够找到的排序算法包括冒泡排序、插入排序、希尔排序、合并排序、快速排序。有些动画演示允许你在针对随机列表、几乎已排好序的列表、倒序列表进行排序时，测试这些排序算法的相对性能。"
        },
        {
            "type": "title",
            "bbox": [
                0.118,
                0.714,
                0.381,
                0.73
            ],
            "angle": 0,
            "content": "3.3.3 矩阵乘法的复杂度"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.733,
                0.966,
                0.77
            ],
            "angle": 0,
            "content": "两个矩阵乘积的定义可以表达为计算两个矩阵乘积的算法。假定 \\(m \\times n\\) 矩阵 \\(\\mathbf{C} = [c_{ij}]\\) 是 \\(m \\times k\\) 矩阵 \\(\\mathbf{A} = [a_{ij}]\\) 和 \\(k \\times n\\) 矩阵 \\(\\mathbf{B} = [b_{ij}]\\) 的乘积。算法1是用伪代码表示的矩阵乘积算法。"
        },
        {
            "type": "title",
            "bbox": [
                0.131,
                0.787,
                0.28,
                0.803
            ],
            "angle": 0,
            "content": "算法1 矩阵乘法"
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.806,
                0.492,
                0.821
            ],
            "angle": 0,
            "content": "procedure matrix multiplication(A, B: 矩阵)"
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.824,
                0.256,
                0.837
            ],
            "angle": 0,
            "content": "for \\(i\\coloneqq 1\\) to \\(m\\)"
        },
        {
            "type": "equation",
            "bbox": [
                0.171,
                0.842,
                0.292,
                0.855
            ],
            "angle": 0,
            "content": "\\[\nf o r j := 1 t o n\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.212,
                0.86,
                0.273,
                0.873
            ],
            "angle": 0,
            "content": "\\[\nc _ {i j} := 0\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.212,
                0.878,
                0.333,
                0.891
            ],
            "angle": 0,
            "content": "\\[\n\\text {f o r} q := 1 \\text {t o} k\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.254,
                0.896,
                0.378,
                0.909
            ],
            "angle": 0,
            "content": "\\[\nc _ {i j} := c _ {i j} + a _ {i q} b _ {q j}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.913,
                0.415,
                0.927
            ],
            "angle": 0,
            "content": "return \\(C\\{C = [c_{ij}]\\) 是 \\(\\mathbf{A}\\) 和 \\(\\pmb{B}\\) 的乘积"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.681,
                0.041,
                0.77,
                0.057
            ],
            "angle": 0,
            "content": "算法"
        },
        {
            "type": "page_number",
            "bbox": [
                0.817,
                0.043,
                0.851,
                0.056
            ],
            "angle": 0,
            "content": "199"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.098,
                0.701,
                0.115
            ],
            "angle": 0,
            "content": "我们可以用算法中使用的加法和乘法的次数来确定这一算法的复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.12,
                0.829,
                0.137
            ],
            "angle": 0,
            "content": "例7用算法1计算两个 \\(n\\times n\\) 整数矩阵的乘积需要用到多少次整数加法和整数乘法？"
        },
        {
            "type": "text",
            "bbox": [
                0.035,
                0.142,
                0.877,
                0.176
            ],
            "angle": 0,
            "content": "解 在 \\(\\mathbf{A}\\) 和 \\(\\pmb{B}\\) 的乘积中有 \\(n^2\\) 个元素。计算每个元素要做 \\(n\\) 次乘法和 \\(n - 1\\) 次加法。所以，一共需要 \\(n^3\\) 次乘法和 \\(n^2 (n - 1)\\) 次加法。"
        },
        {
            "type": "text",
            "bbox": [
                0.034,
                0.18,
                0.879,
                0.233
            ],
            "angle": 0,
            "content": "令人吃惊的是，有比算法1效率高的矩阵乘法算法。例7说明直接根据定义计算两个 \\(n \\times n\\) 矩阵的乘积需要 \\(O(n^{3})\\) 次乘法和加法。而用其他算法计算两个 \\(n \\times n\\) 矩阵的乘积只需 \\(O(n^{\\sqrt{7}})\\) 次乘法和加法。（在[CoLeRiSt09]中可找到这种算法的细节。）"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.236,
                0.802,
                0.254
            ],
            "angle": 0,
            "content": "我们也可以分析第2章描述的计算两个矩阵布尔积的算法复杂度，如算法2所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.272,
                0.262,
                0.287
            ],
            "angle": 0,
            "content": "算法2 0-1矩阵的布尔积"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.29,
                0.576,
                0.306
            ],
            "angle": 0,
            "content": "procedure Boolean product of Zero-One Matrices \\((A, B:0-1\\) 矩阵）"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.308,
                0.171,
                0.322
            ],
            "angle": 0,
            "content": "for \\(i\\coloneqq 1\\) to \\(m\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.327,
                0.206,
                0.34
            ],
            "angle": 0,
            "content": "for \\(j\\coloneqq 1\\) to \\(n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.345,
                0.186,
                0.358
            ],
            "angle": 0,
            "content": "\\(c_{ij}:= 0\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.363,
                0.246,
                0.376
            ],
            "angle": 0,
            "content": "for \\(q\\coloneqq 1\\) to \\(k\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.168,
                0.381,
                0.329,
                0.394
            ],
            "angle": 0,
            "content": "\\(c_{ij} := c_{ij} \\vee (a_{iq} \\wedge b_{qi})\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.398,
                0.347,
                0.412
            ],
            "angle": 0,
            "content": "return \\(C\\{C = [c_{ij}]\\) 是 \\(\\mathbf{A}\\) 和 \\(\\pmb{B}\\) 的布尔积}"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.432,
                0.646,
                0.448
            ],
            "angle": 0,
            "content": "很容易确定计算两个 \\(n \\times n\\) 矩阵的布尔积所需要的比特运算次数。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.454,
                0.744,
                0.47
            ],
            "angle": 0,
            "content": "例8 计算 \\(A \\odot B\\) 需要做多少次比特运算，其中 \\(A\\) 和 \\(B\\) 为 \\(n \\times n\\) 阶0-1矩阵？"
        },
        {
            "type": "text",
            "bbox": [
                0.032,
                0.476,
                0.876,
                0.511
            ],
            "angle": 0,
            "content": "解 \\(A\\odot B\\) 中有 \\(n^2\\) 个元素。用算法2，需要 \\(n\\) 次 \\(\\vee\\) 和 \\(n\\) 次 \\(\\wedge\\) 来计算 \\(A\\odot B\\) 的一个元素。因此，每求一个元素需要 \\(2n\\) 次比特运算。所以，用算法2计算 \\(A\\odot B\\) 需要 \\(2n^{3}\\) 次比特运算。"
        },
        {
            "type": "text",
            "bbox": [
                0.03,
                0.514,
                0.877,
                0.606
            ],
            "angle": 0,
            "content": "矩阵链乘法 涉及矩阵乘法复杂度的还有另一个重要问题。怎样用最少的整数乘法来计算矩阵链 \\(A_{1}A_{2}\\dots A_{n}\\)，其中 \\(A_{1}, A_{2}, \\dots, A_{n}\\) 分别为 \\(m_{1} \\times m_{2}, m_{2} \\times m_{3}, \\dots, m_{n} \\times m_{n+1}\\) 阶的整数矩阵。（因为矩阵乘法是可结合的，如 2.6 节练习 13 所示，所以计算乘法的次序不影响乘积。）注意，用算法 1 把一个 \\(m_{1} \\times m_{2}\\) 矩阵和一个 \\(m_{2} \\times m_{3}\\) 矩阵相乘时需要做 \\(m_{1}m_{2}m_{3}\\) 次整数乘法。例 9 解释该问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.03,
                0.611,
                0.876,
                0.649
            ],
            "angle": 0,
            "content": "例9 \\(A_{1}, A_{2}\\) 和 \\(A_{3}\\) 分别是 \\(30 \\times 20\\)、\\(20 \\times 40\\) 及 \\(40 \\times 10\\) 的整数矩阵，应该用什么次序计算 \\(A_{1}, A_{2}\\) 和 \\(A_{3}\\) 的乘积使得所用的整数乘法次数最少？"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.652,
                0.637,
                0.668
            ],
            "angle": 0,
            "content": "解 有两种方法计算 \\(A_{1}A_{2}A_{3}\\) 的次序，即 \\(A_{1}(A_{2}A_{3})\\) 和 \\((A_{1}A_{2})A_{3}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.032,
                0.671,
                0.876,
                0.706
            ],
            "angle": 0,
            "content": "如果 \\(A_{2}\\) 和 \\(A_{3}\\) 首先相乘，需要做 \\(20 \\cdot 40 \\cdot 10 = 8000\\) 次整数乘法来计算 \\(20 \\times 10\\) 矩阵 \\(A_{2}A_{3}\\)。然后，计算 \\(A_{1}\\) 和 \\(A_{2}A_{3}\\) 的乘积需要 \\(30 \\cdot 20 \\cdot 10 = 6000\\) 次乘法。因此，总共需要使用"
        },
        {
            "type": "equation",
            "bbox": [
                0.354,
                0.709,
                0.551,
                0.724
            ],
            "angle": 0,
            "content": "\\[\n8 0 0 0 + 6 0 0 0 = 1 4 0 0 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.03,
                0.727,
                0.876,
                0.781
            ],
            "angle": 0,
            "content": "次乘法。另一方面，如果 \\(A_{1}\\) 和 \\(A_{2}\\) 首先相乘，需要做 \\(30 \\times 20 \\times 40 = 24000\\) 次乘法来计算 \\(30 \\times 40\\) 矩阵 \\(A_{1}A_{2}\\) 。然后，计算 \\(A_{1}A_{2}\\) 和 \\(A_{3}\\) 的乘积需要 \\(30 \\times 40 \\times 10 = 12000\\) 次乘法。因此，总共需要使用"
        },
        {
            "type": "equation",
            "bbox": [
                0.339,
                0.785,
                0.566,
                0.8
            ],
            "angle": 0,
            "content": "\\[\n2 4 0 0 0 + 1 2 0 0 0 = 3 6 0 0 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.032,
                0.803,
                0.102,
                0.818
            ],
            "angle": 0,
            "content": "次乘法。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.822,
                0.348,
                0.838
            ],
            "angle": 0,
            "content": "显然，第一种计算顺序更有效。"
        },
        {
            "type": "text",
            "bbox": [
                0.03,
                0.841,
                0.876,
                0.876
            ],
            "angle": 0,
            "content": "我们将在8.1节练习57再回到这个问题。[CoLeRiSt09]中讨论了确定计算矩阵链相乘最有效方式的算法。"
        },
        {
            "type": "title",
            "bbox": [
                0.03,
                0.887,
                0.199,
                0.904
            ],
            "angle": 0,
            "content": "3.3.4 算法范型"
        },
        {
            "type": "text",
            "bbox": [
                0.03,
                0.907,
                0.876,
                0.943
            ],
            "angle": 0,
            "content": "3.1节介绍了算法的基本概念。我们给出了许多不同算法的例子，包括搜索和排序算法。我们也介绍了贪婪算法的概念，给出了可以用贪婪算法求解的一些例子。贪婪算法就是一种算"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.889,
                0.516,
                0.929,
                0.53
            ],
            "angle": 0,
            "content": "Links"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.141,
                0.044,
                0.178,
                0.057
            ],
            "angle": 0,
            "content": "200"
        },
        {
            "type": "header",
            "bbox": [
                0.223,
                0.043,
                0.288,
                0.057
            ],
            "angle": 0,
            "content": "第3章"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.099,
                0.96,
                0.135
            ],
            "angle": 0,
            "content": "法范型（algorithmic paradigm）的示例，所谓算法范型就是基于一种特定概念的通用方法，可以用来构造求解一类广泛问题的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.137,
                0.96,
                0.174
            ],
            "angle": 0,
            "content": "本书中我们会基于不同的算法范型——包括最常用的算法范型来构造求解许多不同问题的算法。可以将这些范型作为基础用来构造解决一类广泛问题的有效算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.176,
                0.962,
                0.25
            ],
            "angle": 0,
            "content": "我们已经学过的一些算法就是基于一种本小节要描述的称为蛮力的算法范型。本书后续要学习的算法范型包括第8章的分而治之算法和动态规划、第10章的回溯，以及第7章的随机算法。除了本书描述的以外还有许多重要的算法范型。想了解更多请参考算法设计书籍，如[KlTa06]。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.253,
                0.962,
                0.347
            ],
            "angle": 0,
            "content": "蛮力算法 蛮力是一个基本的但又重要的算法范型。在蛮力算法（brute-force algorithm）中，问题是通过基于对问题的描述和术语的定义以最直接的方式解决的。设计蛮力算法来解决那些不太在意所需计算资源的问题。例如，在某些蛮力算法中，一个问题的求解是通过检查每一种可能的解，然后找出最可能的解。一般情况下，蛮力算法是朴素的问题求解方法，而不需要利用问题的任何特殊结构或聪明的点子。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.349,
                0.964,
                0.444
            ],
            "angle": 0,
            "content": "注意3.1节寻找一个序列中的最大元素的算法1就是一个蛮力算法，因为它检查序列的 \\(n\\) 个元素的每一个以找到最大项。通过每次加一个数来寻找 \\(n\\) 个数之和的算法也是蛮力算法，还有基于定义的矩阵乘法算法（算法1）。冒泡排序、插入排序、选择排序（分别在3.1节算法4和算法5以及练习43的前导文中描述的）也可以认为是蛮力算法，所有这三个排序算法都是最直接的方法，其效率也远比第5章和第8章要讨论的合并排序和快速排序这类排序算法低。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.445,
                0.967,
                0.52
            ],
            "angle": 0,
            "content": "虽然蛮力算法通常比较低效，但通常却非常有用。蛮力算法是能够解决实际问题的，特别是当输入规模不是很大时，即使对于大规模的输入会变得不切实际。再者，当设计新算法来解决一个问题时，目标通常是寻找一个比蛮力算法更有效的算法。这类问题的一个实例如例10所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.525,
                0.966,
                0.564
            ],
            "angle": 0,
            "content": "例10构造一个蛮力算法，寻找平面上 \\(n\\) 个点的集合中的最近点对（closest pair of points），并给出最坏情形下算法用到的位运算次数的大 \\(O\\) 估算。"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.567,
                0.967,
                0.667
            ],
            "angle": 0,
            "content": "解 假设给定输入点 \\((x_{1}, y_{1})\\)，\\((x_{2}, y_{2})\\)，…，\\((x_{n}, y_{n})\\)。回顾一下，\\((x_{i}, y_{i})\\) 和 \\((x_{j}, y_{j})\\) 之间的距离是 \\(\\sqrt{(x_{j} - x_{i})^{2} + (y_{j} - y_{i})^{2}}\\)。寻找这些点的最近点对的蛮力算法可以通过计算 \\(n\\) 个点的所有点对的距离然后确定最小距离来实现。（我们可以做一个简化使得计算变得更容易一些，我们计算点对之间距离的平方而非距离来寻找最近的点对。之所以可以这样做是因为点对之间的距离最小时该点对之间距离的平方也是最小的。）"
        },
        {
            "type": "code_caption",
            "bbox": [
                0.135,
                0.685,
                0.414,
                0.701
            ],
            "angle": 0,
            "content": "算法3 寻找最近点对的蛮力算法"
        },
        {
            "type": "code",
            "bbox": [
                0.134,
                0.704,
                0.692,
                0.848
            ],
            "angle": 0,
            "content": "procedure closest-pair((x1，y1)，(x2，y2)，…，(xn，yn)：实数对）  \nmin=∞  \nfor \\(i:=2\\) to n  \n    for \\(j:=1\\) to i-1  \n        if \\((x_{j} - x_{i})^{2} + (y_{j} - y_{i})^{2} < \\min\\) then  \n            min := (xj - xi)^2 + (yj - yi)^2  \n        closest pair := ((xi，yi)，(xj，yj))  \nreturn closest pair"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.866,
                0.971,
                0.942
            ],
            "angle": 0,
            "content": "要估算算法用到的操作步数，首先注意循环要经过 \\(n(n - 1) / 2\\) 个点对 \\(((x_i, y_i), (x_j, y_j))\\)（读者可以自行验证）。对于每个这样的点对，计算 \\((x_j - x_i)^2 + (y_j - y_i)^2\\)，与 \\(\\min\\) 的当前值比较，如果它小于 \\(\\min\\) 就用这个新值替换 \\(\\min\\) 的当前值。按算术运算和比较的次数来衡量，可以得出该算法使用 \\(\\Theta(n^2)\\) 次操作。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.701,
                0.04,
                0.79,
                0.056
            ],
            "angle": 0,
            "content": "算法"
        },
        {
            "type": "page_number",
            "bbox": [
                0.835,
                0.042,
                0.87,
                0.055
            ],
            "angle": 0,
            "content": "201"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.096,
                0.9,
                0.133
            ],
            "angle": 0,
            "content": "第8章将推导一个确定最近点对的算法，在给定平面中 \\(n\\) 个点作为输入时，其最坏情形复杂度为 \\(O(n\\log n)\\) 。最初发现这样一个效率远高于蛮力方法的算法被认为是相当称奇的。"
        },
        {
            "type": "title",
            "bbox": [
                0.057,
                0.143,
                0.316,
                0.16
            ],
            "angle": 0,
            "content": "3.3.5 理解算法的复杂度"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.163,
                0.905,
                0.296
            ],
            "angle": 0,
            "content": "表1中给出了描述算法时间复杂度的几个常用术语。例如，一个求 \\(n\\) 个元素列表前100项中最大项的算法可以通过对前100项的序列应用算法1得到，其中 \\(n\\) 是满足 \\(n \\geqslant 100\\) 的整数，具有常量复杂度(constant complexity)，因为无论 \\(n\\) 是什么值，这个算法都使用99次比较（读者可以验证）。线性搜索算法具有线性(linear)(最坏情形或平均情形)复杂度，而二分搜索算法具有对数(logarithmic)(最坏情形)复杂度。许多重要的算法都具有 \\(n \\log n\\) 或者线性对数(linearithmetic)(最坏情形)复杂度，例如将在第4章学习的归并排序。（线性对数(linearithmetic)是词语线性(linear)和对数(logarithmic)的复合词。）"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.368,
                0.306,
                0.59,
                0.321
            ],
            "angle": 0,
            "content": "表 1 算法复杂度常用术语"
        },
        {
            "type": "table",
            "bbox": [
                0.058,
                0.322,
                0.905,
                0.434
            ],
            "angle": 0,
            "content": "<table><tr><td>复杂度</td><td>术语</td><td>复杂度</td><td>术语</td></tr><tr><td>Θ(1)</td><td>常量复杂度</td><td>Θ(nb)</td><td>多项式复杂度</td></tr><tr><td>Θ(log n)</td><td>对数复杂度</td><td>Θ(bn), b&gt;1</td><td>指数复杂度</td></tr><tr><td>Θ(n)</td><td>线性复杂度</td><td>Θ(n!)</td><td>阶乘复杂度</td></tr><tr><td>Θ(n log n)</td><td>线性对数复杂度</td><td></td><td></td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.447,
                0.906,
                0.579
            ],
            "angle": 0,
            "content": "一个算法具有多项式复杂度（polynomial complexity）如果它的复杂度是 \\(\\Theta(n^{b})\\)，其中 \\(b\\) 是满足 \\(b \\geq 1\\) 的整数。例如，冒泡排序算法是多项式时间算法，因为它在最坏情形下使用 \\(\\Theta(n^{2})\\) 次比较。一个算法有指数复杂度（exponential complexity）如果它的时间复杂度为 \\(\\Theta(b^{n})\\)，其中 \\(b > 1\\)。通过检查变量的所有可能的真值赋值来判定 \\(n\\) 个变量的复合命题是否是可满足的算法是一个指数复杂度算法，因为它用 \\(\\Theta(2^{n})\\) 次运算。最后，一个算法具有阶乘复杂度（factorial complexity）如果它的时间复杂度是 \\(\\Theta(n!)\\)。寻找一个推销员可以用来访问 \\(n\\) 个城市的所有顺序的算法具有阶乘复杂度，我们将在第 9 章讨论这个算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.581,
                0.906,
                0.694
            ],
            "angle": 0,
            "content": "易解性（tractability）一个能用多项式最坏情形复杂度（或更优）的算法求解的问题称为易解的（tractable），因为针对问题在合理规模的输入下，可期望算法在相对短的时间内给出解答。不过，如果在大 \\(\\Theta\\) 估算中的多项式次数过高（如100次）或者如果多项式的系数非常大，则算法都可能会花特别长的时间来解题。所以，一个能用多项式最坏情形复杂度的算法来解决的问题也不能保证能在合理时间内得到解答，即使是对于相对较小的输入值。幸运的是，实践中这种估算中用到的多项式的次数和系数都不大。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.696,
                0.906,
                0.847
            ],
            "angle": 0,
            "content": "对于那些不能用最坏情形多项式时间复杂度的算法解决的问题情况要糟得多。这种问题称为难解的(intractable)。虽然并不总是，但通常即使对于小规模的输入在最坏情形下也需要特别大量的时间来解决问题。不过，实践中会有这样的情形，具有某种最坏情形时间复杂度的算法在大多数情况下都能够比在最坏情形下更快地解决问题。如果允许少量情况下问题不能在合理的时间内得到解答，那么平均情形时间复杂度就是对算法解题所需时间的一个更好的度量方式。业界许多重要的问题都被认为是难解的，但在实践中对于日常生活中出现的所有输入基本上都能得到解决。另一种处理实践中出现的难解问题的方法是寻求问题的近似解而非精确解。也许存在求近似解的快速算法，甚至还能保证这些近似解和精确解相差不太大。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.849,
                0.909,
                0.943
            ],
            "angle": 0,
            "content": "甚至存在这样一些问题，可以被证明是没有算法能够求解它们的。这种问题称为不可解的（unsolvable）（相对于可以用一个算法求解的可解的（solvable）问题而言）。第一个证明存在不可解问题的是伟大的英国数学家和计算机科学家阿兰·图灵（Alan Turing），当时他证明了停机问题是不可解的。我们在3.1节证明了停机问题是不可解的。（在第13章有图灵小传以及对他在某些其他方面的工作介绍。）"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.145,
                0.049,
                0.183,
                0.064
            ],
            "angle": 0,
            "content": "202"
        },
        {
            "type": "header",
            "bbox": [
                0.227,
                0.048,
                0.292,
                0.064
            ],
            "angle": 0,
            "content": "第3章"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.06,
                0.242,
                0.102,
                0.258
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.06,
                0.396,
                0.102,
                0.412
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.069,
                0.452,
                0.102,
                0.478
            ],
            "angle": 0,
            "content": "?"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.105,
                0.965,
                0.237
            ],
            "angle": 0,
            "content": "P与NP算法复杂度的研究远超出这里所能介绍的。可是，注意人们相信许多可解的问题具有这样的性质，即没有多项式最坏情形时间复杂度的算法能求解，但是一旦有了一个解答，却可以用多项式时间内来验证。能以多项式时间内验证解的问题称为属于NP类（易解的问题属于P类)。缩写NP是指非确定性多项式(nondeterministic polynomial)时间。3.1节讨论的可满足性问题就是一个NP问题的例子——可以快速地验证复合命题的一组变量的真值赋值让这个命题成真，但是至今没有发现找出这种真值赋值的多项式时间算法。（例如，穷举搜索所有可能的真值赋值需要 \\(\\Omega (2^{n})\\) 次位运算，其中 \\(n\\) 是复合命题的变量数。）"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.24,
                0.964,
                0.391
            ],
            "angle": 0,
            "content": "还有一类重要的问题，称为 NP 完全问题（NP-complete problem），具有这样的性质即只要其中任何一个问题能用一个多项式时间最坏情形算法来求解，那么 NP 类的所有问题都能用多项式时间最坏情形算法来求解。可满足性问题也是 NP 完全问题的一个例子。它是一个 NP 问题，并且如果知道了一个求解它的多项式时间算法，那么所有已知在该问题类中的所有问题就都有多项式时间算法（在这个类中有许多重要问题）。最后这个叙述基于这样一个事实，即 NP 中的每个问题可在多项式时间内归约为可满足性问题。尽管已经发现有 3000 多个 NP 完全问题了，但可满足性问题是第一个被证明是 NP 完全的问题。Stephen Cook 和 Leonid Levin 在 20 世纪 70 年代独立证明了该结论，因而阐述该结论的定理称为是 Cook-Levin 定理。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.394,
                0.963,
                0.583
            ],
            "angle": 0,
            "content": "P与NP问题(P versus NP problem)是问NP(有可能在多项式时间内检验其解的一类问题)是否等于P(一类易解的问题)。如果 \\(\\mathrm{P} \\neq \\mathrm{NP}\\), 则存在这样一些不能在多项式时间内求解但其解可以在多项式时间内验证的问题。NP完全性的概念有助于研究解决P与NP问题, 因为NP完全问题是那些在NP类中被认为最不可能是P类中的问题, 由于NP中的每个问题可以在多项式时间内归约为一个NP完全问题。绝大多数理论计算机科学家相信 \\(\\mathrm{P} \\neq \\mathrm{NP}\\), 这意味着没有NP完全问题能在多项式时间内解决。该信念的一个理由是尽管做了广泛的研究, 但没有人成功地证明 \\(\\mathrm{P} = \\mathrm{NP}\\) 。特别是, 没有人找到一个最坏情形多项式时间复杂度的算法能够解决任何NP完全问题。P与NP问题是数学科学(包括理论计算机科学)中最著名的悬而未决的问题之一。它是7个著名的千禧年大奖问题之一, 其中6个依然未解。克雷数学研究所提供100万美元奖金悬赏求解该问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.586,
                0.961,
                0.622
            ],
            "angle": 0,
            "content": "要更多了解算法复杂度的信息，参阅本书最后为本节列出的文献，包括[CoLeRiSt09]。（另外，关于以图灵机来定义的计算复杂度的正式讨论可参见13.5节。）"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.625,
                0.961,
                0.642
            ],
            "angle": 0,
            "content": "实际的考虑注意一个算法时间复杂度的大 \\(\\Theta\\) 估算表达了解题所需要的时间如何随输入规"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.115,
                0.648,
                0.184,
                0.671
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.116,
                0.684,
                0.256,
                0.792
            ],
            "angle": 0,
            "content": "#"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.116,
                0.796,
                0.265,
                0.807
            ],
            "angle": 0,
            "content": "Courtesy of Dr. Stephen Cook"
        },
        {
            "type": "text",
            "bbox": [
                0.274,
                0.683,
                0.962,
                0.752
            ],
            "angle": 0,
            "content": "斯蒂芬·库克(Stephen Cook，1939—）库克出生在布法罗，他的父亲是一名工业化学家并教授大学课程。他的母亲在一所社区学院教授英语课程。在高中时，他曾和当地一位发明了第一个植入式心脏起搏器的著名发明家一起工作，并从此对电子产品产生了极大兴趣。"
        },
        {
            "type": "text",
            "bbox": [
                0.273,
                0.754,
                0.961,
                0.823
            ],
            "angle": 0,
            "content": "库克在密歇根大学主修数学专业，1961年毕业。之后在哈佛大学读研究生，并在1962年获得硕士学位，1966年获得博士学位。1966年库克被任命为加州大学伯克利分校数学系的助理教授。他没有被聘为终身教职可能是因为数学系教员对他的工作没有太大的兴趣，而他的工作现在被认为是理论计算机科学最重要的领域之一。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.825,
                0.961,
                0.857
            ],
            "angle": 0,
            "content": "1970年他加入了多伦多大学，任计算机科学系和数学系的助理教授。他一直在多伦多大学工作，1985年被任命为教授。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.861,
                0.961,
                0.911
            ],
            "angle": 0,
            "content": "库克被认为是计算复杂度理论的创始人之一。1971年他的论文“定理证明过程的复杂度”（The Complexity of Theorem Proving Procedures）形式化了NP完全和多项式时间简化的概念，通过证明可满足性问题就是这样一个NP完全问题从而证明了NP完全问题的存在性，并引入了P与NP问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.913,
                0.961,
                0.946
            ],
            "angle": 0,
            "content": "库克获得过许多奖项，包括1982年的图灵奖。他已婚并有两个儿子。他的业余爱好包括演奏小提琴和参加帆船比赛。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.695,
                0.038,
                0.785,
                0.053
            ],
            "angle": 0,
            "content": "算法"
        },
        {
            "type": "page_number",
            "bbox": [
                0.832,
                0.039,
                0.867,
                0.052
            ],
            "angle": 0,
            "content": "203"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.093,
                0.897,
                0.264
            ],
            "angle": 0,
            "content": "模的增长而增长。在实践中使用被证明是最好的估算（即参照函数最小）。不过，时间复杂度的大 \\(\\Theta\\) 估算不能直接翻译成计算机实际使用的时间量。一个原因是大 \\(\\Theta\\) 估算 \\(f(n)\\) 是 \\(\\Theta(g(n))\\) 的，这里 \\(f(n)\\) 是算法的时间复杂度而 \\(g(n)\\) 是参照函数，意味着存在常数 \\(C_1\\)、\\(C_2\\) 和 \\(k\\) 使得当 \\(n > k\\) 时有 \\(C_1 g(n) \\leqslant f(n) \\leqslant C_2 g(n)\\)。所以在不知道不等式中的常数 \\(C_1\\)、\\(C_2\\) 和 \\(k\\) 时，就不能用这一估算来判定最坏情形下所使用的运算次数的上界和下界。正如前文说过，一次运算所需要的时间还取决于运算类型和使用的计算机。通常，算法的最坏情形时间复杂度只采用大 \\(O\\) 估算，而不是大 \\(\\Theta\\) 估算。注意算法时间复杂度的大 \\(O\\) 估算只能对算法在最坏情形所需时间以输入值规模的函数的形式提供上界，而不提供下界。尽管如此，为了简单起见，我们在讨论算法时间复杂度时经常会用大 \\(O\\) 估算，同时要懂得大 \\(\\Theta\\) 估算能提供更多的信息。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.265,
                0.897,
                0.398
            ],
            "angle": 0,
            "content": "表2给出用算法求解各种输入规模问题所需的时间，这里用位运算的位数 \\( n \\) 表示，并假定每次位运算需要的时间是 \\( 10^{-11} \\) 秒，这是以2018年最快的计算机做位运算所需时间的一种合理估算。需要的时间超过 \\( 10^{100} \\) 年的在表中用星号表示。将来，这些时间会随着更快的计算机的开发而减少。我们可以用表2所列时间来看看当我们在现代计算机上运行一个已知最坏情形时间复杂度的算法时，是否可以期望得到针对给定输入规模问题的一个解。注意我们不能确定一台计算机解决一个特定输入规模问题所需的确切时间，因为这涉及计算机硬件和实现算法的特定软件的许多方面的问题。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.348,
                0.407,
                0.588,
                0.422
            ],
            "angle": 0,
            "content": "表 2 算法所用的计算机时间"
        },
        {
            "type": "table",
            "bbox": [
                0.045,
                0.424,
                0.894,
                0.584
            ],
            "angle": 0,
            "content": "<table><tr><td>问题规模</td><td colspan=\"6\">使用的位运算</td></tr><tr><td>n</td><td>log n</td><td>n</td><td>n log n</td><td>n2</td><td>2n</td><td>n!</td></tr><tr><td>10</td><td>3×10-11s</td><td>10-10s</td><td>3×10-10s</td><td>10-9s</td><td>10-8s</td><td>3×10-7s</td></tr><tr><td>102</td><td>7×10-11s</td><td>10-9s</td><td>7×10-9s</td><td>10-7s</td><td>4×1011yr</td><td>*</td></tr><tr><td>103</td><td>1.0×10-10s</td><td>10-8s</td><td>1×10-7s</td><td>10-5s</td><td>*</td><td>*</td></tr><tr><td>104</td><td>1.3×10-10s</td><td>10-7s</td><td>1×10-6s</td><td>10-3s</td><td>*</td><td>*</td></tr><tr><td>105</td><td>1.7×10-10s</td><td>10-6s</td><td>2×10-5s</td><td>0.1s</td><td>*</td><td>*</td></tr><tr><td>106</td><td>2×10-10s</td><td>10-5s</td><td>2×10-4s</td><td>0.17min</td><td>*</td><td>*</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.596,
                0.892,
                0.69
            ],
            "angle": 0,
            "content": "对于一台计算机求解一个问题需要多长时间有一个的合理估算是很重要。例如，如果一个算法大约需要10小时，也许值得花费这些机时（和金钱）求解该问题。但是，如果算法需要数百亿年来求解一个问题，就没有理由消耗资源来实现这一算法。现代技术最有趣的现象之一是计算机在速度和内存空间的迅速增长。减少计算机解题时间的另一重要因素是并行处理，这是一种同时执行多个运算序列的技术。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.692,
                0.892,
                0.786
            ],
            "angle": 0,
            "content": "有效算法，包括大多数多项式时间复杂度的算法，都能从重大技术进步中得到最大的好处。可是，这些技术进步对于克服指数或阶乘时间复杂度算法的复杂度方面似乎没有什么帮助。由于计算速度的增加，计算机内存的增加，再加上采用得益于并行处理的算法，五年前被认为是不可解的问题现在可以当作例行事务求解了，而且可以肯定这句话在五年以后仍然成立。当采用的算法是难解的时候更是如此。"
        },
        {
            "type": "title",
            "bbox": [
                0.045,
                0.796,
                0.089,
                0.812
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.816,
                0.692,
                0.832
            ],
            "angle": 0,
            "content": "1. 试给出下面算法片断用到的运算次数的大 \\(O\\) 估算（这里运算是指加法或乘法）。"
        },
        {
            "type": "equation",
            "bbox": [
                0.064,
                0.835,
                0.117,
                0.847
            ],
            "angle": 0,
            "content": "\\[\nt := 0\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.064,
                0.852,
                0.18,
                0.866
            ],
            "angle": 0,
            "content": "\\[\n\\text {f o r} i := 1 \\text {t o} 3\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.084,
                0.87,
                0.199,
                0.884
            ],
            "angle": 0,
            "content": "\\[\nf o r j := 1 t o 4\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.102,
                0.888,
                0.18,
                0.901
            ],
            "angle": 0,
            "content": "\\[\nt := t + i j\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.905,
                0.469,
                0.92
            ],
            "angle": 0,
            "content": "2. 试给出下面算法片断用到的加法次数的大 \\(O\\) 估算。"
        },
        {
            "type": "equation",
            "bbox": [
                0.066,
                0.925,
                0.114,
                0.935
            ],
            "angle": 0,
            "content": "\\[\nt := 0\n\\]"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.15,
                0.047,
                0.186,
                0.062
            ],
            "angle": 0,
            "content": "204"
        },
        {
            "type": "header",
            "bbox": [
                0.232,
                0.046,
                0.298,
                0.062
            ],
            "angle": 0,
            "content": "第3章"
        },
        {
            "type": "equation",
            "bbox": [
                0.145,
                0.103,
                0.261,
                0.117
            ],
            "angle": 0,
            "content": "\\[\n\\text {f o r} i := 1 \\text {t o} n\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.165,
                0.122,
                0.282,
                0.134
            ],
            "angle": 0,
            "content": "\\[\nf o r j := 1 t o n\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.185,
                0.14,
                0.282,
                0.152
            ],
            "angle": 0,
            "content": "\\[\nt := t + i + j\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.156,
                0.972,
                0.189
            ],
            "angle": 0,
            "content": "3. 试给出下面算法片断用到的运算次数的大 \\(O\\) 估算，这里运算是指比较或乘法（忽略在 for 循环中测试条件所需的比较，其中 \\(a_1, a_2, \\dots, a_n\\) 是正实数）。"
        },
        {
            "type": "equation",
            "bbox": [
                0.146,
                0.193,
                0.207,
                0.205
            ],
            "angle": 0,
            "content": "\\[\nm := 0\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.148,
                0.211,
                0.263,
                0.223
            ],
            "angle": 0,
            "content": "\\[\nf o r i := 1 t o n\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.167,
                0.229,
                0.308,
                0.242
            ],
            "angle": 0,
            "content": "\\[\nf o r j := i + 1 t o n\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.186,
                0.247,
                0.346,
                0.26
            ],
            "angle": 0,
            "content": "\\[\nm := \\max  (a _ {i} a _ {j}, m)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.263,
                0.975,
                0.296
            ],
            "angle": 0,
            "content": "4. 试给出下面算法片断用到的运算次数的大 \\(O\\) 估算，这里运算是指加法或乘法（忽略在 while 循环中测试条件所需的比较）。"
        },
        {
            "type": "equation",
            "bbox": [
                0.148,
                0.3,
                0.198,
                0.312
            ],
            "angle": 0,
            "content": "\\[\ni := 1\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.148,
                0.319,
                0.198,
                0.329
            ],
            "angle": 0,
            "content": "\\[\nt := 0\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.148,
                0.336,
                0.233,
                0.348
            ],
            "angle": 0,
            "content": "\\[\n\\text {w h i l e} i \\leqslant n\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.168,
                0.354,
                0.239,
                0.365
            ],
            "angle": 0,
            "content": "\\[\nt := t + i\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.169,
                0.372,
                0.225,
                0.382
            ],
            "angle": 0,
            "content": "\\[\ni := 2 i\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.388,
                0.874,
                0.403
            ],
            "angle": 0,
            "content": "5.3.1节练习16给出的在 \\(n\\) 个自然数的序列中寻找最小自然数的算法需要使用多少次比较？"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.406,
                0.848,
                0.421
            ],
            "angle": 0,
            "content": "6. a) 用伪代码写一个算法，使用插入排序将任意长度的实数列表中前 4 项排列成递增序。"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.424,
                0.561,
                0.438
            ],
            "angle": 0,
            "content": "b)证明以比较次数度量算法的时间复杂度是 \\(O(1)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.441,
                0.975,
                0.474
            ],
            "angle": 0,
            "content": "7. 假定已知一个元素是一个有 32 个元素的列表的前 4 个元素中。线性搜索或二分搜索哪个会更快地定位到该元素？"
        },
        {
            "type": "text",
            "bbox": [
                0.124,
                0.48,
                0.975,
                0.517
            ],
            "angle": 0,
            "content": "8. 给定实数 \\( x \\) 和正整数 \\( k \\)，试给出计算 \\( x^{2^k} \\) 使用的乘法次数，计算方法是从 \\( x \\) 开始连续取平方（求 \\( x^2 \\) 、 \\( x^4 \\) 等）。这样是否比通过在 \\( x \\) 乘上适当次数的自身来计算 \\( x^{2^k} \\) 更高效？"
        },
        {
            "type": "text",
            "bbox": [
                0.124,
                0.52,
                0.976,
                0.552
            ],
            "angle": 0,
            "content": "9. 给出下述算法所使用的比较次数的大 \\(O\\) 估算，通过检查串的每比特是否为1来计算比特串中1的个数（参见3.1节练习25）。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.555,
                0.565,
                0.57
            ],
            "angle": 0,
            "content": "* 10. a)证明下面的算法给出的是比特串 \\( S \\) 中 1 的个数。"
        },
        {
            "type": "text",
            "bbox": [
                0.178,
                0.574,
                0.434,
                0.588
            ],
            "angle": 0,
            "content": "procedure bit count(S:比特串)"
        },
        {
            "type": "equation",
            "bbox": [
                0.179,
                0.593,
                0.266,
                0.604
            ],
            "angle": 0,
            "content": "\\[\n\\text {c o u n t} := 0\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.179,
                0.611,
                0.267,
                0.622
            ],
            "angle": 0,
            "content": "\\[\n\\text {w h i l e} S \\neq 0\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.199,
                0.629,
                0.344,
                0.639
            ],
            "angle": 0,
            "content": "\\[\n\\text {c o u n t} := \\text {c o u n t} + 1\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.2,
                0.647,
                0.329,
                0.658
            ],
            "angle": 0,
            "content": "\\[\nS := S \\wedge (S - 1)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.179,
                0.664,
                0.474,
                0.677
            ],
            "angle": 0,
            "content": "return count{count是 \\(S\\) 中1的个数}"
        },
        {
            "type": "text",
            "bbox": [
                0.178,
                0.68,
                0.978,
                0.713
            ],
            "angle": 0,
            "content": "其中 \\(S - 1\\) 是把 \\(S\\) 中最右边的比特1改为比特0，同时把这一比特右边的所有比特0均改为比特1得到的比特串。[回忆一下， \\(S\\wedge (S - 1)\\) 是 \\(S\\) 和 \\(S - 1\\) 的按位合取运算。]"
        },
        {
            "type": "text",
            "bbox": [
                0.16,
                0.716,
                0.741,
                0.731
            ],
            "angle": 0,
            "content": "b)用 \\(a\\) )中的算法计算比特串S中1的个数需要做多少次按位合取运算？"
        },
        {
            "type": "text",
            "bbox": [
                0.129,
                0.734,
                0.979,
                0.784
            ],
            "angle": 0,
            "content": "11. a) 假设有集合 \\(\\{1, 2, \\dots, n\\}\\) 的 \\(n\\) 个子集 \\(S_{1}, S_{2}, \\dots, S_{n}\\) 。试写出一个蛮力算法来判定是否有一对子集是不相交的。[提示：算法应该针对子集进行循环；对于每个子集 \\(S_{i}\\)，需要对所有其他子集进行循环；而对其他子集中的每个 \\(S_{j}\\)，需要针对 \\(S_{i}\\) 中所有元素 \\(k\\) 做循环以判定 \\(k\\) 是否也属于 \\(S_{j}\\)。]"
        },
        {
            "type": "text",
            "bbox": [
                0.16,
                0.787,
                0.773,
                0.802
            ],
            "angle": 0,
            "content": "b) 试给出算法用于判定一个整数是否在其中一个子集中的次数的大 \\(O\\) 估算。"
        },
        {
            "type": "text",
            "bbox": [
                0.13,
                0.805,
                0.979,
                0.838
            ],
            "angle": 0,
            "content": "12. 考虑下面的算法，以 \\(n\\) 个整数 \\(a_1, a_2, \\dots, a_n\\) 的序列作为输入，生成一个矩阵 \\(M = \\{m_{ij}\\}\\) 作为输出，其中对于 \\(j \\geq i\\) 时 \\(m_{ij}\\) 是整数序列 \\(a_i, a_{i+1}, \\dots, a_j\\) 中的最小项，否则 \\(m_{ij} = 0\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.162,
                0.841,
                0.528,
                0.856
            ],
            "angle": 0,
            "content": "初始化 \\(M\\) 使得当 \\(j \\geqslant i\\) 时 \\(m_{ij} = a_i\\) 否则 \\(m_{ij} = 0\\)"
        },
        {
            "type": "equation",
            "bbox": [
                0.165,
                0.86,
                0.28,
                0.871
            ],
            "angle": 0,
            "content": "\\[\n\\text {f o r} i := 1 \\text {t o} n\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.185,
                0.878,
                0.326,
                0.89
            ],
            "angle": 0,
            "content": "\\[\nf o r j := i + 1 t o n\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.203,
                0.896,
                0.342,
                0.907
            ],
            "angle": 0,
            "content": "\\[\n\\text {f o r} k := i + 1 \\text {t o} j\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.221,
                0.914,
                0.384,
                0.926
            ],
            "angle": 0,
            "content": "\\[\nm _ {i j} := \\min  \\left(m _ {i j}, a _ {k}\\right)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.165,
                0.93,
                0.597,
                0.944
            ],
            "angle": 0,
            "content": "return \\(M = \\{m_{ij}\\} \\{m_{ij}\\) 是 \\(a_{i}, a_{i + 1}, \\dots, a_{j}\\) 中的最小项\\}"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.701,
                0.04,
                0.793,
                0.056
            ],
            "angle": 0,
            "content": "算 法"
        },
        {
            "type": "page_number",
            "bbox": [
                0.837,
                0.042,
                0.874,
                0.055
            ],
            "angle": 0,
            "content": "205"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.097,
                0.486,
                0.11
            ],
            "angle": 0,
            "content": "a) 证明这个算法使用 \\(O(n^{3})\\) 次比较来计算矩阵 \\(\\pmb{M}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.115,
                0.9,
                0.145
            ],
            "angle": 0,
            "content": "b) 证明这个算法使用 \\(\\Omega(n^3)\\) 次比较来计算矩阵 \\(M\\)。利用该事实以及 a) 得出结论该算法使用 \\(\\Theta(n^3)\\) 次比较。「提示：在算法的两层外循环中只考虑当 \\(i \\leqslant n/4\\) 和 \\(j \\geqslant 3n/4\\) 的情形。」"
        },
        {
            "type": "list",
            "bbox": [
                0.084,
                0.097,
                0.9,
                0.145
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.15,
                0.823,
                0.166
            ],
            "angle": 0,
            "content": "13. 计算多项式 \\(a_{n}x^{n} + a_{n - 1}x^{n - 1} + \\dots +a_{1}x + a_{0}\\) 在 \\(x = c\\) 处的值的传统算法可以用伪代码表示为："
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.169,
                0.478,
                0.183
            ],
            "angle": 0,
            "content": "procedure polynomial \\((c, a_0, a_1, \\dots, a_n\\) ：实数）"
        },
        {
            "type": "equation",
            "bbox": [
                0.105,
                0.187,
                0.451,
                0.291
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{r l} & \\text {p o w e r : = 1} \\\\ & y := a _ {0} \\\\ & \\text {f o r i = 1 t o n} \\\\ & \\text {p o w e r : = p o w e r * c} \\\\ & y := y + a _ {i} * \\text {p o w e r} \\\\ & \\text {r e t u r n y} \\\\ & \\text {y} \\{y = a _ {n} c ^ {n} + a _ {n - 1} c ^ {n - 1} + \\dots + a _ {1} c + a _ {0} \\} \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.294,
                0.463,
                0.309
            ],
            "angle": 0,
            "content": "其中 \\(y\\) 的最终值即是该多项式在 \\(x = c\\) 处的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.312,
                0.743,
                0.326
            ],
            "angle": 0,
            "content": "a)按上述算法步骤计算 \\(3x^{2} + x + 1\\) 在 \\(x = 2\\) 处的值并给出每步赋值语句所赋的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.33,
                0.903,
                0.361
            ],
            "angle": 0,
            "content": "b)准确地说计算 \\(n\\) 阶多项式在 \\(x = c\\) 处的值需要使用多少次乘法和加法？（不要计算增加循环变量的值所做的加法。）"
        },
        {
            "type": "list",
            "bbox": [
                0.086,
                0.312,
                0.903,
                0.361
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.365,
                0.906,
                0.416
            ],
            "angle": 0,
            "content": "14. 有比上一题中给出的传统算法更有效的计算多项式值的算法（以使用的乘法和加法次数来度量）。这个算法称为霍纳法(Horner's method)。下面的伪代码说明怎样用这一方法计算 \\( a_{n}x^{n} + a_{n - 1}x^{n - 1} + \\dots + a_{1}x + a_{0} \\) 在 \\( x = c \\) 处的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.419,
                0.489,
                0.434
            ],
            "angle": 0,
            "content": "procedure Horner \\((c, a_0, a_1, a_2, \\dots, a_n\\) ：实数）"
        },
        {
            "type": "equation",
            "bbox": [
                0.126,
                0.439,
                0.472,
                0.505
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{r l} & y := a _ {n} \\\\ & \\text {f o r} i = 1 \\text {t o} n \\\\ & y := y * c + a _ {n - i} \\\\ & \\text {r e t u r n} y \\{y = a _ {n} c ^ {n} + a _ {n - 1} c ^ {n - 1} + \\dots + a _ {1} c + a _ {0} \\} \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.509,
                0.725,
                0.523
            ],
            "angle": 0,
            "content": "a)按上述算法步骤计算 \\(3x^{2} + x + 1\\) 在 \\(x = 2\\) 的值并给出每步赋值语句所赋的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.527,
                0.906,
                0.558
            ],
            "angle": 0,
            "content": "b)准确地说此算法计算 \\(n\\) 阶多项式在 \\(x = c\\) 处的值需要使用多少次乘法和加法？（不要计算增加循环变量的值所做的加法。）"
        },
        {
            "type": "list",
            "bbox": [
                0.088,
                0.509,
                0.906,
                0.558
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.563,
                0.906,
                0.595
            ],
            "angle": 0,
            "content": "15. 使用需要 \\( f(n) \\) 次比特运算的算法解决规模为 \\( n \\) 的问题时在 1 秒内能解决的问题的最大规模 \\( n \\) 是多少？这里每次比特运算能够在 \\( 10^{-9} \\) 秒完成，且采用下列函数 \\( f(n) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.599,
                0.717,
                0.631
            ],
            "angle": 0,
            "content": "a)logn b)n c)n log n d) \\(n^2\\) e) \\(2^{n}\\) f)n！"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.634,
                0.906,
                0.667
            ],
            "angle": 0,
            "content": "16. 使用需要 \\( f(n) \\) 次比特运算的算法解决规模为 \\( n \\) 的问题时在 1 天时间内能解决的问题的最大规模 \\( n \\) 是多少？这里每次比特运算能够在 \\( 10^{-11} \\) 秒完成，且采用下列函数 \\( f(n) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.67,
                0.677,
                0.724
            ],
            "angle": 0,
            "content": "a)logn b)1000n c)n² d)1000n² e)n³ f)2n g)2²n h)2²n"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.727,
                0.906,
                0.759
            ],
            "angle": 0,
            "content": "17. 使用需要 \\( f(n) \\) 次比特运算的算法解决规模为 \\( n \\) 的问题时在 1 分钟内能解决的问题的最大规模 \\( n \\) 是多少？这里每次比特运算能够在 \\( 10^{-12} \\) 秒完成，且采用下列函数 \\( f(n) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.763,
                0.725,
                0.817
            ],
            "angle": 0,
            "content": "a)log log n b)log n c) \\((\\log n)^2\\) d)1000000n e)n² f)2g) \\(2^{n^2}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.82,
                0.906,
                0.852
            ],
            "angle": 0,
            "content": "18. 如果算法求解规模为 \\( n \\) 的问题需 \\( 2n^{2} + 2^{n} \\) 次运算，每次运算需 \\( 10^{-9} \\) 秒，对于下面给出的 \\( n \\) 值，请问算法解题需要多少时间？"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.856,
                0.681,
                0.887
            ],
            "angle": 0,
            "content": "a)10 b)20 c)50 d)100"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.891,
                0.711,
                0.905
            ],
            "angle": 0,
            "content": "19. 如果每次运算需要使用下列时间，请问使用 \\(2^{50}\\) 次运算的算法需要多少时间？"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.909,
                0.724,
                0.923
            ],
            "angle": 0,
            "content": "a) \\(10^{-6}\\) 秒 b) \\(10^{-9}\\) 秒 c) \\(10^{-12}\\) 秒"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.927,
                0.909,
                0.941
            ],
            "angle": 0,
            "content": "20.当你将问题的输入规模从 \\(n\\) 翻倍到 \\(2n\\) 时对解题所需时间有什么影响？假定算法解决输入规模为 \\(n\\) 的"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.132,
                0.045,
                0.169,
                0.059
            ],
            "angle": 0,
            "content": "206"
        },
        {
            "type": "header",
            "bbox": [
                0.214,
                0.044,
                0.279,
                0.059
            ],
            "angle": 0,
            "content": "第3章"
        },
        {
            "type": "text",
            "bbox": [
                0.134,
                0.1,
                0.951,
                0.133
            ],
            "angle": 0,
            "content": "问题时所需的毫秒数为如下函数。[尽可能将答案表达得简单些，或者一个比值或者一个差值。你的答案可以是 \\( n \\) 的函数或常量。]"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.136,
                0.227,
                0.151
            ],
            "angle": 0,
            "content": "a) log log \\(n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.434,
                0.136,
                0.495,
                0.15
            ],
            "angle": 0,
            "content": "b) \\(\\log n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.685,
                0.137,
                0.741,
                0.149
            ],
            "angle": 0,
            "content": "c)100n"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.154,
                0.213,
                0.168
            ],
            "angle": 0,
            "content": "d) \\(n\\log n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.435,
                0.154,
                0.468,
                0.167
            ],
            "angle": 0,
            "content": "e) \\(n^2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.685,
                0.155,
                0.718,
                0.167
            ],
            "angle": 0,
            "content": "f) \\(n^3\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.172,
                0.172,
                0.185
            ],
            "angle": 0,
            "content": "g)2\""
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.189,
                0.951,
                0.239
            ],
            "angle": 0,
            "content": "21. 当你将问题的输入规模从 \\( n \\) 增长到 \\( n + 1 \\) 时对解题所需时间有什么影响？假定算法解决输入规模为 \\( n \\) 的问题时所需的毫秒数为如下函数。[尽可能将答案表达得简单些，或者一个比值或者一个差值。你的答案可以是 \\( n \\) 的函数或常量。]"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.244,
                0.197,
                0.258
            ],
            "angle": 0,
            "content": "a) \\(\\log n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.434,
                0.244,
                0.492,
                0.257
            ],
            "angle": 0,
            "content": "b)100n"
        },
        {
            "type": "text",
            "bbox": [
                0.685,
                0.243,
                0.72,
                0.256
            ],
            "angle": 0,
            "content": "c) \\(n^2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.265,
                0.172,
                0.278
            ],
            "angle": 0,
            "content": "d) \\(n^3\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.434,
                0.265,
                0.468,
                0.278
            ],
            "angle": 0,
            "content": "e) \\(2^{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.685,
                0.263,
                0.721,
                0.277
            ],
            "angle": 0,
            "content": "f) \\(2^{n^2}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.284,
                0.172,
                0.297
            ],
            "angle": 0,
            "content": "g)n!"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.301,
                0.573,
                0.315
            ],
            "angle": 0,
            "content": "22. 判定下述情况需要的最少比较次数，即最好情况性能。"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.319,
                0.535,
                0.333
            ],
            "angle": 0,
            "content": "a)用3.1节算法1寻找 \\(n\\) 个整数的序列的最大值。"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.337,
                0.536,
                0.351
            ],
            "angle": 0,
            "content": "b)用线性搜索在 \\(n\\) 个元素的列表中定位一个元素。"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.354,
                0.535,
                0.368
            ],
            "angle": 0,
            "content": "c)用二分搜索在 \\(n\\) 个元素的列表中定位一个元素。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.372,
                0.95,
                0.404
            ],
            "angle": 0,
            "content": "23. 试分析线性搜索的平均情形性能，如果恰有一半的情况 \\( x \\) 不在列表中；而且当 \\( x \\) 在列表中时它出现在列表中任何位置的可能性都一样。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.408,
                0.95,
                0.44
            ],
            "angle": 0,
            "content": "24. 一个算法解题时相对于某一运算来说是最优的，如果不存在其他算法在解此题时使用更少的此种运算。"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.444,
                0.949,
                0.476
            ],
            "angle": 0,
            "content": "a) 证明 3.1 节算法 1 相对于整数比较的次数而言是最优的。[注意：这里不考虑用于循环管理中的比较。]"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.48,
                0.759,
                0.494
            ],
            "angle": 0,
            "content": "b)线性搜索相对于整数比较次数是最优的吗？（不计循环管理中用到的比较。）"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.498,
                0.786,
                0.512
            ],
            "angle": 0,
            "content": "25.描述3.1节练习27给出的三分搜索算法用比较次数度量的最坏情形时间复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.516,
                0.768,
                0.529
            ],
            "angle": 0,
            "content": "26. 描述3.1节练习28中给出的搜索算法用比较次数度量的最坏情形时间复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.533,
                0.915,
                0.547
            ],
            "angle": 0,
            "content": "27. 分析你为 3.1 节练习 29 设计的在非递减序整数表中定位一个众数的算法的最坏情形时间复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.551,
                0.915,
                0.565
            ],
            "angle": 0,
            "content": "28. 分析你为 3.1 节练习 30 设计的在非递减序整数表中定位所有众数的算法的最坏情形时间复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.569,
                0.949,
                0.601
            ],
            "angle": 0,
            "content": "29. 分析你为 3.1 节练习 33 设计的在整数序列中寻找第一个与它前面某项相等的项的算法的最坏情形时间复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.605,
                0.949,
                0.637
            ],
            "angle": 0,
            "content": "30. 分析你为 3.1 节练习 34 设计的求序列中所有那些大于其前面各项之和的项的算法的最坏情形时间复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.641,
                0.897,
                0.655
            ],
            "angle": 0,
            "content": "31. 分析你为 3.1 节练习 35 设计的求序列中第一个小于前一项的项的算法的最坏情形时间复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.659,
                0.949,
                0.691
            ],
            "angle": 0,
            "content": "32. 用比较次数作为度量来确定 3.1 节练习 5 的在整数排序表中寻找所有多次出现的值的算法的最坏情形时间复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.694,
                0.949,
                0.726
            ],
            "angle": 0,
            "content": "33. 用比较次数作为度量来确定 3.1 节练习 9 的判断一个 \\( n \\) 个字符的串是否是回文的算法的最坏情形时间复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.73,
                0.949,
                0.762
            ],
            "angle": 0,
            "content": "34. 选择排序(参见3.1节练习41的前导文)给 \\(n\\) 个项排序要用多少次比较？基于你的答案，试给出以选择排序中的比较次数作为度量选择排序复杂度的大 \\(O\\) 估算。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.766,
                0.949,
                0.798
            ],
            "angle": 0,
            "content": "35. 对于在 3.1 节练习 49 前的说明中描述的二分插入排序，以所使用的比较次数和所交换的项数来度量，找出其最坏情形复杂度的大 \\(O\\) 估算。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.802,
                0.949,
                0.834
            ],
            "angle": 0,
            "content": "36. 采用朴素字符串匹配器在 \\( n \\) 个字符的文本中查询 \\( m \\) 个字符的模式时，如果模式的第一个字符没有出现在文本中，试确定需要多少次字符比较。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.838,
                0.949,
                0.869
            ],
            "angle": 0,
            "content": "37. 采用朴素字符串匹配器在 \\( n \\) 个字符的文本中查询 \\( m \\) 个字符的模式的所有出现，试以 \\( m \\) 和 \\( n \\) 为参数确定字符比较次数的大 \\( O \\) 估算。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.873,
                0.779,
                0.887
            ],
            "angle": 0,
            "content": "38. 试确定3.1节练习3la和b中判定两个字符串是否为易位词的算法的大 \\(O\\) 估算。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.891,
                0.815,
                0.905
            ],
            "angle": 0,
            "content": "39. 试确定 3.1 节练习 32a 和 b 中寻找 \\( n \\) 个实数中最靠近的两个实数的算法的大 \\( O \\) 估算。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.909,
                0.949,
                0.941
            ],
            "angle": 0,
            "content": "40. 证明以比较次数作为度量时采用25美分、10美分、5美分和1美分硬币找 \\(n\\) 美分零钱的贪婪算法具有 \\(O(n)\\) 复杂度。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.701,
                0.038,
                0.79,
                0.054
            ],
            "angle": 0,
            "content": "算法"
        },
        {
            "type": "page_number",
            "bbox": [
                0.835,
                0.039,
                0.872,
                0.053
            ],
            "angle": 0,
            "content": "207"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.095,
                0.752,
                0.11
            ],
            "angle": 0,
            "content": "练习41和42涉及给定 \\(n\\) 个讲座的开始和结束时间时尽可能多地安排讲座的问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.113,
                0.901,
                0.146
            ],
            "angle": 0,
            "content": "41. 试找出通过检查讲座的所有可能子集的方式来安排讲座的蛮力算法的复杂度。[提示：利用 \\( n \\) 个元素的集合有 \\( 2^n \\) 个子集的这一事实。]"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.148,
                0.901,
                0.199
            ],
            "angle": 0,
            "content": "42. 找出通过在每一步加入一个和那些已安排讲座兼容的结束时间最早的讲座的方式安排最多讲座的贪婪算法的复杂度(3.1节算法7)。假设讲座还没有按最早结束时间排序，并且假设排序的最坏情形时间复杂度是 \\(O(n \\log n)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.201,
                0.901,
                0.234
            ],
            "angle": 0,
            "content": "43. 试描述当列表规模从 \\(n\\) 翻倍到 \\(2n\\) 时，其中 \\(n\\) 是正整数，采用这些算法在一个列表中搜索一个元素在最坏情形下所用的比较次数是如何变化的。"
        },
        {
            "type": "list",
            "bbox": [
                0.055,
                0.113,
                0.901,
                0.234
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.238,
                0.18,
                0.252
            ],
            "angle": 0,
            "content": "a)线性搜索"
        },
        {
            "type": "text",
            "bbox": [
                0.435,
                0.238,
                0.531,
                0.252
            ],
            "angle": 0,
            "content": "b)二分搜索"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.255,
                0.901,
                0.288
            ],
            "angle": 0,
            "content": "44. 试描述当待排序的列表规模从 \\( n \\) 翻倍到 \\( 2n \\) 时，其中 \\( n \\) 是正整数，采用这些排序算法在最坏情形下所用的比较次数是如何变化的。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.291,
                0.18,
                0.306
            ],
            "angle": 0,
            "content": "a) 冒泡排序"
        },
        {
            "type": "text",
            "bbox": [
                0.435,
                0.292,
                0.531,
                0.305
            ],
            "angle": 0,
            "content": "b)插入排序"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.309,
                0.408,
                0.324
            ],
            "angle": 0,
            "content": "c)选择排序（见3.1节练习41的前导文）"
        },
        {
            "type": "text",
            "bbox": [
                0.435,
                0.309,
                0.798,
                0.324
            ],
            "angle": 0,
            "content": "d)二分插入排序（见3.1节练习47的前导文）"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.327,
                0.682,
                0.341
            ],
            "angle": 0,
            "content": "一个 \\(n \\times n\\) 矩阵称为是上三角矩阵（upper triangular）如果当 \\(i > j\\) 时 \\(a_{ij} = 0\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.344,
                0.901,
                0.377
            ],
            "angle": 0,
            "content": "45. 参考矩阵乘积的定义，用汉语描述计算两个上三角矩阵乘积的算法，它忽略在计算中自动等于零的乘积项。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.38,
                0.568,
                0.394
            ],
            "angle": 0,
            "content": "46. 给出练习 45 中计算两个上三角矩阵乘积算法的伪代码描述。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.398,
                0.672,
                0.412
            ],
            "angle": 0,
            "content": "47. 练习 45 中计算两个 \\(n \\times n\\) 上三角矩阵乘积算法需要用到多少次元素乘法？"
        },
        {
            "type": "list",
            "bbox": [
                0.055,
                0.344,
                0.901,
                0.412
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.415,
                0.717,
                0.43
            ],
            "angle": 0,
            "content": "在练习 \\(48\\sim 49\\) 中假设用于 \\(p\\times q\\) 矩阵和 \\(q\\times r\\) 矩阵相乘所需的元素乘法次数是 \\(pqr\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.433,
                0.768,
                0.448
            ],
            "angle": 0,
            "content": "48. 计算乘积 \\( ABC \\) 的最佳次序是什么，如果 \\( A \\)、\\( B \\) 和 \\( C \\) 分别是 \\( 3 \\times 9 \\)、\\( 9 \\times 4 \\) 和 \\( 4 \\times 2 \\) 矩阵？"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.451,
                0.901,
                0.484
            ],
            "angle": 0,
            "content": "49. 计算乘积 \\( ABCD \\) 的最佳次序是什么，如果 \\( A, B, C \\) 和 \\( D \\) 分别是 \\( 30 \\times 10 \\)、\\( 10 \\times 40 \\)、\\( 40 \\times 50 \\) 和 \\( 50 \\times 30 \\) 矩阵？"
        },
        {
            "type": "list",
            "bbox": [
                0.055,
                0.415,
                0.901,
                0.484
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.055,
                0.499,
                0.24,
                0.518
            ],
            "angle": 0,
            "content": "关键术语和结论"
        },
        {
            "type": "title",
            "bbox": [
                0.055,
                0.527,
                0.101,
                0.542
            ],
            "angle": 0,
            "content": "术语"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.546,
                0.712,
                0.561
            ],
            "angle": 0,
            "content": "算法（algorithm）：一组用于执行一个计算或求解一个问题的精确指令的有限序列。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.564,
                0.606,
                0.579
            ],
            "angle": 0,
            "content": "搜索算法（searching algorithm）：在一个列表中定位一个元素的问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.582,
                0.594,
                0.597
            ],
            "angle": 0,
            "content": "线性搜索算法（linear search algorithm）：逐个元素搜索列表的过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.599,
                0.803,
                0.615
            ],
            "angle": 0,
            "content": "二分搜索算法（binary search algorithm）：在有序列表中通过不断将列表分半进行搜索的过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.618,
                0.562,
                0.633
            ],
            "angle": 0,
            "content": "排序（sorting）：按既定的顺序重新排列一个列表中元素的次序。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.635,
                0.854,
                0.65
            ],
            "angle": 0,
            "content": "字符串搜索(string searching)：给定一个字符串，确定其在另一个更长的字符串中所有出现的位置。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.653,
                0.858,
                0.669
            ],
            "angle": 0,
            "content": "\\(f(x)\\) 是 \\(O(g(x))\\) 的 \\((f(x)isO(g(x)))\\) ：给定常数 \\(C\\) 和 \\(k\\) ，对所有 \\(x > k\\) 有 \\(\\left|f(x)\\right|\\leqslant C\\left|g(x)\\right|\\) 的事实。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.672,
                0.899,
                0.707
            ],
            "angle": 0,
            "content": "\\(f(x)\\) 是 \\(O(g(x))\\) 的这一关系的凭证（witness to the relationship \\(f(x)\\) is \\(O(g(x))\\)）：一对 \\(C\\) 和 \\(k\\) 使得只要 \\(x > k\\) 就有 \\(\\left|f(x)\\right| \\leqslant C\\left|g(x)\\right|\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.71,
                0.88,
                0.727
            ],
            "angle": 0,
            "content": "\\(f(x)\\) 是 \\(\\Omega(g(x))\\) 的 \\((f(x)\\) is \\(\\Omega(g(x)))\\) ：给定正常数 \\(C\\) 和 \\(k\\) ，对所有 \\(x > k\\) 有 \\(\\left|f(x)\\right| \\geqslant C\\left|g(x)\\right|\\) 的事实。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.73,
                0.731,
                0.745
            ],
            "angle": 0,
            "content": "\\(f(x)\\) 是 \\(\\Theta(g(x))\\) 的 \\((f(x) \\text{is} \\Theta(g(x)):)\\): \\(f(x)\\) 是 \\(O(g(x))\\) 和 \\(f(x)\\) 是 \\(\\Omega(g(x))\\) 的事实。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.748,
                0.51,
                0.763
            ],
            "angle": 0,
            "content": "时间复杂度（time complexity）：算法解题需要的时间量。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.765,
                0.611,
                0.78
            ],
            "angle": 0,
            "content": "空间复杂度（space complexity）：算法解题需要的计算机存储空间量。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.783,
                0.851,
                0.798
            ],
            "angle": 0,
            "content": "最坏情形时间复杂度（worst-case time complexity）：算法求解给定大小的问题时需要的最大时间量。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.801,
                0.865,
                0.816
            ],
            "angle": 0,
            "content": "平均情形时间复杂度(average-case time complexity)：算法求解给定大小的问题时需要的平均时间量。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.819,
                0.672,
                0.834
            ],
            "angle": 0,
            "content": "算法范型（algorithmic paradigm）：基于某个特定的概念构造算法的通用方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.837,
                0.851,
                0.851
            ],
            "angle": 0,
            "content": "蛮力算法（brute force）：从问题和定义出发以最朴素的方式构造求解问题的算法这样一种算法范型。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.855,
                0.658,
                0.869
            ],
            "angle": 0,
            "content": "贪婪算法(greedy algorithm)：根据指定条件在每一步都做最好选择的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.872,
                0.68,
                0.887
            ],
            "angle": 0,
            "content": "易解问题（tractable problem）：存在最坏情形多项式时间算法可以求解的问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.89,
                0.712,
                0.904
            ],
            "angle": 0,
            "content": "难解问题(intractable problem)：不存在最坏情形多项式时间算法可以求解的问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.908,
                0.489,
                0.923
            ],
            "angle": 0,
            "content": "可解问题（solvable problem）：可以由算法求解的问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.926,
                0.526,
                0.94
            ],
            "angle": 0,
            "content": "不可解问题（unsolvable problem）：不能由算法求解的问题。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.132,
                0.04,
                0.169,
                0.053
            ],
            "angle": 0,
            "content": "208"
        },
        {
            "type": "header",
            "bbox": [
                0.214,
                0.039,
                0.279,
                0.053
            ],
            "angle": 0,
            "content": "第3章"
        },
        {
            "type": "title",
            "bbox": [
                0.106,
                0.104,
                0.153,
                0.119
            ],
            "angle": 0,
            "content": "结论"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.123,
                0.706,
                0.138
            ],
            "angle": 0,
            "content": "线性和二分搜索算法(linear and binary search algorithms)：（参见3.1节。）"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.141,
                0.706,
                0.156
            ],
            "angle": 0,
            "content": "冒泡排序（bubble sort）：采用在每一遍都交换错位的相邻元素的排序方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.159,
                0.953,
                0.192
            ],
            "angle": 0,
            "content": "插入排序 (insertion sort)：当列表的前 \\(j - 1\\) 个元素已排好序时，在第 \\(j\\) 步把第 \\(j\\) 个元素插入列表中正确的位置上的排序方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.195,
                0.461,
                0.21
            ],
            "angle": 0,
            "content": "线性搜索具有 \\(O(n)\\) 的最坏情形时间复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.213,
                0.49,
                0.228
            ],
            "angle": 0,
            "content": "二分搜索具有 \\(O(\\log n)\\) 的最坏情形时间复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.231,
                0.523,
                0.246
            ],
            "angle": 0,
            "content": "冒泡和插入排序具有 \\(O(n^{2})\\) 的最坏情形时间复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.25,
                0.296,
                0.264
            ],
            "angle": 0,
            "content": "\\(\\log n!\\) 是 \\(O(n \\log n)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.267,
                0.953,
                0.301
            ],
            "angle": 0,
            "content": "如果 \\(f_{1}(x)\\) 是 \\(O(g_{1}(x))\\) 的且 \\(f_{2}(x)\\) 是 \\(O(g_{2}(x))\\) 的，则 \\((f_{1} + f_{2})(x)\\) 是 \\(O(\\max (g_1(x),g_2(x)))\\) 的且\\((f_{1}f_{2})(x)\\) 是 \\(O((g_{1}g_{2}(x))\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.304,
                0.953,
                0.337
            ],
            "angle": 0,
            "content": "如果 \\(a_0, a_1, \\dots, a_n\\) 都是实数且 \\(a_n \\neq 0\\)，则 \\(a_n x^n + a_{n-1} x^{n-1} + \\dots + a_1 x + a_0\\) 是 \\(\\Theta(x^n)\\) 的，因而也是 \\(O(n)\\) 的和 \\(\\Omega(n)\\) 的。"
        },
        {
            "type": "title",
            "bbox": [
                0.108,
                0.352,
                0.192,
                0.371
            ],
            "angle": 0,
            "content": "复习题"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.378,
                0.272,
                0.392
            ],
            "angle": 0,
            "content": "1. a)定义术语算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.396,
                0.404,
                0.411
            ],
            "angle": 0,
            "content": "b)有哪些不同方式可以描述算法？"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.414,
                0.68,
                0.429
            ],
            "angle": 0,
            "content": "c)求解问题的一个算法和求解该问题的一个计算机程序有什么不同？"
        },
        {
            "type": "list",
            "bbox": [
                0.128,
                0.396,
                0.68,
                0.429
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.433,
                0.626,
                0.447
            ],
            "angle": 0,
            "content": "2. a) 用中文描述在一个 \\( n \\) 个整数的列表中寻找最大整数的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.13,
                0.451,
                0.348,
                0.466
            ],
            "angle": 0,
            "content": "b)用伪代码表达这一算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.13,
                0.469,
                0.348,
                0.483
            ],
            "angle": 0,
            "content": "c)该算法使用多少次比较？"
        },
        {
            "type": "list",
            "bbox": [
                0.13,
                0.451,
                0.348,
                0.483
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.487,
                0.884,
                0.502
            ],
            "angle": 0,
            "content": "3. a)叙述 \\( f(n) \\) 是 \\( O(g(n)) \\) 的这一事实的定义，其中 \\( f(n) \\) 和 \\( g(n) \\) 是从正整数集到实数集的函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.505,
                0.822,
                0.52
            ],
            "angle": 0,
            "content": "b)利用 \\(f(n)\\) 是 \\(O(g(n))\\) 的这一事实的定义直接证明或反驳 \\(n^2 +18n + 107\\) 是 \\(O(n^{3})\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.523,
                0.821,
                0.538
            ],
            "angle": 0,
            "content": "c)利用 \\(f(n)\\) 是 \\(O(g(n))\\) 的这一事实的定义直接证明或反驳 \\(n^3\\) 是 \\(O(n^{2} + 18n + 107)\\) 的。"
        },
        {
            "type": "list",
            "bbox": [
                0.128,
                0.505,
                0.822,
                0.538
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.543,
                0.955,
                0.576
            ],
            "angle": 0,
            "content": "4. 排列下列函数使得每个函数是大 \\(O\\) 列表中下一个函数的： \\((\\log n)^{3}\\) 、 \\(n^{3} / 1000000\\) 、 \\(\\sqrt{n}\\) 、 \\(100n + 101\\) 、 \\(3^n\\) 、 \\(n!\\) 、 \\(2^{n}n^{2}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.579,
                0.928,
                0.595
            ],
            "angle": 0,
            "content": "5. a)如何得出对一个函数的大 \\(O\\) 估算，该函数是一些不同项之和，而其中每个项又是多个函数之积？"
        },
        {
            "type": "text",
            "bbox": [
                0.13,
                0.598,
                0.955,
                0.631
            ],
            "angle": 0,
            "content": "b)给出函数 \\( f(n) = (n! + 1)(2^n + 1) + (n^{n - 2} + 8n^{n - 3})(n^3 + 2^n) \\) 的大 \\( O \\) 估算。对于 \\( f(x) \\) 是 \\( O(g(x)) \\) 的估算中的函数 \\( g \\)，采用一个最低次数的简单函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.634,
                0.955,
                0.667
            ],
            "angle": 0,
            "content": "6. a) 对于在一个 \\(n\\) 个整数的列表中寻找最小整数的算法，试定义最坏情形时间复杂度、平均情形时间复杂度和最好情形时间复杂度的含义（用比较次数来度量）。"
        },
        {
            "type": "text",
            "bbox": [
                0.13,
                0.67,
                0.955,
                0.703
            ],
            "angle": 0,
            "content": "b) 通过比较每个整数和当前已找到的最小整数的方式来寻找 \\( n \\) 个整数的列表中最小整数的算法，用比较次数来度量时，其最坏情形、平均情形和最好情形时间复杂度是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.706,
                0.794,
                0.721
            ],
            "angle": 0,
            "content": "7. a) 试描述在以递增序排列的整数列表中寻找一个整数的线性搜索和二分搜索算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.724,
                0.481,
                0.739
            ],
            "angle": 0,
            "content": "b)比较这两个算法的最坏情形时间复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.742,
                0.61,
                0.757
            ],
            "angle": 0,
            "content": "c)（用比较次数来度量）两个算法之一是否总是比另一个快？"
        },
        {
            "type": "list",
            "bbox": [
                0.132,
                0.724,
                0.61,
                0.757
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.76,
                0.331,
                0.774
            ],
            "angle": 0,
            "content": "8. a) 试描述冒泡排序算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.778,
                0.553,
                0.793
            ],
            "angle": 0,
            "content": "b)用冒泡排序算法对列表5，2，4，1，3进行排序。"
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.796,
                0.519,
                0.811
            ],
            "angle": 0,
            "content": "c)给出冒泡排序算法所用比较次数的大 \\(O\\) 估算。"
        },
        {
            "type": "list",
            "bbox": [
                0.132,
                0.778,
                0.553,
                0.811
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.815,
                0.331,
                0.829
            ],
            "angle": 0,
            "content": "9. a) 试描述插入排序算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.833,
                0.553,
                0.847
            ],
            "angle": 0,
            "content": "b)用插入排序算法对列表2，5，1，4，3进行排序。"
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.851,
                0.519,
                0.865
            ],
            "angle": 0,
            "content": "c)给出插入排序算法所用比较次数的大 \\(O\\) 估算。"
        },
        {
            "type": "list",
            "bbox": [
                0.132,
                0.833,
                0.553,
                0.865
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.869,
                0.361,
                0.883
            ],
            "angle": 0,
            "content": "10. a) 试解释贪婪算法的概念。"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.887,
                0.769,
                0.901
            ],
            "angle": 0,
            "content": "b)试给出一个能生成最优解的贪婪算法的例子，并解释它为什么生成最优解。"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.905,
                0.859,
                0.919
            ],
            "angle": 0,
            "content": "c)试给出一个并不总是生成最优解的贪婪算法的例子，并解释它为什么不能生成最优解。"
        },
        {
            "type": "list",
            "bbox": [
                0.142,
                0.887,
                0.859,
                0.919
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.923,
                0.603,
                0.937
            ],
            "angle": 0,
            "content": "11. 试定义一个问题是易解的含义和一个问题是可解的含义。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.7,
                0.037,
                0.79,
                0.052
            ],
            "angle": 0,
            "content": "算法"
        },
        {
            "type": "page_number",
            "bbox": [
                0.835,
                0.038,
                0.871,
                0.052
            ],
            "angle": 0,
            "content": "209"
        },
        {
            "type": "title",
            "bbox": [
                0.055,
                0.105,
                0.16,
                0.124
            ],
            "angle": 0,
            "content": "补充练习"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.132,
                0.569,
                0.146
            ],
            "angle": 0,
            "content": "1. a)描述在一整数列表中定位最大整数的最后一次出现的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.074,
                0.15,
                0.327,
                0.163
            ],
            "angle": 0,
            "content": "b)估算一下所用到的比较次数。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.168,
                0.531,
                0.181
            ],
            "angle": 0,
            "content": "2. a) 描述在一整数列表中寻找最大整数和次大整数的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.074,
                0.185,
                0.327,
                0.199
            ],
            "angle": 0,
            "content": "b)估算一下所用到的比较次数。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.203,
                0.55,
                0.216
            ],
            "angle": 0,
            "content": "3. a) 给出一个判断一个比特串中是否含两个相邻的 0 的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.074,
                0.221,
                0.33,
                0.234
            ],
            "angle": 0,
            "content": "b)这个算法会用到多少次比较？"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.239,
                0.9,
                0.27
            ],
            "angle": 0,
            "content": "4. a) 假定一整数列表按从大到小的次序排列，而且整数可以重复出现。设计一个寻找整数 \\( x \\) 在该整数列表中的所有出现位置的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.075,
                0.275,
                0.329,
                0.288
            ],
            "angle": 0,
            "content": "b)估算一下所用到的比较次数。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.293,
                0.9,
                0.324
            ],
            "angle": 0,
            "content": "5. a) 修改 3.1 节算法 1 以寻找一个 \\( n \\) 个元素序列中的最大元素和最小元素，采用的方法在连续检查每个元素时更新临时最大元素和临时最小元素。"
        },
        {
            "type": "text",
            "bbox": [
                0.075,
                0.329,
                0.295,
                0.341
            ],
            "angle": 0,
            "content": "b)用伪代码描述a)中算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.074,
                0.346,
                0.848,
                0.359
            ],
            "angle": 0,
            "content": "c)这个算法要执行多少次序列中元素的比较？（不计入那些用来判断是否到达序列结尾的比较。）"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.364,
                0.903,
                0.449
            ],
            "angle": 0,
            "content": "6. a) 用汉语详细描述一个算法的步骤，该算法在一个 \\( n \\) 个元素的列表中寻找最大元素和最小元素，采用的方法是检查相邻元素对并记录下临时最大和临时最小元素。如果 \\( n \\) 是奇数，则临时最大元素和临时最小元素的初始值都等于第一个元素；如果 \\( n \\) 是偶数，则通过比较两个起始元素来找到临时最大元素和临时最小元素。临时最大元素和临时最小元素通过与所检查的元素对中的最大元素和最小元素相比较而获得更新。"
        },
        {
            "type": "text",
            "bbox": [
                0.077,
                0.453,
                0.297,
                0.466
            ],
            "angle": 0,
            "content": "b)用伪代码描述a)中算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.471,
                0.903,
                0.501
            ],
            "angle": 0,
            "content": "c)这个算法要执行多少次序列中元素的比较？（不计入那些用来判断是否到达序列结尾的比较。）这与练习5中的比较次数相比有何区别？"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.507,
                0.903,
                0.538
            ],
            "angle": 0,
            "content": "*7. 证明就比较次数而言在 \\( n \\) 个元素列表中寻找最大元素和最小元素的算法的最坏情形复杂度至少是 \\( \\lceil 3n / 2 \\rceil - 2 \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.542,
                0.797,
                0.555
            ],
            "angle": 0,
            "content": "8. 设计一个有效算法在一个 \\( n \\) 个元素列表中寻找第二大元素并确定算法的最坏情形复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.56,
                0.853,
                0.572
            ],
            "angle": 0,
            "content": "9. 设计一个算法在 \\( n \\) 个数的序列中寻找所有两项之和相等的数对，并确定算法的最坏情形复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.578,
                0.903,
                0.608
            ],
            "angle": 0,
            "content": "10. 设计一个算法在一个 \\(n\\) 个整数的序列中寻找最近的整数对，并确定算法的最坏情形复杂度。[提示：将序列排序。利用排序能在最坏情形时间复杂度 \\(O(n \\log n)\\) 内完成的事实。]"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.614,
                0.903,
                0.644
            ],
            "angle": 0,
            "content": "剃须刀排序(shaker sort)(或双向冒泡排序)依次比较相邻的元素对，如有逆序就交换它们，交替地从头到尾和从尾到头一遍遍扫描表，直到不需要交换为止。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.65,
                0.592,
                0.662
            ],
            "angle": 0,
            "content": "11. 说明剃须刀排序为列表3，5，1，4，6，2排序时所用的步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.668,
                0.306,
                0.68
            ],
            "angle": 0,
            "content": "12. 用伪代码描述剃须刀排序。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.685,
                0.544,
                0.697
            ],
            "angle": 0,
            "content": "13. 证明以比较次数来度量时剃须刀排序具有 \\(O(n^{2})\\) 复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.703,
                0.696,
                0.715
            ],
            "angle": 0,
            "content": "14. 试解释为什么对于接近正确顺序的列表进行排序时剃须刀排序是很有效的。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.721,
                0.332,
                0.733
            ],
            "angle": 0,
            "content": "15. 证明 \\((n \\log n + n^2)^3\\) 是 \\(O(n^6)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.739,
                0.39,
                0.751
            ],
            "angle": 0,
            "content": "16. 证明 \\(8x^{3} + 12x + 100\\log x\\) 是 \\(O(x^3)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.756,
                0.46,
                0.769
            ],
            "angle": 0,
            "content": "17. 给出 \\((x^{2} + x(\\log x)^{3})\\cdot (2^{x} + x^{3})\\) 的大 \\(O\\) 估算。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.777,
                0.34,
                0.806
            ],
            "angle": 0,
            "content": "18. 找出 \\(\\sum_{j=1}^{n} j(j+1)\\) 的大 \\(O\\) 估算。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.81,
                0.281,
                0.822
            ],
            "angle": 0,
            "content": "* 19. 证明 \\(n!\\) 不是 \\(O(2^n)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.829,
                0.277,
                0.84
            ],
            "angle": 0,
            "content": "* 20. 证明 \\(n^n\\) 不是 \\(O(n!)\\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.846,
                0.906,
                0.876
            ],
            "angle": 0,
            "content": "21. 在这个函数列表中找出所有同阶的函数对： \\( n^2 + (\\log n)^2 \\)， \\( n^2 + n \\)， \\( n^2 + \\log 2^n + 1 \\)， \\( (n + 1)^3 - (n - 1)^3 \\) 和 \\( (n + \\log n)^2 \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.881,
                0.883,
                0.894
            ],
            "angle": 0,
            "content": "22. 在这个函数列表中找出所有同阶的函数对： \\( n^2 + 2^n \\)， \\( n^2 + 2^{100} \\)， \\( n^2 + 2^{2n} \\)， \\( n^2 + n! \\)， \\( n^2 + 3^n \\) 和 \\( (n^2 + 1)^2 \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.901,
                0.36,
                0.914
            ],
            "angle": 0,
            "content": "23. 找出整数 \\(n (n > 2)\\) 使得 \\(n^{2^{100}} < 2^n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.922,
                0.4,
                0.936
            ],
            "angle": 0,
            "content": "24.找出整数 \\(n(n > 2)\\) 使得 \\((\\log n)^{2^{100}} <   \\sqrt{n}\\)"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.136,
                0.039,
                0.172,
                0.052
            ],
            "angle": 0,
            "content": "210"
        },
        {
            "type": "header",
            "bbox": [
                0.218,
                0.038,
                0.284,
                0.053
            ],
            "angle": 0,
            "content": "第3章"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.094,
                0.956,
                0.128
            ],
            "angle": 0,
            "content": "* 25. 将函数 \\(n^n\\) ， \\((\\log n)^2\\) ， \\(n^{1.0001}\\) ， \\((1.0001)^n\\) ， \\(2\\sqrt{\\log_2n}\\) 和 \\(n(\\log n)^{1001}\\) 排成列表使得每个函数是大 \\(O\\) 下一个函数。[提示：可以用算法来判断其中某些函数的相对大小。]"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.133,
                0.956,
                0.167
            ],
            "angle": 0,
            "content": "* 26. 将函数 \\( {2}^{100n},{2}^{n2},{2}^{n1},{2}^{2n},n{\\log }_{n}n{\\log }_{n}n,{n}^{3/2},n{\\left( \\log n\\right) }^{3/2} \\) 和 \\( {n}^{4/3}{\\left( \\log n\\right) }^{2} \\) 排成列表使得每个函数是大 \\( O \\) 后面的函数。[提示: 可以用算法来判断其中某些函数的相对大小。]"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.17,
                0.956,
                0.203
            ],
            "angle": 0,
            "content": "* 27. 试给出一个例子，两个从正整数集合到正整数集合的递增函数 \\( f(n) \\) 和 \\( g(n) \\) 使得 \\( f(n) \\) 不是 \\( O(g(n)) \\) 的，同时 \\( g(n) \\) 也不是 \\( O(f(n)) \\) 的。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.205,
                0.956,
                0.239
            ],
            "angle": 0,
            "content": "28. 证明如果硬币的面值是 \\(c^0, c^1, \\dots, c^k\\)，其中 \\(k\\) 是一个正整数且 \\(c\\) 是一个正整数，则贪婪算法总是使用最少的硬币找零钱。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.242,
                0.956,
                0.293
            ],
            "angle": 0,
            "content": "29. a) 用伪代码描述一个蛮力算法，当给定 \\( n \\) 个正整数的序列作为输入时，该算法判定序列中是否存在两个不同的项其和是第三项。算法应该对序列项的所有三元组作循环，检查前两项之和是否等于第三项。"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.295,
                0.495,
                0.31
            ],
            "angle": 0,
            "content": "b) 试给出 a) 中蛮力算法复杂度的大 \\(O\\) 估算。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.313,
                0.956,
                0.346
            ],
            "angle": 0,
            "content": "30. a) 设计一个更有效的算法求解练习 29 所描述的问题，首先对输入序列进行排序，然后针对每个项对检查其差值是否也在序列中。"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.349,
                0.761,
                0.364
            ],
            "angle": 0,
            "content": "b) 试给出该算法复杂度的大 \\(O\\) 估算。它是否比练习29中的蛮力算法更有效？"
        },
        {
            "type": "list",
            "bbox": [
                0.108,
                0.313,
                0.956,
                0.364
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.367,
                0.956,
                0.454
            ],
            "angle": 0,
            "content": "如3.1节练习60的前导文所描述，假设有 \\(s\\) 位男士和 \\(s\\) 位女士，每位都有一个对异性成员的喜好列表。我们说一位女士 \\(\\boldsymbol{\\varpi}\\) 是一位男士 \\(m\\) 的合法伴侣（valid partner）如果存在某个稳定的匹配使他们结为夫妇。同样，一位男士 \\(m\\) 是一位女士 \\(\\boldsymbol{\\varpi}\\) 的合法伴侣如果存在某个稳定的匹配使他们结为夫妇。一个匹配称为是男性最优的（male optimal），如果每位男士都被指派了他的喜好列表中最高阶的合法伴侣。一个匹配称为是女性最差的(female pessimal)，如果每位女士都被指派了她的喜好列表中最低阶的合法伴侣。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.457,
                0.956,
                0.508
            ],
            "angle": 0,
            "content": "31. 试找出每位男士和每位女士的所有合法伴侣，假设有三位男士 \\(m_{1}\\)、\\(m_{2}\\) 和 \\(m_{3}\\)，以及三位女士 \\(w_{1}\\)、\\(w_{2}\\) 和 \\(w_{3}\\)，男士对女士的喜好列表从高到低为：\\(m_{1}\\)、\\(w_{3}\\)、\\(w_{1}\\)、\\(w_{2}\\)；\\(m_{2}\\)、\\(w_{3}\\)、\\(w_{2}\\)、\\(w_{1}\\)；\\(m_{3}\\)、\\(w_{2}\\)、\\(w_{3}\\)、\\(w_{1}\\)；女士对男士的喜好列表从高到低为：\\(w_{1}\\)、\\(m_{3}\\)、\\(m_{2}\\)、\\(m_{1}\\)；\\(w_{2}\\)、\\(m_{1}\\)、\\(m_{3}\\)、\\(m_{2}\\)；\\(w_{3}\\)、\\(m_{3}\\)、\\(m_{2}\\)、\\(m_{1}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.51,
                0.903,
                0.526
            ],
            "angle": 0,
            "content": "* 32. 证明在 3.1 节练习 61 的前导文中给出的延迟接受算法总是产生一个男性最优女性最差的匹配。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.529,
                0.617,
                0.544
            ],
            "angle": 0,
            "content": "33. 试定义一个女性最优的匹配和一个男性最差的匹配的含义。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.546,
                0.838,
                0.561
            ],
            "angle": 0,
            "content": "* 34. 证明在延迟接受算法中，当采用女士求婚方式时，产生的匹配是女性最优男性最差的。"
        },
        {
            "type": "list",
            "bbox": [
                0.095,
                0.51,
                0.903,
                0.561
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.564,
                0.851,
                0.579
            ],
            "angle": 0,
            "content": "在练习35和36中，考虑3.1节练习61的前导文中描述的寻找男士和女士匹配问题的变体。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.582,
                0.942,
                0.597
            ],
            "angle": 0,
            "content": "* 35. 在这个练习中我们考虑匹配问题，其中男士和女士数量可以不一样，因此不可能为每个人匹配一位异性。"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.6,
                0.956,
                0.651
            ],
            "angle": 0,
            "content": "a)扩展3.1节练习60前导文中给出的稳定匹配的定义，使其涵盖男士和女士数量不等的情形。要避免所有这样的情况其中一位男士和一位女士更喜欢对方而不是当前匹配中的伴侣，包括那些未被匹配的人。（假设一位未匹配的人更喜欢和一位异性成员匹配，而不是剩余未匹配的人。）"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.654,
                0.892,
                0.669
            ],
            "angle": 0,
            "content": "b)当男士和女士数量不一致时，基于a中稳定匹配的定义改编延迟接受算法以寻找稳定匹配。"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.672,
                0.687,
                0.687
            ],
            "angle": 0,
            "content": "c) 证明根据 a 的定义，由 b 给出的算法产生的所有匹配都是稳定的。"
        },
        {
            "type": "list",
            "bbox": [
                0.139,
                0.6,
                0.956,
                0.687
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.69,
                0.772,
                0.705
            ],
            "angle": 0,
            "content": "* 36. 在这个练习中我们考虑这样的匹配问题，其中某些男士-女士配对是不允许的。"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.708,
                0.956,
                0.758
            ],
            "angle": 0,
            "content": "a)扩展稳定匹配的定义，使其涵盖男士和女士数量相等但某些男士-女士配对被禁止的情形。要避免所有这样的情况其中一位男士和一位女士更喜欢对方而不是当前匹配中的伴侣，包括那些未被匹配的人。"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.761,
                0.954,
                0.794
            ],
            "angle": 0,
            "content": "b)当男士和女士数量一致但某些男士、女士配对被禁止的情形下，改编延迟接受算法以寻找稳定匹配。（假设一位未匹配的人更喜欢和一位非禁配伴侣的异性成员匹配，而不是剩余未匹配的人。）"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.798,
                0.687,
                0.812
            ],
            "angle": 0,
            "content": "c) 证明根据 a 的定义，由 b 给出的算法产生的所有匹配都是稳定的。"
        },
        {
            "type": "list",
            "bbox": [
                0.139,
                0.708,
                0.956,
                0.812
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.815,
                0.956,
                0.884
            ],
            "angle": 0,
            "content": "练习 \\(37\\sim 40\\) 涉及在单处理器上调度 \\(n\\) 个作业的问题。要完成作业 \\(j\\) ，处理器必须不间断地用 \\(t_j\\) 时间来运行作业 \\(j\\) 。每个作业有一个截止时刻 \\(d_{j}\\) 。如果在时刻 \\(s_j\\) 开始作业 \\(j\\) ，则它会在 \\(e_j = s_j + t_j\\) 时刻完成。作业的拖延(lateness)衡量作业是在其截止时刻后多少时间内完成，即作业 \\(j\\) 的拖延是 \\(\\max (0,e_j - d_j)\\) 。希望设计一个贪婪算法使得 \\(n\\) 个作业中的最大作业拖延最小化。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.887,
                0.956,
                0.938
            ],
            "angle": 0,
            "content": "37. 假设有五个作业，其所需运行时间和截止时刻为： \\( t_1 = 25 \\)， \\( d_1 = 50 \\)； \\( t_2 = 15 \\)， \\( d_2 = 60 \\)； \\( t_3 = 20 \\)， \\( d_3 = 60 \\)； \\( t_4 = 5 \\)， \\( d_4 = 55 \\)； \\( t_5 = 10 \\)， \\( d_5 = 75 \\)。当作业调度的顺序为作业3、作业1、作业4、作业2、作业5（从时刻0开始）时找出任意作业的最大拖延。对于调度顺序为作业5、作业3、作业3、作业1、作业"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.687,
                0.039,
                0.775,
                0.054
            ],
            "angle": 0,
            "content": "算法"
        },
        {
            "type": "page_number",
            "bbox": [
                0.822,
                0.04,
                0.856,
                0.054
            ],
            "angle": 0,
            "content": "211"
        },
        {
            "type": "text",
            "bbox": [
                0.072,
                0.096,
                0.245,
                0.11
            ],
            "angle": 0,
            "content": "2时回答同样的问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.04,
                0.114,
                0.887,
                0.146
            ],
            "angle": 0,
            "content": "38. 一个运行 \\(t\\) 时间且截止时刻为 \\(d\\) 的作业的宽松度(slackness)是 \\(d - t\\) ，其截止时刻和所需运行时间的差。找出一个实例证明通过增加宽松度来调度作业并不一定能产生一个具有尽可能最小的最大拖延的调度。"
        },
        {
            "type": "text",
            "bbox": [
                0.04,
                0.149,
                0.885,
                0.181
            ],
            "angle": 0,
            "content": "39. 找出一个实例证明以作业所需时间递增序来调度作业并不一定能产生一个具有尽可能最小的最大拖延的调度。"
        },
        {
            "type": "text",
            "bbox": [
                0.029,
                0.184,
                0.885,
                0.234
            ],
            "angle": 0,
            "content": "* 40. 证明以截止时刻的递增序来调度作业总是产生一个作业最大拖延最小化的调度。[提示：首先证明一个调度要是最优的，被调度的作业之间必须没有空闲时间，这样一个具有较早的截止时刻的作业之前不会安排其他作业。]"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.237,
                0.887,
                0.27
            ],
            "angle": 0,
            "content": "41. 假设有一个总容量为 \\( W \\) kg 的背包。我们有 \\( n \\) 件物品，第 \\( j \\) 件物品的质量是 \\( w_{j} \\) 。背包问题（knapsack problem）寻求这 \\( n \\) 件物品的一个子集使得其具有不超过 \\( W \\) 的尽可能最大的总质量。"
        },
        {
            "type": "text",
            "bbox": [
                0.07,
                0.273,
                0.36,
                0.286
            ],
            "angle": 0,
            "content": "a)设计一个蛮力算法求解背包问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.068,
                0.29,
                0.884,
                0.321
            ],
            "angle": 0,
            "content": "b)当背包容量为 \\(18\\mathrm{kg}\\) 且有五件物品：一个 \\(5\\mathrm{kg}\\) 的睡袋、一个 \\(8\\mathrm{kg}\\) 的帐篷、一个 \\(7\\mathrm{kg}\\) 的食品包、一个 \\(4\\mathrm{kg}\\) 的盛水容器和一个 \\(11\\mathrm{kg}\\) 的便携式炉灶时，求解背包问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.037,
                0.325,
                0.884,
                0.392
            ],
            "angle": 0,
            "content": "在练习 \\(42\\sim 46\\) 中我们研究负载均衡问题。问题的输入是一组 \\(p\\) 个处理器和 \\(n\\) 个作业，\\(t_j\\) 是运行作业 \\(j\\) 所需时间，作业在结束前必须不间断地在单独的机器上运行，一个处理器一次只能运行一个作业。处理器 \\(k\\) 的负载 \\(L_{k}\\) 是指派给处理器 \\(k\\) 的所有作业的运行时间的总和。跨度（makespan）是所有处理器的最大负载。负载均衡问题寻求一种作业到处理器的指派使得跨度最小化。"
        },
        {
            "type": "text",
            "bbox": [
                0.037,
                0.395,
                0.884,
                0.428
            ],
            "angle": 0,
            "content": "42. 假设我们有三个处理器和五个作业，其运行时间为 \\( t_1 = 3 \\)，\\( t_2 = 5 \\)，\\( t_3 = 4 \\)，\\( t_4 = 7 \\)，和 \\( t_5 = 8 \\)。针对该输入求解负载均衡问题以找出五个作业到三个处理器的指派使得跨度最小化。"
        },
        {
            "type": "text",
            "bbox": [
                0.037,
                0.431,
                0.776,
                0.445
            ],
            "angle": 0,
            "content": "43. 当 \\( p \\) 个处理器来运行 \\( n \\) 个作业时，其中运行作业 \\( j \\) 所需时间为 \\( t_j \\)，假设 \\( L^* \\) 是最小跨度。"
        },
        {
            "type": "text",
            "bbox": [
                0.068,
                0.45,
                0.289,
                0.463
            ],
            "angle": 0,
            "content": "a)证明 \\(L^{*}\\geqslant \\max_{j = 1,2,\\dots ,n}t_{j}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.068,
                0.47,
                0.256,
                0.499
            ],
            "angle": 0,
            "content": "b) 证明 \\(L^{*} \\geqslant \\frac{1}{p} \\sum_{i=1}^{n} t_{j}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.037,
                0.502,
                0.877,
                0.516
            ],
            "angle": 0,
            "content": "44. 用伪代码写出贪婪算法，按序遍历作业并将每个作业指派到算法运行至此时具有最小负载的处理器。"
        },
        {
            "type": "text",
            "bbox": [
                0.037,
                0.52,
                0.451,
                0.533
            ],
            "angle": 0,
            "content": "45. 针对练习 42 给出的输入运行练习 44 中的算法。"
        },
        {
            "type": "list",
            "bbox": [
                0.037,
                0.502,
                0.877,
                0.533
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.035,
                0.537,
                0.884,
                0.586
            ],
            "angle": 0,
            "content": "最优化问题的渐近算法(approximation algorithm)生成的解保证接近于最优解。更确切地说，假设最优化问题针对输入 \\(S\\) 寻求最小化 \\(F(X)\\)，这里 \\(F\\) 是输入 \\(X\\) 的函数。如果一个算法总能找到具有 \\(F(T) \\leqslant cF(S)\\) 性质的输入 \\(T\\)，这里 \\(c\\) 是一个固定的正实数，则该算法称为该问题的一个 \\(c\\) 渐近算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.027,
                0.59,
                0.823,
                0.605
            ],
            "angle": 0,
            "content": "* 46. 证明练习 44 中的算法是求解负载均衡问题的一个 2 渐近算法。[提示：利用练习 43 的结论。]"
        },
        {
            "type": "title",
            "bbox": [
                0.04,
                0.619,
                0.172,
                0.637
            ],
            "angle": 0,
            "content": "计算机课题"
        },
        {
            "type": "title",
            "bbox": [
                0.04,
                0.644,
                0.272,
                0.658
            ],
            "angle": 0,
            "content": "按给定的输入与输出写程序。"
        },
        {
            "type": "text",
            "bbox": [
                0.037,
                0.662,
                0.442,
                0.675
            ],
            "angle": 0,
            "content": "1. 给定 \\( n \\) 个整数的列表，找出列表中的最大整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.679,
                0.59,
                0.692
            ],
            "angle": 0,
            "content": "2. 给定 \\( n \\) 个整数的列表，找出最大整数在列表中的首次和末次出现。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.697,
                0.627,
                0.71
            ],
            "angle": 0,
            "content": "3. 给定 \\( n \\) 个不同整数的列表，用线性搜索确定一个整数在列表中的位置。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.715,
                0.663,
                0.728
            ],
            "angle": 0,
            "content": "4. 给定 \\( n \\) 个不同整数的有序列表，用二分搜索确定一个整数在列表中的位置。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.732,
                0.423,
                0.745
            ],
            "angle": 0,
            "content": "5. 给定 \\( n \\) 个整数的列表，用冒泡排序对其排序。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.75,
                0.423,
                0.763
            ],
            "angle": 0,
            "content": "6. 给定 \\( n \\) 个整数的列表，用插入排序对其排序。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.767,
                0.793,
                0.781
            ],
            "angle": 0,
            "content": "7. 给定两个字符串，利用朴素字符串匹配算法判定较短的字符串是否出现在较长的字符串中。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.785,
                0.658,
                0.798
            ],
            "angle": 0,
            "content": "8. 给定一个整数 \\( n \\)，用收银员算法以 25、10、5 和 1 美分硬币找 \\( n \\) 美分零钱。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.803,
                0.793,
                0.816
            ],
            "angle": 0,
            "content": "9. 给定 \\( n \\) 个讲座的开始和结束时间，利用适当的贪婪算法在一个报告厅安排尽可能多的讲座。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.82,
                0.881,
                0.851
            ],
            "angle": 0,
            "content": "10. 给定 \\( n \\) 个整数的有序列表和列表中的一个整数 \\( x \\)，找出使用线性搜索和二分搜索确定 \\( x \\) 在列表中的位置时所用的比较次数。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.855,
                0.783,
                0.869
            ],
            "angle": 0,
            "content": "11. 给定一个整数列表，确定使用冒泡排序和插入排序对该列表进行排序时所用的比较次数。"
        },
        {
            "type": "list",
            "bbox": [
                0.036,
                0.662,
                0.881,
                0.869
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.038,
                0.884,
                0.172,
                0.902
            ],
            "angle": 0,
            "content": "计算和探索"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.908,
                0.512,
                0.923
            ],
            "angle": 0,
            "content": "使用一个计算程序或你自己编写的计算程序做下面的练习。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.926,
                0.881,
                0.941
            ],
            "angle": 0,
            "content": "1. 当 \\( b \\) 和 \\( d \\) 是正整数且 \\( d \\geq 2 \\) 时，我们知道 \\( n^b \\) 是 \\( O(d^n) \\) 的。对于这几组值： \\( b = 10 \\) 和 \\( d = 2 \\) 、 \\( b = 20 \\) 和 \\( d = \\)"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.141,
                0.038,
                0.177,
                0.051
            ],
            "angle": 0,
            "content": "212"
        },
        {
            "type": "header",
            "bbox": [
                0.223,
                0.036,
                0.288,
                0.052
            ],
            "angle": 0,
            "content": "第3章"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.093,
                0.759,
                0.108
            ],
            "angle": 0,
            "content": "3、 \\(b = 1000\\) 和 \\(d = 7\\) ，请给出常量 \\(C\\) 和 \\(k\\) 的值使得只要 \\(x > k\\) 时就有 \\(n^b\\leqslant Cd^n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.111,
                0.962,
                0.144
            ],
            "angle": 0,
            "content": "2. 利用收银员算法以不同面值硬币给不同的 \\( n \\) 值找零钱，并确定是否用了最少量的硬币。你能否找出保证收银员算法用尽可能少硬币的条件？"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.146,
                0.961,
                0.179
            ],
            "angle": 0,
            "content": "3. 利用整数 1, 2, …, \\( n \\) 的随机序发生器，找出冒泡排序、插入排序、二分插入排序和选择排序对这些整数进行排序时所用的比较次数。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.181,
                0.961,
                0.215
            ],
            "angle": 0,
            "content": "4. 当使用问题3中的算法对只有一小部分数据是错序的序列进行排序时，收集与这些算法的比较次数相关的实验证据。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.217,
                0.961,
                0.251
            ],
            "angle": 0,
            "content": "*5. 写一个动画演示程序，给定随机排列的数字1到100，使得程序能演示问题3中所有算法进行排序时的过程。"
        },
        {
            "type": "list",
            "bbox": [
                0.1,
                0.111,
                0.962,
                0.251
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.116,
                0.265,
                0.225,
                0.284
            ],
            "angle": 0,
            "content": "写作课题"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.291,
                0.482,
                0.307
            ],
            "angle": 0,
            "content": "用本教材以外的资料，按下列要求写成论文。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.309,
                0.614,
                0.323
            ],
            "angle": 0,
            "content": "1. 查一查算法一词的历史，试描述早期作品中这一词的用法。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.327,
                0.917,
                0.342
            ],
            "angle": 0,
            "content": "2. 查找一下巴赫曼(Bachmann)关于大 \\(O\\) 记号的最初引入。试解释他和其他人如何使用这个记号的。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.345,
                0.689,
                0.359
            ],
            "angle": 0,
            "content": "3. 试解释如何根据排序算法所依赖的基础原理来对排序算法进行分类。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.362,
                0.375,
                0.376
            ],
            "angle": 0,
            "content": "4. 试描述基数(radix)排序算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.38,
                0.429,
                0.394
            ],
            "angle": 0,
            "content": "5. 试描述字符串匹配的一些不同算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.398,
                0.56,
                0.412
            ],
            "angle": 0,
            "content": "6. 试描述字符串匹配在生物信息学中的一些不同应用。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.415,
                0.962,
                0.448
            ],
            "angle": 0,
            "content": "7. 试描述处理器能以多快的速度执行运算的历史趋势，并用这些趋势来估算将来20年后处理器又能以多快的速度执行运算。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.451,
                0.671,
                0.466
            ],
            "angle": 0,
            "content": "8. 设计一个关于算法范型的详细列表，并用每种范型提供一些实例。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.469,
                0.962,
                0.501
            ],
            "angle": 0,
            "content": "9. 试解释图灵奖是什么，并描述用来选择获奖者的标准。列出六位以往的获奖者，以及他们获奖的原因。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.504,
                0.792,
                0.519
            ],
            "angle": 0,
            "content": "10. 试描述并行算法的含义。试解释怎样扩展本书中使用的伪代码以描述并行算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.522,
                0.962,
                0.554
            ],
            "angle": 0,
            "content": "11. 试解释怎样度量并行算法的复杂度。给出一些例子说明这一概念，并说明并行算法如何比没有并行操作的算法更快完成任务。"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.557,
                0.419,
                0.571
            ],
            "angle": 0,
            "content": "12. 试描述六个不同的 NP 完全问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.575,
                0.715,
                0.59
            ],
            "angle": 0,
            "content": "13. 试证明许多不同的 NP 完全问题之一如何能够规约到可满足性问题的。"
        },
        {
            "type": "list",
            "bbox": [
                0.114,
                0.309,
                0.962,
                0.59
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.806,
                0.094,
                0.882,
                0.113
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "header",
            "bbox": [
                0.594,
                0.117,
                0.882,
                0.129
            ],
            "angle": 0,
            "content": "Discrete Mathematics and Its Applications, 8E"
        },
        {
            "type": "title",
            "bbox": [
                0.669,
                0.138,
                0.892,
                0.165
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.216,
                0.895,
                0.271
            ],
            "angle": 0,
            "content": "数学中专门研究整数集合及其性质的分支称为数论。本章我们将讲解数论中的一些重要概念，其中许多会在计算机科学中用到。在我们讲解数论时会使用第一章讲到的证明方法来证明许多定理。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.274,
                0.895,
                0.33
            ],
            "angle": 0,
            "content": "我们首先介绍整数整除性的概念，并用来介绍模算术，或时钟算术。模算术计算一个整数被一个固定的正整数(称为模)除时所得的余数。我们要证明许多模算术相关的重要结论都会在本章中得到广泛应用。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.332,
                0.895,
                0.407
            ],
            "angle": 0,
            "content": "整数可以用任何一个大于1的整数 \\(b\\) 作为基数来表示。本章中我们讨论以 \\(b\\) 为基数的整数表示，并给出寻找其表示的一个算法。特别是，我们要讨论二进制、八进制和十六进制（以2、8和16为基数)表示。我们将描述用这些表示法执行算术运算的算法，并研究其复杂度。这些算法就是最初被称为算法的过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.409,
                0.895,
                0.504
            ],
            "angle": 0,
            "content": "我们将会讨论素数，即那些只有1和其自身作为其正因子的正整数。我们会证明存在无限多的素数，我们给出的证明被认为是数学中最漂亮的证明之一。还会讨论素数的分布以及涉及素数的许多著名的开放问题。我们将引入最大公约数的概念并研究计算它们的欧几里得算法。该算法最初在几千年前就有描述。我们还将介绍算术基本定理，这个核心结论告诉我们每个正整数具有唯一的素因子分解式。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.506,
                0.895,
                0.561
            ],
            "angle": 0,
            "content": "我们会解释如何求解线性同余方程，以及用著名的中国余数定理来求解线性同余方程组。还将引入伪素数的概念，即伪装成素数的合数，并说明这个概念如何帮助我们快速产生素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.563,
                0.897,
                0.678
            ],
            "angle": 0,
            "content": "本章还将介绍数论的许多重要应用。特别是，利用数论来产生伪随机数、为计算机文件分配内存地址，以及找出在各种识别码中检错用的校验位。我们还将介绍密码学学科。数论无论是在数千年前最早使用的古典密码学还是在电子通信中扮演重要角色的现代密码学中都起着最根本的作用。我们将说明所讲的这些概念如何用在密码协议中，为共享密钥和发送签名消息而引入的协议。曾经被认为是最纯粹数学学科的数论已经成了为计算机和因特网提供安全的一个基本工具。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.679,
                0.9,
                0.737
            ],
            "angle": 0,
            "content": "最后需要注意的是，本章的目的是介绍数论中某些关键方面。就像本书所涵盖的其他主题一样，还有更多的东西需要学习。有兴趣的学生可以参考[Roll]，这是本书作者关于数论的教科书，其中更全面地探索了这个有趣的主题。"
        },
        {
            "type": "title",
            "bbox": [
                0.055,
                0.749,
                0.308,
                0.77
            ],
            "angle": 0,
            "content": "4.1 整除性和模算术"
        },
        {
            "type": "title",
            "bbox": [
                0.055,
                0.777,
                0.179,
                0.794
            ],
            "angle": 0,
            "content": "4.1.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.797,
                0.902,
                0.873
            ],
            "angle": 0,
            "content": "本节将要展开的内容是基于整除性的概念。一个整数被一个正整数除，得到一个商和一个余数。与这些余数打交道导致模算术，它在数学中起着重要的作用并广泛应用于计算机科学领域中。本章稍后还将讨论模算术的一些重要应用，包括生成伪随机数、为文件分配内存地址、构造校验位以及为信息加密。"
        },
        {
            "type": "title",
            "bbox": [
                0.055,
                0.883,
                0.179,
                0.9
            ],
            "angle": 0,
            "content": "4.1.2 除法"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.903,
                0.902,
                0.94
            ],
            "angle": 0,
            "content": "当一个整数除以第二个非零整数除的时候，商可能是也可能不是一个整数。例如，\\(12/3 = 4\\) 是整数，而 \\(11/4 = 2.75\\) 不是。这引出了定义1。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.141,
                0.041,
                0.177,
                0.054
            ],
            "angle": 0,
            "content": "214"
        },
        {
            "type": "header",
            "bbox": [
                0.223,
                0.04,
                0.288,
                0.054
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.103,
                0.951,
                0.158
            ],
            "angle": 0,
            "content": "定义1 如果 \\(a\\) 和 \\(b\\) 是整数且 \\(a \\neq 0\\)，我们称 \\(a\\) 整除 \\(b\\) 如果有整数 \\(c\\) 使得 \\(b = ac\\)，或者等价地，如果 \\(b / a\\) 是一个整数。当 \\(a\\) 整除 \\(b\\) 时，我们称 \\(a\\) 是 \\(b\\) 的一个因子或除数，而 \\(b\\) 是 \\(a\\) 的一个倍数。用记号 \\(a \\mid b\\) 表示 \\(a\\) 整除 \\(b\\)。当 \\(a\\) 不能整除 \\(b\\) 时则写成 \\(a \\nmid b\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.168,
                0.767,
                0.184
            ],
            "angle": 0,
            "content": "评注 可以用量词把 \\(a|b\\) 表示成 \\((\\exists c(ac = b)\\) ，其中论域是整数集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.188,
                0.641,
                0.203
            ],
            "angle": 0,
            "content": "在图1中，数轴显示的是哪些整数能被正整数 \\(d\\) 整除。"
        },
        {
            "type": "image",
            "bbox": [
                0.252,
                0.211,
                0.825,
                0.244
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.404,
                0.252,
                0.668,
                0.267
            ],
            "angle": 0,
            "content": "图1 能被正整数 \\(d\\) 整除的整数"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.282,
                0.435,
                0.299
            ],
            "angle": 0,
            "content": "例1 判断是否有 \\(3 \\mid 7\\) 和 \\(3 \\mid 12\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.305,
                0.863,
                0.321
            ],
            "angle": 0,
            "content": "解 可以看出 \\(3 \\nmid 7\\) ，因为 \\(7 / 3\\) 不是整数。另一方面，\\(3 \\mid 12\\) 成立，因为 \\(12 / 3 = 4\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.328,
                0.777,
                0.345
            ],
            "angle": 0,
            "content": "例2 令 \\(n\\) 和 \\(d\\) 为正整数。不超过 \\(n\\) 的正整数中有多少个能被 \\(d\\) 整除？"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.35,
                0.959,
                0.405
            ],
            "angle": 0,
            "content": "解 能被 \\(d\\) 整除的正整数都是具有 \\(dk\\) 形式的整数，其中 \\(k\\) 是正整数。因此，不超过 \\(n\\) 的正整数中能被 \\(d\\) 整除的正整数的个数等于满足 \\(0 < dk \\leqslant n\\) 或 \\(0 < k \\leqslant n / d\\) 的整数 \\(k\\) 的个数。所以，存在 \\(\\lfloor n / d \\rfloor\\) 个正整数既不超过 \\(n\\) 又能被 \\(d\\) 整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.408,
                0.536,
                0.424
            ],
            "angle": 0,
            "content": "定理1给出了整数整除性的一些基本性质。"
        },
        {
            "type": "text",
            "bbox": [
                0.16,
                0.434,
                0.551,
                0.45
            ],
            "angle": 0,
            "content": "定理1 令 \\(a, b, c\\) 为整数，其中 \\(a \\neq 0\\)。则"
        },
        {
            "type": "text",
            "bbox": [
                0.161,
                0.453,
                0.47,
                0.47
            ],
            "angle": 0,
            "content": "(i)如果 \\(a\\mid b\\) 和 \\(a\\mid c\\) ，则 \\(a\\mid (b + c)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.161,
                0.473,
                0.553,
                0.49
            ],
            "angle": 0,
            "content": "(ii) 如果 \\(a \\mid b\\)，那么对所有整数 \\(c\\) 都有 \\(a \\mid bc\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.161,
                0.493,
                0.417,
                0.51
            ],
            "angle": 0,
            "content": "(iii)如果 \\(a|b\\) ， \\(b\\mid c\\) ，则 \\(a\\mid c\\) 。"
        },
        {
            "type": "list",
            "bbox": [
                0.161,
                0.453,
                0.553,
                0.51
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.521,
                0.959,
                0.556
            ],
            "angle": 0,
            "content": "证明下面给出(i)的一个直接证明。假定 \\(a|b\\) 和 \\(a|c\\) 。则从整除性定义可知，存在整数 \\(s\\) 和 \\(t\\) 满足 \\(b = as\\) 和 \\(c = at\\) 。因此"
        },
        {
            "type": "equation",
            "bbox": [
                0.414,
                0.561,
                0.652,
                0.575
            ],
            "angle": 0,
            "content": "\\[\nb + c = a s + a t = a (s + t)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.579,
                0.863,
                0.595
            ],
            "angle": 0,
            "content": "于是， \\(a\\) 整除 \\(b + c\\) 。这就证明了定理中的(i)。（ii)和(iii)的证明留作练习3和练习4。"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.599,
                0.391,
                0.614
            ],
            "angle": 0,
            "content": "定理1有一个有用的推论。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.624,
                0.948,
                0.66
            ],
            "angle": 0,
            "content": "推论1 如果 \\(a, b, c\\) 是整数，其中 \\(a \\neq 0\\)，使得 \\(a \\mid b\\) 和 \\(a \\mid c\\)，那么当 \\(m\\) 和 \\(n\\) 是整数时有 \\(a \\mid mb + nc\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.672,
                0.957,
                0.709
            ],
            "angle": 0,
            "content": "证明采用直接证明法。由定理1中的(ii)可知，当 \\(m\\) 和 \\(n\\) 是整数时有 \\(a \\mid mb\\) 和 \\(a \\mid nc\\) 。再由定理1中的(i)可得 \\(a \\mid mb + nc\\) 。"
        },
        {
            "type": "title",
            "bbox": [
                0.109,
                0.721,
                0.283,
                0.737
            ],
            "angle": 0,
            "content": "4.1.3 除法算法"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.741,
                0.882,
                0.757
            ],
            "angle": 0,
            "content": "当一个整数被一个正整数除时，会得到一个商和一个余数，如下面除法算法所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.767,
                0.95,
                0.803
            ],
            "angle": 0,
            "content": "定理2 除法算法(division algorithm)。令 \\(a\\) 为整数，\\(d\\) 为正整数。则存在唯一的整数 \\(q\\) 和 \\(r\\)，满足 \\(0 \\leqslant r < d\\)，使得 \\(a = dq + r\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.149,
                0.813,
                0.682,
                0.829
            ],
            "angle": 0,
            "content": "我们将除法算法的证明放到5.2节。（参见例5和练习37。）"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.833,
                0.956,
                0.867
            ],
            "angle": 0,
            "content": "评注 定理2并不是一个真正的算法。（为什么不是呢？）尽管如此，我们还是使用它传统的名称。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.877,
                0.948,
                0.912
            ],
            "angle": 0,
            "content": "定义2 在除法算法的等式中，\\(d\\) 称为是除数，\\(a\\) 称为是被除数，\\(q\\) 称为是商，\\(r\\) 称为是余数。下面的记号用来表示商和余数。"
        },
        {
            "type": "equation",
            "bbox": [
                0.395,
                0.917,
                0.665,
                0.932
            ],
            "angle": 0,
            "content": "\\[\nq = a \\operatorname {d i v} d, \\quad r = a \\operatorname {m o d} d\n\\]"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.036,
                0.326,
                0.097,
                0.341
            ],
            "angle": 0,
            "content": "Extra Examples"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.652,
                0.041,
                0.785,
                0.057
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.831,
                0.043,
                0.866,
                0.056
            ],
            "angle": 0,
            "content": "215"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.098,
                0.895,
                0.134
            ],
            "angle": 0,
            "content": "评注 注意对于固定的 \\(d\\) 而言，\\(q = a \\operatorname{div} d\\) 和 \\(r = a \\bmod d\\) 两者均为整数集合上的函数。再者，当 \\(a\\) 是一个整数而 \\(d\\) 是一个正整数时，我们有 \\(a \\operatorname{div} d = \\lfloor a / d \\rfloor\\) 和 \\(a \\bmod d = a - d\\)。（参见练习24。）"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.137,
                0.306,
                0.153
            ],
            "angle": 0,
            "content": "例3和4解释除法算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.158,
                0.453,
                0.175
            ],
            "angle": 0,
            "content": "例3 当101除以11时商和余数是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.181,
                0.215,
                0.197
            ],
            "angle": 0,
            "content": "解 我们知道"
        },
        {
            "type": "equation",
            "bbox": [
                0.396,
                0.201,
                0.548,
                0.216
            ],
            "angle": 0,
            "content": "\\[\n1 0 1 = 1 1 \\cdot 9 + 2\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.22,
                0.677,
                0.236
            ],
            "angle": 0,
            "content": "因此，当101除以11时商为 \\(9 = 101\\) div11，而余数为 \\(2 = 101 \\mod 11\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.242,
                0.448,
                0.259
            ],
            "angle": 0,
            "content": "例4 当一11除以3时商和余数是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.265,
                0.215,
                0.281
            ],
            "angle": 0,
            "content": "解 我们知道"
        },
        {
            "type": "equation",
            "bbox": [
                0.384,
                0.285,
                0.556,
                0.301
            ],
            "angle": 0,
            "content": "\\[\n- 1 1 = 3 (- 4) + 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.304,
                0.687,
                0.32
            ],
            "angle": 0,
            "content": "因此，当-11除以3时商为 \\(-4 = -11\\) div3，而余数为 \\(1 = -11\\) mod3。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.323,
                0.532,
                0.339
            ],
            "angle": 0,
            "content": "注意余数不能是负数。因此，余数不是-2，即使"
        },
        {
            "type": "equation",
            "bbox": [
                0.384,
                0.344,
                0.556,
                0.358
            ],
            "angle": 0,
            "content": "\\[\n- 1 1 = 3 (- 3) - 2\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.362,
                0.306,
                0.378
            ],
            "angle": 0,
            "content": "因为 \\(r = -2\\) 不满足 \\(0 \\leqslant r < 3\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.381,
                0.609,
                0.397
            ],
            "angle": 0,
            "content": "注意整数 \\(a\\) 可被整数 \\(d\\) 整除当且仅当 \\(a\\) 被 \\(d\\) 除时余数为0。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.4,
                0.894,
                0.495
            ],
            "angle": 0,
            "content": "评注 一种编程语言可能有一两个模算术的运算符，记作 mod（在 BASIC、Maple、Mathematica、EXCEL 和 SQL 中）、%（在 C、C++、Java 和 Python 中）、rem（在 Ada 和 Lisp 中），或其他什么符号。在使用时要小心，因为对于 \\( a < 0 \\)，这些运算中有的会返回 \\( a - m \\lceil a / m \\rceil \\) 而不是 \\( a \\mod m = a - m \\lfloor a / m \\rfloor \\) （如练习 24 所示）。还有，与 \\( a \\mod m \\) 不同，这些运算中有些对于当 \\( m < 0 \\) 时，甚至当 \\( m = 0 \\) 时也有定义。"
        },
        {
            "type": "title",
            "bbox": [
                0.047,
                0.505,
                0.194,
                0.522
            ],
            "angle": 0,
            "content": "4.1.4 模算术"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.525,
                0.892,
                0.621
            ],
            "angle": 0,
            "content": "在某些场合我们只关心当一个整数除以一个正整数时所得的余数。比如，当我们问从现在开始再过50小时后（在24小时制的钟表上）是几点时，我们只想知道当50加上当前时间后除以24所得的余数。因为我们经常只对余数感兴趣，所以我们有一个特殊的记号。我们已经引入了记号 \\( a \\mod m \\) 表示当整数 \\( a \\) 除以正整数 \\( m \\) 时的余数。我们现在引入一个不同的但又相关的记号来表示当两个整数除以正整数 \\( m \\) 时具有同样的余数。"
        },
        {
            "type": "title",
            "bbox": [
                0.046,
                0.626,
                0.111,
                0.65
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.047,
                0.662,
                0.184,
                0.764
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.045,
                0.768,
                0.163,
                0.788
            ],
            "angle": 0,
            "content": "Hilton Archive/Getty Images"
        },
        {
            "type": "text",
            "bbox": [
                0.204,
                0.662,
                0.892,
                0.802
            ],
            "angle": 0,
            "content": "卡尔·弗里德里希·高斯（Karl Friedrich Gauss，1777—1855）高斯是一位泥瓦匠的儿子，是一个神童。10岁时即展现了非凡的潜力，当时他迅速解答了老师为了让班级找点事而出的难题。老师要求学生找出前100个正整数的和。高斯发现可以通过将这100个数分成50对来求和，每一对的和都是 \\(101:100 + 1\\) ，\\(99 + 2\\) ，…，\\(50 + 51\\) 。这个智慧的火花引起了包括布朗斯威克的费迪南德公爵在内的资助人的注意，是他们的资助高斯才得以在卡洛林学院和哥廷根大学学习。还学生时期，他就发明了最小平方法用于估计从实验结果得到的变量的最可能的值。1796年高斯在几何学做出了奠基性的发现，推动了自古以来已停滞不前的这一学科的发展。他证明了只"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.804,
                0.324,
                0.819
            ],
            "angle": 0,
            "content": "用圆规和直尺可以画出正17边形。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.821,
                0.891,
                0.872
            ],
            "angle": 0,
            "content": "1799年高斯给出了代数基本定理第一个严格的证明，该定理指出 \\(n\\) 次多项式在复数域中恰有 \\(n\\) 个根（重根以重数计算）。当他成功地用不充分的数据计算出人类首次发现的小行星谷神星的轨道时，高斯赢得了世界声誉。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.874,
                0.891,
                0.943
            ],
            "angle": 0,
            "content": "高斯被他同时代的数学家称为数学王子。尽管高斯以其在几何学、代数学、数学分析、天文学和物理学上的许多发现而知名，他对数论也有着特别的兴趣，这从他的名言可见一斑：“数学是科学的皇后，而数论则是数学的皇后。”1801年高斯出版的《算术研究》(Disquisitiones Arithmeticae)一书为现代数论奠定了基础。"
        },
        {
            "type": "text",
            "bbox": [
                0.907,
                0.241,
                0.967,
                0.258
            ],
            "angle": 0,
            "content": "Extra Examples"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.141,
                0.043,
                0.177,
                0.057
            ],
            "angle": 0,
            "content": "216"
        },
        {
            "type": "header",
            "bbox": [
                0.222,
                0.042,
                0.288,
                0.057
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.105,
                0.951,
                0.161
            ],
            "angle": 0,
            "content": "定义3 如果 \\(a\\) 和 \\(b\\) 为整数而 \\(m\\) 为正整数，则当 \\(m\\) 整除 \\(a - b\\) 时称 \\(a\\) 模 \\(m\\) 同余 \\(b\\) 。用记号 \\(a \\equiv b (\\bmod m)\\) 表示 \\(a\\) 模 \\(m\\) 同余 \\(b\\) 。我们称 \\(a \\equiv b (\\bmod m)\\) 为同余式（congruence），而那个 \\(m\\) 是它的模（modulus）。如果 \\(a\\) 和 \\(b\\) 不是模 \\(m\\) 同余的，则写成 \\(a \\not\\equiv b (\\bmod m)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.169,
                0.962,
                0.224
            ],
            "angle": 0,
            "content": "尽管两个记号 \\(a \\equiv b (\\bmod m)\\) 和 \\(a \\bmod m = b\\) 都包含“\\(\\bmod\\)”，但它们表示本质上不同的概念。第一个表示两个整数间的关系，而第二个表示一个函数。可是，关系式 \\(a \\equiv b (\\bmod m)\\) 和 \\(\\bmod m\\) 函数又紧密地相关，正如定理3所描述的。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.233,
                0.955,
                0.269
            ],
            "angle": 0,
            "content": "定理3 令 \\(a\\) 和 \\(b\\) 为整数，并令 \\(m\\) 为正整数。则 \\(a \\equiv b (\\bmod m)\\) 当且仅当 \\(a \\bmod m = b \\bmod m\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.279,
                0.962,
                0.314
            ],
            "angle": 0,
            "content": "定理3的证明留作练习21和22。回顾一下， \\(a \\bmod m\\) 和 \\(b \\bmod m\\) 分别是当 \\(a\\) 和 \\(b\\) 除以 \\(m\\) 时所得的余数。因此，定理3也就是说 \\(a \\equiv b (\\bmod m)\\) 当且仅当 \\(a\\) 和 \\(b\\) 在被 \\(m\\) 除时具有相同的余数。"
        },
        {
            "type": "text",
            "bbox": [
                0.159,
                0.319,
                0.627,
                0.336
            ],
            "angle": 0,
            "content": "例5 判断17是否模6同余5，24是否模6同余14。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.341,
                0.961,
                0.375
            ],
            "angle": 0,
            "content": "解 由于6整除 \\(17 - 5 = 12\\) ，所以 \\(17 \\equiv 5(\\mathrm{mod} 6)\\) 。可是，因为 \\(24 - 14 = 10\\) 不能被6整除，所以 \\(24 \\nmid 14(\\mathrm{mod} 6)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.379,
                0.962,
                0.414
            ],
            "angle": 0,
            "content": "伟大的德国数学家卡尔·弗里德里希·高斯在18世纪末创造了同余的概念。同余的概念在数论的发展中起着重要的作用。"
        },
        {
            "type": "text",
            "bbox": [
                0.16,
                0.417,
                0.561,
                0.433
            ],
            "angle": 0,
            "content": "定理4提供了一个很有用的方法来处理同余。"
        },
        {
            "type": "text",
            "bbox": [
                0.169,
                0.442,
                0.951,
                0.459
            ],
            "angle": 0,
            "content": "定理4 令 \\(m\\) 为正整数。整数 \\(a\\) 和 \\(b\\) 是模 \\(m\\) 同余的当且仅当存在整数 \\(k\\) 使得 \\(a = b + km\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.469,
                0.965,
                0.523
            ],
            "angle": 0,
            "content": "证明 如果 \\(a \\equiv b (\\bmod m)\\), 由同余的定义 (定义3), 可得 \\(m \\mid (a - b)\\) 。这表示存在整数 \\(k\\) 使得 \\(a - b = km\\), 于是 \\(a = b + km\\) 。反之, 如果存在整数 \\(k\\) 使得 \\(a = b + km\\), 则 \\(km = a - b\\) 。故, \\(m\\) 整除 \\(a - b\\), 所以 \\(a \\equiv b (\\bmod m)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.526,
                0.965,
                0.561
            ],
            "angle": 0,
            "content": "所有和 \\(a\\) 模 \\(m\\) 同余的整数集合称为 \\(a\\) 模 \\(m\\) 的同余类。在第9章中将证明有 \\(m\\) 个互不相交的模 \\(m\\) 等价类，而这些等价类的并就是整数集。"
        },
        {
            "type": "text",
            "bbox": [
                0.162,
                0.564,
                0.482,
                0.58
            ],
            "angle": 0,
            "content": "定理5说明加法和乘法是保同余的。"
        },
        {
            "type": "text",
            "bbox": [
                0.171,
                0.59,
                0.744,
                0.626
            ],
            "angle": 0,
            "content": "定理5 令 \\(m\\) 为正整数。如果 \\(a \\equiv b (\\bmod m)\\)，\\(c \\equiv d (\\bmod m)\\)，则 \\(a + c \\equiv b + d (\\bmod m)\\) 并且 \\(ac \\equiv bd (\\bmod m)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.635,
                0.966,
                0.669
            ],
            "angle": 0,
            "content": "证明采用直接证明法。因为 \\(a \\equiv b (\\bmod m)\\) 且 \\(c \\equiv d (\\bmod m)\\)，由定理4可知存在整数 \\(s\\) 和 \\(t\\) 使得 \\(b = a + sm\\) 和 \\(d = c + tm\\)。于是，"
        },
        {
            "type": "equation",
            "bbox": [
                0.318,
                0.673,
                0.772,
                0.689
            ],
            "angle": 0,
            "content": "\\[\nb + d = (a + s m) + (c + t m) = (a + c) + m (s + t)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.692,
                0.147,
                0.707
            ],
            "angle": 0,
            "content": "及"
        },
        {
            "type": "equation",
            "bbox": [
                0.331,
                0.712,
                0.76,
                0.726
            ],
            "angle": 0,
            "content": "\\[\nb d = (a + s m) (c + t m) = a c + m (a t + c s + s t m)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.73,
                0.168,
                0.745
            ],
            "angle": 0,
            "content": "因此"
        },
        {
            "type": "equation",
            "bbox": [
                0.357,
                0.75,
                0.735,
                0.764
            ],
            "angle": 0,
            "content": "\\[\na + c \\equiv b + d (\\mathrm {m o d} m)   \\text {及}   a c \\equiv b d (\\mathrm {m o d} m)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.163,
                0.77,
                0.714,
                0.787
            ],
            "angle": 0,
            "content": "例6 由于 \\(7 \\equiv 2(\\mathrm{mod}5)\\) 和 \\(11 \\equiv 1(\\mathrm{mod}5)\\)，所以从定理5可知"
        },
        {
            "type": "equation",
            "bbox": [
                0.398,
                0.793,
                0.697,
                0.808
            ],
            "angle": 0,
            "content": "\\[\n1 8 = 7 + 1 1 \\equiv 2 + 1 = 3 (\\mathrm {m o d} 5)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.812,
                0.147,
                0.827
            ],
            "angle": 0,
            "content": "且"
        },
        {
            "type": "equation",
            "bbox": [
                0.402,
                0.832,
                0.692,
                0.846
            ],
            "angle": 0,
            "content": "\\[\n7 7 = 7 \\cdot 1 1 \\equiv 2 \\cdot 1 = 2 (\\mathrm {m o d} 5)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.849,
                0.972,
                0.903
            ],
            "angle": 0,
            "content": "在处理同余时必须小心。有些我们可能期待为真的性质其实不然。例如，如果 \\(ac \\equiv bc \\pmod{m}\\)，同余式 \\(a \\equiv b \\pmod{m}\\) 可能是假的。类似地，如果 \\(a \\equiv b \\pmod{m}\\) 而 \\(c \\equiv d \\pmod{m}\\)，同余式 \\(a^c \\equiv b^d \\pmod{m}\\) 也可以是假的。（参见练习43。）"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.906,
                0.971,
                0.941
            ],
            "angle": 0,
            "content": "推论2给出了如何利用每个整数的 \\(\\mod m\\) 函数值找出两个整数的和与积的该函数的值。在5.4节需要用到该结论。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.653,
                0.042,
                0.785,
                0.059
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.832,
                0.043,
                0.868,
                0.057
            ],
            "angle": 0,
            "content": "217"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.105,
                0.51,
                0.122
            ],
            "angle": 0,
            "content": "推论2 令 \\(m\\) 是正整数，令 \\(a\\) 和 \\(b\\) 是整数。则"
        },
        {
            "type": "equation",
            "bbox": [
                0.249,
                0.126,
                0.693,
                0.14
            ],
            "angle": 0,
            "content": "\\[\n(a + b) \\bmod m = ((a \\bmod m) + (b \\bmod m)) \\bmod m\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.144,
                0.102,
                0.158
            ],
            "angle": 0,
            "content": "并且"
        },
        {
            "type": "equation",
            "bbox": [
                0.273,
                0.163,
                0.666,
                0.179
            ],
            "angle": 0,
            "content": "\\[\na b \\mod m = ((a \\mod m) (b \\mod m)) \\mod m 。\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.189,
                0.895,
                0.223
            ],
            "angle": 0,
            "content": "证明 根据 \\(\\mathrm{mod} m\\) 和模 \\(m\\) 同余的定义，可得 \\(a \\equiv (a \\bmod m) (\\bmod m)\\) 并且 \\(b \\equiv (b \\bmod m) (\\bmod m)\\)。因此，由定理 5 可得"
        },
        {
            "type": "equation",
            "bbox": [
                0.286,
                0.228,
                0.657,
                0.243
            ],
            "angle": 0,
            "content": "\\[\na + b \\equiv (a \\bmod m) + (b \\bmod m) (\\bmod m)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.247,
                0.077,
                0.261
            ],
            "angle": 0,
            "content": "和"
        },
        {
            "type": "equation",
            "bbox": [
                0.306,
                0.267,
                0.638,
                0.282
            ],
            "angle": 0,
            "content": "\\[\na b \\equiv (a \\bmod m) (b \\bmod m) (\\bmod m) 。\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.285,
                0.556,
                0.302
            ],
            "angle": 0,
            "content": "这个推论中的等式是从定理3的最后两个同余式得来的。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.305,
                0.898,
                0.34
            ],
            "angle": 0,
            "content": "在4.6节研究密码学时，我们会采用mod函数进行大量的计算。例7解释了我们会遇到的涉及mod函数的计算。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.345,
                0.411,
                0.362
            ],
            "angle": 0,
            "content": "例7 试计算 \\((19^{3} \\mod 31)^{4} \\mod 23\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.368,
                0.898,
                0.404
            ],
            "angle": 0,
            "content": "解为了计算 \\((19^{3} \\mod 31)^{4} \\mod 23\\) ，我们需要先计算 \\(19^{3} \\mod 31\\) 。因为 \\(19^{3} = 6859\\) 且 \\(6859 = 221 \\cdot 31 + 8\\) ，我们有 \\(19^{3} \\mod 31 = 6859 \\mod 31 = 8\\) 。因此，\\((19^{3} \\mod 31)^{4} \\mod 23 = 8^{4} \\mod 23\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.407,
                0.9,
                0.442
            ],
            "angle": 0,
            "content": "接下来，注意到 \\(8^{4} = 4096\\) ，因为 \\(4096 = 178 \\cdot 23 + 2\\) ，我们有 \\(4096 \\mod 23 = 2\\) 。故 \\((19^{3} \\mod 31)^{4} \\mod 23 = 2\\) 。"
        },
        {
            "type": "title",
            "bbox": [
                0.051,
                0.454,
                0.231,
                0.47
            ],
            "angle": 0,
            "content": "4.1.5 模 \\(m\\) 算术"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.475,
                0.899,
                0.511
            ],
            "angle": 0,
            "content": "我们可以在 \\(\\mathbf{Z}_m\\) ，即小于 \\(m\\) 的非负整数的集合 \\(\\{0,1,\\dots ,m - 1\\}\\) 上定义算术运算。特别是，我们定义这些整数的加法（用 \\(+\\) 表示）如下"
        },
        {
            "type": "equation",
            "bbox": [
                0.367,
                0.515,
                0.582,
                0.53
            ],
            "angle": 0,
            "content": "\\[\na + _ {m} b = (a + b) \\mathbf {m o d} m\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.534,
                0.744,
                0.55
            ],
            "angle": 0,
            "content": "这里等式右边的加法是普通的整数加法，我们定义这些整数的乘法 \\((\\cdot_{m})\\) 如下"
        },
        {
            "type": "equation",
            "bbox": [
                0.373,
                0.554,
                0.578,
                0.569
            ],
            "angle": 0,
            "content": "\\[\na \\cdot_ {m} b = (a \\cdot b) \\bmod m\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.573,
                0.899,
                0.608
            ],
            "angle": 0,
            "content": "这里等式右边的乘法是普通的整数乘法。运算 \\(+\\) 和 \\(\\cdot\\) 称为模 \\(m\\) 加法和乘法，当使用到这些运算时，我们说是在进行模 \\(m\\) 算术。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.614,
                0.625,
                0.632
            ],
            "angle": 0,
            "content": "例8 利用 \\(\\mathbf{Z}_m\\) 中加法和乘法的定义，计算 \\(7 + _{11}9\\) 及 \\(7\\cdot_{11}9\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.636,
                0.5,
                0.653
            ],
            "angle": 0,
            "content": "解 利用模11加法和乘法的定义，可以得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.286,
                0.656,
                0.665,
                0.671
            ],
            "angle": 0,
            "content": "\\[\n7 + _ {1 1} 9 = (7 + 9) \\bmod 1 1 = 1 6 \\bmod 1 1 = 5\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.675,
                0.079,
                0.69
            ],
            "angle": 0,
            "content": "和"
        },
        {
            "type": "equation",
            "bbox": [
                0.292,
                0.695,
                0.661,
                0.71
            ],
            "angle": 0,
            "content": "\\[\n7 \\cdot_ {1 1} 9 = (7 \\cdot 9) \\bmod 1 1 = 6 3 \\bmod 1 1 = 8\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.713,
                0.275,
                0.729
            ],
            "angle": 0,
            "content": "故 \\(7 + _{11}9 = 5\\) ， \\(7\\cdot_{11}9 = 8\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.733,
                0.856,
                0.749
            ],
            "angle": 0,
            "content": "运算 \\(+\\) 和 \\(\\cdot_{m}\\) 满足普通整数加法和乘法的许多同样的性质。特别是，满足这些性质："
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.753,
                0.641,
                0.769
            ],
            "angle": 0,
            "content": "封闭性：如果 \\(a\\) 和 \\(b\\) 属于 \\(\\mathbf{Z}_m\\) ，则 \\(a + _m b\\) 和 \\(a\\cdot_{m}b\\) 也属于 \\(\\mathbf{Z}_m\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.772,
                0.901,
                0.789
            ],
            "angle": 0,
            "content": "结合律：如果 \\(a, b\\) 和 \\(c\\) 属于 \\(\\mathbf{Z}_m\\)，则有 \\((a + _{m}b) + _{m}c = a + _{m}(b + _{m}c)\\) 和 \\((a\\cdot_{m}b)\\cdot_{m}c = a\\cdot_{m}(b\\cdot_{m}c)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.792,
                0.697,
                0.808
            ],
            "angle": 0,
            "content": "交换律：如果 \\(a\\) 和 \\(b\\) 属于 \\(\\mathbf{Z}_m\\) ，则 \\(a + _m b = b + _m a\\) 和 \\(a\\cdot_{m}b = b\\cdot_{m}a\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.812,
                0.9,
                0.846
            ],
            "angle": 0,
            "content": "单位元：元素0和1分别是模 \\(m\\) 加法和乘法的单位元。即，如果 \\(a\\) 属于 \\(\\mathbf{Z}_m\\) ，则 \\(a + _{m}0 = 0 + _{m}a = a\\) 和 \\(a\\cdot_{m}1 = 1\\cdot_{m}a = a\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.85,
                0.9,
                0.885
            ],
            "angle": 0,
            "content": "加法逆元：如果 \\(a \\neq 0\\) 属于 \\(\\mathbf{Z}_m\\)，则 \\(m - a\\) 是 \\(a\\) 的模 \\(m\\) 加法逆元，而 0 是其自身的加法逆元。即 \\(a + _{m}(m - a) = 0\\) 且 \\(0 + _{m}0 = 0\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.889,
                0.9,
                0.924
            ],
            "angle": 0,
            "content": "分配律：如果 \\(a, b\\) 和 \\(c\\) 属于 \\(\\mathbf{Z}_m\\)，则 \\(a \\cdot_m (b + _mc) = (a \\cdot_m b) + _m (a \\cdot_m c)\\) 和 \\((a + _mc) \\cdot _mc = (a \\cdot_m c) + _m (b \\cdot_m c)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.927,
                0.9,
                0.943
            ],
            "angle": 0,
            "content": "这些性质是在整数性质的基础上通过模 \\(m\\) 同余式和余数的性质得出的，其证明留作练习。"
        },
        {
            "type": "image",
            "bbox": [
                0.911,
                0.19,
                0.941,
                0.215
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.14,
                0.041,
                0.177,
                0.055
            ],
            "angle": 0,
            "content": "218"
        },
        {
            "type": "header",
            "bbox": [
                0.222,
                0.04,
                0.288,
                0.055
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.097,
                0.959,
                0.151
            ],
            "angle": 0,
            "content": "\\(48\\sim 50\\) 。注意这里列出了 \\(\\mathbf{Z}_m\\) 中的每个元素都有一个加法逆元的性质，但是没有包括类似乘法逆元的性质。这是因为模 \\(m\\) 乘法逆元并不一定存在。例如，2 的模 6 乘法逆元就不存在，读者可以自行验证。在本章稍后我们会讨论什么时候一个整数会有模 \\(m\\) 乘法逆元。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.154,
                0.959,
                0.208
            ],
            "angle": 0,
            "content": "评注 因为带有模 \\(m\\) 加法和乘法运算的 \\(\\mathbf{Z}_m\\) 满足上面所列的性质，所以 \\(\\mathbf{Z}_m\\) 连同模加法被称为一个交换群，而 \\(\\mathbf{Z}_m\\) 连同这两个运算被称为一个交换环。注意整数集合加上普通的加法和乘法也构成一个交换环。群和环是有关抽象代数课程所研究的对象。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.211,
                0.959,
                0.247
            ],
            "angle": 0,
            "content": "评注 在练习36及后续章节中，当涉及 \\(\\mathbf{Z}_m\\) 时我们会用不带下标 \\(m\\) 的十和·记号来代表运算符号 \\(+\\) 和 \\(\\cdot_{m}\\) 。"
        },
        {
            "type": "title",
            "bbox": [
                0.111,
                0.258,
                0.159,
                0.273
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.278,
                0.32,
                0.292
            ],
            "angle": 0,
            "content": "1. 17 能整除下列各数吗？"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.296,
                0.177,
                0.31
            ],
            "angle": 0,
            "content": "a)68"
        },
        {
            "type": "text",
            "bbox": [
                0.338,
                0.296,
                0.377,
                0.31
            ],
            "angle": 0,
            "content": "b)84"
        },
        {
            "type": "text",
            "bbox": [
                0.541,
                0.296,
                0.589,
                0.31
            ],
            "angle": 0,
            "content": "c)357"
        },
        {
            "type": "text",
            "bbox": [
                0.751,
                0.296,
                0.81,
                0.309
            ],
            "angle": 0,
            "content": "d)1001"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.313,
                0.397,
                0.328
            ],
            "angle": 0,
            "content": "2. 证明如果 \\(a\\) 是不为0的整数，则"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.331,
                0.228,
                0.345
            ],
            "angle": 0,
            "content": "a)1整除 \\( a \\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.54,
                0.331,
                0.635,
                0.345
            ],
            "angle": 0,
            "content": "b) \\(a\\) 整除0。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.348,
                0.378,
                0.363
            ],
            "angle": 0,
            "content": "3. 证明定理1的第(ii)部分成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.366,
                0.382,
                0.381
            ],
            "angle": 0,
            "content": "4. 证明定理1的第(iii)部分成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.385,
                0.638,
                0.4
            ],
            "angle": 0,
            "content": "5. 证明如果 \\(a \\mid b\\) 且 \\(b \\mid a\\)，其中 \\(a\\) 和 \\(b\\) 为整数，则 \\(a = b\\) 或 \\(a = -b\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.404,
                0.67,
                0.42
            ],
            "angle": 0,
            "content": "6. 证明如果 \\(a, b, c\\) 和 \\(d\\) 为整数且 \\(a \\neq 0\\) 使得 \\(a \\mid c\\) 及 \\(b \\mid d\\)，则 \\(ab \\mid cd\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.424,
                0.682,
                0.44
            ],
            "angle": 0,
            "content": "7. 证明如果 \\(a, b, c\\) 为整数，其中 \\(a \\neq 0\\) 且 \\(c \\neq 0\\)，使得 \\(ac \\mid bc\\)，则 \\(a \\mid b\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.444,
                0.744,
                0.46
            ],
            "angle": 0,
            "content": "8. 证明或反驳如果 \\(a \\mid bc\\)；这里 \\(a, b, c\\) 均为正整数且 \\(a \\neq 0\\)，则 \\(a \\mid b\\) 或者 \\(a \\mid c\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.463,
                0.619,
                0.478
            ],
            "angle": 0,
            "content": "9. 证明如果 \\(a\\) 和 \\(b\\) 是整数且 \\(a\\) 整除 \\(b\\)，则 \\(a\\) 是奇数或 \\(b\\) 是偶数。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.481,
                0.692,
                0.496
            ],
            "angle": 0,
            "content": "10. 证明如果 \\(a\\) 和 \\(b\\) 是非0整数，\\(a\\) 整除 \\(b\\) 且 \\(a + b\\) 是奇数，则 \\(a\\) 是奇数。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.499,
                0.673,
                0.514
            ],
            "angle": 0,
            "content": "11. 证明如果 \\(a\\) 是整数且不能被3整除，则 \\((a + 1)(a + 2)\\) 能被3整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.516,
                0.501,
                0.531
            ],
            "angle": 0,
            "content": "12. 证明如果 \\(a\\) 是正整数，则4不能整除 \\(a^2 + 2\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.534,
                0.378,
                0.548
            ],
            "angle": 0,
            "content": "13. 下列各式的商和余数是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.551,
                0.239,
                0.566
            ],
            "angle": 0,
            "content": "a)19除以7"
        },
        {
            "type": "text",
            "bbox": [
                0.336,
                0.551,
                0.468,
                0.566
            ],
            "angle": 0,
            "content": "b)-111除以11"
        },
        {
            "type": "text",
            "bbox": [
                0.54,
                0.552,
                0.652,
                0.566
            ],
            "angle": 0,
            "content": "c)789除以23"
        },
        {
            "type": "text",
            "bbox": [
                0.751,
                0.552,
                0.874,
                0.565
            ],
            "angle": 0,
            "content": "d)1001除以13"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.57,
                0.237,
                0.584
            ],
            "angle": 0,
            "content": "e)0除以19"
        },
        {
            "type": "text",
            "bbox": [
                0.336,
                0.57,
                0.42,
                0.584
            ],
            "angle": 0,
            "content": "f03除以5"
        },
        {
            "type": "text",
            "bbox": [
                0.54,
                0.57,
                0.644,
                0.584
            ],
            "angle": 0,
            "content": "g)-1除以3"
        },
        {
            "type": "text",
            "bbox": [
                0.751,
                0.57,
                0.837,
                0.584
            ],
            "angle": 0,
            "content": "h)4除以1"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.587,
                0.378,
                0.602
            ],
            "angle": 0,
            "content": "14. 下列各式的商和余数是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.605,
                0.239,
                0.619
            ],
            "angle": 0,
            "content": "a)44除以8"
        },
        {
            "type": "text",
            "bbox": [
                0.336,
                0.605,
                0.449,
                0.619
            ],
            "angle": 0,
            "content": "b)777除以21"
        },
        {
            "type": "text",
            "bbox": [
                0.54,
                0.605,
                0.671,
                0.619
            ],
            "angle": 0,
            "content": "c)-123除以19"
        },
        {
            "type": "text",
            "bbox": [
                0.751,
                0.605,
                0.864,
                0.619
            ],
            "angle": 0,
            "content": "d)-1除以23"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.623,
                0.282,
                0.637
            ],
            "angle": 0,
            "content": "e)-2002除以87"
        },
        {
            "type": "text",
            "bbox": [
                0.336,
                0.623,
                0.429,
                0.637
            ],
            "angle": 0,
            "content": "f)0除以17"
        },
        {
            "type": "text",
            "bbox": [
                0.54,
                0.623,
                0.715,
                0.637
            ],
            "angle": 0,
            "content": "g)1234567除以1001"
        },
        {
            "type": "text",
            "bbox": [
                0.751,
                0.623,
                0.891,
                0.637
            ],
            "angle": 0,
            "content": "h)-100除以101"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.64,
                0.457,
                0.655
            ],
            "angle": 0,
            "content": "15. 12小时制的钟表上显示的时间是几点？"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.658,
                0.324,
                0.672
            ],
            "angle": 0,
            "content": "a)11点之后的80小时"
        },
        {
            "type": "text",
            "bbox": [
                0.336,
                0.658,
                0.518,
                0.672
            ],
            "angle": 0,
            "content": "b)12点之前的40小时"
        },
        {
            "type": "text",
            "bbox": [
                0.54,
                0.658,
                0.72,
                0.672
            ],
            "angle": 0,
            "content": "c)6点之后的100小时"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.676,
                0.457,
                0.69
            ],
            "angle": 0,
            "content": "16. 24小时制的钟表上显示的时间是几点？"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.693,
                0.324,
                0.708
            ],
            "angle": 0,
            "content": "a)2点之后的100小时"
        },
        {
            "type": "text",
            "bbox": [
                0.336,
                0.693,
                0.518,
                0.708
            ],
            "angle": 0,
            "content": "b)12点之前的45小时"
        },
        {
            "type": "text",
            "bbox": [
                0.54,
                0.694,
                0.729,
                0.708
            ],
            "angle": 0,
            "content": "c)19点之后的168小时"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.711,
                0.859,
                0.726
            ],
            "angle": 0,
            "content": "17. 假设 \\(a\\) 和 \\(b\\) 是整数，\\(a \\equiv 4 (\\mathrm{mod} 13)\\) 且 \\(b \\equiv 9 (\\mathrm{mod} 13)\\) 。试找出满足 \\(0 \\leqslant c \\leqslant 12\\) 的整数 \\(c\\) 使得"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.729,
                0.282,
                0.743
            ],
            "angle": 0,
            "content": "a) \\(c\\equiv 9a\\) (mod 13)"
        },
        {
            "type": "text",
            "bbox": [
                0.336,
                0.729,
                0.484,
                0.742
            ],
            "angle": 0,
            "content": "b) \\(c\\equiv 11b(\\mathrm{mod} 13)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.54,
                0.729,
                0.696,
                0.742
            ],
            "angle": 0,
            "content": "c) \\( c \\equiv a + b (\\mathrm{mod} 13) \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.751,
                0.729,
                0.926,
                0.742
            ],
            "angle": 0,
            "content": "\\(\\mathbf{d})c\\equiv 2a + 3b(\\mathrm{mod}13)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.746,
                0.314,
                0.76
            ],
            "angle": 0,
            "content": "e) \\(c\\equiv a^2 +b^2\\) (mod 13)"
        },
        {
            "type": "text",
            "bbox": [
                0.336,
                0.746,
                0.507,
                0.76
            ],
            "angle": 0,
            "content": "f) \\(c \\equiv a^3 - b^3 \\pmod{13}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.764,
                0.868,
                0.779
            ],
            "angle": 0,
            "content": "18. 假设 \\(a\\) 和 \\(b\\) 是整数，\\(a \\equiv 11 (\\mod 19)\\) 且 \\(b \\equiv 3 (\\mod 19)\\)。试找出满足 \\(0 \\leqslant c \\leqslant 18\\) 的整数 \\(c\\) 使得"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.782,
                0.292,
                0.796
            ],
            "angle": 0,
            "content": "a) \\(c\\equiv 13a(\\mathrm{mod} 19)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.336,
                0.782,
                0.475,
                0.796
            ],
            "angle": 0,
            "content": "b) \\(c\\equiv 8b(\\mathrm{mod}19)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.54,
                0.782,
                0.696,
                0.796
            ],
            "angle": 0,
            "content": "c) \\( c \\equiv a - b (\\mathrm{mod} 19) \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.751,
                0.782,
                0.926,
                0.796
            ],
            "angle": 0,
            "content": "\\(\\mathrm{d})c\\equiv 7a + 3b(\\mathrm{mod}19)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.8,
                0.332,
                0.814
            ],
            "angle": 0,
            "content": "e) \\(c\\equiv 2a^2 +3b^2 (\\mathrm{mod} 19)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.336,
                0.8,
                0.517,
                0.814
            ],
            "angle": 0,
            "content": "f) \\(c\\equiv a^3 +4b^3 (\\mathrm{mod} 19)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.818,
                0.728,
                0.832
            ],
            "angle": 0,
            "content": "19. 证明如果 \\(a\\) 和 \\(b\\) 是正整数，则 \\((-a)\\) div \\(d = -a\\) div \\(d\\) 当且仅当 \\(d\\) 整除 \\(a\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.836,
                0.785,
                0.85
            ],
            "angle": 0,
            "content": "20. 证明或反驳如果 \\(a, b\\) 和 \\(d\\) 是整数，且 \\(d > 0\\)，则 \\((a + b) \\operatorname{div} d = a \\operatorname{div} d + b \\operatorname{div} d\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.853,
                0.668,
                0.867
            ],
            "angle": 0,
            "content": "21. 令 \\( m \\) 为正整数。证明如果 \\( a \\bmod m = b \\bmod m \\)，则 \\( a \\equiv b (\\bmod m) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.871,
                0.668,
                0.885
            ],
            "angle": 0,
            "content": "22. 令 \\( m \\) 为正整数。证明如果 \\( a \\equiv b (\\bmod m) \\)，则 \\( a \\bmod m = b \\bmod m \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.888,
                0.614,
                0.903
            ],
            "angle": 0,
            "content": "23. 证明如果 \\(n\\) 和 \\(k\\) 均为正整数，则有 \\(\\lceil n / k \\rceil = \\lfloor (n - 1) / k \\rfloor + 1\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.905,
                0.914,
                0.921
            ],
            "angle": 0,
            "content": "24. 证明如果 \\(a\\) 为整数而 \\(d\\) 是大于1的正整数，则 \\(a\\) 除以 \\(d\\) 的商和余数分别是 \\(\\lfloor a / d\\rfloor\\) 和 \\(a - d\\lfloor a / d\\rfloor\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.924,
                0.793,
                0.939
            ],
            "angle": 0,
            "content": "25. 试找出与整数 \\( a \\) 模 \\( m \\) 同余的绝对值最小的整数的计算公式，这里 \\( m \\) 为一正整数。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.659,
                0.037,
                0.792,
                0.052
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.838,
                0.038,
                0.874,
                0.052
            ],
            "angle": 0,
            "content": "219"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.094,
                0.209,
                0.108
            ],
            "angle": 0,
            "content": "26. 计算下列各量："
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.113,
                0.199,
                0.126
            ],
            "angle": 0,
            "content": "a)-17 mod 2"
        },
        {
            "type": "text",
            "bbox": [
                0.279,
                0.112,
                0.383,
                0.126
            ],
            "angle": 0,
            "content": "b)144 mod 7"
        },
        {
            "type": "text",
            "bbox": [
                0.484,
                0.113,
                0.613,
                0.126
            ],
            "angle": 0,
            "content": "c)-101 mod 13"
        },
        {
            "type": "text",
            "bbox": [
                0.695,
                0.113,
                0.807,
                0.126
            ],
            "angle": 0,
            "content": "d)199 mod 19"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.13,
                0.208,
                0.144
            ],
            "angle": 0,
            "content": "27. 计算下列各量："
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.148,
                0.18,
                0.162
            ],
            "angle": 0,
            "content": "a)13 mod 3"
        },
        {
            "type": "text",
            "bbox": [
                0.279,
                0.148,
                0.4,
                0.162
            ],
            "angle": 0,
            "content": "b)-97 mod 11"
        },
        {
            "type": "text",
            "bbox": [
                0.484,
                0.148,
                0.594,
                0.162
            ],
            "angle": 0,
            "content": "c)155 mod 19"
        },
        {
            "type": "text",
            "bbox": [
                0.695,
                0.148,
                0.826,
                0.162
            ],
            "angle": 0,
            "content": "d)-221 mod 23"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.166,
                0.285,
                0.179
            ],
            "angle": 0,
            "content": "28. 找出 \\(a \\operatorname{div} m\\) 和 \\(a \\mod m\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.185,
                0.258,
                0.198
            ],
            "angle": 0,
            "content": "a) \\( a = -111 \\)，\\( m = 99 \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.484,
                0.185,
                0.675,
                0.198
            ],
            "angle": 0,
            "content": "b) \\(a = -9999\\) ， \\(m = 101\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.203,
                0.272,
                0.216
            ],
            "angle": 0,
            "content": "c) \\(a = 10299\\) ， \\(m = 999\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.484,
                0.203,
                0.69,
                0.216
            ],
            "angle": 0,
            "content": "d) \\(a = 123456\\) ， \\(m = 1001\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.22,
                0.284,
                0.233
            ],
            "angle": 0,
            "content": "29. 找出 \\(a \\operatorname{div} m\\) 和 \\(a \\mod m\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.239,
                0.248,
                0.252
            ],
            "angle": 0,
            "content": "a) \\( a = 228 \\)，\\( m = 119 \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.484,
                0.239,
                0.656,
                0.252
            ],
            "angle": 0,
            "content": "b) \\(a = 9009\\) ， \\(m = 223\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.257,
                0.289,
                0.27
            ],
            "angle": 0,
            "content": "c) \\(a = -10101\\) ， \\(m = 333\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.484,
                0.257,
                0.72,
                0.27
            ],
            "angle": 0,
            "content": "d) \\(a = -765432\\) ， \\(m = 38271\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.274,
                0.218,
                0.288
            ],
            "angle": 0,
            "content": "30.找出整数 \\(\\alpha\\) 使得"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.292,
                0.348,
                0.307
            ],
            "angle": 0,
            "content": "a) \\( a \\equiv 43 (\\mathrm{mod} 23) \\) 且 \\( -22 \\leqslant a \\leqslant 0 \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.484,
                0.293,
                0.755,
                0.306
            ],
            "angle": 0,
            "content": "b) \\(a \\equiv 17 (\\mathrm{mod} 29)\\) 且 \\(-14 \\leqslant a \\leqslant 14\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.311,
                0.369,
                0.324
            ],
            "angle": 0,
            "content": "c) \\(a \\equiv -11 \\pmod{21}\\) 且 \\(90 \\leqslant a \\leqslant 110\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.328,
                0.217,
                0.342
            ],
            "angle": 0,
            "content": "31. 找出整数 \\(a\\) 使得"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.346,
                0.365,
                0.361
            ],
            "angle": 0,
            "content": "a) \\( a \\equiv -15 (\\mathrm{mod} 27) \\) 且 \\( -26 \\leqslant a \\leqslant 0 \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.484,
                0.347,
                0.754,
                0.36
            ],
            "angle": 0,
            "content": "b) \\(a \\equiv 24(\\mathrm{mod}31)\\) 且 \\(-15 \\leqslant a \\leqslant 15\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.365,
                0.359,
                0.378
            ],
            "angle": 0,
            "content": "c) \\(a \\equiv 99 (\\mathrm{mod} 41)\\) 且 \\(100 \\leqslant a \\leqslant 140\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.382,
                0.346,
                0.396
            ],
            "angle": 0,
            "content": "32. 列出5个模12同余于4的整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.399,
                0.521,
                0.414
            ],
            "angle": 0,
            "content": "33. 列出在 \\(-100\\) 到 \\(100\\) 之间所有模25同余于-1的整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.418,
                0.369,
                0.432
            ],
            "angle": 0,
            "content": "34. 判断下列各整数是否模7同余于3。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.437,
                0.124,
                0.449
            ],
            "angle": 0,
            "content": "a)37"
        },
        {
            "type": "text",
            "bbox": [
                0.279,
                0.437,
                0.318,
                0.449
            ],
            "angle": 0,
            "content": "b)66"
        },
        {
            "type": "text",
            "bbox": [
                0.484,
                0.437,
                0.539,
                0.449
            ],
            "angle": 0,
            "content": "c)-17"
        },
        {
            "type": "text",
            "bbox": [
                0.694,
                0.437,
                0.751,
                0.449
            ],
            "angle": 0,
            "content": "d)-67"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.454,
                0.377,
                0.468
            ],
            "angle": 0,
            "content": "35. 判断下列各整数是否模17同余于5。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.473,
                0.124,
                0.485
            ],
            "angle": 0,
            "content": "a)80"
        },
        {
            "type": "text",
            "bbox": [
                0.279,
                0.473,
                0.326,
                0.485
            ],
            "angle": 0,
            "content": "b)103"
        },
        {
            "type": "text",
            "bbox": [
                0.484,
                0.473,
                0.539,
                0.485
            ],
            "angle": 0,
            "content": "c)-29"
        },
        {
            "type": "text",
            "bbox": [
                0.694,
                0.473,
                0.761,
                0.485
            ],
            "angle": 0,
            "content": "d)-122"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.49,
                0.179,
                0.504
            ],
            "angle": 0,
            "content": "36. 找出下列值"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.508,
                0.377,
                0.522
            ],
            "angle": 0,
            "content": "a) \\((177\\mod 31 + 270\\mod 31)\\mod 31\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.484,
                0.509,
                0.775,
                0.522
            ],
            "angle": 0,
            "content": "b) (177 mod 31 · 270 mod 31) mod 31"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.526,
                0.179,
                0.54
            ],
            "angle": 0,
            "content": "37. 找出下列值"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.544,
                0.396,
                0.557
            ],
            "angle": 0,
            "content": "a) \\((-133 \\mod 23 + 261 \\mod 23) \\mod 23\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.484,
                0.544,
                0.776,
                0.557
            ],
            "angle": 0,
            "content": "b) (457 mod 23 · 182 mod 23) mod 23"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.562,
                0.179,
                0.575
            ],
            "angle": 0,
            "content": "38. 找出下列值"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.58,
                0.257,
                0.594
            ],
            "angle": 0,
            "content": "a) \\((19^{2}\\mod 41)\\mod 9\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.484,
                0.58,
                0.676,
                0.593
            ],
            "angle": 0,
            "content": "b) \\((32^{3} \\mod 13)^{2} \\mod 11\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.598,
                0.267,
                0.611
            ],
            "angle": 0,
            "content": "c) \\((7^{3} \\mod 23)^{2} \\mod 31\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.484,
                0.598,
                0.677,
                0.611
            ],
            "angle": 0,
            "content": "d) \\((21^{2} \\mod 15)^{3} \\mod 22\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.616,
                0.179,
                0.629
            ],
            "angle": 0,
            "content": "39.找出下列值"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.634,
                0.278,
                0.647
            ],
            "angle": 0,
            "content": "a) \\((99^{2}\\mod 32)^{3}\\mod 15\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.484,
                0.634,
                0.666,
                0.647
            ],
            "angle": 0,
            "content": "b) \\((3^4\\bmod 17)^2\\bmod 11\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.652,
                0.277,
                0.665
            ],
            "angle": 0,
            "content": "c) \\((19^{3} \\mod 23)^{2} \\mod 31\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.484,
                0.652,
                0.677,
                0.665
            ],
            "angle": 0,
            "content": "d) \\((89^{3}\\mod 79)^{4}\\mod 26\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.67,
                0.897,
                0.701
            ],
            "angle": 0,
            "content": "40. 证明：如果 \\(a \\equiv b (\\bmod m)\\)，\\(c \\equiv d (\\bmod m)\\)，其中 \\(a, b, c, d\\) 和 \\(m\\) 为整数，且 \\(m \\geqslant 2\\) 则 \\(a - c \\equiv b - d (\\bmod m)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.706,
                0.886,
                0.721
            ],
            "angle": 0,
            "content": "41. 证明：如果 \\( n \\mid m \\)，\\( n \\) 和 \\( m \\) 为大于 1 的整数，并且如果 \\( a \\equiv b (\\bmod m) \\)，其中 \\( a, b \\) 为整数，则 \\( a \\equiv b (\\bmod n) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.022,
                0.725,
                0.812,
                0.739
            ],
            "angle": 0,
            "content": "42. 证明：如果 \\(a, b, c\\) 和 \\(m\\) 为整数使得 \\(m \\geqslant 2, c > 0\\)，且 \\(a \\equiv b (\\bmod m)\\)，则 \\(ac \\equiv bc (\\bmod mc)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.743,
                0.354,
                0.757
            ],
            "angle": 0,
            "content": "43. 试举出下列关于同余描述的反例。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.761,
                0.731,
                0.775
            ],
            "angle": 0,
            "content": "a)如果 \\(ac\\equiv bc(\\mathrm{mod}m)\\) ，其中 \\(a\\) ， \\(b\\) ， \\(c\\) 和 \\(m\\) 为整数，且 \\(m\\geqslant 2\\) ，则 \\(a\\equiv b(\\mathrm{mod}m)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.779,
                0.898,
                0.811
            ],
            "angle": 0,
            "content": "b)如果 \\(a\\equiv b(\\mathrm{mod}  m)\\) ， \\(c\\equiv d(\\mathrm{mod}  m)\\) ，其中 \\(a\\) ， \\(b\\) ， \\(c\\) ， \\(d\\) ， \\(m\\) 均为整数，且 \\(c\\) ， \\(d\\) 为正整数， \\(m\\geqslant 2\\) ，则\\(a^c\\equiv b^d (\\mathrm{mod}  m)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.815,
                0.489,
                0.829
            ],
            "angle": 0,
            "content": "44. 证明：如果 \\( n \\) 是一个整数，则 \\( n^2 \\equiv 0 \\) 或 \\( 1 (\\mathrm{mod} 4) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.833,
                0.898,
                0.864
            ],
            "angle": 0,
            "content": "45. 利用练习 44 证明：如果 \\( m \\) 是一个形如 \\( 4k + 3 \\) 的正整数（\\( k \\) 为非负整数），则 \\( m \\) 就不是两个整数的平方和。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.869,
                0.489,
                0.882
            ],
            "angle": 0,
            "content": "46. 证明：如果 \\( n \\) 是一个奇正整数，则 \\( n^2 \\equiv 1 (\\mathrm{mod} 8) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.887,
                0.816,
                0.901
            ],
            "angle": 0,
            "content": "47. 证明：如果 \\(a, b, k, m\\) 为整数使得 \\(k \\geqslant 1, m \\geqslant 2\\)，并且 \\(a \\equiv b (\\bmod m)\\)，则 \\(a^k \\equiv b^k (\\bmod m)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.905,
                0.898,
                0.937
            ],
            "angle": 0,
            "content": "48. 证明带有模 \\(m\\) 加法的 \\(\\mathbf{Z}_m\\) 满足封闭性、结合律、交换律，0 是加法单位元，并且对于任意非零 \\(a\\) 有 \\(m - a\\) 是 \\(a\\) 的模 \\(m\\) 逆元，其中 \\(m \\geqslant 2\\) 是一个整数。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.127,
                0.039,
                0.164,
                0.053
            ],
            "angle": 0,
            "content": "220"
        },
        {
            "type": "header",
            "bbox": [
                0.208,
                0.038,
                0.275,
                0.053
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.094,
                0.93,
                0.109
            ],
            "angle": 0,
            "content": "49. 证明带有模 \\(m\\) 乘法的 \\(\\mathbf{Z}_m\\) 满足封闭性、结合律、交换律，1是乘法单位元，其中 \\(m \\geqslant 2\\) 是一个整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.113,
                0.635,
                0.127
            ],
            "angle": 0,
            "content": "50. 证明在 \\(\\mathbf{Z}_m\\) 上乘法对加法满足分配律，其中 \\(m \\geqslant 2\\) 是一个整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.13,
                0.64,
                0.144
            ],
            "angle": 0,
            "content": "51. 试写出 \\(\\mathbf{Z}_{5}\\) 的加法和乘法表（这里的加法和乘法是指 \\(+\\) 和 \\(\\cdot\\)）。"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.147,
                0.64,
                0.161
            ],
            "angle": 0,
            "content": "52. 试写出 \\(Z_{6}\\) 的加法和乘法表（这里的加法和乘法是指 \\(+\\) 和 \\(\\cdot\\)）。"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.164,
                0.948,
                0.196
            ],
            "angle": 0,
            "content": "53. 试判定从整数集到整数集的函数 \\( f(a) = a \\operatorname{div} d \\) 和 \\( g(a) = a \\mod d \\) 是否是一对一的，试判断这些函数是否是映上的，其中 \\( d \\) 是一个固定的正整数。"
        },
        {
            "type": "list",
            "bbox": [
                0.096,
                0.094,
                0.948,
                0.196
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.1,
                0.211,
                0.357,
                0.23
            ],
            "angle": 0,
            "content": "4.2 整数表示和算法"
        },
        {
            "type": "title",
            "bbox": [
                0.101,
                0.238,
                0.229,
                0.255
            ],
            "angle": 0,
            "content": "4.2.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.258,
                0.953,
                0.35
            ],
            "angle": 0,
            "content": "整数的表示可以采用任意大于1的整数为基数来表示，如本节所要介绍的。尽管我们常用十进制（以10为基数）表示，但是二进制（以2为基数）、八进制（以8为基数）和十六进制（以16为基数）的表示法也是很常用的，尤其是在计算机科学中。给定基数 \\(b\\) 和整数 \\(n\\) ，我们要给出如何构建这个整数以 \\(b\\) 为基数的表示法。我们还将解释如何在二进制和八进制之间以及二进制和十六进制之间进行表示法的快速转换。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.353,
                0.953,
                0.407
            ],
            "angle": 0,
            "content": "正如3.1节所提到的，术语算法最初指的是用整数的十进制表示来进行算术运算的过程。这些算法经修改后能处理二进制表示，它是计算机算术的基础。同时它为算法及算法复杂度概念提供了很好的解释。因此，本节将讨论这些算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.409,
                0.953,
                0.445
            ],
            "angle": 0,
            "content": "我们将介绍计算 \\(a \\operatorname{div} d\\) 和 \\(a \\bmod d\\) 的算法，其中 \\(a\\) 和 \\(d\\) 是整数且 \\(d > 1\\)。最后还将描述一个高效算法来计算指数的模运算，这在密码学中是一个特别重要的算法，如4.6小节所述。"
        },
        {
            "type": "title",
            "bbox": [
                0.104,
                0.456,
                0.279,
                0.473
            ],
            "angle": 0,
            "content": "4.2.2 整数表示"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.476,
                0.955,
                0.569
            ],
            "angle": 0,
            "content": "在日常生活中都用十进制记号来表示整数。在十进制记号中，整数 \\(n\\) 可写成和式 \\(a_{k}10^{k} + a_{k-1}10^{k-1} + \\dots + a_{1}1^{0} + a_{0}\\)，这里 \\(a_{j}\\) 是一个整数，满足 \\(0 \\leqslant a_{j} \\leqslant 9, j = 0, 1, \\dots, k\\)。例如，965用来表示 \\(9 \\cdot 10^{2} + 6 \\cdot 10 + 5\\)。不过，有时用10以外的数为基数更方便。特别是计算机通常用二进制记号（以2为基数）来做算术运算，而用八进制（基数为8）或十六进制（基数为16）记号来表示字符，如字母或数字。事实上，可以用任何大于1的整数为基数来表示整数。这可表述为定理1。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.577,
                0.948,
                0.613
            ],
            "angle": 0,
            "content": "定理1 令 \\(b\\) 是一个大于1的整数。则如果 \\(n\\) 是一个正整数，就可以唯一地表示为下面的形式："
        },
        {
            "type": "equation",
            "bbox": [
                0.374,
                0.616,
                0.684,
                0.633
            ],
            "angle": 0,
            "content": "\\[\nn = a _ {k} b ^ {k} + a _ {k - 1} b ^ {k - 1} + \\dots + a _ {1} b + a _ {0}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.637,
                0.735,
                0.653
            ],
            "angle": 0,
            "content": "其中 \\(k\\) 是非负整数，\\(a_0, a_1, \\dots, a_k\\) 是小于 \\(b\\) 的非负整数，且 \\(a_k \\neq 0\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.662,
                0.957,
                0.735
            ],
            "angle": 0,
            "content": "这个定理的证明可以使用数学归纳法来构造，该方法将在5.1节讨论。证明也可以在[Ro10]中找到。定理1中给出的 \\(n\\) 的表示称为 \\(\\pmb{n}\\) 的 \\(\\textit{\\textbf{b}}\\) 进制展开式。 \\(n\\) 的 \\(^b\\) 进制展开式可记为\\((a_{k}a_{k - 1}\\dots a_{1}a_{0})_{b}\\) 。例如， \\((245)_{8}\\) 表示 \\(2\\cdot 8^{2} + 4\\cdot 8 + 5 = 165\\) 。典型地，整数的十进制展开式的下标10可以省略，因为以10为基数或十进制展开式通常就是用来表示整数的。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.738,
                0.957,
                0.793
            ],
            "angle": 0,
            "content": "二进制展开式 选择2为基数就得到整数的二进制展开式。在二进制记号中每位数字或者是0或者是1。换言之，一个整数的二进制展开式就是一个比特串。计算机中采用二进制展开式（及相关的从二进制展开式变化而来的其他展开式）来表示整数并做整数算术运算。"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.798,
                0.792,
                0.816
            ],
            "angle": 0,
            "content": "例1 以 \\((101011111)_{2}\\) 为二进制展开式的整数的十进制展开式是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.82,
                0.259,
                0.836
            ],
            "angle": 0,
            "content": "解 我们有"
        },
        {
            "type": "equation",
            "bbox": [
                0.273,
                0.837,
                0.796,
                0.873
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} (1 0 1 0 1 1 1 1) _ {2} = 1 \\cdot 2 ^ {8} + 0 \\cdot 2 ^ {7} + 1 \\cdot 2 ^ {6} + 0 \\cdot 2 ^ {5} + 1 \\cdot 2 ^ {4} \\\\ + 1 \\cdot 2 ^ {3} + 1 \\cdot 2 ^ {2} + 1 \\cdot 2 ^ {1} + 1 \\cdot 2 ^ {0} = 3 5 1 。 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.877,
                0.958,
                0.913
            ],
            "angle": 0,
            "content": "八进制和十六进制展开式 计算机科学中最重要的基数有2、8和16。基数8的展开式称为八进制展开式，而基数16的展开式称为十六进制展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.149,
                0.917,
                0.628,
                0.935
            ],
            "angle": 0,
            "content": "例2八进制展开式 \\((7016)_{8}\\) 的十进制展开式是什么？"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.66,
                0.038,
                0.796,
                0.055
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.839,
                0.039,
                0.874,
                0.054
            ],
            "angle": 0,
            "content": "221"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.095,
                0.577,
                0.112
            ],
            "angle": 0,
            "content": "解 利用 \\(b\\) 进制展开式的定义，以及 \\(b = 8\\) ，可以得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.28,
                0.115,
                0.682,
                0.13
            ],
            "angle": 0,
            "content": "\\[\n(7 0 1 6) _ {8} = 7 \\cdot 8 ^ {3} + 0 \\cdot 8 ^ {2} + 1 \\cdot 8 + 6 = 3 5 9 8\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.133,
                0.907,
                0.188
            ],
            "angle": 0,
            "content": "十六进制展开式需要用到16个不同的数字。通常，所使用的十六进制数字是0，1，2，3，4，5，6，7，8，9，A，B，C，D，E和F，其中字母A到F表示相当于（十进制表示的）10到15的数字。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.193,
                0.612,
                0.21
            ],
            "angle": 0,
            "content": "例3十六进制展开式 \\((2\\mathrm{AE0B})_{16}\\) 的十进制展开式是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.215,
                0.578,
                0.232
            ],
            "angle": 0,
            "content": "解 利用 \\(b\\) 进制展开式的定义，以及 \\(b = 8\\) ，可以得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.182,
                0.235,
                0.78,
                0.251
            ],
            "angle": 0,
            "content": "\\[\n(2 \\mathrm {A E} 0 \\mathrm {B}) _ {1 6} = 2 \\cdot 1 6 ^ {4} + 1 0 \\cdot 1 6 ^ {3} + 1 4 \\cdot 1 6 ^ {2} + 0 \\cdot 1 6 + 1 1 = 1 7 5 6 2 7\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.254,
                0.907,
                0.291
            ],
            "angle": 0,
            "content": "每个十六进制数字可以用4位来表示。例如，可以看出 \\((11100101)_2 = (E5)_{16}\\)，因为 \\((1110)_2 = (E)_{16}\\) 而 \\((0101)_2 = (5)_{16}\\)。字节是长度为8的比特串，可以用两位十六进制数字来表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.293,
                0.907,
                0.329
            ],
            "angle": 0,
            "content": "进制转换 现在介绍一个算法以构造一个整数 \\(n\\) 的 \\(b\\) 进制展开式。首先，用 \\(b\\) 除 \\(n\\) 得到商和余数，即"
        },
        {
            "type": "equation",
            "bbox": [
                0.361,
                0.332,
                0.605,
                0.347
            ],
            "angle": 0,
            "content": "\\[\nn = b q _ {0} + a _ {0} \\quad 0 \\leqslant a _ {0} <   b\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.35,
                0.67,
                0.368
            ],
            "angle": 0,
            "content": "余数 \\(a_0\\) 就是 \\(n\\) 的 \\(b\\) 进制展开式中最右边的数字。下一步用 \\(b\\) 除 \\(q_0\\) 得"
        },
        {
            "type": "equation",
            "bbox": [
                0.358,
                0.371,
                0.609,
                0.387
            ],
            "angle": 0,
            "content": "\\[\nq _ {0} = b q _ {1} + a _ {1} \\quad 0 \\leqslant a _ {1} <   b\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.389,
                0.907,
                0.425
            ],
            "angle": 0,
            "content": "可以看出 \\(a_1\\) 是 \\(n\\) 的 \\(b\\) 进制展开式中从右边第二位数字。继续这一过程，连续用商数除以 \\(b\\) 并以余数为新的 \\(b\\) 进制数字。这一过程在商为0时终止。该过程从右向左产生 \\(n\\) 的 \\(b\\) 进制数字。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.43,
                0.421,
                0.447
            ],
            "angle": 0,
            "content": "例4求 \\((12345)_{10}\\) 的八进制展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.453,
                0.356,
                0.469
            ],
            "angle": 0,
            "content": "解 首先用8除12345得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.384,
                0.472,
                0.584,
                0.487
            ],
            "angle": 0,
            "content": "\\[\n1 2 3 4 5 = 8 \\cdot 1 5 4 3 + 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.491,
                0.248,
                0.508
            ],
            "angle": 0,
            "content": "连续用8除商数得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.4,
                0.51,
                0.571,
                0.582
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} 1 5 4 3 = 8 \\cdot 1 9 2 + 7 \\\\ 1 9 2 = 8 \\cdot 2 4 + 0 \\\\ 2 4 = 8 \\cdot 3 + 0 \\\\ 3 = 8 \\cdot 0 + 3 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.586,
                0.907,
                0.603
            ],
            "angle": 0,
            "content": "由此得到一连串的余数，1，7，0，0和3就是12345的八进制展开式中从右向左的数字。于是，"
        },
        {
            "type": "equation",
            "bbox": [
                0.381,
                0.606,
                0.591,
                0.622
            ],
            "angle": 0,
            "content": "\\[\n(1 2 3 4 5) _ {1 0} = (3 0 0 7 1) _ {8}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.627,
                0.434,
                0.645
            ],
            "angle": 0,
            "content": "例5 求 \\((177130)_{10}\\) 的十六进制展开。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.65,
                0.377,
                0.666
            ],
            "angle": 0,
            "content": "解 首先用16除177130得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.364,
                0.67,
                0.609,
                0.685
            ],
            "angle": 0,
            "content": "\\[\n1 7 7 1 3 0 = 1 6 \\cdot 1 1 0 7 0 + 1 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.688,
                0.26,
                0.705
            ],
            "angle": 0,
            "content": "连续用16除商数得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.384,
                0.707,
                0.591,
                0.78
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} 1 1 0 7 0 = 1 6 \\cdot 6 9 1 + 1 4 \\\\ 6 9 1 = 1 6 \\cdot 4 3 + 3 \\\\ 4 3 = 1 6 \\cdot 2 + 1 1 \\\\ 2 = 1 6 \\cdot 0 + 2 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.784,
                0.911,
                0.819
            ],
            "angle": 0,
            "content": "由此得到一连串的余数，10，14，3，11，2就是 \\((177130)_{10}\\) 的十六进制（基数16）展开式中从右向左的数字。从而得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.372,
                0.822,
                0.602,
                0.838
            ],
            "angle": 0,
            "content": "\\[\n(1 7 7 1 3 0) _ {1 0} = (2 \\mathrm {B} 3 \\mathrm {E A}) _ {1 6}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.841,
                0.667,
                0.858
            ],
            "angle": 0,
            "content": "（回忆一下整数10、11和14分别对应于十六进制数字A、B和E。）"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.863,
                0.38,
                0.88
            ],
            "angle": 0,
            "content": "例6 求 \\((241)_{10}\\) 的二进制展开。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.885,
                0.334,
                0.901
            ],
            "angle": 0,
            "content": "解 首先用2除241得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.406,
                0.905,
                0.57,
                0.92
            ],
            "angle": 0,
            "content": "\\[\n2 4 1 = 2 \\cdot 1 2 0 + 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.923,
                0.254,
                0.94
            ],
            "angle": 0,
            "content": "连续用2除商数得到"
        },
        {
            "type": "text",
            "bbox": [
                0.922,
                0.429,
                0.984,
                0.446
            ],
            "angle": 0,
            "content": "Extra Examples"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.127,
                0.04,
                0.162,
                0.053
            ],
            "angle": 0,
            "content": "222"
        },
        {
            "type": "header",
            "bbox": [
                0.208,
                0.038,
                0.273,
                0.053
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "equation",
            "bbox": [
                0.45,
                0.095,
                0.597,
                0.224
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} 1 2 0 = 2 \\cdot 6 0 + 0 \\\\ 6 0 = 2 \\cdot 3 0 + 0 \\\\ 3 0 = 2 \\cdot 1 5 + 0 \\\\ 1 5 = 2 \\cdot 7 + 1 \\\\ 7 = 2 \\cdot 3 + 1 \\\\ 3 = 2 \\cdot 1 + 1 \\\\ 1 = 2 \\cdot 0 + 1 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.228,
                0.945,
                0.263
            ],
            "angle": 0,
            "content": "由此得到一连串的余数，1，0，0，0，1，1，1，1就是 \\((241)_{10}\\) 的二进制（基数2）展开式中从右向左的数字。于是"
        },
        {
            "type": "equation",
            "bbox": [
                0.417,
                0.266,
                0.629,
                0.282
            ],
            "angle": 0,
            "content": "\\[\n(2 4 1) _ {1 0} = (1 1 1 1 0 0 0 1) _ {2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.285,
                0.722,
                0.302
            ],
            "angle": 0,
            "content": "算法1中给出的伪代码计算整数 \\(n\\) 的 \\(b\\) 进制展开式 \\((a_{k - 1}\\dots a_1a_0)_b\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.317,
                0.331,
                0.332
            ],
            "angle": 0,
            "content": "算法1 构造 \\(b\\) 进制展开式"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.336,
                0.512,
                0.35
            ],
            "angle": 0,
            "content": "procedure base b expansion \\((n, b)\\) 正整数且 \\(b > 1\\)"
        },
        {
            "type": "equation",
            "bbox": [
                0.111,
                0.355,
                0.164,
                0.383
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} q := n \\\\ k := 0 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.111,
                0.39,
                0.261,
                0.455
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} \\text {w h i l e} q \\neq 0 \\\\ a _ {k} := q \\bmod b \\\\ q := q \\operatorname {d i v} b \\\\ k := k + 1 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.46,
                0.584,
                0.474
            ],
            "angle": 0,
            "content": "return \\((a_{k - 1}\\dots a_1a_0)\\{(a_{k - 1}\\dots a_1a_0)_b\\) 就是 \\(n\\) 的 \\(b\\) 进制展开式}"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.493,
                0.945,
                0.528
            ],
            "angle": 0,
            "content": "在算法1中， \\(q\\) 表示通过连续用 \\(b\\) 去除时所得到的商，初始值 \\(q = n\\) 。 \\(b\\) 进制展开式中的数字就是做这些除法时得到的余数，即由 \\(q \\mod b\\) 得出。当得到的商 \\(q = 0\\) 时，该算法结束。"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.53,
                0.931,
                0.546
            ],
            "angle": 0,
            "content": "评注 注意算法1可认为是一个贪婪算法，因为在每一步都是取尽可能大的 \\(b\\) 进制数字。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.549,
                0.945,
                0.622
            ],
            "angle": 0,
            "content": "二进制、八进制和十六进制展开式之间的转换 二进制与八进制之间以及二进制与十六进制之间的转换是非常容易的，因为每个八进制数字对应一组三位二进制数字，而每个十六进制数字对应着一组四位二进制数字，这种对应关系如表1所示（未表示开头的0）。（这些对应关系的证明留作练习 \\(13\\sim 16\\) 。)这种转换的解释如例7所示。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.305,
                0.634,
                0.739,
                0.648
            ],
            "angle": 0,
            "content": "表 1 整数 0 到 15 的十六进制、八进制和二进制表示"
        },
        {
            "type": "table",
            "bbox": [
                0.097,
                0.65,
                0.945,
                0.716
            ],
            "angle": 0,
            "content": "<table><tr><td>十进制</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td></tr><tr><td>十六进制</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td></tr><tr><td>八进制</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td></tr><tr><td>二进制</td><td>0</td><td>1</td><td>10</td><td>11</td><td>100</td><td>101</td><td>110</td><td>111</td><td>1000</td><td>1001</td><td>1010</td><td>1011</td><td>1100</td><td>1101</td><td>1110</td><td>1111</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.727,
                0.938,
                0.744
            ],
            "angle": 0,
            "content": "例7求(111101011 \\(1100)_{2}\\) 的八进制和十六进制展开式以及 \\((765)_{8}\\) 和 \\(\\mathrm{(A8D)}_{16}\\) 的二进制展开。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.749,
                0.945,
                0.86
            ],
            "angle": 0,
            "content": "解为了把(1111010111100)转化成八进制记号，可以把数字分成3个一组，必要时在最左一组的开头加一些0。这些组从左至右为011、111、010、111和100，分别对应八进制数字3、7、2、7和4。于是， \\((1111010111100)_2 = (37274)_8\\) 。为了把(1111010111100)转化成十六进制记号，可以把数字分成4个一组，必要时在最左一组的开头加一些0。这些组从左至右为0011、1110、1011和1100，分别对应十六进制数字3、E、B和C。于是， \\((1111010111100)_2 = (3\\mathrm{EBC})_{16}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.862,
                0.945,
                0.936
            ],
            "angle": 0,
            "content": "为了把 \\((765)_{8}\\) 转化成二进制记号，把每个八进制数字换成一组3个二进制数字。这些分组是111、110和101。于是， \\((765)_{8} = (111110101)_{2}\\) 。为了把 \\((\\mathrm{A8D})_{16}\\) 转化成二进制记号，把每个十六进制数字换成一组4个二进制数字。这些分组是1010、1000和1101。于是， \\((\\mathrm{A8D})_{16} = (101010001101)_{2}\\) 。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.654,
                0.037,
                0.787,
                0.053
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.832,
                0.038,
                0.869,
                0.052
            ],
            "angle": 0,
            "content": "223"
        },
        {
            "type": "title",
            "bbox": [
                0.05,
                0.101,
                0.266,
                0.119
            ],
            "angle": 0,
            "content": "4.2.3 整数运算算法"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.122,
                0.897,
                0.176
            ],
            "angle": 0,
            "content": "对用二进制展开式表示的整数做运算的算法在计算机算术中格外重要。我们将介绍对两个二进制展开式表示的整数做加法和乘法的算法。还将以实际使用的位运算次数来分析这些算法的计算复杂度。在整个讨论中假定 \\(a\\) 和 \\(b\\) 的二进制展开式为"
        },
        {
            "type": "equation",
            "bbox": [
                0.269,
                0.18,
                0.675,
                0.196
            ],
            "angle": 0,
            "content": "\\[\na = \\left(a _ {n - 1} a _ {n - 2} \\dots a _ {1} a _ {0}\\right) _ {2}, \\quad b = \\left(b _ {n - 1} b _ {n - 2} \\dots b _ {1} b _ {0}\\right) _ {2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.198,
                0.63,
                0.214
            ],
            "angle": 0,
            "content": "这样 \\(a\\) 和 \\(b\\) 各有 \\(n\\) 比特（必要时让其中一个的开头加上几比特0）。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.217,
                0.595,
                0.234
            ],
            "angle": 0,
            "content": "我们用这些整数中的位数来衡量整数算术算法的复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.236,
                0.897,
                0.291
            ],
            "angle": 0,
            "content": "加法算法 考虑以二进制记号表示的两个整数相加的问题。做加法的过程可以基于通常借助纸笔做加法的方法。该方法就是通过把对应位的二进制数字相加，当产生进位时再加上进位，从而计算两个整数的和。现在来详细描述这个过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.294,
                0.563,
                0.31
            ],
            "angle": 0,
            "content": "要把 \\(a\\) 和 \\(b\\) 相加，首先把最右边的位相加。这样可得"
        },
        {
            "type": "equation",
            "bbox": [
                0.382,
                0.314,
                0.561,
                0.329
            ],
            "angle": 0,
            "content": "\\[\na _ {0} + b _ {0} = c _ {0} \\cdot 2 + \\bar {s} _ {0}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.332,
                0.896,
                0.367
            ],
            "angle": 0,
            "content": "其中 \\(s_0\\) 是 \\(a + b\\) 的二进制展开式中最右边的一位数字，而 \\(c_{0}\\) 是进位， \\(c_{0}\\) 为0或1。然后把下一对二进制位及进位相加，"
        },
        {
            "type": "equation",
            "bbox": [
                0.36,
                0.371,
                0.582,
                0.386
            ],
            "angle": 0,
            "content": "\\[\na _ {1} + b _ {1} + c _ {0} = c _ {1} \\cdot 2 + s _ {1}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.389,
                0.897,
                0.463
            ],
            "angle": 0,
            "content": "其中 \\(s_1\\) 是 \\(a + b\\) 的二进制展开中的下一位（从右算起）数字，\\(c_1\\) 是进位。继续这一过程，把两个二进制展开式中对应的二进制位及进位相加，给出 \\(a + b\\) 的二进制展开式中从右算起的下一位数字。最后，把 \\(a_{n-1}\\)、\\(b_{n-1}\\) 和 \\(c_{n-2}\\) 相加得 \\(c_{n-1} \\cdot 2 + s_{n-1}\\)。和的首位数字是 \\(s_n = c_{n-1}\\)。这一过程产生 \\(a\\) 与 \\(b\\) 之和的二进制展开式，即 \\(a + b = (s_n s_{n-1} s_{n-2} \\cdots s_1 s_0)_2\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.468,
                0.455,
                0.485
            ],
            "angle": 0,
            "content": "例8 把 \\(a = (1110)_2\\) 和 \\(b = (1011)_2\\) 相加。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.491,
                0.461,
                0.506
            ],
            "angle": 0,
            "content": "解 按照算法中规定的步骤，首先注意到"
        },
        {
            "type": "equation",
            "bbox": [
                0.348,
                0.51,
                0.595,
                0.526
            ],
            "angle": 0,
            "content": "\\[\na _ {0} + b _ {0} = 0 + 1 = 0 \\cdot 2 + 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.529,
                0.357,
                0.545
            ],
            "angle": 0,
            "content": "所以 \\(c_{0} = 0\\) ，而 \\(s_0 = 1\\) 。然后，因为"
        },
        {
            "type": "equation",
            "bbox": [
                0.31,
                0.548,
                0.633,
                0.564
            ],
            "angle": 0,
            "content": "\\[\na _ {1} + b _ {1} + c _ {0} = 1 + 1 + 0 = 1 \\cdot 2 + 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.567,
                0.304,
                0.583
            ],
            "angle": 0,
            "content": "从而 \\(c_{1} = 1\\) ，而 \\(s_1 = 0\\) 。继续，"
        },
        {
            "type": "equation",
            "bbox": [
                0.175,
                0.587,
                0.496,
                0.602
            ],
            "angle": 0,
            "content": "\\[\na _ {2} + b _ {2} + c _ {1} = 1 + 0 + 1 = 1 \\cdot 2 + 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.606,
                0.357,
                0.621
            ],
            "angle": 0,
            "content": "所以 \\(c_{2} = 1\\) ，而 \\(s_2 = 0\\) 。最后，由于"
        },
        {
            "type": "equation",
            "bbox": [
                0.175,
                0.625,
                0.496,
                0.64
            ],
            "angle": 0,
            "content": "\\[\na _ {3} + b _ {3} + c _ {2} = 1 + 1 + 1 = 1 \\cdot 2 + 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.644,
                0.622,
                0.678
            ],
            "angle": 0,
            "content": "从而 \\(c_{3} = 1\\) 且 \\(s_3 = 1\\) 。这表明 \\(s_4 = c_3 = 1\\) 。因此，\\(s = a + b = (11001)_2\\) 。相加的过程如图1所示，其中进位用斜体表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.682,
                0.367,
                0.698
            ],
            "angle": 0,
            "content": "加法算法可用伪代码描述如下。"
        },
        {
            "type": "image",
            "bbox": [
                0.713,
                0.577,
                0.804,
                0.65
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.636,
                0.659,
                0.88,
                0.675
            ],
            "angle": 0,
            "content": "图1 \\((1110)_2\\) 和 \\((1011)_2\\) 相加"
        },
        {
            "type": "title",
            "bbox": [
                0.062,
                0.717,
                0.207,
                0.732
            ],
            "angle": 0,
            "content": "算法2 整数相加"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.736,
                0.297,
                0.749
            ],
            "angle": 0,
            "content": "procedure add(a, b: 正整数)"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.753,
                0.623,
                0.768
            ],
            "angle": 0,
            "content": "\\(\\{a\\) 和 \\(b\\) 的二进制展开式分别是 \\((a_{n - 1}a_{n - 2}\\dots a_1a_0)_2\\) 和 \\((b_{n - 1}b_{n - 2}\\dots b_1b_0)_2\\}\\)"
        },
        {
            "type": "equation",
            "bbox": [
                0.062,
                0.773,
                0.27,
                0.856
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} c := 0 \\\\ f o r j := 0 t o n - 1 \\\\ d := \\left\\lfloor \\left(a _ {j} + b _ {j} + c\\right) / 2 \\right\\rfloor \\\\ s _ {j} := a _ {j} + b _ {j} + c - 2 d \\\\ c := d \\\\ \\end{array}\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.062,
                0.863,
                0.117,
                0.874
            ],
            "angle": 0,
            "content": "\\[\ns _ {n} := c\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.879,
                0.481,
                0.893
            ],
            "angle": 0,
            "content": "return \\((s_{n}s_{n - 1}\\dots s_{0})_{2}\\) {和的二进制展开是 \\((s_n s_{n - 1}\\dots s_0)_2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.914,
                0.489,
                0.93
            ],
            "angle": 0,
            "content": "下面分析算法2使用的二进制位相加的次数。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.126,
                0.038,
                0.162,
                0.051
            ],
            "angle": 0,
            "content": "224"
        },
        {
            "type": "header",
            "bbox": [
                0.208,
                0.036,
                0.274,
                0.052
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.095,
                0.949,
                0.134
            ],
            "angle": 0,
            "content": "例9 使用算法2将两个二进制表示中具有 \\(n\\) （或少于 \\(n\\) ）位二进制位的整数相加时需要用多少次二进制位加法？"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.136,
                0.95,
                0.209
            ],
            "angle": 0,
            "content": "解 两个整数相加是通过连续对一对二进制位相加，当有进位产生时再加上进位来完成的。把两个二进制位及进位相加需要2次二进制位加法。因此，需要用到的二进制位加法总数少于二进制展开式中位数的两倍。从而，算法2把两个 \\(n\\) 位整数相加需要的二进制位加法次数是 \\(O(n)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.213,
                0.949,
                0.248
            ],
            "angle": 0,
            "content": "乘法算法 下面考虑两个 \\(n\\) 位整数 \\(a\\) 和 \\(b\\) 的乘法。传统的算法（用纸笔做乘法）如下。利用分配律，可以看出"
        },
        {
            "type": "equation",
            "bbox": [
                0.343,
                0.253,
                0.707,
                0.286
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} a b = a \\left(b _ {0} 2 ^ {0} + b _ {1} 2 ^ {1} + \\dots + b _ {n - 1} 2 ^ {n - 1}\\right) \\\\ = a \\left(b _ {0} 2 ^ {0}\\right) + a \\left(b _ {1} 2 ^ {1}\\right) + \\dots + a \\left(b _ {n - 1} 2 ^ {n - 1}\\right) \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.29,
                0.951,
                0.364
            ],
            "angle": 0,
            "content": "可以用这一等式来计算 \\(ab\\) 。首先注意到当 \\(b_{j} = 1\\) 时 \\(ab_{j} = a\\) ，而当 \\(b_{j} = 0\\) 时 \\(ab_{j} = 0\\) 。每当用2乘一项时，可以把该项的二进制展开式向左移一位并在尾部加上一个0。因而，可以通过把 \\(ab_{j}\\) 的二进制展开式向左移位 \\(j\\) 位，再在尾部加上 \\(j\\) 个0来获得 \\((ab_{j})2^{j}\\) 。最后，把 \\(n\\) 个整数 \\(ab_{j}2^{j}\\) ，\\(j = 0,1,2,\\dots ,n - 1\\) ，相加就得到 \\(ab\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.367,
                0.424,
                0.383
            ],
            "angle": 0,
            "content": "算法3展示了乘法的这一过程。"
        },
        {
            "type": "title",
            "bbox": [
                0.117,
                0.402,
                0.266,
                0.417
            ],
            "angle": 0,
            "content": "算法3 整数相乘"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.421,
                0.391,
                0.435
            ],
            "angle": 0,
            "content": "procedure multiply \\((a, b)\\) ：正整数）"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.439,
                0.681,
                0.452
            ],
            "angle": 0,
            "content": "\\(\\{a\\) 和 \\(b\\) 的二进制展开式分别是 \\((a_{n - 1}a_{n - 2}\\dots a_1a_0)_2\\) 和 \\((b_{n - 1}b_{n - 2}\\dots b_1b_0)_2\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.458,
                0.265,
                0.469
            ],
            "angle": 0,
            "content": "for \\(j\\coloneqq 0\\) to \\(n - 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.162,
                0.475,
                0.399,
                0.487
            ],
            "angle": 0,
            "content": "if \\( b_{j} = 1 \\) then \\( c_{j} := a \\) 移动 \\( j \\) 位"
        },
        {
            "type": "equation",
            "bbox": [
                0.162,
                0.494,
                0.249,
                0.505
            ],
            "angle": 0,
            "content": "\\[\n\\text {e l s e} c _ {i} := 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.122,
                0.511,
                0.366,
                0.524
            ],
            "angle": 0,
            "content": "\\(\\{c_{0}, c_{1}, \\dots, c_{n-1}\\) 是部分乘积\\}"
        },
        {
            "type": "equation",
            "bbox": [
                0.121,
                0.53,
                0.172,
                0.541
            ],
            "angle": 0,
            "content": "\\[\np := 0\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.121,
                0.548,
                0.265,
                0.559
            ],
            "angle": 0,
            "content": "\\[\nf o r j := 0 t o n - 1\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.164,
                0.566,
                0.247,
                0.578
            ],
            "angle": 0,
            "content": "\\[\np := p + c _ {j}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.583,
                0.3,
                0.595
            ],
            "angle": 0,
            "content": "return \\( p \\) { \\( p \\) 是 \\( ab \\) 的值}"
        },
        {
            "type": "text",
            "bbox": [
                0.144,
                0.616,
                0.396,
                0.633
            ],
            "angle": 0,
            "content": "例10解释了该算法的应用。"
        },
        {
            "type": "text",
            "bbox": [
                0.144,
                0.638,
                0.524,
                0.655
            ],
            "angle": 0,
            "content": "例10 求 \\(a = (110)_2\\) 和 \\(b = (101)_2\\) 的乘积。"
        },
        {
            "type": "text",
            "bbox": [
                0.144,
                0.66,
                0.294,
                0.676
            ],
            "angle": 0,
            "content": "解 首先注意到"
        },
        {
            "type": "equation",
            "bbox": [
                0.369,
                0.681,
                0.68,
                0.694
            ],
            "angle": 0,
            "content": "\\[\na b _ {0} \\cdot 2 ^ {0} = (1 1 0) _ {2} \\cdot 1 \\cdot 2 ^ {0} = (1 1 0) _ {2}\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.369,
                0.701,
                0.69,
                0.714
            ],
            "angle": 0,
            "content": "\\[\na b _ {1} \\cdot 2 ^ {1} = (\\tilde {1} 1 0) _ {2} \\cdot 0 \\cdot 2 ^ {1} = (0 0 0 0) _ {2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.718,
                0.131,
                0.733
            ],
            "angle": 0,
            "content": "及"
        },
        {
            "type": "equation",
            "bbox": [
                0.364,
                0.738,
                0.697,
                0.752
            ],
            "angle": 0,
            "content": "\\[\na b _ {2} \\cdot 2 ^ {2} = (1 1 0) _ {2} \\cdot 1 \\cdot 2 ^ {2} = (1 1 0 0 0) _ {2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.756,
                0.675,
                0.81
            ],
            "angle": 0,
            "content": "为计算乘积，把 \\((110)_2\\) 、 \\((0000)_2\\) 和 \\((11000)_2\\) 相加。完成这些加法（利用算法2，必要时首位加0）即得 \\(ab = (11110)_2\\) 。这一过程如图2所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.814,
                0.675,
                0.849
            ],
            "angle": 0,
            "content": "下面来确定算法3做乘法时用到的二进制位加法和移位次数。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.854,
                0.675,
                0.892
            ],
            "angle": 0,
            "content": "例11 用算法3计算 \\(a\\) 和 \\(b\\) 的乘积需用多少次二进制位加法和移位？"
        },
        {
            "type": "image",
            "bbox": [
                0.763,
                0.761,
                0.864,
                0.862
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.699,
                0.871,
                0.928,
                0.887
            ],
            "angle": 0,
            "content": "图2 \\((110)_{2}\\) 和 \\((101)_2\\) 相乘"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.898,
                0.955,
                0.935
            ],
            "angle": 0,
            "content": "解算法3通过把部分乘积 \\(c_{0}\\) ， \\(c_{1}\\) ， \\(c_{2}\\) ，…， \\(c_{n - 1}\\) 相加来计算 \\(a\\) 和 \\(b\\) 的乘积。当 \\(b_{j} = 1\\) 时，通过把 \\(a\\) 的二进制展开式移 \\(j\\) 位来计算部分积 \\(c_{j}\\) 。当 \\(b_{j} = 0\\) 时，因为 \\(c_{j} = 0\\) 而不需要移位。因"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.66,
                0.036,
                0.796,
                0.052
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.839,
                0.037,
                0.876,
                0.052
            ],
            "angle": 0,
            "content": "225"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.092,
                0.66,
                0.109
            ],
            "angle": 0,
            "content": "此，为求出所有 \\(n\\) 个整数 \\(ab_{j}2^{j}\\) ， \\(j = 0\\) ，1，2，…， \\(n - 1\\) ，最多需要"
        },
        {
            "type": "equation",
            "bbox": [
                0.377,
                0.113,
                0.581,
                0.127
            ],
            "angle": 0,
            "content": "\\[\n0 + 1 + 2 + \\dots + n - 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.131,
                0.599,
                0.148
            ],
            "angle": 0,
            "content": "次移位。因此，由3.2节例5可知所需移位的次数是 \\(O(n^{2})\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.151,
                0.906,
                0.206
            ],
            "angle": 0,
            "content": "要把 \\(ab_{j}\\) 从 \\(j = 0\\) 到 \\(j = n - 1\\) 加起来，需要做一次 \\(n\\) 位整数加法一次 \\((n + 1)\\) 位整数加法……和一次 \\(2n\\) 位整数加法。由例9可知这些加法都需要 \\(O(n)\\) 次二进制位加法。因此，全部 \\(n\\) 个数相加总共需要 \\(O(n^{2})\\) 次二进制位加法。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.208,
                0.907,
                0.244
            ],
            "angle": 0,
            "content": "令人惊讶的是，有比传统整数乘法算法更有效的算法。8.3节将描述一个算法，它使用 \\(O(n^{1.585})\\) 次比特运算来完成 \\(n\\) 位数的乘法。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.248,
                0.912,
                0.344
            ],
            "angle": 0,
            "content": "div和mod算法 给定整数 \\(a\\) 和 \\(d\\) ， \\(d > 0\\) ，可以用算法4来计算 \\(q = a\\mathrm{div}d\\) 和 \\(r = a\\bmod d\\) 。在这个蛮力算法中，当 \\(a\\) 为正时，就从 \\(a\\) 中尽可能多次减去 \\(d\\) ，直到剩下的值小于 \\(d\\) 为止。所做减法的次数就是商而最后减剩下的值就是余数。算法4也能处理 \\(a\\) 为负的情况。算法先求出当 \\(\\mid a\\mid\\) 除以 \\(d\\) 时的商 \\(q\\) 和余数 \\(r\\) 。然后，当 \\(a < 0\\) 且 \\(r > 0\\) 时，算法就用这些结果来计算当 \\(a\\) 除以 \\(d\\) 时的商一 \\((q + 1)\\) 和余数 \\(d - r\\) 。留给读者证明(练习65)假设 \\(a > d\\) 时该算法用 \\(O(q\\log a)\\) 次比特运算。"
        },
        {
            "type": "code_caption",
            "bbox": [
                0.072,
                0.362,
                0.272,
                0.378
            ],
            "angle": 0,
            "content": "算法4 计算div和mod"
        },
        {
            "type": "code",
            "bbox": [
                0.071,
                0.381,
                0.49,
                0.56
            ],
            "angle": 0,
            "content": "procedure division algorithm(a:整数，d：正整数)  \n\\(q:=0\\)   \n\\(r:=|a|\\)   \nwhile \\(r\\geqslant d\\)   \n\\(r:=r-d\\)   \n\\(q:=q+1\\)   \nif \\(a<0\\) 且 \\(r>0\\) then  \n\\(r:=d-r\\)   \n\\(q:=-(q+1)\\)   \nreturn \\((q,r)\\{q=a\\mathrm{div}d\\) 是商， \\(r=a\\bmod d\\) 是余数）"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.578,
                0.912,
                0.653
            ],
            "angle": 0,
            "content": "当正整数 \\(a\\) 除以正整数 \\(d\\) 时，还有比算法4更有效的算法能确定商 \\(q = a \\mod d\\) 和余数 \\(r = a \\bmod d\\)（细节参见[Kn98]）。这些算法需要 \\(O(\\log a \\cdot \\log d)\\) 次比特运算。如果 \\(a\\) 和 \\(d\\) 的二进制展开式都不超过 \\(n\\) 位，则我们可以用 \\(n^2\\) 来替代 \\(\\log a \\cdot \\log d\\)。这意味着当 \\(a\\) 除以 \\(d\\) 时需要 \\(O(n^2)\\) 次比特运算来计算商和余数。"
        },
        {
            "type": "title",
            "bbox": [
                0.063,
                0.664,
                0.258,
                0.681
            ],
            "angle": 0,
            "content": "4.2.4 模指数运算"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.684,
                0.914,
                0.759
            ],
            "angle": 0,
            "content": "在密码学中不使用过量内存而能够有效地计算 \\(b^{n} \\mod m\\) 是很重要的，其中 \\(b, n, m\\) 是大整数。先计算 \\(b^{n}\\) 然后再求 \\(b^{n}\\) 除以 \\(m\\) 的余数的方法是不可行的，因为 \\(b^{n}\\) 会是一个非常大的数，而且需要用大量内存来存储这样的数。取而代之，我们使用一种用指数 \\(n\\) 的二进制展开式的算法来避免时间和内存的问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.762,
                0.915,
                0.837
            ],
            "angle": 0,
            "content": "在给出这个基于指数的二进制展开式的快速模指数算法之前，首先观察到采用下面的方法可以避免使用大量内存，即利用(4.1节定理5的推论2给出的)事实 \\(b^{k + 1}\\mod \\bar{m} = b(b^k\\bmod m)\\) mod \\(m\\) ，通过连续计算 \\(b^{k}\\mathrm{mod}m\\) ， \\(k = 1\\) ，2，…， \\(n\\) 来计算 \\(b^{n}\\mathrm{mod}m\\) （回顾一下， \\(1\\leqslant b <   m)\\) 。可是，这样的方法也有不实际的一面，因为需要 \\(n - 1\\) 次乘法，且 \\(n\\) 可能是非常大的数。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.839,
                0.915,
                0.876
            ],
            "angle": 0,
            "content": "为了促成快速模指数算法，我们解释一下其基本思想。我们来解释如何利用 \\(n\\) 的二进制展开式，比如 \\(n = (a_{k - 1}\\dots a_1a_0)_2\\) ，来计算 \\(b^{n}\\) 。首先，注意到"
        },
        {
            "type": "equation",
            "bbox": [
                0.305,
                0.879,
                0.669,
                0.896
            ],
            "angle": 0,
            "content": "\\[\nb ^ {n} = b _ {a + 1} ^ {a - 2 ^ {k + 1} + \\dots + a _ {1} \\cdot 2 + a _ {0}} = b _ {a + 1} ^ {a - 2 ^ {k + 1}} \\dots b _ {a _ {1}} ^ {a _ {2}} \\cdot b _ {a _ {0}}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.899,
                0.918,
                0.937
            ],
            "angle": 0,
            "content": "这说明为了计算 \\(b^n\\) 的值，只需要计算 \\(b, b^2, (b^2)^2 = b^4, (b^4)^2 = b^8, \\dots, b^{2^{i+1}}\\) 的值。一旦有了这些值，把列表中 \\(a_j = 1\\) 的那些项 \\(b^{2^j}\\) 相乘。（为了提高效率并减少空间需求，每乘一项后，都"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.136,
                0.038,
                0.172,
                0.052
            ],
            "angle": 0,
            "content": "226"
        },
        {
            "type": "header",
            "bbox": [
                0.218,
                0.037,
                0.284,
                0.052
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "image",
            "bbox": [
                0.06,
                0.113,
                0.095,
                0.142
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.06,
                0.172,
                0.095,
                0.199
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.094,
                0.405,
                0.11
            ],
            "angle": 0,
            "content": "做一次模 \\(m\\) 运算以缩小结果值。）"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.113,
                0.957,
                0.169
            ],
            "angle": 0,
            "content": "这就可以得到 \\(b^n\\) 的值。例如，要计算 \\(3^{11}\\)，由于 \\(11 = (1011)_2\\)，因此 \\(3^{11} = 3^8 3^2 3^1\\)。通过连续取平方，可以得到 \\(3^2 = 9\\)，\\(3^4 = 9^2 = 81\\) 和 \\(3^8 = 81^2 = 6561\\)。因此，\\(3^{11} = 3^8 3^2 3^1 = 6561 \\cdot 9 \\cdot 3 = 177147\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.174,
                0.957,
                0.252
            ],
            "angle": 0,
            "content": "该算法依次求出 \\(b \\mod m\\)，\\(b^2 \\mod m\\)，\\(b^4 \\mod m\\)，\\(\\cdots\\)，\\(b^{2^{k-1}} \\mod m\\)，并把其中 \\(a_j = 1\\) 的那些项 \\(b^{2^j} \\mod m\\) 相乘，在每次乘法后求乘积除以 \\(m\\) 所得的余数。注意我们只需要执行 \\(O(\\log_2(n))\\) 次乘法运算。这个算法的伪代码如算法5所示。注意在算法5中，我们可以使用最有效的算法来计算 mod 函数的值，而并非一定要使用算法4。"
        },
        {
            "type": "title",
            "bbox": [
                0.12,
                0.271,
                0.326,
                0.286
            ],
            "angle": 0,
            "content": "算法5 快速模指数运算"
        },
        {
            "type": "code",
            "bbox": [
                0.119,
                0.289,
                0.767,
                0.413
            ],
            "angle": 0,
            "content": "procedure modular exponentiation(b：整数， \\(n = (a_{k - 1}a_{k - 2}\\dots a_1a_0)_2\\) ， \\(m\\) ：正整数）  \n\\(x:=1\\)   \npower \\(\\coloneqq b\\bmod m\\)   \nfor \\(i\\coloneqq 0\\) to \\(k - 1\\) if \\(a_i = 1\\) then \\(x\\coloneqq (x\\cdot \\mathrm{power})\\mathrm{mod}m\\) power \\(\\coloneqq\\) (power·power)mod \\(m\\)   \nreturn \\(x\\{x\\) 等于 \\(b^n\\bmod m\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.432,
                0.501,
                0.448
            ],
            "angle": 0,
            "content": "我们用例12说明算法5是如何工作的。"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.454,
                0.441,
                0.47
            ],
            "angle": 0,
            "content": "例12 用算法5求 \\(3^{644} \\mod 645\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.476,
                0.957,
                0.551
            ],
            "angle": 0,
            "content": "解算法5首先令 \\(x = 1\\) 和 \\(\\mathrm{power} = 3\\mod 645 = 3\\) 。在计算 \\(3^{644}\\) mod645的过程中，这个算法通过连续取平方并做模645运算来减小结果值的方法计算 \\(3^{2^j}\\) mod645， \\(j = 1\\) ，2，…，9。如果 \\(a_{j} = 1\\) （其中 \\(a_{j}\\) 是644二进制展开式(1010000100)中的第 \\(j\\) 位)，就在 \\(x\\) 当前值上乘以 \\(3^{2^j}\\) mod645并做模645来减小结果值。下面是所用到的步骤："
        },
        {
            "type": "code",
            "bbox": [
                0.149,
                0.557,
                0.952,
                0.774
            ],
            "angle": 0,
            "content": "\\(i = 0\\) ：因为 \\(a_0 = 0\\) ，所以有 \\(x = 1\\) 和 \\(\\text{power} = 3^2\\bmod 645 = 9\\bmod 645 = 9\\)   \n\\(i = 1\\) ：因为 \\(a_1 = 0\\) ，所以有 \\(x = 1\\) 和 \\(\\mathrm{power} = 9^{2}\\) mod \\(645 = 81\\) mod \\(645 = 81\\)   \n\\(i = 2\\) ：因为 \\(a_2 = 1\\) ，所以有 \\(x = 1\\cdot 81\\) mod \\(645 = 81\\) 和 \\(\\mathrm{power} = 81^2\\) mod \\(645 = 6561\\) mod \\(645 = 111\\)   \n\\(i = 3\\) ：因为 \\(a_3 = 0\\) ，所以有 \\(x = 81\\) 和 \\(\\mathrm{power} = 111^2\\) mod \\(645 = 12321\\) mod \\(645 = 66\\)   \n\\(i = 4\\) ：因为 \\(a_4 = 0\\) ，所以有 \\(x = 81\\) 和 \\(\\mathrm{power} = 66^2\\) mod \\(645 = 4356\\) mod \\(645 = 486\\)   \n\\(i = 5\\) ：因为 \\(a_5 = 0\\) ，所以有 \\(x = 81\\) 和 \\(\\mathrm{power} = 486^2\\) mod \\(645 = 236196\\) mod \\(645 = 126\\)   \n\\(i = 6\\) ：因为 \\(a_6 = 0\\) ，所以有 \\(x = 81\\) 和 \\(\\mathrm{power} = 126^2\\) mod \\(645 = 15876\\) mod \\(645 = 396\\)   \n\\(i = 7\\) ：因为 \\(a_7 = 1\\) ，所以有 \\(x = (81\\cdot 396)\\bmod 645 = 471\\) 和 \\(\\mathrm{power} = 396^2\\bmod 645 =\\)   \n\\(i = 8\\) ：因为 \\(a_8 = 0\\) ，所以有 \\(x = 471\\) 和 \\(\\mathrm{power} = 81^2\\bmod 645 = 6561\\bmod 645 = 111;\\)   \n\\(i = 9\\) ：因为 \\(a_9 = 1\\) ，所以有 \\(x = (471\\cdot 111)\\bmod 645 = 36.\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.781,
                0.643,
                0.797
            ],
            "angle": 0,
            "content": "这展示了遵循算法5的步骤得出结果 \\(3^{644} \\mod 645 = 36\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.144,
                0.801,
                0.945,
                0.817
            ],
            "angle": 0,
            "content": "算法5是非常高效的，它用 \\(O((\\log m)^2 \\log n)\\) 次比特运算就能求得 \\(b^n \\mod m\\) （参见练习64）。"
        },
        {
            "type": "title",
            "bbox": [
                0.106,
                0.829,
                0.154,
                0.844
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.849,
                0.495,
                0.863
            ],
            "angle": 0,
            "content": "1. 把下列整数从十进制表示转换为二进制表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.867,
                0.177,
                0.88
            ],
            "angle": 0,
            "content": "a)231"
        },
        {
            "type": "text",
            "bbox": [
                0.304,
                0.867,
                0.364,
                0.88
            ],
            "angle": 0,
            "content": "b)4532"
        },
        {
            "type": "text",
            "bbox": [
                0.49,
                0.867,
                0.561,
                0.88
            ],
            "angle": 0,
            "content": "c)97644"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.885,
                0.495,
                0.899
            ],
            "angle": 0,
            "content": "2. 把下列整数从十进制表示转换为二进制表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.904,
                0.177,
                0.916
            ],
            "angle": 0,
            "content": "a)321"
        },
        {
            "type": "text",
            "bbox": [
                0.305,
                0.903,
                0.363,
                0.916
            ],
            "angle": 0,
            "content": "b)1023"
        },
        {
            "type": "text",
            "bbox": [
                0.49,
                0.903,
                0.571,
                0.916
            ],
            "angle": 0,
            "content": "c)100632"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.921,
                0.495,
                0.936
            ],
            "angle": 0,
            "content": "3. 把下列整数从二进制表示转换为十进制表示。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.656,
                0.042,
                0.788,
                0.057
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.835,
                0.043,
                0.871,
                0.056
            ],
            "angle": 0,
            "content": "227"
        },
        {
            "type": "text",
            "bbox": [
                0.075,
                0.099,
                0.173,
                0.113
            ],
            "angle": 0,
            "content": "a) \\((11111)_2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.248,
                0.099,
                0.401,
                0.113
            ],
            "angle": 0,
            "content": "b) \\((100000001)_2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.434,
                0.099,
                0.575,
                0.113
            ],
            "angle": 0,
            "content": "c) \\((101010101)_2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.631,
                0.099,
                0.834,
                0.113
            ],
            "angle": 0,
            "content": "d) (110 1001 0001 0000)2"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.117,
                0.439,
                0.131
            ],
            "angle": 0,
            "content": "4. 把下列整数从二进制表示转换为十进制表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.075,
                0.134,
                0.173,
                0.148
            ],
            "angle": 0,
            "content": "a) \\((11011)_2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.248,
                0.134,
                0.4,
                0.148
            ],
            "angle": 0,
            "content": "b) (10 1011 0101)2"
        },
        {
            "type": "text",
            "bbox": [
                0.434,
                0.134,
                0.583,
                0.149
            ],
            "angle": 0,
            "content": "c) (11 1011 1110)2"
        },
        {
            "type": "text",
            "bbox": [
                0.631,
                0.134,
                0.834,
                0.148
            ],
            "angle": 0,
            "content": "d) (111 1100 0001 1111)2"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.152,
                0.439,
                0.166
            ],
            "angle": 0,
            "content": "5. 把下列整数从八进制表示转换为二进制表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.075,
                0.169,
                0.148,
                0.184
            ],
            "angle": 0,
            "content": "a) \\((572)_8\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.248,
                0.169,
                0.332,
                0.184
            ],
            "angle": 0,
            "content": "b) \\((1604)_8\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.434,
                0.169,
                0.507,
                0.184
            ],
            "angle": 0,
            "content": "c) \\((423)_8\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.631,
                0.169,
                0.714,
                0.184
            ],
            "angle": 0,
            "content": "d) (2417)8"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.187,
                0.439,
                0.201
            ],
            "angle": 0,
            "content": "6. 把下列整数从二进制表示转换为八进制表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.075,
                0.204,
                0.201,
                0.218
            ],
            "angle": 0,
            "content": "a) \\((11110111)_2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.248,
                0.204,
                0.419,
                0.219
            ],
            "angle": 0,
            "content": "b) (1010 1010 1010)2"
        },
        {
            "type": "text",
            "bbox": [
                0.434,
                0.204,
                0.585,
                0.219
            ],
            "angle": 0,
            "content": "c) (111 0111 0111 0"
        },
        {
            "type": "text",
            "bbox": [
                0.631,
                0.204,
                0.834,
                0.219
            ],
            "angle": 0,
            "content": "\\(\\mathbf{d})\\) (101 0101 0101 0101)2"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.222,
                0.458,
                0.236
            ],
            "angle": 0,
            "content": "7. 把下列整数从十六进制表示转换为二进制表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.075,
                0.24,
                0.157,
                0.255
            ],
            "angle": 0,
            "content": "a \\((80\\mathrm{E})_{16}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.248,
                0.24,
                0.353,
                0.254
            ],
            "angle": 0,
            "content": "b) (135 AB)"
        },
        {
            "type": "text",
            "bbox": [
                0.434,
                0.24,
                0.534,
                0.254
            ],
            "angle": 0,
            "content": "c) (ABBA)16"
        },
        {
            "type": "text",
            "bbox": [
                0.631,
                0.24,
                0.768,
                0.254
            ],
            "angle": 0,
            "content": "d) (DEFACED)16"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.257,
                0.513,
                0.272
            ],
            "angle": 0,
            "content": "8. 把 \\((\\mathrm{BADFACED})_{16}\\) 从十六进制表示转换为二进制表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.275,
                0.487,
                0.289
            ],
            "angle": 0,
            "content": "9. 把 \\((\\mathrm{ABCDEF})_{16}\\) 从十六进制表示转换为二进制表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.293,
                0.521,
                0.307
            ],
            "angle": 0,
            "content": "10. 把练习6中的整数从二进制表示转换为十六进制表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.311,
                0.545,
                0.325
            ],
            "angle": 0,
            "content": "11. 把(1011 0111 1011)2从二进制表示转换为十六进制表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.328,
                0.56,
                0.342
            ],
            "angle": 0,
            "content": "12. 把 \\((1100001100011)_2\\) 从二进制表示转换为十六进制表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.345,
                0.896,
                0.378
            ],
            "angle": 0,
            "content": "13. 证明一个正整数的十六进制展开式可以从其二进制展开式求得，方法是每四位二进制数字组成一组，必要时在开头加一些0，把每组四个二进制数字转换成一个十六进制数字。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.381,
                0.896,
                0.413
            ],
            "angle": 0,
            "content": "14. 证明一个正整数的二进制展开式可以从其十六进制展开式求得，方法是把每个十六进制数字转换成一组四个二进制数字。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.416,
                0.896,
                0.449
            ],
            "angle": 0,
            "content": "15. 证明一个正整数的八进制展开式可以从其二进制展开式求得，方法是每三位二进制数字组成一组，必要时在开头加一些0，把每组三个二进制数字转换成一个八进制数字。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.452,
                0.896,
                0.484
            ],
            "angle": 0,
            "content": "16. 证明一个正整数的二进制展开式可以从其八进制展开式求得，方法是把每个八进制数字转换成一组三个二进制数字。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.487,
                0.675,
                0.501
            ],
            "angle": 0,
            "content": "17. 把 \\((7345321)_{8}\\) 转换为二进制表示，把 \\((1010111011)_{2}\\) 转换为八进制表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.505,
                0.798,
                0.519
            ],
            "angle": 0,
            "content": "18. 给出一个将整数的十六进制表示转换为八进制表示的过程，用二进制表示作为中间步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.523,
                0.798,
                0.537
            ],
            "angle": 0,
            "content": "19. 给出一个将整数的八进制表示转换为十六进制表示的过程，用二进制表示作为中间步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.54,
                0.896,
                0.572
            ],
            "angle": 0,
            "content": "20. 试解释如何从二进制转换为64进制，从64进制转换为二进制，从八进制转换为64进制，以及从64进制转换为八进制。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.575,
                0.482,
                0.589
            ],
            "angle": 0,
            "content": "21.找出下列每一对数的和与积。答案用二进制表示"
        },
        {
            "type": "text",
            "bbox": [
                0.079,
                0.593,
                0.314,
                0.608
            ],
            "angle": 0,
            "content": "a) \\((1000111)_2\\) ， \\((1110111)_2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.432,
                0.593,
                0.682,
                0.608
            ],
            "angle": 0,
            "content": "b) \\((11101111)_2\\) ， \\((10111101)_2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.611,
                0.369,
                0.626
            ],
            "angle": 0,
            "content": "c) \\((1010101010)_2\\) ， \\((111110000)_2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.432,
                0.611,
                0.731,
                0.626
            ],
            "angle": 0,
            "content": "d) \\((100000001)_2\\) ， \\((111111111)_2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.629,
                0.482,
                0.643
            ],
            "angle": 0,
            "content": "22. 找出下列每一对数的和与积。答案用三进制表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.646,
                0.226,
                0.661
            ],
            "angle": 0,
            "content": "a) \\((112)_3\\) ， \\((210)_3\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.432,
                0.646,
                0.604,
                0.661
            ],
            "angle": 0,
            "content": "b) \\((2112)_3\\) ， \\((12021)_3\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.664,
                0.252,
                0.679
            ],
            "angle": 0,
            "content": "c) \\((20001)_3\\) ， \\((1111)_3\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.432,
                0.664,
                0.614,
                0.679
            ],
            "angle": 0,
            "content": "d) \\((120021)_3\\) ， \\((2002)_3\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.682,
                0.482,
                0.695
            ],
            "angle": 0,
            "content": "23. 找出下列每一对数的和与积。答案用八进制表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.699,
                0.226,
                0.714
            ],
            "angle": 0,
            "content": "a) \\((763)_8\\) ， \\((147)_8\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.432,
                0.699,
                0.586,
                0.714
            ],
            "angle": 0,
            "content": "b) \\((6001)_8\\) ， \\((272)_8\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.717,
                0.234,
                0.731
            ],
            "angle": 0,
            "content": "c) \\((1111)_{8}\\), \\((777)_{8}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.432,
                0.717,
                0.604,
                0.731
            ],
            "angle": 0,
            "content": "d) \\((54321)_8\\) ， \\((3456)_8\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.735,
                0.499,
                0.748
            ],
            "angle": 0,
            "content": "24. 找出下列每一对数的和与积。答案用十六进制表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.752,
                0.25,
                0.767
            ],
            "angle": 0,
            "content": "a) \\((1\\mathrm{AE})_{16}\\) ， \\((\\mathrm{BBC})_{16}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.432,
                0.752,
                0.62,
                0.767
            ],
            "angle": 0,
            "content": "b) \\((20\\mathrm{CBA})_{16}\\) ，（A01）"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.77,
                0.278,
                0.784
            ],
            "angle": 0,
            "content": "c) \\((\\mathrm{ABCDE})_{16}\\) ， \\((1111)_{16}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.432,
                0.77,
                0.646,
                0.784
            ],
            "angle": 0,
            "content": "d) \\((\\mathrm{E0000E})_{16}\\) ， \\(\\mathrm{(BAAA)}_{16}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.788,
                0.287,
                0.802
            ],
            "angle": 0,
            "content": "25. 用算法5求 \\(7^{644} \\mod 645\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.806,
                0.295,
                0.82
            ],
            "angle": 0,
            "content": "26. 用算法5求 \\(11^{644} \\mod 645\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.823,
                0.281,
                0.837
            ],
            "angle": 0,
            "content": "27. 用算法5求 \\(3^{2003} \\mod 99\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.841,
                0.31,
                0.855
            ],
            "angle": 0,
            "content": "28. 用算法5求 \\(123^{1001} \\mod 101\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.858,
                0.833,
                0.873
            ],
            "angle": 0,
            "content": "29. 证明每个正整数都可以唯一地表示为 2 的不同次幂的和。[提示：考虑整数的二进制展开式。]"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.876,
                0.323,
                0.89
            ],
            "angle": 0,
            "content": "30. 可以证明每个整数都能表示为"
        },
        {
            "type": "list",
            "bbox": [
                0.05,
                0.788,
                0.833,
                0.89
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "equation",
            "bbox": [
                0.365,
                0.894,
                0.607,
                0.908
            ],
            "angle": 0,
            "content": "\\[\ne _ {k} 3 ^ {k} + e _ {k - 1} 3 ^ {k - 1} + \\dots + e _ {1} 3 + e _ {0}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.911,
                0.894,
                0.944
            ],
            "angle": 0,
            "content": "的形式，其中 \\(e_j = -1\\) ，0或1， \\(j = 0\\) ，1，2，…， \\(k\\) 。这一类展开称为平衡三进制展开式。求下列整数的平衡三进制展开式。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.135,
                0.042,
                0.172,
                0.056
            ],
            "angle": 0,
            "content": "228"
        },
        {
            "type": "header",
            "bbox": [
                0.216,
                0.041,
                0.28,
                0.057
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.099,
                0.17,
                0.111
            ],
            "angle": 0,
            "content": "a)5"
        },
        {
            "type": "text",
            "bbox": [
                0.305,
                0.099,
                0.345,
                0.111
            ],
            "angle": 0,
            "content": "b)13"
        },
        {
            "type": "text",
            "bbox": [
                0.491,
                0.099,
                0.527,
                0.111
            ],
            "angle": 0,
            "content": "c)37"
        },
        {
            "type": "text",
            "bbox": [
                0.687,
                0.099,
                0.726,
                0.111
            ],
            "angle": 0,
            "content": "d)79"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.116,
                0.689,
                0.131
            ],
            "angle": 0,
            "content": "31. 证明一个正整数被3整除当且仅当它的十进制数字之和能被3整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.134,
                0.953,
                0.166
            ],
            "angle": 0,
            "content": "32. 证明一个正整数能被11整除当且仅当它的偶数位十进制数字之和与奇数位十进制数字之和的差能被11整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.17,
                0.953,
                0.202
            ],
            "angle": 0,
            "content": "33. 求证一个正整数能被 3 整除当且仅当它的偶数位二进制数字之和与奇数位二进制数字之和的差能被 3 整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.205,
                0.654,
                0.22
            ],
            "angle": 0,
            "content": "34. 如何利用整数 \\( n \\) 的十进制展开式来判定 \\( n \\) 能否被下面的数整除？"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.224,
                0.171,
                0.237
            ],
            "angle": 0,
            "content": "a)2"
        },
        {
            "type": "text",
            "bbox": [
                0.307,
                0.225,
                0.336,
                0.236
            ],
            "angle": 0,
            "content": "b)5"
        },
        {
            "type": "text",
            "bbox": [
                0.493,
                0.226,
                0.529,
                0.236
            ],
            "angle": 0,
            "content": "c)10"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.242,
                0.655,
                0.256
            ],
            "angle": 0,
            "content": "35. 如何利用整数 \\( n \\) 的十进制展开式来判定 \\( n \\) 能否被下面的数整除？"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.261,
                0.171,
                0.272
            ],
            "angle": 0,
            "content": "a)4"
        },
        {
            "type": "text",
            "bbox": [
                0.307,
                0.261,
                0.346,
                0.272
            ],
            "angle": 0,
            "content": "b)25"
        },
        {
            "type": "text",
            "bbox": [
                0.493,
                0.261,
                0.529,
                0.272
            ],
            "angle": 0,
            "content": "c)20"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.277,
                0.942,
                0.292
            ],
            "angle": 0,
            "content": "36. 假设 \\(n\\) 和 \\(b\\) 是正整数且 \\(b \\geqslant 2\\), \\(n\\) 的 \\(b\\) 进制展开式为 \\(n = (a_{m}a_{m-1}\\dots a_{1}a_{0})_{b}\\) 。求下列数的 \\(b\\) 进制展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.297,
                0.18,
                0.31
            ],
            "angle": 0,
            "content": "a)bn"
        },
        {
            "type": "text",
            "bbox": [
                0.308,
                0.297,
                0.354,
                0.31
            ],
            "angle": 0,
            "content": "b) \\( b^{2}n \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.493,
                0.297,
                0.561,
                0.31
            ],
            "angle": 0,
            "content": "c) \\(\\lfloor n / b\\rfloor\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.689,
                0.296,
                0.766,
                0.31
            ],
            "angle": 0,
            "content": "d) \\(\\lfloor n / b^2\\rfloor\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.314,
                0.753,
                0.328
            ],
            "angle": 0,
            "content": "37. 证明如果 \\(n\\) 和 \\(b\\) 是正整数且 \\(b \\geqslant 2\\)，则 \\(n\\) 的 \\(b\\) 进制表示有 \\(\\lfloor \\log b n \\rfloor + 1\\) 位数字。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.332,
                0.928,
                0.346
            ],
            "angle": 0,
            "content": "38. 试找出 \\(n\\) 位7进制展开式 \\((111\\dots 111)_{7}(n\\) 个1)的十进制展开式。[提示：使用几何级数求和公式。]"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.35,
                0.955,
                0.382
            ],
            "angle": 0,
            "content": "39. 试找出 \\(3n\\) 位二进制展开式 \\((101101\\dots 101101)_2\\) （这个二进制展开式包含 \\(n\\) 份101的拷贝）的十进制展开式。[提示：使用几何级数求和公式。]"
        },
        {
            "type": "list",
            "bbox": [
                0.107,
                0.314,
                0.955,
                0.382
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.385,
                0.957,
                0.454
            ],
            "angle": 0,
            "content": "整数的1的补码表示法可以简化计算机算术。为了表示绝对值小于 \\(2^{n - 1}\\) 的正负整数，共需要 \\(n\\) 比特。最左边一比特用来表示符号。该位置上的比特0表示正整数，比特1表示负整数。对正整数来说，其余比特正好等同于该整数的二进制展开式。对负整数来说，其余比特可用通过先找出该整数绝对值的二进制展开式然后对其各比特求补得到，其中1的补码是0，而0的补码是1。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.457,
                0.564,
                0.472
            ],
            "angle": 0,
            "content": "40. 用长度为六的比特串找出下列整数的1的补码表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.476,
                0.185,
                0.488
            ],
            "angle": 0,
            "content": "a)22"
        },
        {
            "type": "text",
            "bbox": [
                0.311,
                0.476,
                0.348,
                0.488
            ],
            "angle": 0,
            "content": "b)31"
        },
        {
            "type": "text",
            "bbox": [
                0.496,
                0.477,
                0.542,
                0.488
            ],
            "angle": 0,
            "content": "c)-7"
        },
        {
            "type": "text",
            "bbox": [
                0.693,
                0.476,
                0.75,
                0.488
            ],
            "angle": 0,
            "content": "d)-19"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.493,
                0.529,
                0.507
            ],
            "angle": 0,
            "content": "41. 下列长度为五的 1 的补码所表示的是什么整数？"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.512,
                0.21,
                0.524
            ],
            "angle": 0,
            "content": "a)11001"
        },
        {
            "type": "text",
            "bbox": [
                0.312,
                0.513,
                0.376,
                0.524
            ],
            "angle": 0,
            "content": "b)01101"
        },
        {
            "type": "text",
            "bbox": [
                0.497,
                0.513,
                0.559,
                0.524
            ],
            "angle": 0,
            "content": "c)10001"
        },
        {
            "type": "text",
            "bbox": [
                0.693,
                0.512,
                0.758,
                0.524
            ],
            "angle": 0,
            "content": "d)11111"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.529,
                0.957,
                0.561
            ],
            "angle": 0,
            "content": "42. 如果 \\( m \\) 是一个小于 \\( 2^{n-1} \\) 的正整数，当用长度为 \\( n \\) 的比特串时，怎样从 \\( m \\) 的 1 的补码表示求出一 \\( m \\) 的 1 的补码表示？"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.565,
                0.622,
                0.579
            ],
            "angle": 0,
            "content": "43. 怎样从两个整数的 1 的补码表示得到其和的 1 的补码表示？"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.583,
                0.622,
                0.597
            ],
            "angle": 0,
            "content": "44. 怎样从两个整数的 1 的补码表示得到其差的 1 的补码表示？"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.6,
                0.957,
                0.633
            ],
            "angle": 0,
            "content": "45. 证明1的补码表示为 \\((a_{n - 1}a_{n - 2}\\dots a_1a_0)\\) 的整数 \\(m\\) 可以通过等式 \\(m = -a_{n - 1}(2^{n - 1} - 1) + a_{n - 2}2^{n - 2} + \\dots + a_1\\cdot 2 + a_0\\) 计算而得。"
        },
        {
            "type": "list",
            "bbox": [
                0.11,
                0.529,
                0.957,
                0.633
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.636,
                0.96,
                0.725
            ],
            "angle": 0,
            "content": "整数的2的补码表示也可以用来简化计算机算术，而且比1的补码表示更常用。对给定的正整数 \\(n\\) ，要表示满足 \\(-2^{n - 1}\\leqslant x\\leqslant 2^{n - 1} - 1\\) 的整数 \\(x\\) ，共需要 \\(n\\) 比特。最左边一比特用来表示符号。与1的补码展示式一样，该位置上的比特0表示正整数，比特1表示负整数。对正整数来说，其余比特等同于该整数的二进制展开式。对负整数而言，其余比特是 \\(2^{n - 1} - |x|\\) 的二进制展开式中。计算机中常用整数的2的补码表示，因为不论整数是正是负，都很容易用这种表示来做整数的加法和减法。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.728,
                0.643,
                0.742
            ],
            "angle": 0,
            "content": "46. 解答练习 40，这次使用 2 的补码表示并用长度为六的比特串。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.746,
                0.626,
                0.76
            ],
            "angle": 0,
            "content": "47. 解答练习 41，如果每个表示都是长度为五的 2 的补码表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.764,
                0.385,
                0.778
            ],
            "angle": 0,
            "content": "48. 用2的补码表示解答练习42。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.782,
                0.385,
                0.796
            ],
            "angle": 0,
            "content": "49. 用2的补码表示解答练习43。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.8,
                0.385,
                0.814
            ],
            "angle": 0,
            "content": "50. 用2的补码表示解答练习44。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.818,
                0.96,
                0.85
            ],
            "angle": 0,
            "content": "51. 证明2的补码表示为 \\((a_{n - 1}a_{n - 2}\\dots a_1a_0)\\) 的整数 \\(m\\) 可以通过等式 \\(m = -a_{n - 1}\\cdot 2^{n - 1} + a_{n - 2}\\cdot 2^{n - 2} + \\dots +\\) \\(a_1\\cdot 2 + a_0\\) 计算而得。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.854,
                0.697,
                0.868
            ],
            "angle": 0,
            "content": "52. 试给出一个简单的算法从整数的1的补码表示构成其2的补码表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.871,
                0.962,
                0.922
            ],
            "angle": 0,
            "content": "53. 有时通过用四位二进制展开式表示每个十进制数字来为整数编码。这就产生了整数的二进制编码的十进制形式。例如，用这种方式为791编码得011110010001。采用这种编码方式表示一个 \\(n\\) 位的十进制数需要多少比特？"
        },
        {
            "type": "list",
            "bbox": [
                0.112,
                0.728,
                0.962,
                0.922
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.925,
                0.38,
                0.94
            ],
            "angle": 0,
            "content": "康托尔展开式是这种形式的和式"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.638,
                0.044,
                0.771,
                0.06
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.816,
                0.046,
                0.854,
                0.059
            ],
            "angle": 0,
            "content": "229"
        },
        {
            "type": "equation",
            "bbox": [
                0.295,
                0.102,
                0.618,
                0.117
            ],
            "angle": 0,
            "content": "\\[\na _ {n} n! + a _ {n - 1} (n - 1)! + \\dots + a _ {2} 2! + a _ {1} 1!\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.035,
                0.119,
                0.4,
                0.134
            ],
            "angle": 0,
            "content": "其中 \\(a_{i}\\) 为整数且 \\(0 \\leqslant a_{i} \\leqslant i, i = 1, 2, \\dots, n\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.035,
                0.137,
                0.303,
                0.152
            ],
            "angle": 0,
            "content": "54. 求下列各数的康托尔展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.155,
                0.101,
                0.169
            ],
            "angle": 0,
            "content": "a)2"
        },
        {
            "type": "text",
            "bbox": [
                0.232,
                0.155,
                0.266,
                0.168
            ],
            "angle": 0,
            "content": "b)7"
        },
        {
            "type": "text",
            "bbox": [
                0.417,
                0.155,
                0.457,
                0.168
            ],
            "angle": 0,
            "content": "c)19"
        },
        {
            "type": "text",
            "bbox": [
                0.614,
                0.155,
                0.655,
                0.168
            ],
            "angle": 0,
            "content": "d)87"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.173,
                0.127,
                0.186
            ],
            "angle": 0,
            "content": "e)1000"
        },
        {
            "type": "text",
            "bbox": [
                0.233,
                0.173,
                0.326,
                0.186
            ],
            "angle": 0,
            "content": "f)1000000"
        },
        {
            "type": "text",
            "bbox": [
                0.025,
                0.19,
                0.397,
                0.204
            ],
            "angle": 0,
            "content": "* 55. 试描述找出整数的康托尔展开式的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.025,
                0.208,
                0.451,
                0.222
            ],
            "angle": 0,
            "content": "* 56. 试描述将两个整数的康托尔展开式相加的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.035,
                0.226,
                0.641,
                0.24
            ],
            "angle": 0,
            "content": "57. 按照书中给出的加法算法步骤，一步一步把 \\((10111)_2\\) 和 \\((11010)_2\\) 相加。"
        },
        {
            "type": "text",
            "bbox": [
                0.035,
                0.244,
                0.623,
                0.259
            ],
            "angle": 0,
            "content": "58. 按照书中给出的乘法算法步骤，一步一步把 \\((1110)_2\\) 和 \\((1010)_2\\) 相乘。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.262,
                0.415,
                0.276
            ],
            "angle": 0,
            "content": "59. 试描述计算两个二进制展开式之差的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.28,
                0.508,
                0.294
            ],
            "angle": 0,
            "content": "60. 试估算两个二进制展开式的减法所需比特运算的次数。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.297,
                0.752,
                0.312
            ],
            "angle": 0,
            "content": "61. 设计一个算法，给定整数 \\(a\\) 和 \\(b\\) 的二进制展开，判断是否有 \\(a > b\\) ，\\(a = b\\) ，或者 \\(a < b\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.315,
                0.885,
                0.329
            ],
            "angle": 0,
            "content": "62. 当整数 \\( a \\) 和 \\( b \\) 中较大的数的二进制展开式有 \\( n \\) 位时，练习61中的比较算法需要要做多少次比特运算？"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.333,
                0.711,
                0.347
            ],
            "angle": 0,
            "content": "63. 采用所需除法次数来衡量，试估算求整数 \\(n\\) 的 \\(b\\) 进制展开式的算法1的复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.025,
                0.351,
                0.618,
                0.365
            ],
            "angle": 0,
            "content": "* 64. 证明算法5使用 \\(O((\\log m)^2 \\log n)\\) 次二进制位运算来计算 \\(b^n \\mod m\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.369,
                0.548,
                0.384
            ],
            "angle": 0,
            "content": "65. 证明算法4使用 \\(O(q\\log |a|)\\) 次二进制位运算，假设 \\(a > d\\)。"
        },
        {
            "type": "list",
            "bbox": [
                0.025,
                0.19,
                0.885,
                0.384
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.039,
                0.399,
                0.32,
                0.42
            ],
            "angle": 0,
            "content": "4.3 素数和最大公约数"
        },
        {
            "type": "title",
            "bbox": [
                0.04,
                0.428,
                0.166,
                0.444
            ],
            "angle": 0,
            "content": "4.3.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.04,
                0.447,
                0.889,
                0.502
            ],
            "angle": 0,
            "content": "4.1节研究了整数整除性的概念。基于整除性的一个重要概念就是素数。素数是大于1的且不能被1和它自身以外的正整数整除的整数。对素数的研究可以追溯到远古时代。几千年前人们就知道素数有无限多个，在欧几里得的著作中所发现的该事实的证明也以其优雅和漂亮而闻名。"
        },
        {
            "type": "text",
            "bbox": [
                0.04,
                0.505,
                0.889,
                0.578
            ],
            "angle": 0,
            "content": "我们将讨论整数中素数的分布。我们还将描述一部分近400年来数学家所发现的有关素数的结论。特别是，我们要介绍一个重要的定理——算术基本定理。该定理断言每个正整数都可以唯一表示为按非递减排序的素数乘积，它具有很多有趣的推论。我们还将讨论一些有关素数的古老且至今仍然悬而未决的猜想。"
        },
        {
            "type": "text",
            "bbox": [
                0.04,
                0.581,
                0.889,
                0.635
            ],
            "angle": 0,
            "content": "素数已经成为现代密码系统中必不可缺少的一部分，我们将阐述其在密码学中的一些重要性质。比如，寻找大素数在现代密码学中是一个基本课题。对大整数进行素因子分解所需的时间尺度是一些重要的现代密码系统中密码强度的基础。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.638,
                0.889,
                0.674
            ],
            "angle": 0,
            "content": "本节还将介绍两个整数的最大公约数和最小公倍数。我们还将讨论一个重要算法，即欧几里得算法来计算最大公约数。"
        },
        {
            "type": "title",
            "bbox": [
                0.043,
                0.685,
                0.17,
                0.701
            ],
            "angle": 0,
            "content": "4.3.2 素数"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.705,
                0.889,
                0.74
            ],
            "angle": 0,
            "content": "每个大于1的整数至少能被两个整数整除，因为一个正整数可以被1和它自己整除。恰有两个不同的正整数因子的整数称为素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.748,
                0.885,
                0.786
            ],
            "angle": 0,
            "content": "定义1大于1的整数 \\( p \\) 称为素数，如果 \\( p \\) 的正因子只是1和 \\( p \\) 。大于1但又不是素数的正整数称为合数。"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.795,
                0.89,
                0.831
            ],
            "angle": 0,
            "content": "评注 整数1不是素数，因为它只有一个正因子。还要注意整数 \\(n\\) 是合数当且仅当存在整数 \\(a\\) 使得 \\(a \\mid n\\) 并且 \\(1 < a < n\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.836,
                0.892,
                0.875
            ],
            "angle": 0,
            "content": "例1 整数7是素数，因为它仅有的正因子是1和7。而整数9是合数，因为它能被3整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.877,
                0.796,
                0.894
            ],
            "angle": 0,
            "content": "正如算术基本定理所阐述的，素数是正整数的基本构件。证明将在5.2节给出。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.903,
                0.886,
                0.94
            ],
            "angle": 0,
            "content": "定理1 算术基本定理 每个大于1的整数都可以唯一地写为两个或多个素数的乘积，其中素数因子以非递减序排列。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.142,
                0.048,
                0.178,
                0.062
            ],
            "angle": 0,
            "content": "230"
        },
        {
            "type": "header",
            "bbox": [
                0.223,
                0.047,
                0.29,
                0.063
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.153,
                0.104,
                0.497,
                0.12
            ],
            "angle": 0,
            "content": "例2给出了一些整数的素因子分解式。"
        },
        {
            "type": "text",
            "bbox": [
                0.153,
                0.126,
                0.605,
                0.143
            ],
            "angle": 0,
            "content": "例2 100、641、999和1024的素因子分解式如下"
        },
        {
            "type": "equation",
            "bbox": [
                0.337,
                0.149,
                0.737,
                0.22
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} 1 0 0 = 2 \\cdot 2 \\cdot 5 \\cdot 5 = 2 ^ {2} 5 ^ {2} \\\\ 6 4 1 = 6 4 1 \\\\ 9 9 9 = 3 \\cdot 3 \\cdot 3 \\cdot 3 7 = 3 ^ {3} \\cdot 3 7 \\\\ 1 0 2 4 = 2 \\cdot 2 \\cdot 2 \\cdot 2 \\cdot 2 \\cdot 2 \\cdot 2 \\cdot 2 \\cdot 2 \\cdot 2 = 2 ^ {1 0} \\\\ \\end{array}\n\\]"
        },
        {
            "type": "title",
            "bbox": [
                0.111,
                0.234,
                0.264,
                0.251
            ],
            "angle": 0,
            "content": "4.3.3 试除法"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.254,
                0.96,
                0.291
            ],
            "angle": 0,
            "content": "证明一个给定的整数是素数是很重要的。例如，在密码学中大素数就用在为信息加密的某些方法中。一个证明整数为素数的过程就是基于下面的观察。"
        },
        {
            "type": "text",
            "bbox": [
                0.162,
                0.302,
                0.749,
                0.321
            ],
            "angle": 0,
            "content": "定理2 如果 \\(n\\) 是一个合数，那么 \\(n\\) 必有一个素因子小于等于 \\(\\sqrt{n}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.329,
                0.962,
                0.437
            ],
            "angle": 0,
            "content": "证明 如果 \\(n\\) 是合数，由合数的定义，可知它有一个满足 \\(1 < a < n\\) 的因子 \\(a\\)。故，由正整数的因子的定义，可知 \\(n = ab\\)，其中 \\(b\\) 是大于 1 的正整数。我们证明 \\(a \\leqslant \\sqrt{n}\\) 或 \\(b \\leqslant \\sqrt{n}\\)。如果 \\(a > \\sqrt{n}\\) 且 \\(b > \\sqrt{n}\\)，则 \\(ab > \\sqrt{n} \\cdot \\sqrt{n} = n\\)，矛盾。因此，有 \\(a \\leqslant \\sqrt{n}\\) 或 \\(b \\leqslant \\sqrt{n}\\)。因为 \\(a\\) 和 \\(b\\) 都是 \\(n\\) 的因子，我们已经看到了 \\(n\\) 有一个不超过 \\(\\sqrt{n}\\) 的正因子。这个因子或者是素数，或者（由算术基本定理）有比它小的素因子。无论哪种情况，\\(n\\) 有一个素因子小于或等于 \\(\\sqrt{n}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.44,
                0.962,
                0.5
            ],
            "angle": 0,
            "content": "从定理2可知，如果一个整数不能被小于或等于其平方根的素数整除，则它就是素数。这一结论导致了称为试除法的蛮力算法。要用试除法，我们把 \\( n \\) 除以所有不超过 \\( \\sqrt{n} \\) 的素数，如果不能被其中任意一个素数整除就可以得出结论 \\( n \\) 是素数。例3就是用试除法来证明101是素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.504,
                0.363,
                0.522
            ],
            "angle": 0,
            "content": "例3 证明101是素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.53,
                0.96,
                0.566
            ],
            "angle": 0,
            "content": "解 不超过 \\(\\sqrt{101}\\) 的素数仅有 2, 3, 5 和 7。因为 101 不能被 2, 3, 5 和 7 整除 (101 被这些数除的商都不是整数), 所以 101 是素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.568,
                0.962,
                0.705
            ],
            "angle": 0,
            "content": "由于每个整数都有素因子分解式，所以有一个寻找素因子分解式的算法将会很有用。考虑寻找整数 \\( n \\) 的素因子分解式的问题。从最小素数2开始，依次用素数去除 \\( n \\) 。如果 \\( n \\) 有素因子，则由定理2可知，可以找到一个不超过 \\( \\sqrt{n} \\) 的素因子 \\( p \\) 。所以，如果找不到不超过 \\( \\sqrt{n} \\) 的素因子，则 \\( n \\) 为素数。否则，如果找到一个素因子 \\( p \\)，则可以继续对 \\( n / p \\) 做因子分解。注意 \\( n / p \\) 没有小于 \\( p \\) 的素因子。同样的道理，如果 \\( n / p \\) 没有大于等于 \\( p \\) 且不超过它的平方根的素因子，则它为素数。否则，如果它有素因子 \\( q \\)，则可以继续对 \\( n / (pq) \\) 做因子分解。这一过程一直继续直到因子分解只剩一个素数为止。例4解释了这一过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.709,
                0.455,
                0.727
            ],
            "angle": 0,
            "content": "例4 找出7007的素因子分解式。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.731,
                0.962,
                0.788
            ],
            "angle": 0,
            "content": "解 要找出7007的素因子分解式，首先不断地用素数去除7007，从2开始。2、3和5都除不尽7007。但是，7除尽7007，\\(7007 / 7 = 1001\\)。下一步，从7开始不断地用素数去除1001。立刻发现7还能整除1001，因为 \\(1001 / 7 = 143\\)。继续从7开始不断用素数去除143。虽然7不"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.796,
                0.157,
                0.811
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.111,
                0.829,
                0.253,
                0.933
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.11,
                0.936,
                0.251,
                0.947
            ],
            "angle": 0,
            "content": "Source: Math Tutor Archive"
        },
        {
            "type": "text",
            "bbox": [
                0.268,
                0.829,
                0.96,
                0.933
            ],
            "angle": 0,
            "content": "埃拉托斯特尼（公元前276一公元前194）他出生在昔兰尼(埃及以西的一个希腊殖民地)并在雅典的柏拉图学院学习。我们知道当时国王托勒密二世邀请埃拉托斯特尼到亚历山大来教他的儿子，后来埃拉托斯特尼成为亚历山大最著名的图书馆(一个古代智慧资料库)的馆长。埃拉托斯特尼是一个知识面极宽的学者，著作论及数学、地理学、天文学、历史学、哲学和文学批评。除了在数学领域的工作外，他还以古代历史编年表和著名的测量地球大小而闻名。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.652,
                0.037,
                0.784,
                0.052
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.83,
                0.038,
                0.865,
                0.052
            ],
            "angle": 0,
            "content": "231"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.093,
                0.894,
                0.146
            ],
            "angle": 0,
            "content": "能整除143，但11整除143，得 \\(143 / 11 = 13\\) 。由于13为素数，这一过程完成。由此得出\\(7007 = 7\\cdot 1001 = 7\\cdot 7\\cdot 143 = 7\\cdot 7\\cdot 11\\cdot 13\\) 。因此，7007的素因子分解式是 \\(7\\cdot 7\\cdot 11\\cdot 13 =\\) \\(7^{2}\\cdot 11\\cdot 13\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.151,
                0.894,
                0.187
            ],
            "angle": 0,
            "content": "素数的研究在古代是为了探究原理。今天，其研究已经有了很实用的目的。特别是，大素数在密码学中起着关键作用，在4.6节将会看到。"
        },
        {
            "type": "title",
            "bbox": [
                0.048,
                0.197,
                0.311,
                0.214
            ],
            "angle": 0,
            "content": "4.3.4 埃拉托斯特尼筛法"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.217,
                0.894,
                0.272
            ],
            "angle": 0,
            "content": "注意，不超过100的合数必定有一个不超过10的素因子。因为小于10的素数仅有2、3、5和7，所以不超过100的素数就是这四个素数以及那些大于1且不超过100同时不能被2、3、5和7之一整除的正整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.274,
                0.894,
                0.501
            ],
            "angle": 0,
            "content": "埃拉托斯特尼筛法（sieve of Eratosthenes）就是用来寻找不超过一个给定整数的所有素数。例如，下列过程就是寻找不超过100的素数。首先构造 \\(1\\sim 100\\) 全部整数的列表。筛法开始过程，除了2以外，删除那些能被2整除的整数。因为3是保留下来的第一个大于2的整数，所以除了3以外，删除所有那些能被3整除的整数。因为5是3之后保留下来的下一个整数，所以除了5以外，删除那些能被5整除的整数。保留下来的下一个数是7，所以，除了7以外，删除那些能被7整除的整数。因为所有不超过100的合数能被2、3、5或7整除，所以除了1以外，所有保留下来的整数都是素数。在表1中展示了每个阶段被删除的整数，其中第一个区域中能被2整除的每个整数(2除外)加一条下划线，第二个区域能被3整除的每个整数(3除外)加一条下划线，第三个区域中能被5整除的每个整数(5除外)加一条下划线，第四个区域中能被7整除的每个整数(7除外)加一条下划线。没有下划线的整数就是不超过100的素数。我们得出结论：不超过100的整数是2，3，5，7，11，13，17，19，23，29，31，37，41，43，47，53，59，61，67，71，73，79，83，89，97。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.365,
                0.512,
                0.57,
                0.527
            ],
            "angle": 0,
            "content": "表 1 埃拉托斯特尼筛法"
        },
        {
            "type": "table",
            "bbox": [
                0.049,
                0.532,
                0.891,
                0.939
            ],
            "angle": 0,
            "content": "<table><tr><td colspan=\"11\">2以外能被2整除的整数加一条下划线</td><td colspan=\"10\">3以外能被3整除的整数加一条下划线</td></tr><tr><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td></td></tr><tr><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td><td>18</td><td>19</td><td>20</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td><td>18</td><td>19</td><td>20</td><td></td></tr><tr><td>21</td><td>22</td><td>23</td><td>24</td><td>25</td><td>26</td><td>27</td><td>28</td><td>29</td><td>30</td><td>21</td><td>22</td><td>23</td><td>24</td><td>25</td><td>26</td><td>27</td><td>28</td><td>29</td><td>30</td><td></td></tr><tr><td>31</td><td>32</td><td>33</td><td>34</td><td>35</td><td>36</td><td>37</td><td>38</td><td>39</td><td>40</td><td>31</td><td>32</td><td>33</td><td>34</td><td>35</td><td>36</td><td>37</td><td>38</td><td>39</td><td>40</td><td></td></tr><tr><td>41</td><td>42</td><td>43</td><td>44</td><td>45</td><td>46</td><td>47</td><td>48</td><td>49</td><td>50</td><td>41</td><td>42</td><td>43</td><td>44</td><td>45</td><td>46</td><td>47</td><td>48</td><td>49</td><td>50</td><td></td></tr><tr><td>51</td><td>52</td><td>53</td><td>54</td><td>55</td><td>56</td><td>57</td><td>58</td><td>59</td><td>60</td><td>51</td><td>52</td><td>53</td><td>54</td><td>55</td><td>56</td><td>57</td><td>58</td><td>59</td><td>60</td><td></td></tr><tr><td>61</td><td>62</td><td>63</td><td>64</td><td>65</td><td>66</td><td>67</td><td>68</td><td>69</td><td>70</td><td>61</td><td>62</td><td>63</td><td>64</td><td>65</td><td>66</td><td>67</td><td>68</td><td>69</td><td>70</td><td></td></tr><tr><td>71</td><td>72</td><td>73</td><td>74</td><td>75</td><td>76</td><td>77</td><td>78</td><td>79</td><td>80</td><td>71</td><td>72</td><td>73</td><td>74</td><td>75</td><td>76</td><td>77</td><td>78</td><td>79</td><td>80</td><td></td></tr><tr><td>81</td><td>82</td><td>83</td><td>84</td><td>85</td><td>86</td><td>87</td><td>88</td><td>89</td><td>90</td><td>81</td><td>82</td><td>83</td><td>84</td><td>85</td><td>86</td><td>87</td><td>88</td><td>89</td><td>90</td><td></td></tr><tr><td>91</td><td>92</td><td>93</td><td>94</td><td>95</td><td>96</td><td>97</td><td>98</td><td>99</td><td>100</td><td>91</td><td>92</td><td>93</td><td>94</td><td>95</td><td>96</td><td>97</td><td>98</td><td>99</td><td>100</td><td></td></tr><tr><td colspan=\"10\">5以外能被5整除的整数加一条下划线</td><td colspan=\"10\">7以外能被7整除的整数加一条下划线;斜体表示的整数是素数</td><td></td></tr><tr><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td></td></tr><tr><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td><td>18</td><td>19</td><td>20</td><td>11</td><td>12</td><td>13</td><td>14</td><td>14</td><td>15</td><td>16</td><td>17</td><td>18</td><td>19</td><td></td></tr><tr><td>21</td><td>22</td><td>23</td><td>24</td><td>25</td><td>26</td><td>27</td><td>28</td><td>29</td><td>30</td><td>21</td><td>22</td><td>23</td><td>24</td><td>25</td><td>26</td><td>27</td><td>28</td><td>29</td><td>30</td><td></td></tr><tr><td>31</td><td>32</td><td>33</td><td>34</td><td>35</td><td>36</td><td>37</td><td>38</td><td>39</td><td>40</td><td>31</td><td>33</td><td>33</td><td>34</td><td>35</td><td>36</td><td>37</td><td>38</td><td>39</td><td>40</td><td></td></tr><tr><td>41</td><td>42</td><td>43</td><td>44</td><td>45</td><td>46</td><td>47</td><td>48</td><td>49</td><td>50</td><td>41</td><td>42</td><td>43</td><td>44</td><td>45</td><td>46</td><td>47</td><td>48</td><td>49</td><td>50</td><td></td></tr><tr><td>51</td><td>52</td><td>53</td><td>53</td><td>54</td><td>55</td><td>56</td><td>57</td><td>58</td><td>59</td><td>51</td><td>52</td><td>53</td><td>54</td><td>55</td><td>56</td><td>57</td><td>58</td><td>59</td><td>60</td><td></td></tr><tr><td>61</td><td>62</td><td>63</td><td>64</td><td>65</td><td>66</td><td>67</td><td>68</td><td>69</td><td>70</td><td>61</td><td>62</td><td>63</td><td>64</td><td>65</td><td>66</td><td>67</td><td>68</td><td>69</td><td>70</td><td></td></tr><tr><td>71</td><td>71</td><td>72</td><td>73</td><td>74</td><td>75</td><td>76</td><td>77</td><td>78</td><td>79</td><td>71</td><td>72</td><td>73</td><td>74</td><td>75</td><td>76</td><td>77</td><td>78</td><td>79</td><td>80</td><td></td></tr><tr><td>81</td><td>82</td><td>83</td><td>84</td><td>85</td><td>86</td><td>87</td><td>88</td><td>89</td><td>90</td><td>81</td><td>82</td><td>83</td><td>84</td><td>85</td><td>86</td><td>87</td><td>88</td><td>89</td><td>90</td><td></td></tr><tr><td>91</td><td>91</td><td>92</td><td>93</td><td>94</td><td>95</td><td>96</td><td>97</td><td>98</td><td>99</td><td>100</td><td>91</td><td>92</td><td>93</td><td>94</td><td>95</td><td>96</td><td>97</td><td>98</td><td>99</td><td>100</td></tr></table>"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.142,
                0.041,
                0.178,
                0.054
            ],
            "angle": 0,
            "content": "232"
        },
        {
            "type": "header",
            "bbox": [
                0.225,
                0.04,
                0.289,
                0.054
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.096,
                0.964,
                0.228
            ],
            "angle": 0,
            "content": "素数的无限性 人们长期以来就已经知道有无限多个素数。这意味着当 \\(p_1, p_2, \\dots, p_n\\) 是 \\(n\\) 个最小的素数时，我们知道就有一个更大的素数不在其中。我们将用欧几里得在其著名的数学教科书《几何原本》(The Elements)中给出的证明来证明这个事实。这个简单优雅的证明被许多数学家认为是数学中最漂亮的证明。它是《天书中的证明》(Proofs from THE BOOK)一书中位列第一的证明，这里天书是指想象中完美证明的集册，这些证明被著名数学家保罗·埃德斯声称是由上帝维护的。顺便提一下，存在数量巨大的不同的证明来证明存在无限多个素数，并且新的证明还在以惊人的速度频繁地发表出来。"
        },
        {
            "type": "text",
            "bbox": [
                0.169,
                0.237,
                0.424,
                0.253
            ],
            "angle": 0,
            "content": "定理3 存在无限多个素数。"
        },
        {
            "type": "image",
            "bbox": [
                0.073,
                0.264,
                0.103,
                0.289
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.159,
                0.264,
                0.843,
                0.28
            ],
            "angle": 0,
            "content": "证明 用反证法证明这个定理。假设只有有限多个素数 \\(p_1, p_2, \\dots, p_n\\) 。令"
        },
        {
            "type": "equation",
            "bbox": [
                0.459,
                0.284,
                0.624,
                0.299
            ],
            "angle": 0,
            "content": "\\[\nQ = p _ {1} p _ {2} \\dots p _ {n} + 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.301,
                0.965,
                0.376
            ],
            "angle": 0,
            "content": "根据算术基本定理， \\(Q\\) 要么是素数，要么能被写成两个或多个素数之积。但是，没有一个素数\\(p_j\\) 能整除 \\(Q\\) ，因为如果 \\(p_j|Q\\) ，则 \\(p_j\\) 整除 \\(Q - p_1p_2\\dots p_n = 1\\) 。因此，存在一个不在 \\(p_1,p_2,\\dots ,\\) \\(p_n\\) 中的素数。这个素数要么是 \\(Q\\) (如果 \\(Q\\) 是素数)，要么是 \\(Q\\) 的一个素因子。这就是一个矛盾，因为我们假设列出了所有的素数。因此，存在无限多个素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.379,
                0.967,
                0.434
            ],
            "angle": 0,
            "content": "评注 注意在这个证明中我们没有说 \\(Q\\) 是素数！而且，在这个证明中，我们给出的是非构造性的存在性证明：给定 \\(n\\) 个素数，存在一个不在表中的素数。对于构造性的证明，就必须显式地给出一个不在初始的 \\(n\\) 个素数列表中的素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.436,
                0.969,
                0.568
            ],
            "angle": 0,
            "content": "由于存在无限多个素数，所以给定任意正整数都存在大于这个整数的素数。人们不断追求去发现越来越大的素数。近300年来，已知最大的素数几乎都是特殊形式 \\(2^{p} - 1\\) 的整数，其中\\(p\\) 也是素数。（注意当 \\(n\\) 不是素数时 \\(2^{n} - 1\\) 不可能是素数。参见练习9。）这种素数称为梅森素数，这是以法国修道士马兰·梅森的名字命名的，他在17世纪就研究这些素数。之所以已知最大素数通常都是梅森素数，是因为有一个特别有效的称为卢卡斯-莱默尔(Lucas-Lehmer)测试的测试方法可以判断 \\(2^{p} - 1\\) 是否为素数。而且，当前还不可能以差不多同样快的速度判断一个不是这种或其他特殊形式的整数是否为素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.573,
                0.969,
                0.611
            ],
            "angle": 0,
            "content": "例5 整数 \\(2^{2} - 1 = 3\\) ， \\(2^{3} - 1 = 7\\) 和 \\(2^{5} - 1 = 31\\) 都是梅森素数，而 \\(2^{11} - 1 = 2047\\) 不是梅森素数，因为 \\(2047 = 23 \\cdot 89\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.614,
                0.969,
                0.632
            ],
            "angle": 0,
            "content": "自从发明了计算机以后，寻找梅森素数的进展一直稳步向前。截至2018年早些时候，已"
        },
        {
            "type": "text",
            "bbox": [
                0.125,
                0.645,
                0.168,
                0.654
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.125,
                0.674,
                0.267,
                0.777
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.125,
                0.782,
                0.233,
                0.793
            ],
            "angle": 0,
            "content": "©Apic/Getty Images"
        },
        {
            "type": "text",
            "bbox": [
                0.283,
                0.673,
                0.972,
                0.812
            ],
            "angle": 0,
            "content": "马兰·梅森（Marin Mersenne，1588—1648）梅森生在法国的缅因省（现今为萨尔特省）的一个农民家庭，在勒芒学院（College of Mans)和位于La Flèche的基督学院上过学。\\(1609\\sim 1611\\) 年他在索邦大学继续学业，学习神学。1611年他加入米尼玛(Minims)宗教团体，米尼玛的名字来自Minimi一词（这个组织的成员都极为谦逊，自认为是所有宗教团体中最为卑微的）。除了祈祷外，这个团体的成员献身于学术和研究。1612年他在巴黎的皇家广场任牧师，\\(1614\\sim 1618\\) 年他在内维尔(Nevers)的米尼玛修道院教授哲学。1619年他回到巴黎，而他位于Annociade的米尼玛宿舍却成了包括费马和帕斯卡在内的法国科学家、哲学家和数学家的聚会场所。梅森与全欧"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.814,
                0.974,
                0.938
            ],
            "angle": 0,
            "content": "洲的学者频繁通信，担当数学和科学知识交流中心的角色，如同后来的数学学术期刊（及今日之互联网）的作用。梅森撰写的书籍涵盖力学、数学物理、数学、音乐和声学。他研究素数并尝试构造一个能表示所有素数的公式，但没有成功。1644年梅森声称，当 \\( p = 2 \\)，3，5，7，13，17，19，31，67，127，257时， \\( 2^{p} - 1 \\) 是素数；而对于小于257的所有其他素数 \\( p \\)， \\( 2^{p} - 1 \\) 是合数。人们花了300多年的时间在梅森的上述论断中找到5个错误。特别是当 \\( p = 67 \\) 和 \\( p = 257 \\) 时， \\( 2^{p} - 1 \\) 不是素数，而当 \\( p = 61 \\)， \\( p = 87 \\) 和 \\( p = 107 \\) 时， \\( 2^{p} - 1 \\) 是素数。值得一提的是，梅森还为两位当时最有名的人物笛卡儿和伽利略受到宗教批评而辩护。他还协助揭露炼丹术士和占星术士的骗术。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.657,
                0.041,
                0.789,
                0.057
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.836,
                0.043,
                0.871,
                0.056
            ],
            "angle": 0,
            "content": "233"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.097,
                0.904,
                0.21
            ],
            "angle": 0,
            "content": "有50个梅森素数被发现，其中19个是1990年以来找到的。已知最大的梅森素数（时至2018年早些时候）是 \\(2^{77232917} - 1\\) ，这是一个有23249425位的十进制数，在2017年12月被证明是素数。互联网梅森素数大搜索(GIMPS)作为一个共同体致力于寻找新的梅森素数。你可以加入这个大搜索，如果幸运的话，寻找到一个新的梅森素数，甚至有可能赢得现金大奖。顺便说一句，寻找梅森素数本身就是有实际意义的。对超级计算机的一种质量控制检验就是复制了用来判定一个大梅森素数是素数的卢卡斯-莱默尔测试。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.212,
                0.904,
                0.287
            ],
            "angle": 0,
            "content": "素数的分布 定理3告诉我们存在无限多个素数。可是，小于一个正整数 \\(x\\) 的素数有多少个呢？这个问题吸引了数学家很多年。在18世纪晚期，数学家编制了很大的素数表来收集有关素数分布的证据。利用这些证据，当时的大数学家包括高斯和勒让德，都猜想有但没能证明定理4。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.294,
                0.896,
                0.333
            ],
            "angle": 0,
            "content": "定理4 素数定理 当 \\(x\\) 无限增长时，不超过 \\(x\\) 的素数个数与 \\(x / \\ln x\\) 之比 \\(\\pi(x)\\) 趋近于1。（这里 \\(\\ln x\\) 是 \\(x\\) 的自然对数。）"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.341,
                0.904,
                0.396
            ],
            "angle": 0,
            "content": "法国数学家雅克·阿达马(Jacques Hadamard)和比利时数学家瓦列·普金(Charles-Jean-Gustave-Nicholas de la Vallee-Poussin)利用复变函数论在1896年首次证明了素数定理。虽然已经有了不用复变函数论的证明，但是素数定理所有已知的证明都非常复杂。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.398,
                0.904,
                0.434
            ],
            "angle": 0,
            "content": "目前已经证明了素数定理的诸多改进，其中有许多是论述当利用 \\(x / \\ln x\\) 或其他函数来估算 \\(\\pi (x)\\) 时产生的误差问题。该研究领域依然有许多未解决的问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.436,
                0.905,
                0.492
            ],
            "angle": 0,
            "content": "表2展示了 \\(\\pi (x)\\) 和 \\(x / \\ln x\\) 以及二者的比值。这里 \\(x = 10^{n}\\) ， \\(3\\leqslant n\\leqslant 10\\) 。针对非常大的 \\(x\\) 值，人们付出了极大的努力来计算 \\(\\pi (x)\\) 。截至2017年晚些时候，对于所有 \\(n\\leqslant 26\\) 的正整数 \\(n\\) ，小于等于 \\(10^{n}\\) 的素数个数已经被确认。特别是，已知"
        },
        {
            "type": "equation",
            "bbox": [
                0.283,
                0.494,
                0.679,
                0.51
            ],
            "angle": 0,
            "content": "\\[\n\\pi \\left(1 0 ^ {2 6}\\right) = 1 6 9 9 2 4 6 7 5 0 8 7 2 4 3 7 1 4 1 3 2 7 6 0 3\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.513,
                0.164,
                0.53
            ],
            "angle": 0,
            "content": "差值整数为"
        },
        {
            "type": "equation",
            "bbox": [
                0.221,
                0.532,
                0.739,
                0.548
            ],
            "angle": 0,
            "content": "\\[\n\\pi \\left(1 0 ^ {2 6}\\right) - \\left(1 0 ^ {2 6} / \\ln 1 0 ^ {2 6}\\right) = 2 8 8 8 3 3 5 8 9 3 6 8 5 3 1 8 8 8 2 3 2 6 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.551,
                0.267,
                0.568
            ],
            "angle": 0,
            "content": "六位有效数字的比值为"
        },
        {
            "type": "title",
            "bbox": [
                0.059,
                0.575,
                0.126,
                0.597
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.062,
                0.61,
                0.201,
                0.714
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.06,
                0.717,
                0.197,
                0.737
            ],
            "angle": 0,
            "content": "\\(\\langle \\widehat{\\mathbb{C}}\\rangle\\) Paul Fearn/Alamy Stock Photo"
        },
        {
            "type": "text",
            "bbox": [
                0.217,
                0.61,
                0.909,
                0.733
            ],
            "angle": 0,
            "content": "查尔斯·让·古斯塔夫·尼库拉斯·德·拉·瓦列·普金（Charles-Jean-Gustave-Nicholas De La Vallée-Poussin，1866—1962）他出生于比利时鲁汶，是一位地理学教授的儿子。他就学于蒙斯的耶稣会学院，起先学习哲学，后转向工程学。毕业后，他致力于数学而非工程学。他对数学最重要的贡献是他的素数定理证明。他在算术级数中的素数分布方面也有贡献，改进了素数定理以包含误差估算。此外，他在微分方程、分析学和逼近理论方面都有重要贡献。他还撰写了《分析教程》这本教科书，该书对20世纪上半叶的数学思想产生了重大影响。"
        },
        {
            "type": "image",
            "bbox": [
                0.062,
                0.754,
                0.203,
                0.859
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.06,
                0.862,
                0.204,
                0.882
            ],
            "angle": 0,
            "content": "@bpk/Salomon/ullstein bid via Getty Images"
        },
        {
            "type": "text",
            "bbox": [
                0.219,
                0.754,
                0.91,
                0.876
            ],
            "angle": 0,
            "content": "雅克·阿达马(Jacques Hadamard，1865—1963）他出生于法国凡尔赛，父亲是一位拉丁语老师，母亲是一位杰出的钢琴教师。大学毕业后，他在巴黎的一所中学任教。1892年获得博士学位后，他在波尔多理学院担任讲师。之后，他曾在索邦大学、法兰西公学院、巴黎综合理工学院和中央艺术与制造学院任教。阿达马为复分析、泛函分析和数学物理做出了重要贡献。他被认为是一位富有创新精神的老师，撰写了法国学校基础数学相关的许多文章，以及一本广为使用的基本几何学的教科书。"
        },
        {
            "type": "page_footnote",
            "bbox": [
                0.106,
                0.912,
                0.912,
                0.944
            ],
            "angle": 0,
            "content": "\\(\\ominus\\) 截至2018年12月，已知的梅森素数共有51个。已知最大的梅森素数是 \\(2^{82589933} - 1\\) ，一共24862048位。——译者注"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.136,
                0.041,
                0.172,
                0.055
            ],
            "angle": 0,
            "content": "234"
        },
        {
            "type": "header",
            "bbox": [
                0.217,
                0.04,
                0.282,
                0.055
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "equation",
            "bbox": [
                0.365,
                0.097,
                0.697,
                0.113
            ],
            "angle": 0,
            "content": "\\[\n\\pi \\left(1 0 ^ {2 6}\\right) / \\left(1 0 ^ {2 6} / \\ln \\left(1 0 ^ {2 6}\\right)\\right) = 1. 0 1 7 2 9\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.116,
                0.675,
                0.133
            ],
            "angle": 0,
            "content": "你可以在Web上找到大量计算 \\(\\pi (x)\\) 的数据和估算 \\(\\pi (x)\\) 的函数。"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.425,
                0.144,
                0.637,
                0.159
            ],
            "angle": 0,
            "content": "表 2 由 \\( x/\\ln x \\) 逼近 \\( \\pi(x) \\)"
        },
        {
            "type": "table",
            "bbox": [
                0.107,
                0.16,
                0.953,
                0.337
            ],
            "angle": 0,
            "content": "<table><tr><td>\\( x \\)</td><td>\\( \\pi \\left( x\\right) \\)</td><td>\\( x/\\ln x \\)</td><td>\\( \\pi \\left( x\\right) /\\left( {x/\\ln x}\\right) \\)</td></tr><tr><td>\\( {10}^{3} \\)</td><td>168</td><td>144.8</td><td>1. 161</td></tr><tr><td>\\( {10}^{4} \\)</td><td>1229</td><td>1085.7</td><td>1.132</td></tr><tr><td>\\( {10}^{5} \\)</td><td>9592</td><td>8685.9</td><td>1.104</td></tr><tr><td>\\( {10}^{6} \\)</td><td>78 498</td><td>72 382.4</td><td>1.084</td></tr><tr><td>\\( {10}^{7} \\)</td><td>664 579</td><td>620 420.7</td><td>1.071</td></tr><tr><td>\\( {10}^{8} \\)</td><td>5 761 455</td><td>5 428 681.0</td><td>1.061</td></tr><tr><td>\\( {10}^{9} \\)</td><td>50 847 534</td><td>48 254 942.4</td><td>1.054</td></tr><tr><td>\\( {10}^{10} \\)</td><td>455 052 512</td><td>434 294 481.9</td><td>1.048</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.352,
                0.955,
                0.483
            ],
            "angle": 0,
            "content": "我们可以用素数定理来估算随机选择的一个数是素数的可能性。（概率论基础参见第7章。）素数定理告诉我们不超过 \\(x\\) 的素数个数可以用 \\(x / \\ln x\\) 来逼近。因此，一个随机选择的正整数 \\(n\\) 是素数的可能性大约是 \\((n / \\ln n) / n = 1 / \\ln n\\) 。有时候我们需要寻找一个具有特定位数的素数。我们要估算需要选择多少个特定位数的整数才有可能遇到一个素数。利用素数定理和微积分，可以证明一个整数 \\(n\\) 是素数的概率也大约是 \\(1 / \\ln n\\) 。例如，一个靠近 \\(10^{1000}\\) 附近的一个整数是素数的可能性大约是 \\(1 / \\ln 10^{1000}\\)，即大约 \\(1 / 2300\\)。（当然了，如果只选择奇数，可以使找到素数的机会增加一倍。）"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.485,
                0.955,
                0.616
            ],
            "angle": 0,
            "content": "定理2的试除法给出了因子分解和素数测试的过程。可是，这些过程不是很有效的算法，人们已经开发了许多切实有效的算法来做这些事情。因子分解和素数测试对于数论在密码学中的应用已变得很重要。这引起了人们极大的兴趣来开发完成这两个任务的有效算法。在过去的30年中已经研究设计了一些巧妙的过程来有效地生成大素数。再者，2002年Manindra Agrawal、Neeraj Kayal和Nitin Saxena做出了一个重要的理论发现。他们证明存在以整数二进制展开式中位数来衡量的一个多项式时间算法，可以判定一个正整数是否是素数。基于他们工作的算法使用 \\(O((\\log n)^6)\\) 次比特运算可以判定一个正整数 \\(n\\) 是否是素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.618,
                0.955,
                0.711
            ],
            "angle": 0,
            "content": "可是，尽管在同一时期已开发了强有力的因子分解新方法，但大整数的因子分解仍然要比素数测试更加耗时。整数因子分解尚未有多项式时间的算法。尽管如此，大整数分解的挑战引起了许多人的兴趣。互联网上有一个共同体致力于分解大整数，特别是形如 \\(k^n \\pm 1\\) 的大数，其中 \\(k\\) 是个小正整数而 \\(n\\) 是个大正整数（这样的数称为卡宁汉数）。在任何时候，总有一个“十大热门”的这种大数列表等待分解。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.713,
                0.955,
                0.882
            ],
            "angle": 0,
            "content": "素数和算术级数每个奇整数都出现在下面两种算术级数中： \\(4k + 1\\) 或者 \\(4k + 3\\) ， \\(k = 1\\) ，2，…。因为我们知道存在无限多个素数，所以我们会问是否在这两种算术级数中都有无限多个素数。素数5，13，17，29，37，41，…在算术级数 \\(4k + 3\\) 中；而素数3，7，11，19，23，31，43，…则在算术级数 \\(4k + 1\\) 中。这些暗示在两个级数都可能存在无限多个素数。那么其他如 \\(ak + b\\) ， \\(k = 1\\) ，2，…（这里不存在比1大的整数能同时整除 \\(a\\) 和 \\(b\\) )的算术级数呢？这里会包含无限多个素数吗？答案由德国数学家古·勒热纳·狄利克雷给出，他证明了每个这样的级数都包含有无限多个素数。他的证明以及后来所有的证明超出本书的范围。可是，用本书中的概念是有可能证明狄利克雷定理的一些特例的。例如，练习54和55要求证明在 \\(3k + 2\\) 和 \\(3k + 3\\) \\(k = 1\\) ，2，…算术级数中存在无限多个素数。（每个练习的提示提供了证明所需的基本概念。）"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.884,
                0.955,
                0.939
            ],
            "angle": 0,
            "content": "我们解释了每个 \\(ak + b\\) ， \\(k = 1\\) ，2，…的算术级数包含无限多个素数，这里 \\(a\\) 和 \\(b\\) 没有大于1的公因子。但是是否存在仅由素数构成的较长的算术级数呢？例如，一些探索可知5，11，17，23，29是由五个素数构成的算术级数，而199，409，619，829，1039，1249，1459，"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.643,
                0.038,
                0.775,
                0.053
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.822,
                0.04,
                0.856,
                0.052
            ],
            "angle": 0,
            "content": "235"
        },
        {
            "type": "text",
            "bbox": [
                0.04,
                0.095,
                0.887,
                0.17
            ],
            "angle": 0,
            "content": "1669，1879，2089是由十个素数构成的算术级数。在20世纪30年代，多产而富有传奇色彩的数学家保罗·埃德斯猜测对于任意大于2的正整数 \\(n\\) ，存在完全由素数构成的长度为 \\(n\\) 的算术级数。2006年，Ben Green和陶哲轩已经能够证明该猜想了。他们的证明堪称数学中的“环法”，是结合了高级数学若干领域中的概念而得出的一个非构造性证明。"
        },
        {
            "type": "title",
            "bbox": [
                0.041,
                0.18,
                0.391,
                0.198
            ],
            "angle": 0,
            "content": "4.3.5 关于素数的猜想和开放问题"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.2,
                0.887,
                0.236
            ],
            "angle": 0,
            "content": "数论是一门可以从中很容易地提出猜想的学科，其中一些问题很难证明，还有一些开放问题多年来一直悬而未决。例 \\(6\\sim 9\\) 将介绍数论中的一些猜想并讨论其现状。"
        },
        {
            "type": "text",
            "bbox": [
                0.04,
                0.241,
                0.887,
                0.358
            ],
            "angle": 0,
            "content": "例6 有这样一个函数 \\( f(n) \\) 是十分有用的：对所有的正整数 \\( n \\) 有 \\( f(n) \\) 是素数。如果我们有这样一个函数，我们就可以找到大的素数用于密码学或者其他应用中。要寻找这样一个函数，需要测试不同的多项式函数，就像几百年前数学家所做的那样。经过大量的计算我们可以找到多项式 \\( f(n) = n^2 - n + 41 \\) 。这个多项式具有一个有趣的特点：对于不超过40的正整数，\\( f(n) \\) 是素数。[我们有 \\( f(1) = 41 \\)，\\( f(2) = 43 \\)，\\( f(3) = 47 \\)，\\( f(4) = 53 \\) 等。]这就导致我们猜想是否对于所有的正整数 \\( n \\)，都有 \\( f(n) \\) 是素数。我们能解决这个猜想吗？"
        },
        {
            "type": "text",
            "bbox": [
                0.04,
                0.36,
                0.887,
                0.455
            ],
            "angle": 0,
            "content": "解也许结果是意料之中的，那个猜想的结果是假的，我们并不需要看得太远就可以找到一个正整数 \\(n\\) 使得 \\(f(n)\\) 为合数，因为 \\(f(41) = 41^{2} - 41 + 41 = 41^{2}\\) 。因为对于满足 \\(1 \\leqslant n \\leqslant 40\\) 的所有正整数都有 \\(f(n) = n^{2} - n + 41\\) 为素数，我们或许想找到另外一个多项式具有性质：对于所有的正整数 \\(n\\) ，都有 \\(f(n)\\) 为素数。然而，这个多项式并不存在。可以证明对于每一个整数系数多项式 \\(f(n)\\) ，存在一个正整数 \\(y\\) 使得 \\(f(y)\\) 是合数。（参见补充练习23。）"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.457,
                0.887,
                0.532
            ],
            "angle": 0,
            "content": "关于素数的很多重要问题仍然期待着聪明人能给出最终的解。在例 \\(7\\sim 9\\) 中我们描述其中一些最容易理解的且耳熟能详的开放问题。数论以其拥有大量非常容易理解的猜想而著称，这些猜想抵御了最复杂技术的攻克，或者简单地说抵御了所有攻克。我们列出这些猜想是想要说明很多看上去相对简单的问题即使到了21世纪还是悬而未决。"
        },
        {
            "type": "text",
            "bbox": [
                0.04,
                0.536,
                0.887,
                0.634
            ],
            "angle": 0,
            "content": "例7 哥德巴赫猜想 1742年，克里斯蒂安·哥德巴赫在给莱昂哈德·欧拉的一封信中提出一个猜想：每个大于5的奇数 \\(n\\) 都是三个素数之和。欧拉在回信中答复此猜想等价于另一猜想：每个大于2的偶数是两个素数之和（参见补充练习21）。每个大于2的偶数是两个素数之和的这个猜想现在称为哥德巴赫猜想。对于小的偶数可以验证这个猜想。例如，\\(4 = 2 + 2, 6 = 3 + 3, 8 = 5 + 3, 10 = 7 + 3, 12 = 7 + 5\\) 等。在计算机出现之前，人们通过手工计算对上至"
        },
        {
            "type": "title",
            "bbox": [
                0.04,
                0.642,
                0.105,
                0.663
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.042,
                0.676,
                0.179,
                0.78
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.041,
                0.784,
                0.133,
                0.804
            ],
            "angle": 0,
            "content": "Courtesy of Reed, Hutchinson/UCLA"
        },
        {
            "type": "text",
            "bbox": [
                0.198,
                0.675,
                0.887,
                0.761
            ],
            "angle": 0,
            "content": "陶哲轩(1975—）陶哲轩出生在澳大利亚。他的父亲是一名儿科医生而母亲在香港的中学教数学。陶哲轩是一个神童，两岁时就自学算术。10岁时，他成为最年轻的国际数学奥林匹克(IMO)选手；13岁时他赢得了IMO金牌。17岁时陶哲轩获得他的学士学位和硕士学位，并在普林斯顿大学开始研究生学习，三年后获得博士学位。1996年他成为加州大学洛杉矶分校的一名教员，并继续在那里工作。"
        },
        {
            "type": "text",
            "bbox": [
                0.198,
                0.764,
                0.887,
                0.815
            ],
            "angle": 0,
            "content": "陶哲轩知识面极宽，他喜欢在不同的领域研究问题，包括调和分析、偏微分方程、数论和组合数学。他在博客上讨论各种问题的研究进展，你可以通过阅读博客来了解他的工作。他最著名的结论是Green-Tao定理：存在任意长的素数算术级数。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.817,
                0.848,
                0.833
            ],
            "angle": 0,
            "content": "陶哲轩对数学的应用做出了重要贡献，如开发了一种使用尽可能少的信息进行数字图像重建的方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.835,
                0.887,
                0.939
            ],
            "angle": 0,
            "content": "陶哲轩在数学家中间具有神奇的口碑，他成了数学研究员圈里的搞定先生（Mr. Fix-It）。本身也是神童的知名数学家查尔斯·费弗曼曾经说过：“如果你在一个问题上卡住了，那么出路之一是让陶哲轩也感兴趣。”陶哲轩还维护着一个热门的博客，详细描述了他的研究工作和许多数学问题。2006年陶哲轩被授予菲尔茨奖，这是授予40岁以下数学家的最负盛名的奖项。2006年他被授予了麦克阿瑟奖金，并于2008年他获得了Allan T. Waterman奖，其中50万美元的现金奖励为支持科学家在其早期职业生涯中的研究工作。陶哲轩的妻子劳拉是在喷气推进实验室的一名工程师。"
        },
        {
            "type": "image",
            "bbox": [
                0.898,
                0.24,
                0.96,
                0.257
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.146,
                0.04,
                0.182,
                0.054
            ],
            "angle": 0,
            "content": "236"
        },
        {
            "type": "header",
            "bbox": [
                0.228,
                0.039,
                0.292,
                0.054
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.096,
                0.968,
                0.131
            ],
            "angle": 0,
            "content": "百万的数验证了哥德巴赫猜想。使用计算机可以对更大的数进行验证。截至2018年年初，对上至 \\(4 \\times 10^{18}\\) 的所有正偶数都验证了猜想。"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.133,
                0.969,
                0.224
            ],
            "angle": 0,
            "content": "虽然哥德巴赫猜想的证明至今仍未发现，但大多数数学家都认为此猜想是正确的。使用解析数论（远超出本书范围）的一些复杂方法已经证明了一些定理，可以建立比哥德巴赫猜想弱一些的结论。其中就包括每个大于2的偶数都是至多6个素数之和(O.Ramaré在1995年证明)以及每个充分大的正偶数都可以写成一个素数以及另一个或者素数或者两个素数乘积之和（陈景润在1996年证明）。也许哥德巴赫猜想会在不太久的将来得到证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.23,
                0.97,
                0.324
            ],
            "angle": 0,
            "content": "例8 有很多猜想都断言存在无限多个具有某种特殊形式的素数。一种猜想就认为存在无限多个可以写成 \\(n^2 + 1\\) 形式的素数，其中 \\(n\\) 为正整数。例如，\\(5 = 2^2 + 1\\)，\\(17 = 4^2 + 1\\)，\\(37 = 6^2 + 1\\) 等。目前所知的最好结果就是存在无限多个正整数 \\(n\\) 使得 \\(n^2 + 1\\) 或者是素数，或者是至多两个素数之积（Henryk Iwaniec 在 1973 年证明，需要用到远超出本书范围的解析数论中的高级技术）。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.328,
                0.972,
                0.404
            ],
            "angle": 0,
            "content": "例9 李生素数猜想 李生素数是指相差2的一对素数，诸如3和5、5和7、11和13、17和19、4967和4969。李生素数猜想断定存在无限多对孪生素数。关于孪生素数已被证明的最好结果是有无限多对 \\(p\\) 和 \\(p + 2\\) ，其中 \\(p\\) 是素数， \\(p + 2\\) 是素数或者是两个素数乘积（陈景润在1966年证明）。"
        },
        {
            "type": "text",
            "bbox": [
                0.162,
                0.406,
                0.971,
                0.422
            ],
            "angle": 0,
            "content": "截至2018年年初，孪生素数的世界纪录是 \\(2996863034895 \\cdot 2^{1290000} \\pm 1\\) ，是388342位数。"
        },
        {
            "type": "text",
            "bbox": [
                0.122,
                0.424,
                0.975,
                0.555
            ],
            "angle": 0,
            "content": "设 \\(P(n)\\) 为命题：存在无限多对差值恰为 \\(n\\) 的素数对。孪生素数猜想就是命题 \\(P(2)\\) 为真。研究孪生素数猜想的数学家设计了一个稍微弱一点的猜想，称为有界间隔猜想，声称存在一个 \\(N\\) 使得 \\(P(N)\\) 为真。2013年当张益唐证明了有界间隔猜想时，整个数学界为之震惊。张益唐是新罕布什尔大学一位50岁的教授，自2001年以来就没再发表过论文。特别是，他证明了存在一个整数 \\(N\\) ， \\(N < 70000000\\) ，使得 \\(P(N)\\) 为真。一个包括陶哲轩在内的数学家团队又下降了张益唐的上界，证明了存在整数 \\(N \\leqslant 246\\) 使得 \\(P(N)\\) 为真。再后来，他们又证明了如果猜想为真，则可以证明 \\(N \\leqslant 6\\) ，并且这是用张益唐的方法所能证明的最好可能的估算值。"
        },
        {
            "type": "title",
            "bbox": [
                0.124,
                0.564,
                0.456,
                0.581
            ],
            "angle": 0,
            "content": "4.3.6 最大公约数和最小公倍数"
        },
        {
            "type": "text",
            "bbox": [
                0.165,
                0.585,
                0.695,
                0.601
            ],
            "angle": 0,
            "content": "能整除两个整数的最大整数称为这两个整数的最大公约数。"
        },
        {
            "type": "text",
            "bbox": [
                0.134,
                0.609,
                0.964,
                0.647
            ],
            "angle": 0,
            "content": "定义2 令 \\(a\\) 和 \\(b\\) 是两个整数，不全为0。能使 \\(d \\mid a\\) 和 \\(d \\mid b\\) 的最大整数 \\(d\\) 称为 \\(a\\) 和 \\(b\\) 的最大公约数。\\(a\\) 和 \\(b\\) 的最大公约数记作 \\(\\gcd(a, b)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.125,
                0.655,
                0.975,
                0.709
            ],
            "angle": 0,
            "content": "两个不全为0的整数的最大公约数是存在的，因为这两个整数的公约数集合是非空且有限的。寻找两个整数的最大公约数的一个方法是找出两个整数的所有正公约数，然后取其中最大者。如例10和11所示。稍后会给出一个更有效的寻找最大公约数的方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.165,
                0.713,
                0.51,
                0.73
            ],
            "angle": 0,
            "content": "例10 24和36的最大公约数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.165,
                0.735,
                0.845,
                0.752
            ],
            "angle": 0,
            "content": "解24和36的正公约数是1、2、3、4、6和12。因此， \\(\\gcd (24,36) = 12\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.166,
                0.756,
                0.51,
                0.773
            ],
            "angle": 0,
            "content": "例11 17和22的最大公约数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.166,
                0.778,
                0.733,
                0.794
            ],
            "angle": 0,
            "content": "解17和22除了1以外没有正公约数，所以 \\(\\gcd (17,22) = 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.166,
                0.797,
                0.874,
                0.813
            ],
            "angle": 0,
            "content": "因为要说明两个整数没有1以外的正公约数这一点很重要，所以我们有定义3。"
        },
        {
            "type": "text",
            "bbox": [
                0.177,
                0.822,
                0.695,
                0.839
            ],
            "angle": 0,
            "content": "定义3 整数 \\(a\\) 和 \\(b\\) 是互素的如果它们的最大公约数是1。"
        },
        {
            "type": "title",
            "bbox": [
                0.127,
                0.854,
                0.174,
                0.871
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.869,
                0.977,
                0.939
            ],
            "angle": 0,
            "content": "克里斯蒂安·哥德巴赫(1690—1764) 他出生在普鲁士的哥尼斯堡，该城市以著名的七桥问题（将在10.5节进行研究）而闻名于世。1725年，他成为彼得堡科学院的数学教授。1728年，哥德巴赫前往莫斯科教授沙皇之子。1742年，他进入政坛，成为俄罗斯外交部的一名职员。哥德巴赫以其与欧拉和伯努利等著名数学家的书信往来、在数论中的著名猜想，以及分析学中的贡献而闻名于世。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.659,
                0.038,
                0.792,
                0.053
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.838,
                0.039,
                0.874,
                0.052
            ],
            "angle": 0,
            "content": "237"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.098,
                0.699,
                0.115
            ],
            "angle": 0,
            "content": "例12 从例11可知整数17和22是互素的，因为 \\(\\gcd(17, 22) = 1\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.12,
                0.892,
                0.136
            ],
            "angle": 0,
            "content": "因为需要说明一个整数集合中没有两个整数具有大于1的正公约数，所以我们给出定义4。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.146,
                0.856,
                0.163
            ],
            "angle": 0,
            "content": "定义4整数 \\(a_1\\) ， \\(a_2\\) ，…， \\(a_{n}\\) 是两两互素的，如果当 \\(1\\leqslant i <   j\\leqslant n\\) 时有 \\(\\gcd (a_i,a_j) = 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.177,
                0.794,
                0.194
            ],
            "angle": 0,
            "content": "例13 判断整数10、17和21是否两两互素，整数10、19和24是否两两互素。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.199,
                0.905,
                0.235
            ],
            "angle": 0,
            "content": "解 由于 \\(\\gcd(10, 17) = 1\\)，\\(\\gcd(10, 21) = 1\\) 和 \\(\\gcd(17, 21) = 1\\)，所以结论是 \\(10, 17\\) 和 \\(21\\) 是两两互素的。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.239,
                0.642,
                0.255
            ],
            "angle": 0,
            "content": "因为 \\(\\gcd (10,24) = 2 > 1\\) ，可见10，19和24不是两两互素的。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.258,
                0.905,
                0.293
            ],
            "angle": 0,
            "content": "另外一个寻找两个整数的最大公约数的方法是利用这两个整数的素因子分解式。假定两个正整数 \\(a\\) 和 \\(b\\) 的素因子分解式为"
        },
        {
            "type": "equation",
            "bbox": [
                0.326,
                0.298,
                0.63,
                0.314
            ],
            "angle": 0,
            "content": "\\[\na = p _ {1} ^ {a _ {1}} p _ {2} ^ {a _ {2}} \\dots p _ {n} ^ {a _ {n}}, \\quad b = p _ {1} ^ {b _ {1}} p _ {2} ^ {b _ {2}} \\dots p _ {n} ^ {b _ {n}}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.317,
                0.905,
                0.352
            ],
            "angle": 0,
            "content": "其中每个指数都是非负整数，而且出现在 \\(a\\) 或 \\(b\\) 的素因子分解式中的所有素数都出现在这两个分解式中，必要时以0指数出现。则 \\(\\gcd(a, b)\\) 由下式给出"
        },
        {
            "type": "equation",
            "bbox": [
                0.311,
                0.355,
                0.649,
                0.372
            ],
            "angle": 0,
            "content": "\\[\n\\operatorname {g c d} (a, b) = p _ {1} ^ {\\min  \\left(a _ {1}, b _ {1}\\right)} p _ {2} ^ {\\min  \\left(a _ {2}, b _ {2}\\right)} \\dots p _ {n} ^ {\\min  \\left(a _ {n}, b _ {n}\\right)}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.375,
                0.907,
                0.468
            ],
            "angle": 0,
            "content": "其中 \\(\\min (x, y)\\) 代表两个数 \\(x\\) 和 \\(y\\) 的最小值。为证明这一计算 \\(\\gcd(a, b)\\) 的公式是有效的，必须证明等式右边的整数同时能整除 \\(a\\) 和 \\(b\\)，而且没有更大的整数能整除 \\(a\\) 和 \\(b\\)。该整数确实整除 \\(a\\) 和 \\(b\\)，因为其因子分解式中每个素数的指数都不超过 \\(a\\) 和 \\(b\\) 的分解式中该素数的指数。此外，没有更大的整数能整除 \\(a\\) 和 \\(b\\)，因为该分解式中每个素数的指数都不能再增大，而且也不能包括其他素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.475,
                0.907,
                0.514
            ],
            "angle": 0,
            "content": "例14 因为120和500的素因子分解式分别是 \\( 120 = 2^3 \\cdot 3 \\cdot 5 \\) 和 \\( 500 = 2^2 \\cdot 5^3 \\)，所以最大公约数是"
        },
        {
            "type": "equation",
            "bbox": [
                0.267,
                0.517,
                0.698,
                0.532
            ],
            "angle": 0,
            "content": "\\[\n\\operatorname * {g c d} (1 2 0, 5 0 0) = 2 ^ {\\min  (3, 2)} 3 ^ {\\min  (1, 0)} 5 ^ {\\min  (1, 3)} = 2 ^ {2} 3 ^ {0} 5 ^ {1} = 2 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.537,
                0.559,
                0.552
            ],
            "angle": 0,
            "content": "素因子分解式还可用于寻找两个整数的最小公倍数。"
        },
        {
            "type": "text",
            "bbox": [
                0.07,
                0.562,
                0.902,
                0.599
            ],
            "angle": 0,
            "content": "定义5 正整数 \\(a\\) 和 \\(b\\) 的最小公倍数是能被 \\(a\\) 和 \\(b\\) 整除的最小正整数。\\(a\\) 和 \\(b\\) 的最小公倍数记作 \\(\\operatorname{lcm}(a, b)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.608,
                0.909,
                0.663
            ],
            "angle": 0,
            "content": "最小公倍数存在，因为能被 \\(a\\) 和 \\(b\\) 整除的整数集合是非空的（比如，因为 \\(ab\\) 就属于该集合），而每个非空的正整数集合都有一个最小元素（根据5.2节将要讨论的良序性质）。假定 \\(a\\) 和 \\(b\\) 的素因子分解式如前所述。则 \\(a\\) 和 \\(b\\) 的最小公倍数由下式给出"
        },
        {
            "type": "equation",
            "bbox": [
                0.299,
                0.666,
                0.666,
                0.684
            ],
            "angle": 0,
            "content": "\\[\n\\operatorname {l c m} (a, b) = p _ {1} \\max  \\left(a _ {1}, b _ {1}\\right) p _ {2} \\max  \\left(a _ {2}, b _ {2}\\right) \\dots p _ {n} \\max  \\left(a _ {n}, b _ {n}\\right)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.687,
                0.91,
                0.723
            ],
            "angle": 0,
            "content": "其中 \\(\\max (x,y)\\) 表示两个数 \\(x\\) 和 \\(y\\) 中的最大数。这一公式是有效的，因为 \\(a\\) 和 \\(b\\) 的一个公倍数在其分解式中至少含 \\(\\max (a_i,b_i)\\) 个 \\(p_i\\) ，而最小公倍数中没有 \\(a\\) 和 \\(b\\) 的因子之外的素数。"
        },
        {
            "type": "title",
            "bbox": [
                0.064,
                0.732,
                0.127,
                0.753
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.067,
                0.766,
                0.203,
                0.869
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.067,
                0.873,
                0.187,
                0.902
            ],
            "angle": 0,
            "content": "Source: John D. & Catherine T. MacArthur Foundation"
        },
        {
            "type": "text",
            "bbox": [
                0.219,
                0.765,
                0.911,
                0.816
            ],
            "angle": 0,
            "content": "张益唐(YiTang Zhang，1955—）他于1955年出生于中国上海，十岁时就第一次知道了费马大定理和哥德巴赫猜想。他于1982年和1985年分别获得北京大学的学士和硕士学位。后来去美国普渡大学就读，并于1991年读完博士。"
        },
        {
            "type": "text",
            "bbox": [
                0.219,
                0.819,
                0.912,
                0.904
            ],
            "angle": 0,
            "content": "获得博士学位后，由于就业前景不佳又和导师意见不一，张益唐没能在学术圈求得职位。相反，他在纽约皇后区一家餐馆做会计并送外卖，后来又去了肯塔基州，在朋友开的一家赛百味餐厅打工。有时候为了找工作，他就直接以车为家。最后，他还是找到了一个学术职位，在新罕布什尔大学任讲师。1999年至2014年年初，他一直在做这份讲师工作。自2009年到2013年，他从事有界间隔猜想研究，一周7天、每天"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.907,
                0.912,
                0.939
            ],
            "angle": 0,
            "content": "10小时地工作，直到得出了关键发现。他的成功使得新罕布什尔大学将其提升为正教授。2015年，他接受了加州大学圣巴巴拉分校的正教授职位。2014年张益唐被授予麦克阿瑟奖，即天才奖。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.138,
                0.038,
                0.175,
                0.052
            ],
            "angle": 0,
            "content": "238"
        },
        {
            "type": "header",
            "bbox": [
                0.22,
                0.037,
                0.285,
                0.052
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.096,
                0.533,
                0.113
            ],
            "angle": 0,
            "content": "例15 \\(2^{3}3^{5}7^{2}\\) 和 \\(2^{4}3^{3}\\) 的最小公倍数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.149,
                0.119,
                0.256,
                0.135
            ],
            "angle": 0,
            "content": "解 我们有"
        },
        {
            "type": "equation",
            "bbox": [
                0.315,
                0.138,
                0.751,
                0.153
            ],
            "angle": 0,
            "content": "\\[\n\\operatorname {l c m} \\left(2 ^ {3} 3 ^ {5} 7 ^ {2}, 2 ^ {4} 3 ^ {3}\\right) = 2 ^ {\\max  (3, 4)} 3 ^ {\\max  (5, 3)} 7 ^ {\\max  (2, 0)} = 2 ^ {4} 3 ^ {5} 7 ^ {2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.157,
                0.959,
                0.193
            ],
            "angle": 0,
            "content": "定理5给出两个整数的最大公约数和最小公倍数之间的关系。用上面给出的求这两个数的公式就可以证明这一定理。定理证明留作练习31。"
        },
        {
            "type": "text",
            "bbox": [
                0.158,
                0.202,
                0.439,
                0.218
            ],
            "angle": 0,
            "content": "定理5一令 \\(a\\) 和 \\(b\\) 为正整数，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.416,
                0.222,
                0.651,
                0.238
            ],
            "angle": 0,
            "content": "\\[\na b = \\operatorname {g c d} (a, b) \\cdot \\operatorname {l c m} (a, b)\n\\]"
        },
        {
            "type": "title",
            "bbox": [
                0.107,
                0.255,
                0.32,
                0.272
            ],
            "angle": 0,
            "content": "4.3.7 欧几里得算法"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.276,
                0.959,
                0.349
            ],
            "angle": 0,
            "content": "直接从整数的素因子分解式计算两个整数的最大公约数是效率很低的。原因是寻找素因子分解式非常耗时。这里给出一个更高效的寻找最大公约数的方法，称为欧几里得算法。这个算法古代就有了。这是用古希腊数学家欧几里得的名字命名的，他在其著作《几何原本》（The Elements)中记载了这一算法的描述。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.352,
                0.957,
                0.387
            ],
            "angle": 0,
            "content": "在介绍欧几里得算法之前，我们先看一看它是怎样求 \\(\\gcd(91, 287)\\) 的。首先，用两个数中的大数 287 除以两个数中的小数 91，得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.452,
                0.391,
                0.612,
                0.406
            ],
            "angle": 0,
            "content": "\\[\n2 8 7 = 9 1 \\cdot 3 + 1 4\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.41,
                0.957,
                0.464
            ],
            "angle": 0,
            "content": "91和287的任何公约数必定也是 \\(287 - 91 \\cdot 3 = 14\\) 的因子。而且91和14的任何公约数也必定是 \\(287 = 91 \\cdot 3 + 14\\) 的因子。因此，287和91的最大公约数和91与14的最大公约数相同。这意味着求 \\(\\gcd(91, 287)\\) 的问题已被归约为求 \\(\\gcd(91, 14)\\) 的问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.467,
                0.348,
                0.483
            ],
            "angle": 0,
            "content": "接下来，91除以14得"
        },
        {
            "type": "equation",
            "bbox": [
                0.461,
                0.487,
                0.602,
                0.501
            ],
            "angle": 0,
            "content": "\\[\n9 1 = 1 4 \\cdot 6 + 7\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.505,
                0.959,
                0.54
            ],
            "angle": 0,
            "content": "由于91和14的任何公约数也能整除 \\( 91 - 14 \\cdot 6 = 7 \\)，并且14和7的任何公约数整除91，所以gcd(91, 14) = gcd(14, 7)。"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.543,
                0.318,
                0.559
            ],
            "angle": 0,
            "content": "继续14除以7，得"
        },
        {
            "type": "equation",
            "bbox": [
                0.485,
                0.563,
                0.582,
                0.577
            ],
            "angle": 0,
            "content": "\\[\n1 4 = 7 \\cdot 2\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.581,
                0.956,
                0.616
            ],
            "angle": 0,
            "content": "因为7整除14，所以 \\(\\gcd (14,7) = 7\\) 。另外，因为 \\(\\gcd (287,91) = \\gcd (91,14) = \\gcd (14,7) = 7,\\) 所以最初的问题得解。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.62,
                0.956,
                0.655
            ],
            "angle": 0,
            "content": "现在介绍欧几里得算法在一般情况下是如何工作。我们将用辗转相除法把求两个正整数最大公约数的问题归约为求两个较小整数的最大公约数问题，直到两个整数之一为0。"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.658,
                0.708,
                0.674
            ],
            "angle": 0,
            "content": "欧几里得算法的基础是下面关于最大公约数和整除算法的结论。"
        },
        {
            "type": "text",
            "bbox": [
                0.157,
                0.683,
                0.838,
                0.701
            ],
            "angle": 0,
            "content": "引理1 令 \\(a = bq + r\\) ，其中 \\(a, b, q\\) 和 \\(r\\) 均为整数。则 \\(\\gcd(a, b) = \\gcd(b, r)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.71,
                0.956,
                0.744
            ],
            "angle": 0,
            "content": "证明 如果能证明 \\(a\\) 与 \\(b\\) 的公约数和 \\(b\\) 与 \\(r\\) 的公约数相同，也就证明了 \\(\\gcd(a, b) = \\gcd(b, r)\\)，因为这两对整数必定有相同的最大公约数。"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.748,
                0.956,
                0.764
            ],
            "angle": 0,
            "content": "因此，假定 \\(d\\) 整除 \\(a\\) 和 \\(b\\) 。则可得 \\(d\\) 也整除 \\(a - bq = r\\) （根据4.1节定理1）。因此，\\(a\\) 和 \\(b\\) 的"
        },
        {
            "type": "title",
            "bbox": [
                0.107,
                0.775,
                0.153,
                0.788
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.108,
                0.806,
                0.253,
                0.911
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.11,
                0.915,
                0.252,
                0.936
            ],
            "angle": 0,
            "content": "\\(\\odot\\) bilwissedition Ltd. & Co. KG/Alamy Stock Photo"
        },
        {
            "type": "text",
            "bbox": [
                0.266,
                0.806,
                0.957,
                0.893
            ],
            "angle": 0,
            "content": "欧几里得(Euclid，约公元前325—公元前265）欧几里得是最成功的数学著作《几何原本》(The Elements)的作者，该书从古至今已有1000多个不同的版本。人们对欧几里得的生平所知甚少，只知道他在埃及亚历山大的著名学院里任教。显然，欧几里得不强调应用。当一个学生问他学习几何学能得到什么时，他解释说知识本身就值得学习并让他的仆人给了这个学生一枚硬币，“因为他一定要从所学中获利”。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.652,
                0.041,
                0.785,
                0.057
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.832,
                0.043,
                0.868,
                0.056
            ],
            "angle": 0,
            "content": "239"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.098,
                0.344,
                0.114
            ],
            "angle": 0,
            "content": "任何公约数也是 \\(b\\) 和 \\(r\\) 的公约数。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.117,
                0.896,
                0.152
            ],
            "angle": 0,
            "content": "类似地，假定 \\(d\\) 整除 \\(b\\) 和 \\(r\\) 。则 \\(d\\) 也整除 \\(bq + r = a\\) 。因此，\\(b\\) 和 \\(r\\) 的任何公约数也是 \\(a\\) 和 \\(b\\) 的公约数。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.155,
                0.359,
                0.171
            ],
            "angle": 0,
            "content": "因此， \\(\\gcd (a,b) = \\gcd (b,r)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.174,
                0.819,
                0.191
            ],
            "angle": 0,
            "content": "假定 \\(a\\) 和 \\(b\\) 为正整数，且 \\(a \\geq b\\)。令 \\(r_0 = a\\) 和 \\(r_1 = b\\)。当连续应用整除算法时，可得"
        },
        {
            "type": "equation",
            "bbox": [
                0.334,
                0.196,
                0.578,
                0.209
            ],
            "angle": 0,
            "content": "\\[\nr _ {0} = r _ {1} \\overline {{q}} _ {1} + r _ {2} \\quad 0 \\leqslant r _ {2} <   r _ {1}\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.336,
                0.215,
                0.579,
                0.229
            ],
            "angle": 0,
            "content": "\\[\nr _ {1} = r _ {2} q _ {2} + r _ {3} \\quad 0 \\leqslant r _ {3} <   r _ {2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.358,
                0.235,
                0.367,
                0.247
            ],
            "angle": 0,
            "content": "中"
        },
        {
            "type": "equation",
            "bbox": [
                0.321,
                0.254,
                0.619,
                0.287
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} r _ {n - 2} = r _ {n - 1} q _ {n - 1} + r _ {n} \\quad 0 \\leqslant r _ {n} <   r _ {n - 1} \\\\ r _ {n - 1} = r _ {n} q _ {n} \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.291,
                0.896,
                0.326
            ],
            "angle": 0,
            "content": "最终在这一辗转相除序列中会出现余数为0，因为在余数序列 \\(a = r_0 > r_1 > r_2 > \\dots \\geqslant 0\\) 中至多包含 \\(a\\) 项。再者，从引理1可知"
        },
        {
            "type": "equation",
            "bbox": [
                0.209,
                0.331,
                0.731,
                0.364
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} \\operatorname * {g c d} (a, b) = \\operatorname * {g c d} \\left(r _ {0}, r _ {1}\\right) = \\operatorname * {g c d} \\left(r _ {1}, r _ {2}\\right) = \\dots = \\operatorname * {g c d} \\left(r _ {n - 2}, r _ {n - 1}\\right) \\\\ = \\gcd (r _ {n - 1}, r _ {n}) = \\gcd (r _ {n}, 0) = r _ {n} \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.368,
                0.512,
                0.384
            ],
            "angle": 0,
            "content": "因此，最大公约数是除法序列中最后一个非零余数。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.389,
                0.573,
                0.407
            ],
            "angle": 0,
            "content": "例16 用欧几里得算法寻找414和662的最大公约数。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.412,
                0.264,
                0.428
            ],
            "angle": 0,
            "content": "解 连续相除得出："
        },
        {
            "type": "equation",
            "bbox": [
                0.169,
                0.433,
                0.341,
                0.522
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} 6 6 2 = 4 1 4 \\cdot 1 + 2 4 8 \\\\ 4 1 4 = 2 4 8 \\cdot 1 + 1 6 6 \\\\ 2 4 8 = 1 6 6 \\cdot 1 + 8 2 \\\\ 1 6 6 = 8 2 \\cdot 2 + 2 \\\\ 8 2 = 2 \\cdot 4 1 。 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.526,
                0.463,
                0.561
            ],
            "angle": 0,
            "content": "因此， \\(\\gcd (414,662) = 2\\) ，因为2是最后一个非零余数。"
        },
        {
            "type": "table",
            "bbox": [
                0.485,
                0.45,
                0.896,
                0.575
            ],
            "angle": 0,
            "content": "<table><tr><td>j</td><td>rj</td><td>rj+1</td><td>qj+1</td><td>rj+2</td></tr><tr><td>0</td><td>662</td><td>414</td><td>1</td><td>248</td></tr><tr><td>1</td><td>414</td><td>248</td><td>1</td><td>166</td></tr><tr><td>2</td><td>248</td><td>166</td><td>1</td><td>82</td></tr><tr><td>3</td><td>166</td><td>82</td><td>2</td><td>2</td></tr><tr><td>4</td><td>82</td><td>2</td><td>41</td><td>0</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.566,
                0.408,
                0.582
            ],
            "angle": 0,
            "content": "我们可以用右表格来总结这些步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.586,
                0.469,
                0.602
            ],
            "angle": 0,
            "content": "欧几里得算法用伪代码表示如算法1所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.624,
                0.244,
                0.638
            ],
            "angle": 0,
            "content": "算法1 欧几里得算法"
        },
        {
            "type": "text",
            "bbox": [
                0.063,
                0.642,
                0.296,
                0.656
            ],
            "angle": 0,
            "content": "procedure gcd(a, b: 正整数)"
        },
        {
            "type": "equation",
            "bbox": [
                0.063,
                0.662,
                0.256,
                0.779
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} x := a \\\\ y := b \\\\ \\text {w h i l e} y \\neq 0 \\\\ r := x \\bmod y \\\\ x := y \\\\ y := r \\\\ \\text {r e t u r n} x \\{\\gcd (a, b) \\text {是} x \\} \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.801,
                0.895,
                0.856
            ],
            "angle": 0,
            "content": "在算法1中， \\(x\\) 和 \\(y\\) 的初值分别是 \\(a\\) 和 \\(b\\) 。在过程的每一步， \\(x\\) 取 \\(y\\) 的值，而 \\(y\\) 取 \\(x \\mod y\\) 的值，即 \\(x\\) 除以 \\(y\\) 的余数。只要 \\(y \\neq 0\\) ，该过程就不断重复。当 \\(y = 0\\) 时算法终止，而此时 \\(x\\) 的值，该过程中最后一个非零余数，为 \\(a\\) 和 \\(b\\) 的最大公约数。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.859,
                0.892,
                0.896
            ],
            "angle": 0,
            "content": "我们将在5.3节研究欧几里得算法的时间复杂度，并证明求 \\(a\\) 和 \\(b\\) 的最大公约数所要的除法次数当 \\(a \\geq b\\) 时为 \\(O(\\log b)\\)。"
        },
        {
            "type": "title",
            "bbox": [
                0.047,
                0.906,
                0.322,
                0.923
            ],
            "angle": 0,
            "content": "4.3.8 gcd的线性组合表示"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.926,
                0.806,
                0.943
            ],
            "angle": 0,
            "content": "本节之后一直会用到的一个重要结果是两个整数 \\(a\\) 和 \\(b\\) 的最大公约数可以表示为"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.134,
                0.04,
                0.172,
                0.054
            ],
            "angle": 0,
            "content": "240"
        },
        {
            "type": "header",
            "bbox": [
                0.216,
                0.039,
                0.282,
                0.054
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "equation",
            "bbox": [
                0.497,
                0.097,
                0.567,
                0.111
            ],
            "angle": 0,
            "content": "\\[\ns a + t b\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.115,
                0.956,
                0.151
            ],
            "angle": 0,
            "content": "的形式，其中 \\(s\\) 和 \\(t\\) 为整数。换句话说，\\(\\gcd(a, b)\\) 可以表示为 \\(a\\) 和 \\(b\\) 的整系数的线性组合。例如，\\(\\gcd(6, 14) = 2\\)，而 \\(2 = (-2) \\cdot 6 + 1 \\cdot 14\\)。我们将该事实表述为定理6。"
        },
        {
            "type": "text",
            "bbox": [
                0.157,
                0.159,
                0.922,
                0.177
            ],
            "angle": 0,
            "content": "定理6 贝祖定理 如果 \\(a\\) 和 \\(b\\) 为正整数，则存在整数 \\(s\\) 和 \\(t\\) 使得 \\(\\gcd(a, b) = sa + tb\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.192,
                0.946,
                0.246
            ],
            "angle": 0,
            "content": "定义6 如果 \\(a\\) 和 \\(b\\) 为正整数，则使得 \\(\\gcd(a, b) = sa + tb\\) 的整数 \\(s\\) 和 \\(t\\) 称为 \\(a\\) 和 \\(b\\) 的贝祖系数（以18世纪法国数学家艾蒂安·贝祖的名字命名）。还有，等式 \\(\\gcd(a, b) = sa + tb\\) 称为贝祖恒等式。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.256,
                0.956,
                0.292
            ],
            "angle": 0,
            "content": "这里不对定理6做形式证明（证明可参见5.2节练习36和[Ro10]）。我们会给出两种方法，用于找出两个整数的线性组合以使之等于其最大公约数。（本节假定线性组合均以整数为系数。）"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.294,
                0.957,
                0.369
            ],
            "angle": 0,
            "content": "第一种方法要对欧几里得算法的除法步骤做反向处理，所以需要将欧几里得算法的步骤正反向各走一遍。我们用一个例子来解释这种方法的工作原理。第二种方法，即扩展欧几里得算法的好处则是只需要经历一遍欧几里得算法即可找到 \\(a\\) 和 \\(b\\) 的贝祖系数，不像第一种方法那样需要经历两遍。为了运行扩展欧几里得算法，我们设置 \\(s_0 = 1\\) ， \\(s_1 = 0\\) ， \\(t_0 = 0\\) ， \\(t_1 = 1\\) ，并令"
        },
        {
            "type": "equation",
            "bbox": [
                0.365,
                0.373,
                0.7,
                0.389
            ],
            "angle": 0,
            "content": "\\[\ns _ {j} = s _ {j - 2} - q _ {j - 1} s _ {j - 1} t _ {j} = t _ {j - 2} - q _ {j - 1} t _ {j - 1}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.39,
                0.956,
                0.425
            ],
            "angle": 0,
            "content": "对于 \\(j = 2,3,\\dots ,n\\) ，其中 \\(q_{j}\\) 是用上文欧几里得算法求 \\(\\gcd (a,b)\\) 做除法时的商。我们可以用强归纳法(参见5.2节练习44，或[Ro10])证明 \\(\\gcd (a,b) = s_na + t_nb\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.431,
                0.956,
                0.469
            ],
            "angle": 0,
            "content": "例17 通过欧几里得算法的反向处理，试把 \\(\\gcd(252, 198) = 18\\) 表示为252和198的线性组合。"
        },
        {
            "type": "text",
            "bbox": [
                0.149,
                0.472,
                0.692,
                0.488
            ],
            "angle": 0,
            "content": "解 要证明 \\(\\gcd (252,198) = 18\\) ，欧几里得算法做下列除法："
        },
        {
            "type": "equation",
            "bbox": [
                0.451,
                0.492,
                0.619,
                0.562
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} 2 5 2 = 1 \\cdot 1 9 8 + 5 4 \\\\ 1 9 8 = 3 \\cdot 5 4 + 3 6 \\\\ 5 4 = 1 \\cdot 3 6 + 1 8 \\\\ 3 6 = 2 \\cdot 1 8 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.567,
                0.351,
                0.582
            ],
            "angle": 0,
            "content": "我们用表格总结这些步骤："
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.586,
                0.531,
                0.64
            ],
            "angle": 0,
            "content": "用倒数第二个除法（第三次除法），可以把 \\(\\gcd (254,198) = 18\\) 表示为54和36的线性组合。我们得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.245,
                0.644,
                0.399,
                0.658
            ],
            "angle": 0,
            "content": "\\[\n1 8 = 5 4 - 1 \\cdot 3 6\n\\]"
        },
        {
            "type": "table",
            "bbox": [
                0.551,
                0.577,
                0.96,
                0.659
            ],
            "angle": 0,
            "content": "<table><tr><td>j</td><td>rj</td><td>rj+1</td><td>qj+1</td><td>rj+2</td></tr><tr><td>0</td><td>252</td><td>198</td><td>1</td><td>54</td></tr><tr><td>1</td><td>198</td><td>54</td><td>3</td><td>36</td></tr><tr><td>2</td><td>54</td><td>36</td><td>1</td><td>18</td></tr><tr><td>3</td><td>36</td><td>18</td><td>2</td><td>0</td></tr></table>"
        },
        {
            "type": "title",
            "bbox": [
                0.113,
                0.677,
                0.159,
                0.691
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.115,
                0.71,
                0.254,
                0.815
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.114,
                0.819,
                0.245,
                0.839
            ],
            "angle": 0,
            "content": "\\(\\odot\\) Chronicle/Alamy Stock Photo"
        },
        {
            "type": "text",
            "bbox": [
                0.273,
                0.71,
                0.962,
                0.832
            ],
            "angle": 0,
            "content": "艾蒂安·贝祖（Étienne Bézout，1730—1783）贝祖出生在法国的内穆尔镇，他的父亲是一名法官。通过阅读伟大数学家欧拉的著作，强力的兴趣促使他成为了一个数学家。1758年他接受巴黎的科学院任职；1763年他被任命为海岸卫队的审查员，并在那里被指派撰写数学教科书的任务。1767年他完成了四卷本教科书的撰写任务。贝祖以他的六卷本数学综合性教科书而闻名。他的教科书非常受欢迎，那些希望进入以理工科见长的巴黎高等理工学院（École Polytechnique）的几代学生都会学习他的教科书。他的著作被翻译成英文并在北美使用，其中包括哈佛大学。"
        },
        {
            "type": "text",
            "bbox": [
                0.312,
                0.834,
                0.962,
                0.849
            ],
            "angle": 0,
            "content": "他最重要的原创著作是1779年出版的《代数方程通论》（Théorie générale des"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.851,
                0.962,
                0.937
            ],
            "angle": 0,
            "content": "equations algébriques)一书，其中他介绍了解决多未知数的多项式方程组的重要方法。在这本书中最知名的结论现在称为贝祖定理（Bézout's theorem），其一般形式告诉我们，两个平面代数曲线上的共同点数目等于这些曲线度数的乘积。贝祖还发明了判别式（当时被伟大的英国数学家詹姆斯·约瑟夫·西尔维斯特称为 Bézoutian）。虽然他的个性有些保守和忧郁，但他还是一个热心而善良的人。他有一个幸福的婚姻，也是一位父亲。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.647,
                0.039,
                0.78,
                0.055
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.826,
                0.04,
                0.862,
                0.054
            ],
            "angle": 0,
            "content": "241"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.096,
                0.274,
                0.112
            ],
            "angle": 0,
            "content": "第二个除法告诉我们"
        },
        {
            "type": "equation",
            "bbox": [
                0.384,
                0.115,
                0.551,
                0.13
            ],
            "angle": 0,
            "content": "\\[\n3 6 = 1 9 8 - 3 \\cdot 5 4\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.133,
                0.816,
                0.15
            ],
            "angle": 0,
            "content": "将36的这一表达式代入前一等式，就可以把18表示为54和198的线性组合。我们有"
        },
        {
            "type": "equation",
            "bbox": [
                0.19,
                0.153,
                0.746,
                0.168
            ],
            "angle": 0,
            "content": "\\[\n1 8 = 5 4 - 1 \\cdot 3 6 = 5 4 - 1 \\cdot (1 9 8 - 3 \\cdot 5 4) = 4 \\cdot 5 4 - 1 \\cdot 1 9 8\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.172,
                0.274,
                0.188
            ],
            "angle": 0,
            "content": "第一个除法告诉我们"
        },
        {
            "type": "equation",
            "bbox": [
                0.381,
                0.191,
                0.556,
                0.206
            ],
            "angle": 0,
            "content": "\\[\n5 4 = 2 5 2 - 1 \\cdot 1 9 8\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.209,
                0.848,
                0.226
            ],
            "angle": 0,
            "content": "把54的这一表达式代入前面的等式，可以把18表示为252和198的线性组合。得出结论"
        },
        {
            "type": "equation",
            "bbox": [
                0.223,
                0.229,
                0.714,
                0.244
            ],
            "angle": 0,
            "content": "\\[\n1 8 = 4 \\cdot (2 5 2 - 1 \\cdot 1 9 8) - 1 \\cdot 1 9 8 = 4 \\cdot 2 5 2 - 5 \\cdot 1 9 8\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.248,
                0.14,
                0.264
            ],
            "angle": 0,
            "content": "从而得解。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.267,
                0.738,
                0.283
            ],
            "angle": 0,
            "content": "下面的例子展示了如何用扩展欧几里得算法求解上面例子中相同的问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.083,
                0.289,
                0.836,
                0.306
            ],
            "angle": 0,
            "content": "例18利用扩展欧几里得算法将 \\(\\gcd (252,198)\\neq 18\\) 表示为252和198的线性组合。"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.31,
                0.896,
                0.364
            ],
            "angle": 0,
            "content": "解 例17展示了用来计算 \\(\\gcd(252, 198) = 18\\) 的欧几里得算法的步骤。商为 \\(q_{1} = 1\\)，\\(q_{2} = 3\\)，\\(q_{3} = 1\\)，\\(q_{4} = 2\\)。贝祖系数是由扩展欧几里得算法产生的 \\(s_{4}\\) 和 \\(t_{4}\\) 的值，其中 \\(s_{0} = 1\\)，\\(s_{1} = 0\\)，\\(t_{0} = 0\\)，\\(t_{1} = 1\\)，并且对于 \\(j = 2\\)，3，4，有"
        },
        {
            "type": "equation",
            "bbox": [
                0.292,
                0.369,
                0.646,
                0.385
            ],
            "angle": 0,
            "content": "\\[\ns _ {j} = s _ {j - 2} - q _ {j - 1} s _ {j - 1} \\quad t _ {j} = t _ {j - 2} - q _ {j - 1} t _ {j - 1}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.385,
                0.133,
                0.401
            ],
            "angle": 0,
            "content": "我们计算"
        },
        {
            "type": "equation",
            "bbox": [
                0.156,
                0.404,
                0.728,
                0.422
            ],
            "angle": 0,
            "content": "\\[\ns _ {2} = s _ {0} - s _ {1} q _ {1} = 1 - 0 \\cdot 1 = 1 t _ {2} = t _ {0} - t _ {1} q _ {1} = 0 - 1 \\cdot 1 = - 1\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.158,
                0.424,
                0.749,
                0.442
            ],
            "angle": 0,
            "content": "\\[\ns _ {3} = s _ {1} - s _ {2} q _ {2} = 0 - 1 \\cdot 3 = - 3 t _ {3} = t _ {1} - t _ {2} q _ {2} = 1 - (- 1) 3 = 4\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.158,
                0.444,
                0.785,
                0.461
            ],
            "angle": 0,
            "content": "\\[\ns _ {4} = s _ {2} - s _ {3} q _ {3} = 1 - (- 3) \\cdot 1 = 4 t _ {4} = t _ {2} - t _ {3} q _ {3} = - 1 - 4 \\cdot 1 = - 5\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.463,
                0.62,
                0.479
            ],
            "angle": 0,
            "content": "因为 \\(s_4 = 4\\) ， \\(t_4 = -5\\) ，得 \\(18 = \\gcd (252,198) = 4\\cdot 252 - 5\\cdot 198.\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.482,
                0.472,
                0.498
            ],
            "angle": 0,
            "content": "下面用表格总结扩展欧几里得算法的步骤："
        },
        {
            "type": "table",
            "bbox": [
                0.126,
                0.507,
                0.821,
                0.628
            ],
            "angle": 0,
            "content": "<table><tr><td>j</td><td>rj</td><td>rj+1</td><td>qj+1</td><td>rj+2</td><td>sj</td><td>tj</td></tr><tr><td>0</td><td>252</td><td>198</td><td>1</td><td>54</td><td>1</td><td>0</td></tr><tr><td>1</td><td>198</td><td>54</td><td>3</td><td>36</td><td>0</td><td>1</td></tr><tr><td>2</td><td>54</td><td>36</td><td>1</td><td>18</td><td>1</td><td>-1</td></tr><tr><td>3</td><td>36</td><td>18</td><td>2</td><td>0</td><td>-3</td><td>4</td></tr><tr><td>4</td><td></td><td></td><td></td><td></td><td>4</td><td>-5</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.648,
                0.9,
                0.703
            ],
            "angle": 0,
            "content": "可以用定理6推导出一些有用的结果。目标之一是证明算术基本定理（每个正整数最多只有一个素因子分解式）的部分结论。我们要证明如果一个正整数有一个素因子分解式，其中素数是以非递减序排列，则这一分解式是唯一的。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.705,
                0.434,
                0.722
            ],
            "angle": 0,
            "content": "首先，需要推导一些关于整除的结果。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.73,
                0.738,
                0.748
            ],
            "angle": 0,
            "content": "引理2 如果 \\(a, b\\) 和 \\(c\\) 为正整数，使得 \\(\\gcd(a, b) = 1\\) 且 \\(a \\mid bc\\)，则 \\(a \\mid c\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.757,
                0.646,
                0.774
            ],
            "angle": 0,
            "content": "证明 由于 \\(\\gcd (a,b) = 1\\) ，根据贝祖定理知有整数 \\(s\\) 和 \\(t\\) 使得"
        },
        {
            "type": "equation",
            "bbox": [
                0.42,
                0.777,
                0.531,
                0.792
            ],
            "angle": 0,
            "content": "\\[\ns a + t b = 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.795,
                0.254,
                0.811
            ],
            "angle": 0,
            "content": "等式两边乘以 \\(c\\) ，可得"
        },
        {
            "type": "equation",
            "bbox": [
                0.413,
                0.816,
                0.54,
                0.83
            ],
            "angle": 0,
            "content": "\\[\ns a c + t b c = c\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.833,
                0.902,
                0.869
            ],
            "angle": 0,
            "content": "可以用4.1节定理1来证明 \\(a|c\\) 。根据该定理的(ii)， \\(a|tbc\\) 。因为 \\(a|sac\\) 并且 \\(a|tbc\\) ，所以由同一定理的(i)可知， \\(a\\) 整除 \\(sac + tbc\\) 。因为 \\(sac + tbc = c\\) ，从而可得 \\(a|c\\) ，得证。"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.871,
                0.902,
                0.907
            ],
            "angle": 0,
            "content": "在证明素因子分解式唯一性时，我们将使用下面引理2的推广。（引理3的证明留作5.1节的练习64，因为用该节介绍的数学归纳法可以很容易地完成证明。）"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.915,
                0.813,
                0.935
            ],
            "angle": 0,
            "content": "引理3 如果 \\(p\\) 是素数，且 \\(p \\mid a_1a_2 \\cdots a_n\\)，其中 \\(a_i\\) 为整数，则对于某个 \\(i\\)，\\(p \\mid a_i\\)。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.137,
                0.041,
                0.175,
                0.056
            ],
            "angle": 0,
            "content": "242"
        },
        {
            "type": "header",
            "bbox": [
                0.219,
                0.04,
                0.284,
                0.056
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.097,
                0.957,
                0.152
            ],
            "angle": 0,
            "content": "现在可以证明整数分解为素数的唯一性了。即，我们要证明每个整数最多只有一种方式可以写成非递减序素数的乘积。这是算术基本定理的一部分。在5.2节将证明另一部分，即每个整数都有素因子分解式。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.154,
                0.957,
                0.209
            ],
            "angle": 0,
            "content": "证明（正整数素因子分解式的唯一性）我们采用矛盾证明法。假定正整数 \\(n\\) 能用两种不同方式写成素数的乘积，比如说，\\(n = p_1p_2\\dots p_s\\) 和 \\(n = q_1q_2\\dots q_t\\)，其中 \\(p_i, q_j\\) 都是素数，而且 \\(p_1 \\leqslant p_2 \\leqslant \\dots \\leqslant p_s\\) 和 \\(q_1 \\leqslant q_2 \\leqslant \\dots \\leqslant q_t\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.149,
                0.211,
                0.586,
                0.228
            ],
            "angle": 0,
            "content": "当从两个分解式中去掉所有共同的素数时，可得"
        },
        {
            "type": "equation",
            "bbox": [
                0.422,
                0.234,
                0.639,
                0.249
            ],
            "angle": 0,
            "content": "\\[\np _ {i _ {1}} p _ {i _ {2}} \\dots p _ {i _ {u}} = q _ {j _ {1}} q _ {j _ {2}} \\dots q _ {j _ {v}}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.251,
                0.957,
                0.305
            ],
            "angle": 0,
            "content": "其中没有素数同时出现在等式两边，而 \\(u\\) 和 \\(v\\) 为正整数。由引理3可知存在某个 \\(k\\) 使得 \\(p_{i_k}\\) 整除\\(q_{i_k}\\) 。因为没有素数能整除其他素数，所以这是不可能的。因此，最多只有一种以非递减序将 \\(_n\\) 分解为素数的方式。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.308,
                0.956,
                0.362
            ],
            "angle": 0,
            "content": "引理2还可以用来证明同余式两边除以同一整数的一个结果。已经证明（4.1节定理5）可以在同余式两边乘以同一整数。可是，同一个整数去除同余式两边并不一定得到有效的同余式，如例19所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.367,
                0.955,
                0.406
            ],
            "angle": 0,
            "content": "例19 同余式 \\( 14 \\equiv 8 (\\mathrm{mod} 6) \\) 成立，但不能两边同时除以2来得到一个有效的同余式，因为 \\( 14 / 2 = 7 \\)，而 \\( 8 / 2 = 4 \\)，但 \\( 7 \\not\\equiv 4 (\\mathrm{mod} 6) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.409,
                0.955,
                0.445
            ],
            "angle": 0,
            "content": "尽管不能在同余式两边同时除以任意一个整数来得到一个有效同余式，但如果这个整数和模数互素的话就是可以的。定理7就是建立该重要的事实。证明中我们要用到引理2。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.453,
                0.945,
                0.489
            ],
            "angle": 0,
            "content": "定理7 令 \\(m\\) 为正整数，令 \\(a, b\\) 和 \\(c\\) 为整数。如果 \\(ac \\equiv bc (\\bmod m)\\) 且 \\(\\gcd(c, m) = 1\\)，则 \\(a \\equiv b (\\bmod m)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.499,
                0.953,
                0.536
            ],
            "angle": 0,
            "content": "证明 因为 \\(ac \\equiv bc (\\bmod m)\\)，则 \\(m \\mid ac - bc = c(a - b)\\)。根据引理2，因为 \\(\\gcd(c, m) = 1\\) 所以可得 \\(m \\mid a - b\\)。从而可得结论 \\(a \\equiv b (\\bmod m)\\)。"
        },
        {
            "type": "title",
            "bbox": [
                0.106,
                0.547,
                0.153,
                0.562
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.567,
                0.346,
                0.582
            ],
            "angle": 0,
            "content": "1. 判断下列整数是否是素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.585,
                0.169,
                0.599
            ],
            "angle": 0,
            "content": "a)21"
        },
        {
            "type": "text",
            "bbox": [
                0.351,
                0.585,
                0.393,
                0.599
            ],
            "angle": 0,
            "content": "b)29"
        },
        {
            "type": "text",
            "bbox": [
                0.576,
                0.585,
                0.614,
                0.599
            ],
            "angle": 0,
            "content": "c)71"
        },
        {
            "type": "text",
            "bbox": [
                0.761,
                0.586,
                0.801,
                0.599
            ],
            "angle": 0,
            "content": "d)97"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.604,
                0.175,
                0.617
            ],
            "angle": 0,
            "content": "e)111"
        },
        {
            "type": "text",
            "bbox": [
                0.352,
                0.604,
                0.398,
                0.617
            ],
            "angle": 0,
            "content": "f)143"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.621,
                0.345,
                0.636
            ],
            "angle": 0,
            "content": "2. 判断下列整数是否是素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.639,
                0.169,
                0.653
            ],
            "angle": 0,
            "content": "a)19"
        },
        {
            "type": "text",
            "bbox": [
                0.351,
                0.639,
                0.392,
                0.653
            ],
            "angle": 0,
            "content": "b)27"
        },
        {
            "type": "text",
            "bbox": [
                0.576,
                0.64,
                0.613,
                0.652
            ],
            "angle": 0,
            "content": "c)93"
        },
        {
            "type": "text",
            "bbox": [
                0.761,
                0.64,
                0.808,
                0.653
            ],
            "angle": 0,
            "content": "d)101"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.658,
                0.176,
                0.669
            ],
            "angle": 0,
            "content": "e)107"
        },
        {
            "type": "text",
            "bbox": [
                0.352,
                0.658,
                0.398,
                0.67
            ],
            "angle": 0,
            "content": "f)113"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.674,
                0.364,
                0.689
            ],
            "angle": 0,
            "content": "3. 求下列整数的素因子分解式。"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.693,
                0.169,
                0.706
            ],
            "angle": 0,
            "content": "a)88"
        },
        {
            "type": "text",
            "bbox": [
                0.351,
                0.693,
                0.4,
                0.706
            ],
            "angle": 0,
            "content": "b)126"
        },
        {
            "type": "text",
            "bbox": [
                0.576,
                0.693,
                0.622,
                0.706
            ],
            "angle": 0,
            "content": "c)729"
        },
        {
            "type": "text",
            "bbox": [
                0.761,
                0.693,
                0.817,
                0.706
            ],
            "angle": 0,
            "content": "d)1001"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.711,
                0.184,
                0.723
            ],
            "angle": 0,
            "content": "e)1111"
        },
        {
            "type": "text",
            "bbox": [
                0.351,
                0.711,
                0.43,
                0.723
            ],
            "angle": 0,
            "content": "f)909 090"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.728,
                0.362,
                0.742
            ],
            "angle": 0,
            "content": "4. 求下列整数的素因子分解式。"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.746,
                0.169,
                0.76
            ],
            "angle": 0,
            "content": "a)39"
        },
        {
            "type": "text",
            "bbox": [
                0.351,
                0.746,
                0.389,
                0.759
            ],
            "angle": 0,
            "content": "b)81"
        },
        {
            "type": "text",
            "bbox": [
                0.576,
                0.747,
                0.621,
                0.759
            ],
            "angle": 0,
            "content": "c)101"
        },
        {
            "type": "text",
            "bbox": [
                0.761,
                0.747,
                0.808,
                0.759
            ],
            "angle": 0,
            "content": "d)143"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.765,
                0.175,
                0.776
            ],
            "angle": 0,
            "content": "e)289"
        },
        {
            "type": "text",
            "bbox": [
                0.351,
                0.765,
                0.397,
                0.776
            ],
            "angle": 0,
            "content": "f)899"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.781,
                0.329,
                0.796
            ],
            "angle": 0,
            "content": "5. 求 10! 的素因子分解式。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.799,
                0.327,
                0.813
            ],
            "angle": 0,
            "content": "* 6.100! 的尾部有多少个 0?"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.818,
                0.586,
                0.832
            ],
            "angle": 0,
            "content": "7. 试用伪代码表示用来判断一个整数是素数的试除法算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.836,
                0.714,
                0.85
            ],
            "angle": 0,
            "content": "8. 试用伪代码表示正文中所描述的用来寻找一个整数素因子分解式的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.853,
                0.951,
                0.885
            ],
            "angle": 0,
            "content": "9. 证明 \\( a^m + 1 \\) 是合数，如果 \\( a \\) 和 \\( m \\) 是大于 1 的整数且 \\( m \\) 是奇数。[提示：证明 \\( x + 1 \\) 是多项式 \\( x^m + 1 \\) 的因子，如果 \\( m \\) 是奇数。]"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.889,
                0.951,
                0.921
            ],
            "angle": 0,
            "content": "10. 证明如果 \\(2^m + 1\\) 是奇素数，则存在非负整数 \\(n\\) 使得 \\(m = 2n\\)。[提示：首先证明多项式恒等式 \\(x^m + 1 = (x^k + 1)(x^{k(t - 1)} - x^{k(t - 2)} + \\dots - x^k + 1)\\) 成立，其中 \\(m = kt\\) 而 \\(t\\) 是奇数。]"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.924,
                0.734,
                0.94
            ],
            "angle": 0,
            "content": "* 11. 证明 \\(\\log_23\\) 是无理数。回忆一下无理数是不能写成两个整数之比的实数 \\(x\\) 。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.653,
                0.039,
                0.785,
                0.054
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.832,
                0.04,
                0.868,
                0.054
            ],
            "angle": 0,
            "content": "243"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.095,
                0.896,
                0.111
            ],
            "angle": 0,
            "content": "12. 证明对于每个正整数 \\( n \\)，存在 \\( n \\) 个连续的合数。[提示：考虑从 \\( (n + 1)! + 2 \\) 开始的 \\( n \\) 个连续的整数。]"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.114,
                0.71,
                0.129
            ],
            "angle": 0,
            "content": "* 13. 证明或反驳存在 3 个连续的正奇数是素数, 即形如 \\( p \\) 、 \\( p + 2 \\) 、 \\( p + 4 \\) 的奇素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.132,
                0.353,
                0.146
            ],
            "angle": 0,
            "content": "14.哪些小于12的正整数与12互素？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.149,
                0.353,
                0.163
            ],
            "angle": 0,
            "content": "15. 哪些小于30的正整数与30互素？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.166,
                0.353,
                0.18
            ],
            "angle": 0,
            "content": "16. 判断下列各组整数是否两两互素？"
        },
        {
            "type": "list",
            "bbox": [
                0.042,
                0.095,
                0.896,
                0.18
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.184,
                0.195,
                0.198
            ],
            "angle": 0,
            "content": "a)21，34，55"
        },
        {
            "type": "text",
            "bbox": [
                0.294,
                0.184,
                0.408,
                0.198
            ],
            "angle": 0,
            "content": "b)14，17，85"
        },
        {
            "type": "text",
            "bbox": [
                0.517,
                0.184,
                0.665,
                0.198
            ],
            "angle": 0,
            "content": "c)25，41，49，64"
        },
        {
            "type": "text",
            "bbox": [
                0.701,
                0.184,
                0.853,
                0.198
            ],
            "angle": 0,
            "content": "d)17，18，19，23"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.202,
                0.353,
                0.216
            ],
            "angle": 0,
            "content": "17. 判断下列各组整数是否两两互素？"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.219,
                0.195,
                0.234
            ],
            "angle": 0,
            "content": "a)11，15，19"
        },
        {
            "type": "text",
            "bbox": [
                0.294,
                0.219,
                0.407,
                0.234
            ],
            "angle": 0,
            "content": "b)14，15，21"
        },
        {
            "type": "text",
            "bbox": [
                0.517,
                0.219,
                0.665,
                0.234
            ],
            "angle": 0,
            "content": "c)12，17，31，37"
        },
        {
            "type": "text",
            "bbox": [
                0.701,
                0.219,
                0.824,
                0.234
            ],
            "angle": 0,
            "content": "d)7，8，9，11"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.237,
                0.612,
                0.252
            ],
            "angle": 0,
            "content": "18. 一个正整数称为是完全数如果它等于除自身以外所有正因子的和。"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.255,
                0.286,
                0.269
            ],
            "angle": 0,
            "content": "a) 证明 6 和 28 是完全数。"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.272,
                0.472,
                0.287
            ],
            "angle": 0,
            "content": "b) 证明当 \\(2^{p} - 1\\) 为素数时 \\(2^{p - 1}(2^{p} - 1)\\) 是完全数。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.29,
                0.894,
                0.322
            ],
            "angle": 0,
            "content": "19. 证明如果 \\(2^n - 1\\) 为素数，则 \\(n\\) 为素数。[提示：利用恒等式 \\(2^{ab} - 1 = (2^a - 1) \\cdot (2^{a(b - 1)} + 2^{a(b - 2)} + \\dots + 2^a + 1)\\)。]"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.326,
                0.481,
                0.34
            ],
            "angle": 0,
            "content": "20. 判断下列整数是否为素数，以此验证梅森的论断。"
        },
        {
            "type": "list",
            "bbox": [
                0.051,
                0.237,
                0.894,
                0.34
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.343,
                0.147,
                0.357
            ],
            "angle": 0,
            "content": "a) \\(2^{7} - 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.294,
                0.343,
                0.36,
                0.357
            ],
            "angle": 0,
            "content": "b) \\(2^{9} - 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.517,
                0.343,
                0.587,
                0.357
            ],
            "angle": 0,
            "content": "c) \\(2^{11} - 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.701,
                0.343,
                0.774,
                0.357
            ],
            "angle": 0,
            "content": "d) \\(2^{13} - 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.361,
                0.873,
                0.376
            ],
            "angle": 0,
            "content": "欧拉 \\(\\phi\\) -函数在正整数 \\(n\\) 处的值定义为小于等于 \\(n\\) 且与 \\(n\\) 互素的正整数的个数。[注意： \\(\\phi\\) 是希腊字母。]"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.379,
                0.281,
                0.392
            ],
            "angle": 0,
            "content": "21. 求这些欧拉 \\(\\phi\\) -函数的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.396,
                0.137,
                0.41
            ],
            "angle": 0,
            "content": "a) \\(\\phi (4)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.294,
                0.396,
                0.359,
                0.41
            ],
            "angle": 0,
            "content": "b) \\(\\phi (10)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.517,
                0.396,
                0.58,
                0.41
            ],
            "angle": 0,
            "content": "c) \\(\\phi (13)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.414,
                0.373,
                0.428
            ],
            "angle": 0,
            "content": "22. 证明 \\(n\\) 为素数当且仅当 \\(\\phi(n) = n - 1\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.432,
                0.459,
                0.446
            ],
            "angle": 0,
            "content": "23. 当 \\(p\\) 为素数而 \\(k\\) 为正整数时 \\(\\phi(p^k)\\) 的值是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.449,
                0.371,
                0.463
            ],
            "angle": 0,
            "content": "24. 下列各对整数的最大公约数是什么？"
        },
        {
            "type": "list",
            "bbox": [
                0.051,
                0.414,
                0.459,
                0.463
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.466,
                0.295,
                0.481
            ],
            "angle": 0,
            "content": "a) \\(2^{2} \\cdot 3^{3} \\cdot 5^{5}\\), \\(2^{5} \\cdot 3^{3} \\cdot 5^{2}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.517,
                0.466,
                0.865,
                0.481
            ],
            "angle": 0,
            "content": "b) \\(2 \\cdot 3 \\cdot 5 \\cdot 7 \\cdot 11 \\cdot 13, 2^{11} \\cdot 3^9 \\cdot 11 \\cdot 17^{14}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.485,
                0.167,
                0.498
            ],
            "angle": 0,
            "content": "c)17, \\(17^{17}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.517,
                0.485,
                0.655,
                0.498
            ],
            "angle": 0,
            "content": "d) \\(2^{2} \\cdot 7, 5^{3} \\cdot 13\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.503,
                0.137,
                0.516
            ],
            "angle": 0,
            "content": "e)0，5"
        },
        {
            "type": "text",
            "bbox": [
                0.517,
                0.503,
                0.738,
                0.516
            ],
            "angle": 0,
            "content": "f) \\(2\\cdot 3\\cdot 5\\cdot 7\\) ， \\(2\\cdot 3\\cdot 5\\cdot 7\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.52,
                0.371,
                0.534
            ],
            "angle": 0,
            "content": "25. 下列各对整数的最大公约数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.537,
                0.3,
                0.551
            ],
            "angle": 0,
            "content": "a) \\(3^{7} \\cdot 5^{3} \\cdot 7^{3}, 2^{11} \\cdot 3^{5} \\cdot 5^{9}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.517,
                0.537,
                0.769,
                0.551
            ],
            "angle": 0,
            "content": "b) \\(11 \\cdot 13 \\cdot 17, 2^9 \\cdot 3^7 \\cdot 5^5 \\cdot 7^3\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.555,
                0.179,
                0.569
            ],
            "angle": 0,
            "content": "c) \\(23^{31}\\), \\(23^{17}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.517,
                0.556,
                0.74,
                0.569
            ],
            "angle": 0,
            "content": "d) \\(41 \\cdot 43 \\cdot 53\\), \\(41 \\cdot 43 \\cdot 53\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.573,
                0.242,
                0.586
            ],
            "angle": 0,
            "content": "e) \\(3^{13} \\cdot 5^{17}\\), \\(2^{12} \\cdot 7^{21}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.517,
                0.574,
                0.599,
                0.587
            ],
            "angle": 0,
            "content": "f)1111，0"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.591,
                0.417,
                0.605
            ],
            "angle": 0,
            "content": "26. 练习 24 中各对整数的最小公倍数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.608,
                0.417,
                0.622
            ],
            "angle": 0,
            "content": "27. 练习 25 中各对整数的最小公倍数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.626,
                0.864,
                0.64
            ],
            "angle": 0,
            "content": "28. 试求 \\(\\gcd(1000, 625)\\) 和 \\(\\operatorname{lcm}(1000, 625)\\)，并验证 \\(\\gcd(1000, 625) \\cdot \\operatorname{lcm}(1000, 625) = 1000 \\cdot 625\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.644,
                0.892,
                0.675
            ],
            "angle": 0,
            "content": "29. 试求 gcd(92928, 123552) 和 lcm(92928, 123552), 并验证 gcd(92928, 123552) · lcm(92928, 123552) = 92928 · 123552。[提示: 首先找出 92928 和 123552 的素因子分解式。]"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.679,
                0.847,
                0.693
            ],
            "angle": 0,
            "content": "30. 如果两个整数的乘积为 \\(2^{7} 3^{8} 5^{2} 7^{11}\\)，而它们的最大公约数为 \\(2^{3} 3^{4} 5\\)，则它们的最小公倍数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.696,
                0.892,
                0.729
            ],
            "angle": 0,
            "content": "31. 证明如果 \\(a\\) 和 \\(b\\) 为正整数，则 \\(ab = \\gcd(a, b) \\cdot \\operatorname{lcm}(a, b)\\)。[提示：利用 \\(a\\) 和 \\(b\\) 的素因子分解式以及根据素因子分解式给出的 \\(\\gcd(a, b)\\) 和 \\(\\operatorname{lcm}(a, b)\\) 的计算公式。]"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.732,
                0.23,
                0.746
            ],
            "angle": 0,
            "content": "32. 用欧几里得算法求"
        },
        {
            "type": "list",
            "bbox": [
                0.051,
                0.591,
                0.892,
                0.746
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.75,
                0.181,
                0.764
            ],
            "angle": 0,
            "content": "a)gcd(1，5)"
        },
        {
            "type": "text",
            "bbox": [
                0.294,
                0.75,
                0.431,
                0.764
            ],
            "angle": 0,
            "content": "b) gcd(100, 101)"
        },
        {
            "type": "text",
            "bbox": [
                0.517,
                0.75,
                0.652,
                0.764
            ],
            "angle": 0,
            "content": "c)gcd(123，277)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.768,
                0.25,
                0.782
            ],
            "angle": 0,
            "content": "d)gcd(1529，14039)"
        },
        {
            "type": "text",
            "bbox": [
                0.294,
                0.768,
                0.461,
                0.782
            ],
            "angle": 0,
            "content": "e)gcd(1529，14038）"
        },
        {
            "type": "text",
            "bbox": [
                0.517,
                0.768,
                0.705,
                0.782
            ],
            "angle": 0,
            "content": "f) gcd(11 111, 111 111)"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.785,
                0.23,
                0.799
            ],
            "angle": 0,
            "content": "33. 用欧几里得算法求"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.803,
                0.199,
                0.817
            ],
            "angle": 0,
            "content": "a) gcd(12, 18)"
        },
        {
            "type": "text",
            "bbox": [
                0.294,
                0.803,
                0.431,
                0.817
            ],
            "angle": 0,
            "content": "b)gcd(111，201)"
        },
        {
            "type": "text",
            "bbox": [
                0.517,
                0.803,
                0.67,
                0.817
            ],
            "angle": 0,
            "content": "c)gcd(1001，1331)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.821,
                0.263,
                0.835
            ],
            "angle": 0,
            "content": "d)gcd(12345，54321)"
        },
        {
            "type": "text",
            "bbox": [
                0.294,
                0.821,
                0.447,
                0.835
            ],
            "angle": 0,
            "content": "e)gcd(1000，5040)"
        },
        {
            "type": "text",
            "bbox": [
                0.517,
                0.821,
                0.669,
                0.835
            ],
            "angle": 0,
            "content": "f) gcd(9888, 6060)"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.838,
                0.493,
                0.852
            ],
            "angle": 0,
            "content": "34. 用欧几里得算法求 gcd(21, 34) 需要做多少次除法？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.856,
                0.493,
                0.869
            ],
            "angle": 0,
            "content": "35. 用欧几里得算法求 gcd(34, 55) 需要做多少次除法？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.873,
                0.576,
                0.887
            ],
            "angle": 0,
            "content": "36. 证明如果 \\(a\\) 和 \\(b\\) 为正整数，则 \\((2^{a} - 1) \\mod (2^{b} - 1) = 2^{a \\mod b} - 1\\)。"
        },
        {
            "type": "list",
            "bbox": [
                0.051,
                0.838,
                0.576,
                0.887
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.011,
                0.89,
                0.894,
                0.941
            ],
            "angle": 0,
            "content": "* 37. 利用练习36证明如果 \\(a\\) 和 \\(b\\) 为正整数，则 \\(\\gcd(2^a - 1, 2^b - 1) = 2^{\\gcd(a, b)} - 1\\)。[提示：证明当用欧几里得算法计算 \\(\\gcd(2^a - 1, 2^b - 1)\\) 时得到的余数是形如 \\(2^r - 1\\) 的数，其中 \\(r\\) 是用欧几里得算法求 \\(\\gcd(a, b)\\) 时产生的余数。]"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.136,
                0.038,
                0.172,
                0.052
            ],
            "angle": 0,
            "content": "244"
        },
        {
            "type": "header",
            "bbox": [
                0.218,
                0.037,
                0.282,
                0.053
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.094,
                0.85,
                0.108
            ],
            "angle": 0,
            "content": "38. 利用练习 37 证明整数 \\(2^{35} - 1, 2^{34} - 1, 2^{33} - 1, 2^{31} - 1, 2^{29} - 1\\) 和 \\(2^{23} - 1\\) 是两两互素的。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.112,
                0.738,
                0.127
            ],
            "angle": 0,
            "content": "39. 利用例17中的方法把下列各对整数的最大公约数表示为它们的线性组合。"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.13,
                0.218,
                0.145
            ],
            "angle": 0,
            "content": "a)10，11"
        },
        {
            "type": "text",
            "bbox": [
                0.354,
                0.13,
                0.432,
                0.144
            ],
            "angle": 0,
            "content": "b)21，44"
        },
        {
            "type": "text",
            "bbox": [
                0.577,
                0.13,
                0.653,
                0.144
            ],
            "angle": 0,
            "content": "c)36，48"
        },
        {
            "type": "text",
            "bbox": [
                0.762,
                0.13,
                0.839,
                0.144
            ],
            "angle": 0,
            "content": "d)34，55"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.148,
                0.235,
                0.161
            ],
            "angle": 0,
            "content": "e)117，213"
        },
        {
            "type": "text",
            "bbox": [
                0.355,
                0.148,
                0.429,
                0.161
            ],
            "angle": 0,
            "content": "f)0，223"
        },
        {
            "type": "text",
            "bbox": [
                0.577,
                0.147,
                0.68,
                0.161
            ],
            "angle": 0,
            "content": "g)123，2347"
        },
        {
            "type": "text",
            "bbox": [
                0.762,
                0.147,
                0.876,
                0.161
            ],
            "angle": 0,
            "content": "h)3454，4666"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.165,
                0.264,
                0.178
            ],
            "angle": 0,
            "content": "i)9999，11111"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.182,
                0.738,
                0.197
            ],
            "angle": 0,
            "content": "40. 利用例17中的方法把下列各对整数的最大公约数表示为它们的线性组合。"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.2,
                0.261,
                0.215
            ],
            "angle": 0,
            "content": "a)9，11"
        },
        {
            "type": "text",
            "bbox": [
                0.355,
                0.2,
                0.432,
                0.214
            ],
            "angle": 0,
            "content": "b)33，44"
        },
        {
            "type": "text",
            "bbox": [
                0.577,
                0.2,
                0.654,
                0.214
            ],
            "angle": 0,
            "content": "c)35，78"
        },
        {
            "type": "text",
            "bbox": [
                0.762,
                0.2,
                0.84,
                0.213
            ],
            "angle": 0,
            "content": "d)21，55"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.218,
                0.236,
                0.232
            ],
            "angle": 0,
            "content": "e)101，203"
        },
        {
            "type": "text",
            "bbox": [
                0.355,
                0.218,
                0.449,
                0.232
            ],
            "angle": 0,
            "content": "f)124，323"
        },
        {
            "type": "text",
            "bbox": [
                0.577,
                0.218,
                0.696,
                0.232
            ],
            "angle": 0,
            "content": "g）2002，2339"
        },
        {
            "type": "text",
            "bbox": [
                0.762,
                0.217,
                0.883,
                0.231
            ],
            "angle": 0,
            "content": "h）3457，4669"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.236,
                0.28,
                0.249
            ],
            "angle": 0,
            "content": "i)10001，13422"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.253,
                0.957,
                0.32
            ],
            "angle": 0,
            "content": "扩展欧几里得算法可用来把 \\(\\gcd(a, b)\\) 表示成整数 \\(a\\) 和 \\(b\\) 的整系数线性组合。对于 \\(j = 2, 3, \\dots, n\\)，令 \\(s_0 = 1\\)，\\(s_1 = 0\\)，\\(t_0 = 0\\) 和 \\(t_1 = 1\\)，再令 \\(s_j = s_{j-2} - q_{j-1}s_{j-1}\\) 和 \\(t_j = t_{j-2} - q_{j-1}t_{j-1}\\)，其中 \\(q_j\\) 是用欧几里得算法求 \\(\\gcd(a, b)\\) 时的商，如正文所示。可以证明（参见[Ro10]）\\(\\gcd(a, b) = s_na + t_nb\\)。扩展欧几里得算法最大的好处是它只通过一遍欧几里得算法步骤来找出 \\(a\\) 和 \\(b\\) 的贝祖系数，而不像正文中的方法采用两遍步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.324,
                0.688,
                0.338
            ],
            "angle": 0,
            "content": "41. 利用扩展欧几里得算法把 gcd(26, 91) 表示成 26 和 91 的线性组合。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.341,
                0.722,
                0.355
            ],
            "angle": 0,
            "content": "42. 利用扩展欧几里得算法把 \\(\\gcd(252, 356)\\) 表示成 252 和 356 的线性组合。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.359,
                0.705,
                0.372
            ],
            "angle": 0,
            "content": "43. 利用扩展欧几里得算法把 gcd(144，89)表示成 144 和 89 的线性组合。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.376,
                0.805,
                0.39
            ],
            "angle": 0,
            "content": "44. 利用扩展欧几里得算法把 gcd(1001, 100001) 表示成 1001 和 100001 的线性组合。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.394,
                0.416,
                0.408
            ],
            "angle": 0,
            "content": "45. 用伪代码描述扩展欧几里得算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.412,
                0.557,
                0.426
            ],
            "angle": 0,
            "content": "46. 找出恰有 \\(n\\) 个不同正因数的最小正整数，其中 \\(n\\) 是"
        },
        {
            "type": "list",
            "bbox": [
                0.109,
                0.324,
                0.805,
                0.426
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.144,
                0.43,
                0.177,
                0.444
            ],
            "angle": 0,
            "content": "a)3"
        },
        {
            "type": "text",
            "bbox": [
                0.359,
                0.43,
                0.39,
                0.443
            ],
            "angle": 0,
            "content": "b)4"
        },
        {
            "type": "text",
            "bbox": [
                0.582,
                0.43,
                0.61,
                0.442
            ],
            "angle": 0,
            "content": "c)5"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.448,
                0.177,
                0.46
            ],
            "angle": 0,
            "content": "d)6"
        },
        {
            "type": "text",
            "bbox": [
                0.359,
                0.448,
                0.398,
                0.46
            ],
            "angle": 0,
            "content": "e)10"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.464,
                0.957,
                0.496
            ],
            "angle": 0,
            "content": "47. 试找出和素数或素因子分解式相关、用以计算序列第 \\(n\\) 项的公式或规则，使得序列的初始项为下面给出的这些值。"
        },
        {
            "type": "text",
            "bbox": [
                0.144,
                0.5,
                0.543,
                0.514
            ],
            "angle": 0,
            "content": "a)0，1，1，0，1，0，1，0，0，0，1，0，1，…"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.518,
                0.59,
                0.531
            ],
            "angle": 0,
            "content": "b)1，2，3，2，5，2，7，2，3，2，11，2，13，2，…"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.535,
                0.57,
                0.548
            ],
            "angle": 0,
            "content": "c)1，2，2，3，2，4，2，4，3，4，2，6，2，4，…"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.553,
                0.572,
                0.566
            ],
            "angle": 0,
            "content": "d)1，1，1，0，1，1，1，0，0，1，1，0，1，1，…"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.57,
                0.607,
                0.584
            ],
            "angle": 0,
            "content": "e)1，2，3，3，5，5，7，7，7，7，11，11，13，13，…"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.587,
                0.753,
                0.601
            ],
            "angle": 0,
            "content": "f)1，2，6，30，210，2310，30030，510510，9699690，223092870，…"
        },
        {
            "type": "list",
            "bbox": [
                0.144,
                0.5,
                0.753,
                0.601
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.605,
                0.961,
                0.637
            ],
            "angle": 0,
            "content": "48. 试找出和素数或素因子分解式相关、用以计算序列第 \\( n \\) 项的公式或规则，使得序列的初始项为下面给出的这些值。"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.641,
                0.599,
                0.655
            ],
            "angle": 0,
            "content": "a)2，2，3，5，5，7，7，11，11，11，11，13，13，…"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.659,
                0.573,
                0.672
            ],
            "angle": 0,
            "content": "b)0，1，2，2，3，3，4，4，4，5，5，6，6，…"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.676,
                0.572,
                0.689
            ],
            "angle": 0,
            "content": "c)1，0，0，1，0，1，0，1，1，1，0，1，0，1，…"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.693,
                0.713,
                0.707
            ],
            "angle": 0,
            "content": "d)1，-1，-1，0，-1，1，-1，0，0，1，-1，0，-1，1，1，…"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.711,
                0.599,
                0.724
            ],
            "angle": 0,
            "content": "e)1，1，1，1，0，1，1，1，0，1，0，1，0，0，…"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.728,
                0.691,
                0.742
            ],
            "angle": 0,
            "content": "f)4，9，25，49，121，169，289，361，529，841，961，1369，…"
        },
        {
            "type": "list",
            "bbox": [
                0.146,
                0.641,
                0.713,
                0.742
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.746,
                0.514,
                0.761
            ],
            "angle": 0,
            "content": "49. 证明任何3个连续整数的乘积可以被6整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.764,
                0.827,
                0.778
            ],
            "angle": 0,
            "content": "50. 证明如果 \\(a, b\\) 和 \\(m\\) 为整数使得 \\(m \\geqslant 2\\) 且 \\(a \\equiv b (\\bmod m)\\)，则 \\(\\gcd(a, m) = \\gcd(b, m)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.781,
                0.568,
                0.795
            ],
            "angle": 0,
            "content": "* 51. 证明或反驳当 \\( n \\) 为正整数时 \\( {n}^{2} - {79n} + {1601} \\) 为素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.799,
                0.931,
                0.813
            ],
            "angle": 0,
            "content": "52. 证明或反驳对应每个正整数 \\( n \\) 有 \\( p_1p_2\\cdots p_n + 1 \\) 是素数，其中 \\( p_1, p_2, \\cdots, p_n \\) 是 \\( n \\) 个最小的素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.817,
                0.811,
                0.831
            ],
            "angle": 0,
            "content": "53. 证明在每个算术级数 \\(ak + b\\)，\\(k = 1, 2, \\cdots\\) 中存在一个合数，其中 \\(a\\) 和 \\(b\\) 是正整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.834,
                0.964,
                0.866
            ],
            "angle": 0,
            "content": "54.改编正文中关于存在无限多个素数的证明来证明存在无限多个形如 \\(3k + 2\\) 的素数，这里 \\(k\\) 是非负整数。[提示：假设只有有限多个这样的素数 \\(q_{1}\\) ， \\(q_{2}\\) ，…， \\(q_{n}\\) ，考虑这个数 \\(3q_{1}q_{2}\\dots q_{n} - 1\\) 。]"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.869,
                0.964,
                0.902
            ],
            "angle": 0,
            "content": "55.改编正文中关于存在无限多个素数的证明来证明存在无限多个形如 \\(4k + 3\\) 的素数，这里 \\(k\\) 是非负整数。[提示：假设只有有限多个这样的素数 \\(q_{1}\\) ， \\(q_{2}\\) ，…， \\(q_{n}\\) ，考虑这个数 \\(4q_{1}q_{2}\\dots q_{n} - 1\\) 。]"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.904,
                0.965,
                0.937
            ],
            "angle": 0,
            "content": "* 56. 通过构造一个函数来证明正有理数集合是可数的, 该函数将满足 \\(\\gcd(p, q) = 1\\) 的有理数 \\(p / q\\) 映射到一个这样构造的十一进制数, \\(p\\) 的十进制表示后面紧跟一个十一进制数字 \\(A\\) (A 对应于十进制数的"
        },
        {
            "type": "list",
            "bbox": [
                0.102,
                0.781,
                0.965,
                0.937
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.648,
                0.043,
                0.779,
                0.059
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.826,
                0.045,
                0.861,
                0.058
            ],
            "angle": 0,
            "content": "245"
        },
        {
            "type": "text",
            "bbox": [
                0.079,
                0.1,
                0.337,
                0.115
            ],
            "angle": 0,
            "content": "10)再后面紧跟 \\(q\\) 的十进制表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.037,
                0.118,
                0.893,
                0.171
            ],
            "angle": 0,
            "content": "* 57. 通过证明函数 \\(K\\) 是正有理数集合和正整数集合之间的一一对应关系来证明正有理数集合是可数的: \\(K(m / n) = p_{1}^{2a_{1}}p_{2}^{2a_{2}}\\dots p_{s}^{2a_{s}}q_{1}^{2b_{1} - 1}q_{2}^{2b_{2} - 1}\\dots q_{t}^{2b_{t} - 1}\\), 其中 \\(\\gcd(m, n) = 1\\) 并且 \\(m\\) 和 \\(n\\) 的素数幂分解式是 \\(m = p_{1}^{a_{1}}p_{2}^{a_{2}}\\dots p_{s}^{a_{s}}\\) 和 \\(n = q_{1}^{b_{1}}q_{2}^{b_{2}}\\dots q_{t}^{b_{t}}\\)。"
        },
        {
            "type": "title",
            "bbox": [
                0.048,
                0.185,
                0.273,
                0.204
            ],
            "angle": 0,
            "content": "4.4 求解同余方程"
        },
        {
            "type": "title",
            "bbox": [
                0.048,
                0.213,
                0.172,
                0.229
            ],
            "angle": 0,
            "content": "4.4.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.233,
                0.894,
                0.308
            ],
            "angle": 0,
            "content": "求解形如 \\(ax \\equiv b(\\bmod m)\\) 的线性同余方程是数论研究及其应用中的一项基本任务，如同解线性方程在微积分和线性代数中起着重要作用一样。要求解线性同余方程，要采用模 \\(m\\) 的逆。我们将解释如何通过欧几里得算法步骤的反向运算找到模 \\(m\\) 的逆。一旦找到 \\(a\\) 模 \\(m\\) 的逆，我们就可以通过在同余方程 \\(ax \\equiv b(\\bmod m)\\) 两边乘以这个逆来解该同余方程。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.31,
                0.894,
                0.384
            ],
            "angle": 0,
            "content": "线性同余方程组在古时候就有研究。例如，在公元1世纪中国数学家孙子就开始研究了。我们将介绍如何求解模数两两互素的线性同余方程组。我们要证明的结论称为中国余数定理，而我们的证明将给出一个方法来寻找这样的同余方程组的全部解。我们还会展示如何用中国余数定理作为执行大整数算术的基础。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.386,
                0.894,
                0.481
            ],
            "angle": 0,
            "content": "我们将介绍费马的一个很有用的结论，称为费马小定理，它阐述如果 \\( p \\) 是素数且 \\( p \\) 不整除 \\( a \\)，则 \\( a^{p-1} \\equiv 1 (\\bmod p) \\)。还会要检查该命题的逆命题，这会导致一个伪素数的概念。一个相对以 \\( a \\) 为基数的伪素数 \\( m \\) 是一个整数合数 \\( m \\)，由于满足同余式 \\( a^{m-1} \\equiv 1 (\\bmod m) \\) 而伪装成素数。我们还会给出卡米切尔数的一个例子，这是一个整数合数，它是一个相对于所有与之互素的数 \\( a \\) 为基数的伪素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.483,
                0.894,
                0.577
            ],
            "angle": 0,
            "content": "我们还要介绍离散对数的概念，它和普通对数类似。为了定义离散对数，必须首先定义原根(primitive root)。一个素数 \\( p \\) 的原根是一个整数 \\( r \\)，使得每个不能被 \\( p \\) 整除的整数都模 \\( p \\) 同余 \\( r \\) 的一个幂次。如果 \\( r \\) 是 \\( p \\) 的一个原根且 \\( r^e \\equiv a (\\bmod p) \\)，则 \\( e \\) 是以 \\( r \\) 为底 \\( a \\) 模 \\( p \\) 的离散对数。一般来说寻找离散对数是一个非常困难的问题。这个问题的困难性也就成为了许多密码系统安全性的基础。"
        },
        {
            "type": "title",
            "bbox": [
                0.053,
                0.587,
                0.267,
                0.604
            ],
            "angle": 0,
            "content": "4.4.2 线性同余方程"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.608,
                0.321,
                0.624
            ],
            "angle": 0,
            "content": "具有下面形式的同余方程"
        },
        {
            "type": "equation",
            "bbox": [
                0.4,
                0.628,
                0.544,
                0.642
            ],
            "angle": 0,
            "content": "\\[\na x \\equiv b (\\mathrm {m o d} m)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.646,
                0.896,
                0.681
            ],
            "angle": 0,
            "content": "其中 \\(m\\) 为正整数，\\(a\\) 和 \\(b\\) 为整数，而 \\(x\\) 为变量，称为线性同余方程。在数论及其应用中到处可见这种同余方程。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.684,
                0.896,
                0.74
            ],
            "angle": 0,
            "content": "怎样求解线性同余方程 \\(ax \\equiv b(\\bmod m)\\) 呢？即，如何能找出所有满足这一同余方程的整数 \\(x\\) 呢？我们要介绍的一个方法是利用使得 \\(\\overline{a} a \\equiv 1(\\bmod m)\\) 成立的整数 \\(\\overline{a}\\)，如果这样的整数存在。这样的整数 \\(\\overline{a}\\) 称为 \\(a\\) 模 \\(m\\) 的逆。当 \\(a\\) 和 \\(m\\) 互素时，定理1能保证 \\(a\\) 模 \\(m\\) 的逆存在。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.748,
                0.89,
                0.804
            ],
            "angle": 0,
            "content": "定理1 如果 \\(a\\) 和 \\(m\\) 为互素的整数且 \\(m > 1\\)，则 \\(a\\) 模 \\(m\\) 的逆存在。再者，这个模 \\(m\\) 的逆是唯一的。（即，存在唯一小于 \\(m\\) 的正整数 \\(\\overline{a}\\) 是 \\(a\\) 模 \\(m\\) 的逆，并且 \\(a\\) 模 \\(m\\) 的其他每个逆均和 \\(\\overline{a}\\) 模 \\(m\\) 同余。）"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.813,
                0.726,
                0.83
            ],
            "angle": 0,
            "content": "证明 由4.3节定理6，因为 \\(\\gcd (a,m) = 1\\) ，所以存在整数 \\(s\\) 和 \\(t\\) 使得"
        },
        {
            "type": "equation",
            "bbox": [
                0.418,
                0.834,
                0.532,
                0.848
            ],
            "angle": 0,
            "content": "\\[\ns a + t m = 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.852,
                0.137,
                0.868
            ],
            "angle": 0,
            "content": "这蕴含着"
        },
        {
            "type": "equation",
            "bbox": [
                0.378,
                0.872,
                0.571,
                0.887
            ],
            "angle": 0,
            "content": "\\[\ns a + t m \\equiv 1 (\\mathrm {m o d} m)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.89,
                0.314,
                0.906
            ],
            "angle": 0,
            "content": "因为 \\(tm \\equiv 0 (\\mathrm{mod} m)\\)，所以有"
        },
        {
            "type": "equation",
            "bbox": [
                0.405,
                0.91,
                0.548,
                0.925
            ],
            "angle": 0,
            "content": "\\[\ns a \\equiv 1 (\\mathrm {m o d} m)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.928,
                0.616,
                0.945
            ],
            "angle": 0,
            "content": "因此， \\(s\\) 为 \\(a\\) 模 \\(m\\) 的逆。证明该模 \\(m\\) 的逆是唯一的留作练习7。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.146,
                0.043,
                0.185,
                0.057
            ],
            "angle": 0,
            "content": "246"
        },
        {
            "type": "header",
            "bbox": [
                0.228,
                0.042,
                0.295,
                0.058
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.097,
                0.967,
                0.189
            ],
            "angle": 0,
            "content": "当 \\(m\\) 很小时可以利用察看的方式寻找 \\(a\\) 模 \\(m\\) 的逆。要寻找这个逆，我们寻找一个 \\(a\\) 的倍数，它比 \\(m\\) 的一个倍数大1。例如，要寻找3模7的逆，我们可以寻找 \\(j \\cdot 3, j = 1, 2, \\dots, 6\\) ，直到找到3的一个倍数正好比7的一个倍数多1为止。如果我们注意到 \\(2 \\cdot 3 \\equiv -1 (\\bmod 7)\\) 就可以加速该过程。这意味着 \\((-2) \\cdot 3 \\equiv 1 (\\bmod 7)\\) 。因此，\\(5 \\cdot 3 \\equiv 1 (\\bmod 7)\\)，所以5就是3模7的一个逆。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.191,
                0.966,
                0.266
            ],
            "angle": 0,
            "content": "当 \\(\\gcd(a, m) = 1\\) 时我们可以利用欧几里得算法的步骤设计一个比蛮力更有效的算法来寻找 \\(a\\) 模 \\(m\\) 的逆。就像4.3节例17一样颠倒算法步骤，我们可以找到一个线性组合 \\(sa + tm = 1\\) 其中 \\(s\\) 和 \\(t\\) 是整数。在这个模 \\(m\\) 方程的两边做简化可知 \\(s\\) 是 \\(a\\) 模 \\(m\\) 的一个逆。用例1解释这一过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.268,
                0.966,
                0.308
            ],
            "angle": 0,
            "content": "例1 通过首先找出3和7的贝祖系数来求3模7的逆。（注意我们通过察看已经证明了5是3模7的一个逆。）"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.31,
                0.966,
                0.345
            ],
            "angle": 0,
            "content": "解因为 \\(\\gcd (3,7) = 1\\) ，所以定理1说明3模7的逆存在。当用欧几里得算法来求3和7的最大公约数时算法很快结束："
        },
        {
            "type": "equation",
            "bbox": [
                0.478,
                0.348,
                0.601,
                0.363
            ],
            "angle": 0,
            "content": "\\[\n7 = 2 \\cdot 3 + 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.366,
                0.265,
                0.383
            ],
            "angle": 0,
            "content": "从这一等式看到"
        },
        {
            "type": "equation",
            "bbox": [
                0.452,
                0.386,
                0.627,
                0.401
            ],
            "angle": 0,
            "content": "\\[\n- 2 \\cdot 3 + 1 \\cdot 7 = 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.403,
                0.964,
                0.44
            ],
            "angle": 0,
            "content": "这表明一2和1是3和7的贝祖系数。可见一2是3模7的一个逆。注意，与一2模7同余的每个整数也是3的逆，例如5、-9、12等。"
        },
        {
            "type": "text",
            "bbox": [
                0.156,
                0.443,
                0.417,
                0.461
            ],
            "angle": 0,
            "content": "例2 找出101模4620的逆。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.465,
                0.964,
                0.539
            ],
            "angle": 0,
            "content": "解为了完整性，我们给出用来计算101模4620的逆的全部步骤。（只有最后一步超出了4.3节介绍的方法，并在那里的例17中做了解释。）首先，用欧几里得算法证明 \\(\\gcd (101, 4620) = 1\\) 。然后颠倒步骤找出贝祖系数 \\(a\\) 和 \\(b\\) 使得 \\(101a + 4620b = 1\\) 。于是可推出 \\(a\\) 是101模4620的一个逆。欧几里得算法用于寻找 \\(\\gcd (101, 4620)\\) 的步骤是"
        },
        {
            "type": "equation",
            "bbox": [
                0.443,
                0.542,
                0.635,
                0.67
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} 4 6 2 0 = 4 5 \\cdot 1 0 1 + 7 5 \\\\ 1 0 1 = 1 \\cdot 7 5 + 2 6 \\\\ 7 5 = 2 \\cdot 2 6 + 2 3 \\\\ 2 6 = 1 \\cdot 2 3 + 3 \\\\ 2 3 = 7 \\cdot 3 + 2 \\\\ 3 = 1 \\cdot 2 + 1 \\\\ 2 = 2 \\cdot 1 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.672,
                0.962,
                0.728
            ],
            "angle": 0,
            "content": "因为最后非零余数是1，所以可知 \\(\\gcd(101, 4620) = 1\\)。可以通过反向操作这些步骤，用连续的余数对表示 \\(\\gcd(101, 4620) = 1\\)，从而找出101和4620的贝祖系数，在每一步通过将余数表示成除数和被除数的线性组合来消除余数。我们得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.248,
                0.731,
                0.824,
                0.841
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} 1 = 3 - 1 \\cdot 2 \\\\ = 3 - 1 \\cdot (2 3 - 7 \\cdot 3) = - 1 \\cdot 2 3 + 8 \\cdot 3 \\\\ = - 1 \\cdot 2 3 + 8 \\cdot (2 6 - 1 \\cdot 2 3) = 8 \\cdot 2 6 - 9 \\cdot 2 3 \\\\ = 8 \\cdot 2 6 - 9 \\cdot (7 5 - 2 \\cdot 2 6) = - 9 \\cdot 7 5 + 2 6 \\cdot 2 6 \\\\ = - 9 \\cdot 7 5 + 2 6 \\cdot (1 0 1 - 1 \\cdot 7 5) = 2 6 \\cdot 1 0 1 - 3 5 \\cdot 7 5 \\\\ = 2 6 \\cdot 1 0 1 - 3 5 \\cdot (4 6 2 0 - 4 5 \\cdot 1 0 1) = - 3 5 \\cdot 4 6 2 0 + 1 6 0 1 \\cdot 1 0 1 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.843,
                0.958,
                0.878
            ],
            "angle": 0,
            "content": "\\(-35 \\cdot 4620 + 1601 \\cdot 101 = 1\\) 告诉我们 \\(-35\\) 和 1601 是 4620 和 101 的贝祖系数，而 1601 是 101 模 4620 的逆。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.881,
                0.958,
                0.916
            ],
            "angle": 0,
            "content": "一旦有了 \\(a\\) 模 \\(m\\) 的逆 \\(\\overline{a}\\)，就可以通过在线性同余方程两边同时乘以 \\(\\overline{a}\\) 来求解同余方程 \\(ax \\equiv b (\\bmod m)\\)，如例3所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.92,
                0.579,
                0.939
            ],
            "angle": 0,
            "content": "例3 线性同余方程 \\( 3x \\equiv 4 (\\mathrm{mod} 7) \\) 的解是什么？"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.65,
                0.036,
                0.783,
                0.052
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.829,
                0.037,
                0.866,
                0.051
            ],
            "angle": 0,
            "content": "247"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.093,
                0.654,
                0.109
            ],
            "angle": 0,
            "content": "解 从例1知道一2是3模7的逆。在同余式两边同乘以一2得"
        },
        {
            "type": "equation",
            "bbox": [
                0.35,
                0.113,
                0.586,
                0.127
            ],
            "angle": 0,
            "content": "\\[\n- 2 \\cdot 3 x \\equiv - 2 \\cdot 4 (\\mathrm {m o d} 7)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.131,
                0.788,
                0.147
            ],
            "angle": 0,
            "content": "因为 \\(-6 \\equiv 1 (\\bmod 7)\\) 且 \\(-8 \\equiv 6 (\\bmod 7)\\)，所以如果 \\(x\\) 是解，则有 \\(x \\equiv -8 \\equiv 6 (\\bmod 7)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.15,
                0.893,
                0.185
            ],
            "angle": 0,
            "content": "我们需要判断是否每个满足 \\(x \\equiv 6(\\bmod 7)\\) 的都是解。假定 \\(x \\equiv 6(\\bmod 7)\\) 。则由4.1节定理5，可得"
        },
        {
            "type": "equation",
            "bbox": [
                0.335,
                0.188,
                0.599,
                0.203
            ],
            "angle": 0,
            "content": "\\[\n3 x \\equiv 3 \\cdot 6 = 1 8 \\equiv 4 (\\mathrm {m o d} 7)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.206,
                0.893,
                0.242
            ],
            "angle": 0,
            "content": "这表明所有这样的 \\(x\\) 都满足同余方程。从而得出结论同余方程的解是使得 \\(x \\equiv 6 (\\bmod 7)\\) 的整数 \\(x\\)，即6，13，20，…以及-1，-8，-15，…。"
        },
        {
            "type": "title",
            "bbox": [
                0.047,
                0.253,
                0.264,
                0.27
            ],
            "angle": 0,
            "content": "4.4.3 中国剩余定理"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.273,
                0.893,
                0.327
            ],
            "angle": 0,
            "content": "线性同余方程组十分常见。例如，稍后会看到这是一种用来做大整数算术的基础。甚至可以在古代中国和印度数学家的著作中找到以文字游戏体现出来的这种方程组，如例4所给出的。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.333,
                0.89,
                0.37
            ],
            "angle": 0,
            "content": "例4 在公元1世纪，中国数学家孙子问道：“有物不知其数，三分之余二，五分之余三，七分之余二，此物几何？”"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.373,
                0.635,
                0.39
            ],
            "angle": 0,
            "content": "这个谜题可以翻译成下面的问题：下列同余方程组的解什么？"
        },
        {
            "type": "equation",
            "bbox": [
                0.4,
                0.393,
                0.531,
                0.446
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} x \\equiv 2 (\\mathrm {m o d} 3) \\\\ x \\equiv 3 (\\mathrm {m o d} 5) \\\\ x \\equiv 2 (\\mathrm {m o d} 7) \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.45,
                0.529,
                0.466
            ],
            "angle": 0,
            "content": "我们将在稍后求解这一方程组，同时也回答孙子谜题。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.469,
                0.89,
                0.504
            ],
            "angle": 0,
            "content": "中国剩余定理，因涉及线性同余方程组的中国古典问题而得名，当线性同余方程组的模数两两互素时，存在以所有模数之乘积为模的唯一解。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.512,
                0.881,
                0.549
            ],
            "angle": 0,
            "content": "定理2 中国剩余定理。令 \\(m_{1}, m_{2}, \\cdots, m_{n}\\) 为大于1的两两互素的正整数，而 \\(a_{1}, a_{2}, \\cdots, a_{n}\\) 是任意整数。则同余方程组"
        },
        {
            "type": "equation",
            "bbox": [
                0.39,
                0.553,
                0.543,
                0.628
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} x \\equiv a _ {1} (\\mathrm {m o d} m _ {1}) \\\\ x \\equiv a _ {2} (\\mathrm {m o d} m _ {2}) \\\\ \\vdots \\\\ x \\equiv a _ {n} (\\mathrm {m o d} m _ {n}) \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.631,
                0.88,
                0.667
            ],
            "angle": 0,
            "content": "有唯一的模 \\(m = m_{1}m_{2}\\dots m_{n}\\) 的解。（即，存在一个满足 \\(0\\leqslant x\\leqslant m\\) 的解 \\(\\mathcal{X}\\) ，而所有其他的解均与此解模 \\(m\\) 同余。）"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.677,
                0.89,
                0.712
            ],
            "angle": 0,
            "content": "证明 要建立这一定理，需要证明有一个解存在。而且在模 \\(m\\) 下唯一。我们描述一个构造这个解的方法以证明解的存在。而对该解模 \\(m\\) 唯一的证明留作练习30。"
        },
        {
            "type": "text",
            "bbox": [
                0.083,
                0.715,
                0.438,
                0.731
            ],
            "angle": 0,
            "content": "要构造一个满足所有方程的解，首先令"
        },
        {
            "type": "equation",
            "bbox": [
                0.411,
                0.734,
                0.521,
                0.749
            ],
            "angle": 0,
            "content": "\\[\nM _ {k} = m / m _ {k}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.752,
                0.89,
                0.787
            ],
            "angle": 0,
            "content": "\\(k = 1\\) ，2，…， \\(n\\) 。即 \\(M_{k}\\) 是除 \\(m_{k}\\) 以外所有模数的乘积。因为当 \\(i\\neq k\\) 时 \\(m_{i}\\) 和 \\(m_{k}\\) 没有大于1的公因子，可得 \\(\\gcd (m_k,M_k) = 1\\) 。因此，由定理1可知存在整数 \\(y_{k}\\) ，即 \\(M_{k}\\) 模 \\(m_{k}\\) 的逆，使得"
        },
        {
            "type": "equation",
            "bbox": [
                0.378,
                0.79,
                0.554,
                0.806
            ],
            "angle": 0,
            "content": "\\[\nM _ {k} y _ {k} \\equiv 1 (\\mathrm {m o d} m _ {k})\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.809,
                0.377,
                0.824
            ],
            "angle": 0,
            "content": "要构造一个满足所有方程的解，取和"
        },
        {
            "type": "equation",
            "bbox": [
                0.298,
                0.828,
                0.634,
                0.844
            ],
            "angle": 0,
            "content": "\\[\nx = a _ {1} M _ {1} y _ {1} + a _ {2} M _ {2} y _ {2} + \\dots + a _ {n} M _ {n} y _ {n}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.846,
                0.89,
                0.881
            ],
            "angle": 0,
            "content": "现在要证明 \\(x\\) 是方程组的解。首先，注意到因为当 \\(j \\neq k\\) 时有 \\(M_{j} \\equiv 0 (\\bmod m_{k})\\) ，在 \\(x\\) 的求和式中除第 \\(k\\) 项以外的各项模 \\(m_{k}\\) 均同余于 0 。由于 \\(M_{k}y_{k} \\equiv 1 (\\bmod m_{k})\\) ，可看出"
        },
        {
            "type": "equation",
            "bbox": [
                0.343,
                0.884,
                0.588,
                0.9
            ],
            "angle": 0,
            "content": "\\[\nx \\equiv a _ {k} M _ {k} y _ {k} \\equiv a _ {k} (\\mathrm {m o d} m _ {k})\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.903,
                0.591,
                0.918
            ],
            "angle": 0,
            "content": "\\(k = 1\\) ，2，…， \\(n\\) 。这就证明了 \\(x\\) 同时是这 \\(n\\) 个同余方程的解。"
        },
        {
            "type": "text",
            "bbox": [
                0.083,
                0.921,
                0.89,
                0.937
            ],
            "angle": 0,
            "content": "例5解释了怎样用中国剩余定理的证明中给出的构造法来求解同余方程组。并求解由孙子"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.145,
                0.038,
                0.179,
                0.051
            ],
            "angle": 0,
            "content": "248"
        },
        {
            "type": "header",
            "bbox": [
                0.227,
                0.037,
                0.291,
                0.052
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.093,
                0.377,
                0.109
            ],
            "angle": 0,
            "content": "谜题引出的例4中的方程组。"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.115,
                0.965,
                0.191
            ],
            "angle": 0,
            "content": "例5 要求解例4中的同余方程组，首先令 \\(m = 3 \\cdot 5 \\cdot 7 = 105\\) ，\\(M_1 = m / 3 = 35\\) ，\\(M_2 = m / 5 = 21\\) ，\\(M_3 = m / 7 = 15\\) 。可以看出2是 \\(M_1 = 35\\) 模3的逆，因为 \\(35 \\cdot 2 \\equiv 2 \\cdot 2 \\equiv 1 (\\bmod 3)\\) ；1是 \\(M_2 = 21\\) 模5的逆，因为 \\(21 \\equiv 1 (\\bmod 5)\\) ；1也是 \\(M_3 = 15\\) 的模7逆，因为 \\(15 \\equiv 1 (\\bmod 7)\\) 。该方程组的解是那些满足下列式子的 \\(x\\) ："
        },
        {
            "type": "equation",
            "bbox": [
                0.242,
                0.195,
                0.843,
                0.228
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} x \\equiv a _ {1} M _ {1} y _ {1} + a _ {2} M _ {2} y _ {2} + a _ {3} M _ {3} y _ {3} = 2 \\cdot 3 5 \\cdot 2 + 3 \\cdot 2 1 \\cdot 1 + 2 \\cdot 1 5 \\cdot 1 \\\\ = 2 3 3 \\equiv 2 3 (\\mathrm {m o d} 1 0 5) \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.232,
                0.965,
                0.268
            ],
            "angle": 0,
            "content": "从而得出23是方程组的最小正整数解。我们的结论是23是最小的正整数满足除以3时余2，除以5时余3，除以7时余2。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.271,
                0.965,
                0.306
            ],
            "angle": 0,
            "content": "尽管定理2的构造法提供了一个通用方法来求解模数两两互素的同余方程组，但还可以用不同的方法更容易地求解方程组。例6解释了利用一种称为是反向替换的方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.312,
                0.965,
                0.349
            ],
            "angle": 0,
            "content": "例6 利用反向替换方法找出所有整数 \\(x\\) 使得 \\(x \\equiv 1 (\\bmod 5)\\), \\(x \\equiv 2 (\\bmod 6)\\), 和 \\(x \\equiv 3 (\\bmod 7)\\) 成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.353,
                0.965,
                0.388
            ],
            "angle": 0,
            "content": "解 由4.1节定理4可知，第一个同余方程可以重写为一个等式 \\(x = 5t + 1\\) ，这里 \\(t\\) 是一个整数。用这个表达式替换第二个同余方程中的 \\(x\\) ，可得"
        },
        {
            "type": "equation",
            "bbox": [
                0.459,
                0.391,
                0.629,
                0.406
            ],
            "angle": 0,
            "content": "\\[\n5 t + 1 \\equiv 2 (\\mathrm {m o d} 6)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.41,
                0.968,
                0.464
            ],
            "angle": 0,
            "content": "这容易解得 \\(t \\equiv 5(\\bmod 6)\\) （读者应该能验证）。再次应用4.1节定理4，可得 \\(t = 6u + 5\\) ，这里 \\(u\\) 是一个整数。用这个表达式反向替换等式 \\(x = 5t + 1\\) 中的 \\(t\\) 可得 \\(x = 5(6u + 5) + 1 = 30u + 26\\) 。再用这个替换第三个同余方程，得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.449,
                0.468,
                0.641,
                0.482
            ],
            "angle": 0,
            "content": "\\[\n3 0 u + 2 6 \\equiv 3 (\\mathrm {m o d} 7)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.486,
                0.969,
                0.54
            ],
            "angle": 0,
            "content": "解该同余方程可得 \\(u \\equiv 6(\\bmod 7)\\) （读者应该能验证）。故，4.1节定理4告诉我们 \\(u = 7v + 6\\) ，这里 \\(v\\) 是一个整数。用这个表达式替换等式 \\(x = 30u + 26\\) 中的 \\(u\\) 可得 \\(x = 30(7v + 6) + 26 = 210u + 206\\) 。将这个翻译成一个同余式，就找到了同余方程组的解，"
        },
        {
            "type": "equation",
            "bbox": [
                0.463,
                0.544,
                0.631,
                0.558
            ],
            "angle": 0,
            "content": "\\[\nx \\equiv 2 0 6 (\\mathrm {m o d} 2 1 0)\n\\]"
        },
        {
            "type": "title",
            "bbox": [
                0.123,
                0.57,
                0.409,
                0.587
            ],
            "angle": 0,
            "content": "4.4.4 大整数的计算机算术"
        },
        {
            "type": "text",
            "bbox": [
                0.124,
                0.59,
                0.971,
                0.645
            ],
            "angle": 0,
            "content": "假定 \\(m_{1}, m_{2}, \\cdots, m_{n}\\) 是两两互素的模数，并令 \\(m\\) 为其乘积。根据中国剩余定理可以证明（见练习28）满足 \\(0 \\leqslant a < m\\) 的整数 \\(a\\) 可唯一地表示为一个 \\(n\\) 元组，其元素由 \\(a\\) 除以 \\(m_{i}\\) 的余数组成，\\(i = 1, 2, \\cdots, n\\)。即，\\(a\\) 可以唯一地表示为"
        },
        {
            "type": "equation",
            "bbox": [
                0.389,
                0.649,
                0.71,
                0.664
            ],
            "angle": 0,
            "content": "\\[\n(a \\mod m _ {1}, a \\mod m _ {2}, \\dots , a \\mod m _ {n})\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.669,
                0.971,
                0.708
            ],
            "angle": 0,
            "content": "例7当整数用序偶（第一分量是该整数除以3的余数，第二分量是该整数除以4的余数）来表示时，表示小于12的非负整数的序偶是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.168,
                0.711,
                0.755,
                0.727
            ],
            "angle": 0,
            "content": "解通过找出每个整数除以3和除以4的余数，得到下列表示式："
        },
        {
            "type": "equation",
            "bbox": [
                0.387,
                0.731,
                0.713,
                0.801
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} 0 = (0, 0) \\quad 4 = (1, 0) \\quad 8 = (2, 0) \\\\ 1 = (1, 1) \\quad 5 = (2, 1) \\quad 9 = (0, 1) \\\\ 2 = (2, 2) \\quad 6 = (0, 2) \\quad 1 0 = (1, 2) \\\\ 3 = (0, 3) \\quad 7 = (1, 3) \\quad 1 1 = (2, 3) \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.806,
                0.973,
                0.841
            ],
            "angle": 0,
            "content": "要对大整数做算术运算，我们选择模数 \\(m_{1}\\)，\\(m_{2}\\)，…，\\(m_{n}\\)，其中每个 \\(m_{i}\\) 都是大于2的整数，当 \\(i \\neq j\\) 时 \\(\\gcd(m_{i}, m_{j}) = 1\\)，且 \\(m = m_{1}m_{2}\\dots m_{n}\\) 是大于我们要执行算术运算的结果。"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.844,
                0.974,
                0.936
            ],
            "angle": 0,
            "content": "一旦选定模数，大整数算术运算就可以通过在表示这些整数的 \\(n\\) 元组分量（大整数除以 \\(m_{i}\\) 的余数，\\(i = 1,2,\\dots ,n)\\) 上做运算来完成。一旦计算出结果的每个分量值，就可以通过求解 \\(n\\) 个模 \\(m_{i}\\) 同余方程 \\((i = 1,2,\\dots ,n)\\) 来恢复结果的值。大整数算术的这种方法有几个优点。首先，可以用来完成通常在一台计算机上不能做的大整数算术。其次，对不同模数的计算可以并行操作，加快计算速度。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.659,
                0.04,
                0.792,
                0.056
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.837,
                0.041,
                0.874,
                0.055
            ],
            "angle": 0,
            "content": "249"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.099,
                0.905,
                0.176
            ],
            "angle": 0,
            "content": "例8 假定在某台处理器上做小于100的整数算术运算比做大整数算术快得多。如果我们把整数表示为除以100以内两两互素的模的余数，就几乎可以将所有计算限制在100以内的整数上。例如，可以用99，98，97和95作为模数。（这些整数是两两互素的，因为没有大于1的公因子。）"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.178,
                0.906,
                0.252
            ],
            "angle": 0,
            "content": "根据中国剩余定理，每个小于 \\(99 \\cdot 98 \\cdot 97 \\cdot 95 = 89403930\\) 的非负整数均可唯一地用该整数除以这四个模数的余数表示。例如，把123684表示为（33，8，9，89），因为123684 mod \\(99 = 33\\) ，123684 mod \\(98 = 8\\) ，123684 mod \\(97 = 9\\) 及123684 mod \\(95 = 89\\) 。类似地，413456可表示为（32，92，42，16）。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.255,
                0.905,
                0.291
            ],
            "angle": 0,
            "content": "欲求123684和413456的和，我们针对这些四元组而非直接针对这两个整数做运算。我们把四元组的对应分量相加，再按相应的模数压缩各分量。这样可得"
        },
        {
            "type": "equation",
            "bbox": [
                0.259,
                0.295,
                0.705,
                0.345
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} (3 3, 8, 9, 8 9) + (3 2, 9 2, 4 2, \\dot {1} 6) \\\\ = (6 5 \\mod 9 9, 1 0 0 \\mod 9 8, 5 1 \\mod 9 7, 1 0 5 \\mod 9 5) \\\\ = (6 5, 2, 5 1, 1 0) \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.35,
                0.707,
                0.366
            ],
            "angle": 0,
            "content": "要找出和，即（65，2，51，10)所表示的整数，需要求解同余方程组"
        },
        {
            "type": "equation",
            "bbox": [
                0.409,
                0.372,
                0.554,
                0.441
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} x \\equiv 6 5 (\\mathrm {m o d} 9 9) \\\\ x \\equiv 2 (\\mathrm {m o d} 9 8) \\\\ x \\equiv 5 1 (\\mathrm {m o d} 9 7) \\\\ x \\equiv 1 0 (\\mathrm {m o d} 9 5) \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.445,
                0.907,
                0.5
            ],
            "angle": 0,
            "content": "可以证明(参见练习53)537140是方程组唯一小于89403930的非负解。因此，537140是所求的和。注意只有当我们需要恢复(65，2，51，10)所表示的整数时，才必须做大于100的整数算术运算。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.502,
                0.909,
                0.653
            ],
            "angle": 0,
            "content": "对于一组形为 \\(2^{k} - 1\\) 的整数，其中 \\(k\\) 为正整数，做大整数模算术运算是最好的选择，因为这种整数的二进制模算术很容易完成，而且也容易找到两两互素的这样一组整数。[第二个理由是基于4.3节练习37证明的 \\(\\gcd (2^a -1,2^b -1) = 2^{\\gcd (a,b)} - 1\\) 这一事实。]例如，假定在计算机上很容易完成 \\(2^{35}\\) 以内的整数算术，但更大整数的运算则要求有专门的运算过程。我们可以使用小于 \\(2^{35}\\) 两两互素的模数来对大到模数乘积的整数做算术运算。例如，就像4.3节练习38所证明的，整数 \\(2^{35} - 1\\) ， \\(2^{34} - 1\\) ， \\(2^{33} - 1\\) ， \\(2^{31} - 1\\) ， \\(2^{29} - 1\\) 和 \\(2^{23} - 1\\) 是两两互素的。因为这6个模数的乘积超过 \\(2^{184}\\) ，我们可以通过用这6个不超过 \\(2^{35}\\) 的模数做模算术运算来完成大到 \\(2^{184}\\) 的整数算术运算（只要运算结果也不超过这个数）。"
        },
        {
            "type": "title",
            "bbox": [
                0.064,
                0.663,
                0.257,
                0.68
            ],
            "angle": 0,
            "content": "4.4.5 费马小定理"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.682,
                0.91,
                0.795
            ],
            "angle": 0,
            "content": "法国大数学家皮埃尔·德·费马是17世纪上半叶最重要的数学家之一，在数论领域做出了许多重要发现。其中一个非常有用的表现阐述当 \\(p\\) 是素数而 \\(a\\) 是一个不能被 \\(p\\) 整除的整数时 \\(p\\) 整除 \\(a^{p-1}-1\\)。费马在给他的一个通信者的信中公布了这个结果。可是，他在信中并没有加入证明，说是担心证明会太长。尽管费马从来没有发表过这个事实的证明，但没有人怀疑他知道如何证明之，而不像对待费马大定理的证明那样。第一个公开发表的证明归功于莱昂哈德·欧拉。我们用同余式来叙述这个定理。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.804,
                0.764,
                0.82
            ],
            "angle": 0,
            "content": "定理3 费马小定理。如果 \\(p\\) 为素数，\\(a\\) 是一个不能被 \\(p\\) 整除的整数，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.408,
                0.825,
                0.558,
                0.839
            ],
            "angle": 0,
            "content": "\\[\na ^ {p - 1} \\equiv 1 (\\mathrm {m o d} p)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.843,
                0.3,
                0.858
            ],
            "angle": 0,
            "content": "再者，对每个整数 \\(a\\) 都有"
        },
        {
            "type": "equation",
            "bbox": [
                0.423,
                0.864,
                0.548,
                0.877
            ],
            "angle": 0,
            "content": "\\[\na ^ {p} \\equiv a (\\mathrm {m o d} p)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.887,
                0.672,
                0.904
            ],
            "angle": 0,
            "content": "评注 费马小定理告诉我们如果 \\(a \\in \\mathbf{Z}_p\\)，则 \\(a^{p-1} = 1\\) 也在 \\(\\mathbf{Z}_p\\) 中。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.906,
                0.388,
                0.922
            ],
            "angle": 0,
            "content": "定理5的证明要点参见练习19。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.925,
                0.714,
                0.942
            ],
            "angle": 0,
            "content": "费马小定理在计算整数高次幂的模 \\(p\\) 余数时非常有用，如例9所示。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.136,
                0.038,
                0.172,
                0.052
            ],
            "angle": 0,
            "content": "250"
        },
        {
            "type": "header",
            "bbox": [
                0.218,
                0.037,
                0.284,
                0.052
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.096,
                0.352,
                0.113
            ],
            "angle": 0,
            "content": "例9 计算 \\(7^{222} \\mod 11\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.118,
                0.955,
                0.172
            ],
            "angle": 0,
            "content": "解 我们利用费马小定理来计算 \\(7^{222} \\bmod 11\\) 而不采用快速模指数算法。由费马小定理可知 \\(7^{10} \\equiv 1 \\pmod{11}\\)，所以对每个正整数 \\(k\\) 有 \\((7^{10})^k \\equiv 1 \\pmod{11}\\)。为了利用这最后一个同余式，我们将指数 222 除以 10，得 \\(222 = 22 \\cdot 10 + 2\\)。可以看出"
        },
        {
            "type": "equation",
            "bbox": [
                0.297,
                0.175,
                0.763,
                0.191
            ],
            "angle": 0,
            "content": "\\[\n7 ^ {2 2 2} = 7 ^ {2 2 \\cdot 1 0 + 2} = (7 ^ {1 0}) ^ {2 2} 7 ^ {2} \\equiv (1) ^ {2 2} \\cdot 4 9 \\equiv 5 (\\mathrm {m o d} 1 1)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.194,
                0.309,
                0.21
            ],
            "angle": 0,
            "content": "从而得 \\(7^{222} \\mod 11 = 5\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.213,
                0.955,
                0.287
            ],
            "angle": 0,
            "content": "例9解释了如何利用费马小定理来计算 \\(a^n\\bmod p\\) ，其中 \\(p\\) 是素数且 \\(p\\nmid a\\) 。首先，当 \\(n\\) 除以\\(p - 1\\) 时，我们利用除法算法找出商 \\(q\\) 和余数 \\(r\\) ，使得 \\(n = q(p - 1) + r\\) 其中 \\(0\\leqslant r <   p - 1\\) 。随即可得 \\(a^n = a^{q(p - 1) + r} = (a^{p - 1})^q a^r\\equiv 1^q a^r\\equiv a^r (\\bmod p)\\) 。故，为了计算 \\(a^n\\bmod p\\) ，我们只需计算 \\(a^r\\bmod p\\) 。在数论学习中我们会多次利用这种化简带来的好处。"
        },
        {
            "type": "title",
            "bbox": [
                0.105,
                0.297,
                0.257,
                0.314
            ],
            "angle": 0,
            "content": "4.4.6 伪素数"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.32,
                0.953,
                0.378
            ],
            "angle": 0,
            "content": "在4.25节证明了一个整数 \\(n\\) 是素数当它不能被任何 \\(p \\leqslant \\sqrt{n}\\) 的素数 \\(p\\) 整除。遗憾的是，用这一标准来证明给定的整数为素数效率不高。它要求找出所有不超过 \\(\\sqrt{n}\\) 的素数，还要用这些素数通过试除法来看是否能整除 \\(n\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.38,
                0.951,
                0.416
            ],
            "angle": 0,
            "content": "有没有效率较高的方法能判断一个整数是否为素数呢？根据一些消息来源，古代中国数学家相信 \\( n \\) 为奇素数当且仅当"
        },
        {
            "type": "equation",
            "bbox": [
                0.452,
                0.418,
                0.603,
                0.434
            ],
            "angle": 0,
            "content": "\\[\n2 ^ {n - 1} \\equiv 1 (\\mathrm {m o d} n)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.437,
                0.953,
                0.491
            ],
            "angle": 0,
            "content": "如果这一结论成立，就可以提供一个有效的素数测试方法。为什么他们相信这一同余式能用来判断大于2的整数 \\(n\\) 是否为素数呢？首先，他们观察到当 \\(n\\) 为奇素数时该同余式成立。例如，5是素数，而且"
        },
        {
            "type": "equation",
            "bbox": [
                0.402,
                0.494,
                0.655,
                0.51
            ],
            "angle": 0,
            "content": "\\[\n2 ^ {5 - 1} = 2 ^ {4} = 1 6 \\equiv 1 (\\mathrm {m o d} 5)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.513,
                0.953,
                0.567
            ],
            "angle": 0,
            "content": "由费马小定理可知这一观察是正确的，即当 \\(n\\) 是奇素数时有 \\(2^{n - 1} \\equiv 1 (\\mathrm{mod} n)\\) 。其次，他们从未找到能使这个同余式成立的合数。可是，古代中国数学家并非全对。他们所认为的只要 \\(n\\) 是素数则该同余式成立是对的，但他们所得出的结论如果同余式成立则 \\(n\\) 就是素数是不正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.569,
                0.879,
                0.587
            ],
            "angle": 0,
            "content": "不幸的是，存在合数 \\(n\\) 使得 \\(2^{n - 1} \\equiv 1 (\\bmod n)\\) 。这种整数称为以2为基数的伪素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.591,
                0.953,
                0.629
            ],
            "angle": 0,
            "content": "例10 整数341是以2为基数的伪素数，因为它是合数 \\((341 = 11 \\cdot 31)\\)，而且练习37中证明了"
        },
        {
            "type": "equation",
            "bbox": [
                0.443,
                0.632,
                0.612,
                0.648
            ],
            "angle": 0,
            "content": "\\[\n2 ^ {3 4 0} \\equiv 1 (\\mathrm {m o d} 3 4 1)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.651,
                0.571,
                0.667
            ],
            "angle": 0,
            "content": "研究伪素数时还可以使用大于2的整数为基数。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.676,
                0.943,
                0.713
            ],
            "angle": 0,
            "content": "定义1 令 \\(b\\) 是一个正整数。如果 \\(n\\) 是一个正合数且 \\(b^{n-1} \\equiv 1 (\\mod n)\\)，则 \\(n\\) 称为以 \\(b\\) 为基数的伪素数。"
        },
        {
            "type": "title",
            "bbox": [
                0.106,
                0.728,
                0.153,
                0.743
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.107,
                0.762,
                0.247,
                0.864
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.106,
                0.867,
                0.221,
                0.887
            ],
            "angle": 0,
            "content": "@PHOTOS.com/Getty Images"
        },
        {
            "type": "text",
            "bbox": [
                0.263,
                0.761,
                0.954,
                0.9
            ],
            "angle": 0,
            "content": "皮埃尔·德·费马(Pierre de Fermat, 1601-1665) 费马是17世纪最重要的数学家之一，是一位职业律师。他是历史上最著名的业余数学家。费马的数学发现很少发表。我们从他与其他数学家的通信中了解他的工作。费马是解析几何的发明者之一，并且建立了微积分的一些基本概念。费马和帕斯卡一起为概率论建立了数学基础。费马提出了现在最有名的悬而未决的数学问题。他断定当 \\(n\\) 为大于2的整数时，方程 \\(x^{n} + y^{n} = z^{n}\\) 没有非平凡的正整数解。300多年来人们都没有找到证明（或反例）。在他那本古希腊数学家丢番图(Diophantus)的著作中，费马写道他有一个证明但是页边空白写不下了。由于1994年安德鲁·怀尔斯(Andrew Wiles)所给出的第一"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.903,
                0.953,
                0.936
            ],
            "angle": 0,
            "content": "个证明依赖复杂的现代数学，所以多数人认为费马自以为有了一个证明，但那证明是不正确的。不过也许是因为自己不能给出证明，所以他以此诱惑别人去寻找证明。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.647,
                0.037,
                0.778,
                0.052
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.826,
                0.038,
                0.86,
                0.051
            ],
            "angle": 0,
            "content": "251"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.093,
                0.892,
                0.246
            ],
            "angle": 0,
            "content": "给定正整数 \\(n\\)，判断是否有 \\(2^{n-1} \\equiv 1 (\\bmod n)\\) 确实是一个有用的测试，它能够提供一些关于 \\(n\\) 是否为素数的证据。特别是，如果 \\(n\\) 满足这个同余式，则 \\(n\\) 要么是素数，要么是以 2 为基数的伪素数；如果 \\(n\\) 不满足这个同余式，则 \\(n\\) 是合数。可以用 2 以外的基数 \\(b\\) 进行类似的测试，以获得 \\(n\\) 是否为素数的更多证据。如果 \\(n\\) 通过所有这些测试，则 \\(n\\) 要么是素数，要么是以所有所选 \\(b\\) 为基数的伪素数。再者，在不超过 \\(x\\) 的正整数中，其中 \\(x\\) 是正实数，与素数相比，以 \\(b\\) 为基数的伪素数要少得多，其中 \\(b\\) 是正整数。例如，小于 \\(10^{10}\\) 的整数中有 455052512 个素数，但只有 14884 个以 2 为基数的伪素数。可惜的是，不能通过选择足够多的基数来区分素数与伪素数，因为有些正整数能通过满足 \\(\\gcd(b, n) = 1\\) 的基数的所有测试。这引出了定义 2。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.254,
                0.885,
                0.311
            ],
            "angle": 0,
            "content": "定义2 一个正合数 \\(n\\) 如果对于所有满足 \\(\\gcd(b, n) = 1\\) 的正整数 \\(b\\) 都有同余式 \\(b^{n-1} \\equiv 1 (\\mod n)\\) 成立，则称为卡米切尔数。（这些数以罗伯特·卡米切尔的名字命名，他在20世纪早期研究这些数。）"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.322,
                0.888,
                0.382
            ],
            "angle": 0,
            "content": "例11 整数561是卡米切尔数。为了说明这一点，首先注意561是合数，因为 \\(561 = 3 \\cdot 11 \\cdot 17\\) 。其次，注意到如果 \\(\\gcd(b, 561) = 1\\) ，则 \\(\\gcd(b, 3) = \\gcd(b, 11) = \\gcd(b, 17) = 1\\) 。利用费马小定理可得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.217,
                0.385,
                0.707,
                0.4
            ],
            "angle": 0,
            "content": "\\[\nb ^ {2} \\equiv 1 (\\mathrm {m o d} 3), \\quad b ^ {1 0} \\equiv 1 (\\mathrm {m o d} 1 1), \\quad b ^ {1 6} \\equiv 1 (\\mathrm {m o d} 1 7)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.405,
                0.104,
                0.42
            ],
            "angle": 0,
            "content": "从而有"
        },
        {
            "type": "equation",
            "bbox": [
                0.343,
                0.425,
                0.581,
                0.476
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} b ^ {5 6 0} = \\left(b ^ {2}\\right) ^ {2 8 0} \\equiv 1 (\\mathrm {m o d} 3) \\\\ b ^ {5 6 0} = \\left(b ^ {1 0}\\right) ^ {5 6} \\equiv 1 (\\mathrm {m o d} 1 1) \\\\ b ^ {5 6 0} = \\left(b ^ {1 6}\\right) ^ {3 5} \\equiv 1 (\\mathrm {m o d} 1 7) \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.482,
                0.887,
                0.518
            ],
            "angle": 0,
            "content": "根据练习29可得，对于所有满足 \\(\\gcd (b,561) = 1\\) 的正整数 \\(b\\) 都有 \\(b^{560}\\equiv 1(\\mathrm{mod} 561)\\) 。因此，561是卡米切尔数。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.521,
                0.888,
                0.616
            ],
            "angle": 0,
            "content": "尽管存在无限多个卡米切尔数，但可以设计更精细的测试，如练习中所描述的，作为有效的随机素数性测试的基础。这种测试可用来迅速证明一个给定的整数几乎肯定是素数。更准确地说，如果一个整数不是素数，则这个整数通过一系列测试的概率接近于0。第7章将描述这样一个测试，并讨论这个测试所依赖的一些概率论中的概念。这些随机的素数性测试能够而且已经用于在计算机上非常迅速地寻找大素数。"
        },
        {
            "type": "title",
            "bbox": [
                0.041,
                0.626,
                0.279,
                0.643
            ],
            "angle": 0,
            "content": "4.4.7 原根和离散对数"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.647,
                0.887,
                0.683
            ],
            "angle": 0,
            "content": "在正实数集合中，如果 \\(b > 1\\) 且 \\(x = b^{y}\\)，我们说 \\(y\\) 是以 \\(b\\) 为底 \\(x\\) 的对数。这里，我们要说明也能定义模 \\(p\\) 的对数概念，这里 \\(p\\) 是一个素数。在这之前，我们需要一个定义。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.691,
                0.878,
                0.729
            ],
            "angle": 0,
            "content": "定义3 模素数 \\(p\\) 的一个原根是 \\(\\mathbf{Z}_p\\) 中的整数 \\(r\\)，使得 \\(\\mathbf{Z}_p\\) 中的每个非零元素都是 \\(r\\) 的一个幂次。"
        },
        {
            "type": "text",
            "bbox": [
                0.079,
                0.741,
                0.432,
                0.759
            ],
            "angle": 0,
            "content": "例12 判定2和3是否是模11的原根。"
        },
        {
            "type": "text",
            "bbox": [
                0.04,
                0.772,
                0.085,
                0.786
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.042,
                0.804,
                0.177,
                0.911
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.042,
                0.916,
                0.156,
                0.936
            ],
            "angle": 0,
            "content": "The Mathematical Association of America"
        },
        {
            "type": "text",
            "bbox": [
                0.198,
                0.804,
                0.888,
                0.908
            ],
            "angle": 0,
            "content": "罗伯特·丹尼尔·卡米切尔（Robert Daniel Carmichael，1879—1967）卡米切尔出生在亚拉巴马州。1898年他获得Lineville学院的学士学位，1911年获得普林斯顿大学的博士学位。1911～1915年卡米切尔在印第安纳大学任职，\\(1915\\sim 1947\\) 年在伊利诺伊大学任职。卡米切尔是一位活跃的研究者，研究领域广泛，包括数论、实分析、微分方程、数学物理以及群论。他的博士论文是在G.D.伯克霍夫的指导下完成的，被认为是美国人对微分方程的专题所做出的第一份显著贡献。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.143,
                0.038,
                0.178,
                0.052
            ],
            "angle": 0,
            "content": "252"
        },
        {
            "type": "header",
            "bbox": [
                0.225,
                0.037,
                0.29,
                0.052
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.094,
                0.963,
                0.149
            ],
            "angle": 0,
            "content": "解 当我们在 \\(\\mathbf{Z}_{11}\\) 中计算2的幂次时，可得 \\(2^{1} = 2\\) ， \\(2^{2} = 4\\) ， \\(2^{3} = 8\\) ， \\(2^{4} = 5\\) ， \\(2^{5} = 10\\) ， \\(2^{6} = 9\\) ， \\(2^{7} = 7\\) ， \\(2^{8} = 3\\) ， \\(2^{9} = 6\\) ， \\(2^{10} = 1\\) 。因为 \\(\\mathbf{Z}_{11}\\) 中的每个非零元素都是2的一个幂次，所以2是11的原根。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.152,
                0.964,
                0.207
            ],
            "angle": 0,
            "content": "当我们在 \\(\\mathbf{Z}_{11}\\) 中计算3的幂次时，可得 \\(3^{1} = 3\\) ， \\(3^{2} = 9\\) ， \\(3^{3} = 5\\) ， \\(3^{4} = 4\\) ， \\(3^{5} = 1\\) 。我们注意到当计算3的更高幂次时这个模式会重复。因为 \\(\\mathbf{Z}_{11}\\) 中不是所有非零元素都是3的一个幂次，所以可得结论3不是11的原根。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.21,
                0.964,
                0.266
            ],
            "angle": 0,
            "content": "数论中一个重要的事实是对于每个素数 \\(p\\) 都存在一个模 \\(p\\) 的原根。该事实的证明读者可以参考[Ro10]。假设 \\(p\\) 是一个素数而 \\(r\\) 是一个模 \\(p\\) 的原根。如果 \\(a\\) 是介于1和 \\(p - 1\\) 之间的一个整数，即 \\(\\mathbf{Z}_p\\) 中的元素，我们知道存在唯一的指数 \\(e\\) 使得 \\(r^e = a\\) 在 \\(\\mathbf{Z}_p\\) 中，即 \\(r^e \\bmod p = a\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.273,
                0.958,
                0.33
            ],
            "angle": 0,
            "content": "定义4假设 \\(p\\) 是一个素数， \\(r\\) 是一个模 \\(p\\) 的原根，而 \\(a\\) 是介于(含)1和 \\(p - 1\\) 之间的一个整数。如果 \\(r^e \\mod p = a\\) 且 \\(0 \\leqslant e \\leqslant p - 1\\) ，我们说 \\(e\\) 是以 \\(r\\) 为底 \\(a\\) 模 \\(p\\) 的离散对数，并写作 \\(\\log_a a = e\\) （这里隐含理解为有素数 \\(p\\) ）。"
        },
        {
            "type": "text",
            "bbox": [
                0.157,
                0.342,
                0.595,
                0.359
            ],
            "angle": 0,
            "content": "例13 试找出以2为底3和5模11的离散对数。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.364,
                0.968,
                0.42
            ],
            "angle": 0,
            "content": "解 在例12中计算模11的2幂次时，得到 \\( 2^{8} = 3 \\) 和 \\( 2^{4} = 5 \\) 都在 \\( Z_{11} \\) 中。故，以2为底3和5模11的离散对数分别是8和4。（这些是2的幂次，它们分别等于 \\( Z_{11} \\) 中的3和5。）我们写成 \\( \\log_23 = 8 \\) 和 \\( \\log_25 = 4 \\) （这里要理解有模数11，只是没有显式地在记号中注明）。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.423,
                0.969,
                0.478
            ],
            "angle": 0,
            "content": "离散对数问题的输入是一个素数 \\(p\\) 、一个模 \\(p\\) 的原根 \\(r\\) 和一个正整数 \\(a \\in \\mathbf{Z}_p\\) ，而输出是以 \\(r\\) 为底 \\(a\\) 模 \\(p\\) 的离散对数。尽管这个问题可能看起来不难，但实质上没有已知的多项式时间算法可以求解它。这个问题的难度在密码学中起着重要的作用，4.6节将会介绍。"
        },
        {
            "type": "title",
            "bbox": [
                0.12,
                0.488,
                0.166,
                0.504
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.508,
                0.341,
                0.523
            ],
            "angle": 0,
            "content": "1. 证明15是7模26的逆。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.526,
                0.377,
                0.54
            ],
            "angle": 0,
            "content": "2. 证明937是13模2436的逆。"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.544,
                0.563,
                0.559
            ],
            "angle": 0,
            "content": "3. 通过查看（就像例1前所讨论的），找出4模9的逆。"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.562,
                0.572,
                0.577
            ],
            "angle": 0,
            "content": "4. 通过查看（就像例1前所讨论的），找出2模17的逆。"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.58,
                0.605,
                0.595
            ],
            "angle": 0,
            "content": "5. 用例2中的方法对下列每对互素的整数找出 \\(a\\) 模 \\(m\\) 的逆。"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.599,
                0.264,
                0.612
            ],
            "angle": 0,
            "content": "a) \\( a = 4 \\)，\\( m = 9 \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.367,
                0.599,
                0.512,
                0.612
            ],
            "angle": 0,
            "content": "b) \\(a = 19\\) ， \\(m = 141\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.589,
                0.599,
                0.725,
                0.612
            ],
            "angle": 0,
            "content": "c) \\(a = 55\\) ， \\(m = 89\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.774,
                0.599,
                0.922,
                0.612
            ],
            "angle": 0,
            "content": "d) \\(a = 89\\) ， \\(m = 232\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.616,
                0.606,
                0.631
            ],
            "angle": 0,
            "content": "6. 用例2中的方法对下列每对互素的整数找出 \\(a\\) 模 \\(m\\) 的逆。"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.635,
                0.273,
                0.648
            ],
            "angle": 0,
            "content": "a) \\( a = 2 \\)，\\( m = 17 \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.367,
                0.635,
                0.504,
                0.648
            ],
            "angle": 0,
            "content": "b) \\(a = 34\\) ， \\(m = 89\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.589,
                0.635,
                0.743,
                0.648
            ],
            "angle": 0,
            "content": "c) \\(a = 144\\) ， \\(m = 233\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.775,
                0.635,
                0.938,
                0.648
            ],
            "angle": 0,
            "content": "d) \\(a = 200\\) ， \\(m = 1001\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.652,
                0.969,
                0.685
            ],
            "angle": 0,
            "content": "*7. 证明如果 \\(a\\) 和 \\(m\\) 是互素的正整数，则 \\(a\\) 模 \\(m\\) 的逆是模 \\(m\\) 唯一的。[提示：假定同余式 \\(ax \\equiv 1 (\\bmod m)\\) 有两个解 \\(b\\) 和 \\(c\\) 。再用定理7证明 \\(b \\equiv c (\\bmod m)\\) 。]"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.688,
                0.813,
                0.703
            ],
            "angle": 0,
            "content": "8. 证明如果 \\(\\gcd(a, m) > 1\\)，这里 \\(a\\) 是整数而 \\(m > 2\\) 是正整数，则 \\(a\\) 模 \\(m\\) 的逆不存在。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.706,
                0.655,
                0.721
            ],
            "angle": 0,
            "content": "9. 解同余方程 \\(4x \\equiv 5(\\mathrm{mod} 9)\\)，利用练习5a中找到的4模9的逆。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.724,
                0.682,
                0.739
            ],
            "angle": 0,
            "content": "10. 解同余方程 \\(2x \\equiv 7(\\mathrm{mod} 17)\\)，利用练习6a中找到的2模17的逆。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.742,
                0.61,
                0.757
            ],
            "angle": 0,
            "content": "11. 利用练习5b、c和d中找到的模的逆求解下列同余方程。"
        },
        {
            "type": "text",
            "bbox": [
                0.152,
                0.76,
                0.317,
                0.774
            ],
            "angle": 0,
            "content": "a) \\(19x\\equiv 4(\\mathrm{mod} 141)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.442,
                0.76,
                0.605,
                0.774
            ],
            "angle": 0,
            "content": "b) \\(55x\\equiv 34(\\mathrm{mod}89)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.665,
                0.76,
                0.826,
                0.774
            ],
            "angle": 0,
            "content": "c) \\(89x \\equiv 2 (\\mathrm{mod} 232)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.778,
                0.61,
                0.793
            ],
            "angle": 0,
            "content": "12. 利用练习6b、c和d中找到的模的逆求解下列同余方程。"
        },
        {
            "type": "text",
            "bbox": [
                0.152,
                0.796,
                0.317,
                0.81
            ],
            "angle": 0,
            "content": "a) \\(34x \\equiv 77 \\pmod{89}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.442,
                0.796,
                0.614,
                0.81
            ],
            "angle": 0,
            "content": "b) \\(144.x\\equiv 4(\\mathrm{mod}233)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.665,
                0.796,
                0.853,
                0.81
            ],
            "angle": 0,
            "content": "c) \\(200x \\equiv 13 \\pmod{1001}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.814,
                0.969,
                0.864
            ],
            "angle": 0,
            "content": "13. 找出同余方程 \\( 15x^{2} + 19x \\equiv 5 (\\mathrm{mod} 11) \\) 的解。[提示：证明该同余方程等价于同余方程 \\( 15x^{2} + 19x + 6 \\equiv 0 (\\mathrm{mod} 11) \\) 。对同余方程左边做因子分解，证明二次同余方程的解就是两个不同的线性同余方程之一的解。]"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.867,
                0.969,
                0.918
            ],
            "angle": 0,
            "content": "14. 找出同余方程 \\( 12x^{2} + 25x \\equiv 10 (\\mathrm{mod} 11) \\) 的解。[提示：证明该同余方程等价于同余方程 \\( 12x^{2} + 25x + 12 \\equiv 0 (\\mathrm{mod} 11) \\) 。对同余方程左边做因子分解，证明二次同余方程的解就是两个不同的线性同余方程之一的解。]"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.921,
                0.819,
                0.937
            ],
            "angle": 0,
            "content": "* 15. 证明如果 \\( m \\) 是大于 1 的正整数, 而 \\( ac \\equiv bc (\\mathrm{mod} m) \\), 则 \\( a \\equiv b (\\mathrm{mod} m / \\gcd(c, m)) \\)。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.657,
                0.038,
                0.788,
                0.053
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.836,
                0.039,
                0.871,
                0.052
            ],
            "angle": 0,
            "content": "253"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.094,
                0.884,
                0.109
            ],
            "angle": 0,
            "content": "16. a) 证明小于 11 的正整数（除 1 和 10 以外）可以分割成一对整数使得其中的两个整数互为模 11 的逆。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.113,
                0.425,
                0.127
            ],
            "angle": 0,
            "content": "b)用a中的结果证明 \\(10! \\equiv -1 (\\mathrm{mod} 11)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.13,
                0.865,
                0.145
            ],
            "angle": 0,
            "content": "17. 证明如果 \\( p \\) 为素数，则 \\( x^2 \\equiv 1 (\\bmod p) \\) 仅有的解是满足 \\( x \\equiv 1 (\\bmod p) \\) 或 \\( x \\equiv -1 (\\bmod p) \\) 的整数 \\( x \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.148,
                0.901,
                0.181
            ],
            "angle": 0,
            "content": "* 18. a) 推广练习 16a 的结果，即证明如果 \\( p \\) 为素数，则小于 \\( p \\) 的整数，除 1 和 \\( p - 1 \\) 以外，都可以分割成一对整数使得其中的两个整数互为模 \\( p \\) 的逆。[提示：利用练习 17 中的结果。]"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.184,
                0.902,
                0.216
            ],
            "angle": 0,
            "content": "b)从a可以断定，只要 \\(p\\) 是素数则有 \\((p - 1)! \\equiv -1 (\\mod p)\\) 。这一结果称为威尔逊定理（Wilson's theorem）。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.22,
                0.674,
                0.235
            ],
            "angle": 0,
            "content": "c)如果 \\(n\\) 为正整数使得 \\((n - 1)! \\not\\equiv -1 (\\mathrm{mod} n)\\)，我们可以得出什么结论？"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.238,
                0.395,
                0.253
            ],
            "angle": 0,
            "content": "* 19. 本题给出了费马小定理的证明的概要。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.256,
                0.901,
                0.307
            ],
            "angle": 0,
            "content": "a)假定 \\( a \\) 不能被素数 \\( p \\) 整除。证明整数 \\( 1 \\cdot a, 2 \\cdot a, \\dots, (p - 1)a \\) 中的任何两个都不是模 \\( p \\) 同余的。b)从 \\( a \\) 可以得出 \\( 1, 2, \\dots, (p - 1) \\) 的乘积和 \\( a, 2a, \\dots, (p - 1)a \\) 的乘积是模 \\( p \\) 同余的。利用这一结论证明"
        },
        {
            "type": "equation",
            "bbox": [
                0.359,
                0.31,
                0.63,
                0.326
            ],
            "angle": 0,
            "content": "\\[\n(p - 1)! \\equiv a ^ {p - 1} (p - 1)! (\\mathrm {m o d} p)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.328,
                0.903,
                0.361
            ],
            "angle": 0,
            "content": "c)利用4.3节定理7，再由b)可以证明如果 \\(p \\nmid a\\) ，则 \\(a^{p - 1} \\equiv 1(\\mathrm{mod} p)\\) 。[提示：利用4.3节引理3证明 \\(p\\) 不能整除 \\((p - 1)!\\) ，然后再利用4.3节定理7。或者也可以利用练习18b的威尔逊定理。]"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.364,
                0.476,
                0.379
            ],
            "angle": 0,
            "content": "d)利用c证明 \\(a^p\\equiv a(\\mathrm{mod} p)\\) 对所有整数 \\(a\\) 成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.382,
                0.903,
                0.414
            ],
            "angle": 0,
            "content": "20. 利用中国剩余定理证明中的构造法找出同余方程组 \\(x \\equiv 2(\\bmod 3)\\)，\\(x \\equiv 1(\\bmod 4)\\) 和 \\(x \\equiv 3(\\bmod 5)\\) 的所有解。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.418,
                0.903,
                0.45
            ],
            "angle": 0,
            "content": "21. 利用中国剩余定理证明中的构造法找出同余方程组 \\(x \\equiv 1(\\bmod 2)\\)，\\(x \\equiv 2(\\bmod 3)\\)，\\(x \\equiv 3(\\bmod 5)\\) 和 \\(x \\equiv 4(\\bmod 11)\\) 的所有解。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.454,
                0.598,
                0.468
            ],
            "angle": 0,
            "content": "22. 用反向替换方法求解同余方程组 \\(x \\equiv 3(\\bmod 6)\\) 和 \\(x \\equiv 4(\\bmod 7)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.472,
                0.444,
                0.486
            ],
            "angle": 0,
            "content": "23. 用反向替换方法求解练习20的同余方程组。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.49,
                0.444,
                0.504
            ],
            "angle": 0,
            "content": "24. 用反向替换方法求解练习21的同余方程组。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.508,
                0.714,
                0.522
            ],
            "angle": 0,
            "content": "25. 基于中国剩余定理证明中的构造法，写出求解线性同余方程组的伪代码算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.525,
                0.814,
                0.54
            ],
            "angle": 0,
            "content": "* 26. 找出同余方程组 \\( x \\equiv 5(\\mathrm{mod} 6) \\)，\\( x \\equiv 3(\\mathrm{mod} 10) \\) 和 \\( x \\equiv 8(\\mathrm{mod} 15) \\) 的所有解，如果有解的话。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.544,
                0.823,
                0.558
            ],
            "angle": 0,
            "content": "* 27. 找出同余方程组 \\( x \\equiv 7(\\mathrm{mod} 9) \\)，\\( x \\equiv 4(\\mathrm{mod} 12) \\) 和 \\( x \\equiv 16(\\mathrm{mod} 21) \\) 的所有解，如果有解的话。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.562,
                0.903,
                0.594
            ],
            "angle": 0,
            "content": "28. 利用中国剩余定理证明满足 \\(0 \\leqslant a < m = m_{1}m_{2}\\dots m_{n}\\) 的整数 \\(a\\)，其中正整数 \\(m_{1}, m_{2}, \\dots, m_{n}\\) 是两两互素，都能唯一地表示为 \\(n\\) 元组（\\(a \\bmod m_{1}\\)，\\(a \\bmod m_{2}\\)，\\(\\dots\\)，\\(a \\bmod m_{n}\\)）。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.598,
                0.903,
                0.648
            ],
            "angle": 0,
            "content": "* 29. 令 \\(m_{1}, m_{2}, \\cdots, m_{n}\\) 为大于等于 2 的整数且两两互素。证明如果 \\(a \\equiv b (\\bmod m_{i})\\) ，\\(i = 1, 2, \\cdots, n\\) 则 \\(a \\equiv b (\\bmod m)\\) ，其中 \\(m = m_{1}m_{2} \\cdots m_{n}\\) 。（这个结果可以用来证明练习 30 中的中国剩余定理。因此，不要用中国剩余定理证明之。）"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.652,
                0.903,
                0.706
            ],
            "angle": 0,
            "content": "* 30. 通过证明模两两互素的线性同余方程组的解相对于模数乘积为模时是唯一的来完成中国剩余定理的证明。[提示：假定 \\(x\\) 和 \\(y\\) 是方程组的两个解。证明对所有 \\(i\\)，\\(m_i \\mid x - y\\)。再利用练习29得出 \\(m = m_1 m_2 \\dots m_n \\mid x - y\\)。]"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.709,
                0.429,
                0.724
            ],
            "angle": 0,
            "content": "31. 哪些整数被2除时余1，被3除时也余1？"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.727,
                0.378,
                0.742
            ],
            "angle": 0,
            "content": "32. 哪些整数被5整除而被3除时余1？"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.745,
                0.364,
                0.76
            ],
            "angle": 0,
            "content": "33. 利用费马小定理找出 \\(7^{121} \\mod 13\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.763,
                0.378,
                0.778
            ],
            "angle": 0,
            "content": "34. 利用费马小定理找出 \\(23^{1002} \\mod 41\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.781,
                0.628,
                0.796
            ],
            "angle": 0,
            "content": "35. 利用费马小定理证明如果 \\( p \\) 是素数且 \\( p \\nmid a \\)，则 \\( a^{p - 2} \\) 是 \\( a \\) 模 \\( p \\) 的逆。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.799,
                0.381,
                0.814
            ],
            "angle": 0,
            "content": "36. 利用练习 35 找出 5 模 41 的一个逆。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.817,
                0.585,
                0.832
            ],
            "angle": 0,
            "content": "37. a) 利用费马小定理证明 \\(2^{340} \\equiv 1 (\\mathrm{mod} 11)\\)，注意 \\(2^{340} = (2^{10})^{34}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.835,
                0.557,
                0.849
            ],
            "angle": 0,
            "content": "b)利用 \\(2^{340} = (2^5)^{68} = 32^{68}\\) 这一事实证明 \\(2^{340} \\equiv 1 (\\mathrm{mod} 31)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.853,
                0.423,
                0.867
            ],
            "angle": 0,
            "content": "c)从a)和b)推出结论 \\(2^{340}\\equiv 1(\\mathrm{mod}341)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.87,
                0.588,
                0.884
            ],
            "angle": 0,
            "content": "38. a) 利用费马小定理计算 \\( 3^{302} \\mod 5 \\)，\\( 3^{302} \\mod 7 \\) 和 \\( 3^{302} \\mod 11 \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.888,
                0.701,
                0.903
            ],
            "angle": 0,
            "content": "b)利用a中结果及中国剩余定理计算 \\(3^{302} \\mod 385\\)。（注意 \\(385 = 5 \\cdot 7 \\cdot 11\\)。）"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.906,
                0.614,
                0.92
            ],
            "angle": 0,
            "content": "39. a) 利用费马小定理计算 \\(5^{2003} \\mod 7\\), \\(5^{2003} \\mod 11\\) 及 \\(5^{2003} \\mod 13\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.924,
                0.697,
                0.939
            ],
            "angle": 0,
            "content": "b)用a中结果及中国剩余定理求 \\(5^{2003}\\mod 1001\\) 。（注意 \\(1001 = 7\\cdot 11\\cdot 13\\) 。）"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.132,
                0.036,
                0.169,
                0.049
            ],
            "angle": 0,
            "content": "254"
        },
        {
            "type": "header",
            "bbox": [
                0.214,
                0.034,
                0.279,
                0.05
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.091,
                0.672,
                0.106
            ],
            "angle": 0,
            "content": "40. 借助于费马小定理证明如果 \\(n\\) 是一个正整数，则42能整除 \\(n^7 - n\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.109,
                0.951,
                0.141
            ],
            "angle": 0,
            "content": "41. 证明如果 \\( p \\) 是奇素数，则梅森数 \\( 2^p - 1 \\) 的每个因子都具有 \\( 2kp + 1 \\) 的形式，其中 \\( k \\) 是非负整数。[提示：利用费马小定理以及4.3节练习37。]"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.144,
                0.78,
                0.159
            ],
            "angle": 0,
            "content": "42. 利用练习 41 判定 \\(M_{13} = 2^{13} - 1 = 8191\\) 以及 \\(M_{23} = 2^{23} - 1 = 8388607\\) 是否是素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.162,
                0.767,
                0.176
            ],
            "angle": 0,
            "content": "43. 利用练习 41 判定 \\( M_{11} = 2^{11} - 1 = 2047 \\) 以及 \\( M_{17} = 2^{17} - 1 = 131071 \\) 是否是素数。"
        },
        {
            "type": "list",
            "bbox": [
                0.1,
                0.091,
                0.951,
                0.176
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.07,
                0.18,
                0.951,
                0.252
            ],
            "angle": 0,
            "content": "令 \\(n\\) 是正整数，并令 \\(n - 1 = 2^i t\\)，其中 \\(s\\) 是非负整数，而 \\(t\\) 是正奇数。如果或者 \\(b^i \\equiv 1 (\\mathrm{mod} n)\\)，或者对于某个 \\(j\\)，\\(0 \\leq j \\leq s - 1\\)，\\(b^{2^j t} \\equiv -1 (\\mathrm{mod} n)\\)，则称 \\(n\\) 通过以 \\(b\\) 为底的米勒测试。可以证明（参见[Ro10]）一个合数 \\(n\\) 最多只能通过少于 \\(n / 4\\) 个以 \\(b\\) 为底的米勒测试，其中 \\(1 < b < n\\)。能通过以 \\(b\\) 为底的米勒测试的正合数 \\(n\\) 称为以 \\(b\\) 为底的强伪素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.255,
                0.733,
                0.269
            ],
            "angle": 0,
            "content": "* 44. 证明如果 \\( n \\) 是素数, \\( b \\) 是正整数且 \\( n \\nmid b \\), 则 \\( n \\) 能通过以 \\( b \\) 为底的米勒测试。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.273,
                0.851,
                0.287
            ],
            "angle": 0,
            "content": "45. 通过证明2047通过以2为底的米勒测试但却是合数来证明2047是以2为底的强伪素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.291,
                0.341,
                0.305
            ],
            "angle": 0,
            "content": "46. 证明1729是卡米切尔数。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.309,
                0.341,
                0.323
            ],
            "angle": 0,
            "content": "47. 证明2821是卡米切尔数。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.327,
                0.95,
                0.36
            ],
            "angle": 0,
            "content": "* 48. 证明如果 \\(n = p_1p_2\\cdots p_k\\)，其中 \\(p_1, p_2, \\cdots, p_k\\) 是不同的素数且满足 \\(p_j - 1 \\mid n - 1, j = 1, 2, \\cdots, k\\)，则 \\(n\\) 是卡米切尔数。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.363,
                0.95,
                0.395
            ],
            "angle": 0,
            "content": "49. a) 用练习 48 证明每个形如 \\((6m + 1)(12m + 1)(18m + 1)\\) 的整数都是卡米切尔数，这里 \\( m \\) 是正整数，并且 \\( 6m + 1, 12m + 1 \\) 和 \\( 18m + 1 \\) 都是素数。"
        },
        {
            "type": "list",
            "bbox": [
                0.087,
                0.255,
                0.95,
                0.395
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.399,
                0.451,
                0.413
            ],
            "angle": 0,
            "content": "b)用a证明172947529是卡米切尔数。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.416,
                0.833,
                0.431
            ],
            "angle": 0,
            "content": "50. 找出下列各对所表示的小于 28 的非负整数 \\( a \\)，其中每一对都表示（\\( a \\mod 4 \\)，\\( a \\mod 7 \\)）。"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.435,
                0.21,
                0.448
            ],
            "angle": 0,
            "content": "a) (0, 0)"
        },
        {
            "type": "text",
            "bbox": [
                0.348,
                0.435,
                0.424,
                0.448
            ],
            "angle": 0,
            "content": "b) (1, 0)"
        },
        {
            "type": "text",
            "bbox": [
                0.571,
                0.435,
                0.646,
                0.448
            ],
            "angle": 0,
            "content": "c)(1，1)"
        },
        {
            "type": "text",
            "bbox": [
                0.758,
                0.435,
                0.833,
                0.448
            ],
            "angle": 0,
            "content": "d)(2，1)"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.453,
                0.209,
                0.466
            ],
            "angle": 0,
            "content": "e)(2，2)"
        },
        {
            "type": "text",
            "bbox": [
                0.349,
                0.453,
                0.421,
                0.465
            ],
            "angle": 0,
            "content": "f)(0，3)"
        },
        {
            "type": "text",
            "bbox": [
                0.571,
                0.453,
                0.646,
                0.466
            ],
            "angle": 0,
            "content": "g）（2，0）"
        },
        {
            "type": "text",
            "bbox": [
                0.758,
                0.453,
                0.833,
                0.465
            ],
            "angle": 0,
            "content": "h)(3，5)"
        },
        {
            "type": "text",
            "bbox": [
                0.134,
                0.471,
                0.206,
                0.483
            ],
            "angle": 0,
            "content": "i)(3，6)"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.487,
                0.596,
                0.501
            ],
            "angle": 0,
            "content": "51. 将小于 15 的每个非负整数表示为 \\((a \\mod 3, a \\mod 5)\\) 对。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.505,
                0.54,
                0.519
            ],
            "angle": 0,
            "content": "52. 试解释怎样用练习51中求出的数对来计算4加7。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.523,
                0.351,
                0.537
            ],
            "angle": 0,
            "content": "53. 求解例8中的同余方程组。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.541,
                0.341,
                0.555
            ],
            "angle": 0,
            "content": "54. 证明2是19的一个原根。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.558,
                0.471,
                0.572
            ],
            "angle": 0,
            "content": "55. 找出 5 和 6 的以 2 为底模 19 的离散对数。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.575,
                0.949,
                0.608
            ],
            "angle": 0,
            "content": "56. 令 \\( p \\) 是一个奇素数而 \\( r \\) 是 \\( p \\) 的原根。证明如果 \\( a \\) 和 \\( b \\) 是 \\( \\mathbf{Z}_p \\) 中的正整数，则 \\( \\log_r(ab) \\equiv \\log_r a + \\log_r b (\\bmod p - 1) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.611,
                0.49,
                0.626
            ],
            "angle": 0,
            "content": "57. 试写出相对于原根3的模17的离散对数表。"
        },
        {
            "type": "list",
            "bbox": [
                0.1,
                0.487,
                0.949,
                0.626
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.629,
                0.951,
                0.696
            ],
            "angle": 0,
            "content": "如果 \\(m\\) 是正整数，整数 \\(a\\) 称为 \\(m\\) 的二次剩余如果 \\(\\gcd(a, m) = 1\\) 且同余式 \\(x^2 \\equiv a (\\bmod m)\\) 有解。换言之，\\(m\\) 的一个二次剩余是与 \\(m\\) 互素的整数且与一个完全平方数模 \\(m\\) 同余。如果 \\(a\\) 不是 \\(m\\) 的二次剩余且 \\(\\gcd(a, m) = 1\\) ，我们说它是 \\(m\\) 的二次非剩余。例如，2 是 7 的二次剩余，因为 \\(\\gcd(2, 7) = 1\\) 且 \\(3^2 \\equiv 2 (\\bmod 7)\\)；而 3 是 7 的二次非剩余，因为 \\(\\gcd(3, 7) = 1\\) 但 \\(x^2 \\equiv 3 (\\bmod 7)\\) 无解。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.699,
                0.361,
                0.714
            ],
            "angle": 0,
            "content": "58. 哪些整数是11的二次剩余？"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.717,
                0.95,
                0.749
            ],
            "angle": 0,
            "content": "59. 证明如果 \\( p \\) 是奇素数且 \\( a \\) 是不能被 \\( p \\) 整除的整数，则同余式 \\( x^{2} \\equiv a (\\bmod p) \\) 要么无解，要么恰有两个模 \\( p \\) 不同余的解。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.752,
                0.78,
                0.767
            ],
            "angle": 0,
            "content": "60. 证明如果 \\( p \\) 是奇素数，则在 \\( 1, 2, \\dots, p - 1 \\) 中恰有 \\( (p - 1) / 2 \\) 个 \\( p \\) 的二次剩余。"
        },
        {
            "type": "list",
            "bbox": [
                0.1,
                0.629,
                0.951,
                0.767
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.774,
                0.949,
                0.815
            ],
            "angle": 0,
            "content": "如果 \\(p\\) 是奇素数而 \\(a\\) 是不能被 \\(p\\) 整除的整数，则勒让德符号 \\(\\left(\\frac{a}{p}\\right)\\) 定义为1如果 \\(a\\) 为 \\(p\\) 的二次剩余，否则为-1。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.819,
                0.657,
                0.834
            ],
            "angle": 0,
            "content": "61. 证明如果 \\( p \\) 为奇素数，而 \\( a \\) 和 \\( b \\) 为整数，满足 \\( a \\equiv b (\\bmod p) \\)，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.467,
                0.837,
                0.586,
                0.865
            ],
            "angle": 0,
            "content": "\\[\n\\left(\\frac {a}{p}\\right) = \\left(\\frac {b}{p}\\right)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.868,
                0.699,
                0.882
            ],
            "angle": 0,
            "content": "62. 证明欧拉准则，即如果 \\( p \\) 是奇素数且 \\( a \\) 是不能被 \\( p \\) 整除的正整数，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.446,
                0.888,
                0.64,
                0.914
            ],
            "angle": 0,
            "content": "\\[\n\\left(\\frac {a}{p}\\right) \\equiv a ^ {(p - 1) / 2} (\\mathrm {m o d} p)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.916,
                0.951,
                0.932
            ],
            "angle": 0,
            "content": "[提示：如果 \\(a\\) 是模 \\(p\\) 的二次剩余，则可应用费马小定理；否则，可应用练习18b中给出的威尔逊"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.652,
                0.044,
                0.784,
                0.06
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.83,
                0.046,
                0.866,
                0.059
            ],
            "angle": 0,
            "content": "255"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.101,
                0.139,
                0.116
            ],
            "angle": 0,
            "content": "定理。]"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.119,
                0.651,
                0.135
            ],
            "angle": 0,
            "content": "63. 利用练习 62 证明如果 \\( p \\) 是奇素数且 \\( a \\) 和 \\( b \\) 为不能被 \\( p \\) 整除的整数，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.388,
                0.139,
                0.553,
                0.166
            ],
            "angle": 0,
            "content": "\\[\n\\left(\\frac {a b}{p}\\right) = \\left(\\frac {a}{p}\\right) \\left(\\frac {b}{p}\\right)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.17,
                0.895,
                0.203
            ],
            "angle": 0,
            "content": "64. 证明如果 \\( p \\) 是奇素数，则当 \\( p \\equiv 1 (\\bmod 4) \\) 时 -1 是 \\( p \\) 的二次剩余，当 \\( p \\equiv 3 (\\bmod 4) \\)，-1 不是 \\( p \\) 的二次剩余。[提示：利用练习 62。]"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.206,
                0.895,
                0.24
            ],
            "angle": 0,
            "content": "65. 找出同余方程 \\( x^{2} \\equiv 29 (\\mod 35) \\) 的所有解。[提示：找出该同余式模 5 和模 7 的解，再利用中国剩余定理。]"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.244,
                0.895,
                0.277
            ],
            "angle": 0,
            "content": "66. 找出同余方程 \\( x^{2} \\equiv 16 (\\mod 105) \\) 的所有解。[提示：找出该同余式模3、模5和模7的解，再利用中国剩余定理。]"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.281,
                0.722,
                0.296
            ],
            "angle": 0,
            "content": "67. 描述一个蛮力算法求解离散对数问题，并找出这个算法最差和平均时间复杂度。"
        },
        {
            "type": "list",
            "bbox": [
                0.048,
                0.17,
                0.895,
                0.296
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.049,
                0.31,
                0.248,
                0.33
            ],
            "angle": 0,
            "content": "4.5 同余的应用"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.336,
                0.895,
                0.372
            ],
            "angle": 0,
            "content": "同余在离散数学、计算机科学以及其他领域有许多应用。本节将介绍三个应用案例：利用同余为计算机文件分配内存地址、伪随机数的生成，以及校验码。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.375,
                0.895,
                0.43
            ],
            "angle": 0,
            "content": "假定一个客户标识码是10位数字长。为了快速检索客户资料，我们不会用10位数字的标识码对客户记录分配内存地址，而是使用一个与标识码相关的更小的整数。这可以用所谓的散列函数来实现。本节我们要阐述如何用模算术来做散列函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.433,
                0.895,
                0.546
            ],
            "angle": 0,
            "content": "构造随机数序列对随机算法、仿真，及其他应用都是很重要的。构造真正的随机数序列是非常困难的，或许是不可能的，因为任何用来生成我们所期望的随机数的方法都可能会按某种隐含的模式产生这些数。因此，已经开发了一些方法用来寻找具有随机数的许多理想性质的数的序列，可以用于许多需要随机数的应用。本节我们将阐述如何利用同余来生成伪随机数序列。好处是这样生成的伪随机数可以快速构造；缺点是它们具有太多的可预见性而不能用于许多任务。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.549,
                0.895,
                0.604
            ],
            "angle": 0,
            "content": "同余还可以用来为各种标识码产生校验码，如标示零售产品的代码、标识书的书号、机票编号等。我们将解释如何用同余来为各种类型的标识码构造校验码，并证明这些校验码可以用来检测这些标识码在印刷过程中出现的某种差错。"
        },
        {
            "type": "title",
            "bbox": [
                0.048,
                0.615,
                0.218,
                0.632
            ],
            "angle": 0,
            "content": "4.5.1 散列函数"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.635,
                0.895,
                0.709
            ],
            "angle": 0,
            "content": "一家保险公司的中央计算机保存着它的每个客户的档案记录。怎样分配内存地址才能迅速检索到客户记录？这个问题的解就是使用一个适当选择的散列函数。记录使用键来识别，它可以唯一地识别每个客户的记录。例如，客户记录往往可以用客户的社会安全号作为键来标识。一个散列函数 \\( h \\) 将内存地址 \\( h(k) \\) 分配给以 \\( k \\) 为键值的记录。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.712,
                0.686,
                0.728
            ],
            "angle": 0,
            "content": "在实践中，会用到许多不同的散列函数。最常用的散列函数之一是"
        },
        {
            "type": "equation",
            "bbox": [
                0.395,
                0.732,
                0.545,
                0.747
            ],
            "angle": 0,
            "content": "\\[\nh (k) = k \\bmod m\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.75,
                0.391,
                0.767
            ],
            "angle": 0,
            "content": "其中 \\(m\\) 是可供使用的内存地址的数目。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.77,
                0.895,
                0.825
            ],
            "angle": 0,
            "content": "散列函数应该易于计算以便快速定位到文件。散列函数 \\( h(k) = k \\mod m \\) 符合这一要求。为了找到 \\( h(k) \\)，只需计算当 \\( k \\) 被 \\( m \\) 除时的余数。再者，散列函数还应该是满射的，这样所有内存地址均可利用。函数 \\( h(k) = k \\mod m \\) 也符合这一要求。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.83,
                0.895,
                0.869
            ],
            "angle": 0,
            "content": "例1找出由散列函数 \\(h(k) = k\\bmod 111\\) 分配给社会安全号为064212848和037149212的客户记录的内存地址。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.872,
                0.711,
                0.888
            ],
            "angle": 0,
            "content": "解社会安全号为064212848的客户记录被分配到内存地址14，因为"
        },
        {
            "type": "equation",
            "bbox": [
                0.277,
                0.891,
                0.658,
                0.907
            ],
            "angle": 0,
            "content": "\\[\nh (0 6 4 2 1 2 8 4 8) = 0 6 4 2 1 2 8 4 8 \\bmod 1 1 1 = 1 4\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.911,
                0.171,
                0.927
            ],
            "angle": 0,
            "content": "类似地，由于"
        },
        {
            "type": "equation",
            "bbox": [
                0.277,
                0.929,
                0.658,
                0.945
            ],
            "angle": 0,
            "content": "\\[\nh (0 3 7 1 4 9 2 1 2) = 0 3 7 1 4 9 2 1 2 \\bmod 1 1 1 = 6 5\n\\]"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.13,
                0.043,
                0.167,
                0.057
            ],
            "angle": 0,
            "content": "256"
        },
        {
            "type": "header",
            "bbox": [
                0.211,
                0.042,
                0.277,
                0.058
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.099,
                0.676,
                0.115
            ],
            "angle": 0,
            "content": "所以社会安全号为037149212的客户记录被分配到内存地址65。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.118,
                0.951,
                0.172
            ],
            "angle": 0,
            "content": "由于散列函数不是一对一的（因为很可能键值的数量大于内存地址数），所以有可能多个记录被分配到同一个内存地址。当这种情况发生时，就说出现了冲突。消解冲突的一个办法是使用散列函数分配但已被占用的地址后面第一个未占用的地址。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.177,
                0.951,
                0.216
            ],
            "angle": 0,
            "content": "例2 在例1中分配了上述两个地址以后，为社会安全号是107405723的客户记录分配内存地址。"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.219,
                0.752,
                0.235
            ],
            "angle": 0,
            "content": "解 首先注意到 \\(h(k)\\) 把社会安全号107405723映射到地址14，因为"
        },
        {
            "type": "equation",
            "bbox": [
                0.337,
                0.238,
                0.719,
                0.253
            ],
            "angle": 0,
            "content": "\\[\nh (1 0 7 4 0 5 7 2 3) = 1 0 7 4 0 5 7 2 3 \\bmod 1 1 1 = 1 4\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.257,
                0.951,
                0.292
            ],
            "angle": 0,
            "content": "可是，这一地址已被(社会安全号为064212848的客户档案)占用。但是内存地址15，即内存地址14后面第一个未占用的地址，是空的，所以将社会安全号107405723的客户记录分配到该地址。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.314,
                0.951,
                0.369
            ],
            "angle": 0,
            "content": "在例2中我们实际上用了一个线性探测函数，即 \\(h(k,i) = h(k) + i\\bmod m\\) ，来寻找第一个空闲内存地址，这里 \\(i\\) 可以从0到 \\(m - 1\\) 。还有许多其他消解冲突的办法，在本书最后给出的有关散列函数的参考文献中有讨论。"
        },
        {
            "type": "title",
            "bbox": [
                0.104,
                0.379,
                0.279,
                0.396
            ],
            "angle": 0,
            "content": "4.5.2 伪随机数"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.399,
                0.951,
                0.434
            ],
            "angle": 0,
            "content": "随机选择的数在计算机仿真中常需要用到。人们已经设计了很多不同的方法来产生具有随机选择性质的数。因为由系统方法产生的数并不真正是随机的，所以被称为伪随机数。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.437,
                0.957,
                0.492
            ],
            "angle": 0,
            "content": "最常用的产生伪随机数的过程是线性同余法。我们选择4个整数：模数 \\(m\\) 、倍数 \\(a\\) 、增量 \\(c\\) 和种子 \\(x_0\\) ，满足 \\(2 \\leqslant a < m\\) ，\\(0 \\leqslant c < m\\) 及 \\(0 \\leqslant x_0 < m\\) 。通过连续应用下面递归函数来生成一个伪随机数序列 \\(\\{x_n\\}\\) ，满足对所有 \\(n\\) ，\\(0 \\leqslant x_n < m\\) ："
        },
        {
            "type": "equation",
            "bbox": [
                0.427,
                0.495,
                0.64,
                0.511
            ],
            "angle": 0,
            "content": "\\[\nx _ {n + 1} = \\left(a x _ {n} + c\\right) \\boldsymbol {\\operatorname {m o d}} m\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.513,
                0.957,
                0.548
            ],
            "angle": 0,
            "content": "（这是一个递归定义的例子，递归定义将在5.3节讨论。在那里我们会证明这样定义的序列是良定义的。）"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.551,
                0.957,
                0.587
            ],
            "angle": 0,
            "content": "许多计算机试验都要求产生0和1之间的伪随机数。要产生这样的数，可以用线性同余生成器除以模数：即使用数 \\(x_{n} / m\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.592,
                0.957,
                0.631
            ],
            "angle": 0,
            "content": "例3找出由线性同余法生成的伪随机数序列，其中模数 \\(m = 9\\) 、倍数 \\(a = 7\\) 、增量 \\(c = 4\\) 和种子 \\(x_0 = 3\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.634,
                0.957,
                0.669
            ],
            "angle": 0,
            "content": "解通过连续应用递归定义的函数 \\(x_{n + 1} = (7x_n + 4)\\mod 9\\) 来计算该序列中项，插入种子\\(x_0 = 3\\) 找出 \\(x_{1}\\) 作为起始项。可得"
        },
        {
            "type": "equation",
            "bbox": [
                0.286,
                0.672,
                0.785,
                0.688
            ],
            "angle": 0,
            "content": "\\[\nx _ {1} = 7 x _ {0} + 4 \\mod 9 = 7 \\cdot 3 + 4 \\mod 9 = 2 5 \\mod 9 = 7\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.286,
                0.69,
                0.785,
                0.708
            ],
            "angle": 0,
            "content": "\\[\nx _ {2} = 7 x _ {1} + 4 \\mod 9 = 7 \\cdot 7 + 4 \\mod 9 = 5 3 \\mod 9 = 8\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.286,
                0.711,
                0.785,
                0.728
            ],
            "angle": 0,
            "content": "\\[\nx _ {3} = 7 x _ {2} + 4 \\mod 9 = 7 \\cdot 8 + 4 \\mod 9 = 6 0 \\mod 9 = 6\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.286,
                0.731,
                0.785,
                0.747
            ],
            "angle": 0,
            "content": "\\[\nx _ {4} = 7 x _ {3} + 4 \\mod 9 = 7 \\cdot 6 + 4 \\mod 9 = 4 6 \\mod 9 = 1\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.286,
                0.75,
                0.785,
                0.767
            ],
            "angle": 0,
            "content": "\\[\nx _ {5} = 7 x _ {4} + 4 \\mod 9 = 7 \\cdot 1 + 4 \\mod 9 = 1 1 \\mod 9 = 2\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.286,
                0.77,
                0.785,
                0.787
            ],
            "angle": 0,
            "content": "\\[\nx _ {6} = 7 x _ {5} + 4 \\mod 9 = 7 \\cdot 2 + 4 \\mod 9 = 1 8 \\mod 9 = 0\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.286,
                0.79,
                0.776,
                0.807
            ],
            "angle": 0,
            "content": "\\[\nx _ {7} = 7 x _ {6} + 4 \\bmod 9 = 7 \\cdot 0 + 4 \\bmod 9 = 4 \\bmod 9 = 4\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.286,
                0.81,
                0.785,
                0.826
            ],
            "angle": 0,
            "content": "\\[\nx _ {8} = 7 x _ {7} + 4 \\mod 9 = 7 \\cdot 4 + 4 \\mod 9 = 3 2 \\mod 9 = 5\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.286,
                0.829,
                0.785,
                0.846
            ],
            "angle": 0,
            "content": "\\[\nx _ {9} = 7 x _ {8} + 4 \\mod 9 = 7 \\cdot 5 + 4 \\mod 9 = 3 9 \\mod 9 = 3\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.849,
                0.701,
                0.865
            ],
            "angle": 0,
            "content": "由于 \\(x_{9} = x_{0}\\) 而且每一项都只依赖于其前面的一项，所以产生序列"
        },
        {
            "type": "equation",
            "bbox": [
                0.33,
                0.868,
                0.743,
                0.883
            ],
            "angle": 0,
            "content": "\\[\n3, 7, 8, 6, 1, 2, 0, 4, 5, 3, 7, 8, 6, 1, 2, 0, 4, 5, 3, \\dots\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.887,
                0.477,
                0.902
            ],
            "angle": 0,
            "content": "这个序列包含9个不同的数，然后重复。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.906,
                0.962,
                0.941
            ],
            "angle": 0,
            "content": "大部分计算机确实使用线性同余生成器来生成伪随机数，通常是使用增量 \\(c = 0\\) 的线性同余生成器。这样的生成器称为纯倍式生成器。例如，以 \\(2^{31} - 1\\) 为模，以 \\(7^5 = 16807\\) 为倍数的纯"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.648,
                0.04,
                0.779,
                0.055
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.826,
                0.041,
                0.862,
                0.054
            ],
            "angle": 0,
            "content": "257"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.096,
                0.779,
                0.113
            ],
            "angle": 0,
            "content": "倍式生成器就广为采用。采用这些参数，可以证明在重复之前会产生 \\(2^{31} - 2\\) 个数。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.116,
                0.894,
                0.209
            ],
            "angle": 0,
            "content": "由线性同余生成器生成的伪随机数已经在很长时间里为不同的任务所采用。遗憾的是，已经证明这样生成的伪随机数序列并不具有真正随机数所具有一些重要的统计特性。因此，这种方法对于某些任务（如大型仿真）是不可取的。对于这类敏感的任务，可用其他方法来产生伪随机序列，比如或者利用某种排序算法或者对随机的物理现象中产生的数进行取样。有关伪随机数更详细的论述参见[Kn97]和[Re10]。"
        },
        {
            "type": "title",
            "bbox": [
                0.047,
                0.219,
                0.194,
                0.237
            ],
            "angle": 0,
            "content": "4.5.3 校验码"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.239,
                0.895,
                0.315
            ],
            "angle": 0,
            "content": "同余可用于检查数字串中的错误。在这样的字串中检错的一项常用技术就是在串的结尾处添加一个额外的数字。这最后一个数字，或校验码，是用特定的函数来计算的。然后为了判定一个数字串是否正确，需要做一个检验看看这最后一位数字是否具有正确的值。下面先看看这个概念在比特串的正确性检验中的应用。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.319,
                0.895,
                0.378
            ],
            "angle": 0,
            "content": "例4奇偶校验位数字信息一般用比特串表示，并划分成指定大小的块。每个块在存储或发送前，块的结尾处会添加一个额外的比特，称为奇偶校验位。比特串 \\(x_{1}x_{2}\\dots x_{n}\\) 的奇偶校验位 \\(x_{n + 1}\\) 定义为"
        },
        {
            "type": "equation",
            "bbox": [
                0.331,
                0.382,
                0.612,
                0.397
            ],
            "angle": 0,
            "content": "\\[\nx _ {n + 1} = x _ {1} + x _ {2} + \\dots + x _ {n} \\bmod 2\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.4,
                0.897,
                0.474
            ],
            "angle": 0,
            "content": "由此得出如果在这个 \\(n\\) 比特的块中有偶数个1比特，则 \\(x_{n + 1}\\) 是0；如果在这个 \\(n\\) 比特的块中有奇数个1比特，则 \\(x_{n + 1}\\) 是1。当我们检查一个含有奇偶校验位的串时，如果奇偶校验位错了，我们就知道比特串中有一个差错。奇偶校验可以检测到前面比特中奇数个错误，但不能检测到偶数个错误。（参见练习14。）"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.477,
                0.897,
                0.513
            ],
            "angle": 0,
            "content": "假设我们在传输过程中接收到比特串01100101和11010110，每串都以一个奇偶校验位结尾。这些比特串是正确的吗？"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.516,
                0.897,
                0.609
            ],
            "angle": 0,
            "content": "解 在将这些串判定为正确的之前，我们先检测它们的奇偶校验位。第一串的奇偶校验位是1。因为 \\(0 + 1 + 1 + 0 + 0 + 1 + 0 \\equiv 1 (\\mathrm{mod} 2)\\)，所以奇偶校验位是正确的。第二串的奇偶校验位是0。因为 \\(1 + 1 + 0 + 1 + 0 + 1 + 1 \\equiv 1 (\\mathrm{mod} 2)\\)，所以奇偶校验位是不正确的。我们得出结论，第一串在传输过程中可能是正确的，第二串在传输中肯定出错了。我们判定第一串为正确的（即使它仍然可能包含偶数个错误），而拒绝第二串。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.611,
                0.897,
                0.686
            ],
            "angle": 0,
            "content": "利用同余来计算校验位广泛地用于检查各类标识码的正确性。例5和6描述如何为标识产品(通用产品代码)和书(国际标准书号)的代码计算校验位。练习18、28和32的前导文分别介绍了在汇票号码、机票号码、期刊标识号码中利用同余来计算并使用校验码。注意同余也可以为银行账号、驾驶执照号码、信用卡号码和许多其他标识码计算校验码。"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.69,
                0.9,
                0.749
            ],
            "angle": 0,
            "content": "例5UPC零售产品通常由其通用产品代码(UniversalProductCode，UPC)标识。UPC最常用的形式是12位十进制数字：第一位数字标识产品种类，接着五位标识制造商，再五位标识特定产品，最后一位是校验码。校验码由同余式决定："
        },
        {
            "type": "equation",
            "bbox": [
                0.11,
                0.752,
                0.841,
                0.769
            ],
            "angle": 0,
            "content": "\\[\n3 x _ {1} + x _ {2} + 3 x _ {3} + x _ {4} + 3 x _ {5} + x _ {6} + 3 x _ {7} + x _ {8} + 3 x _ {9} + x _ {1 0} + 3 x _ {1 1} + x _ {1 2} \\equiv 0 (\\mathrm {m o d} 1 0) 。\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.771,
                0.208,
                0.787
            ],
            "angle": 0,
            "content": "试回答下列问题："
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.791,
                0.603,
                0.806
            ],
            "angle": 0,
            "content": "(a)假设UPC的前11位是79357343104。校验码是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.81,
                0.434,
                0.825
            ],
            "angle": 0,
            "content": "(b)041331021641 是否是合法的 UPC?"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.829,
                0.901,
                0.903
            ],
            "angle": 0,
            "content": "解 (a) 我们将 79357343104 的数字代入 UPC 校验码的同余式中。得 \\(3 \\cdot 7 + 9 + 3 \\cdot 3 + 5 + 3 \\cdot 7 + 3 + 3 \\cdot 4 + 3 + 3 \\cdot 1 + 0 + 3 \\cdot 4 + x_{12} \\equiv 0 (\\mathrm{mod} 10)\\) 。化简后得 \\(21 + 9 + 9 + 5 + 21 + 3 + 12 + 3 + 3 + 0 + 12 + x_{12} \\equiv 0 (\\mathrm{mod} 10)\\) 。故，\\(98 + x_{12} \\equiv 0 (\\mathrm{mod} 10)\\) 。由此可得 \\(x_{12} \\equiv 2 (\\mathrm{mod} 10)\\)，所以校验码是 2。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.906,
                0.901,
                0.94
            ],
            "angle": 0,
            "content": "(b) 要检查 041331021641 是否合法，我们将这些数字代入必须满足的同余式中。得 \\(3 \\cdot 0 + 4 + 3 \\cdot 1 + 3 + 3 \\cdot 3 + 1 + 3 \\cdot 0 + 2 + 3 \\cdot 1 + 6 + 3 \\cdot 4 + 1 \\equiv 0 + 4 + 3 + 3 + 9 + 1 + 0 + 2 + 3 + 6 + 12+\\)"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.133,
                0.041,
                0.17,
                0.055
            ],
            "angle": 0,
            "content": "258"
        },
        {
            "type": "header",
            "bbox": [
                0.214,
                0.04,
                0.281,
                0.055
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.097,
                0.612,
                0.113
            ],
            "angle": 0,
            "content": "\\(1 \\equiv 4 \\not\\equiv 0 (\\mathrm{mod} 10)\\) 。故，041331021641不是合法的UPC。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.119,
                0.954,
                0.217
            ],
            "angle": 0,
            "content": "例6 ISBN 所有图书都由一个国际标准书号(International Standard Book Number, ISBN-10)标识，一个由出版商指定的10位数代码 \\(x_{1}x_{2}\\dots x_{10}\\)。（最近，新引入的称为ISBN-13的一个13位数字代码用来标识更大量出版的著作。参见补充练习42的前导文。）一个ISBN-10包含不同分组来标识语言、出版商、出版公司赋予图书的编号、最后一位校验码（或者是数字或者是字母X代表10）。这个校验码的选择满足"
        },
        {
            "type": "equation",
            "bbox": [
                0.428,
                0.221,
                0.629,
                0.256
            ],
            "angle": 0,
            "content": "\\[\nx _ {1 0} = \\sum_ {i = 0} ^ {9} i x _ {i} (\\mathrm {m o d} 1 1)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.257,
                0.273,
                0.274
            ],
            "angle": 0,
            "content": "或者等价地，满足"
        },
        {
            "type": "equation",
            "bbox": [
                0.437,
                0.277,
                0.621,
                0.311
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {i = 0} ^ {1 0} i x _ {i} \\equiv 0 (\\mathrm {m o d} 1 1)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.313,
                0.407,
                0.329
            ],
            "angle": 0,
            "content": "试回答下列关于ISBN-10的问题："
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.332,
                0.74,
                0.348
            ],
            "angle": 0,
            "content": "(a)本书第6版的ISBN-10的前9位是007288008。校验码是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.351,
                0.503,
                0.367
            ],
            "angle": 0,
            "content": "(b)084930149X是否是合法的ISBN-10？"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.372,
                0.95,
                0.445
            ],
            "angle": 0,
            "content": "解 (a) 校验码由同余式 \\(\\sum_{i=1}^{10} ix_i \\equiv 0 (\\bmod 11)\\) 确定。代入数字 007288008 得 \\(x_{10} \\equiv 1 \\cdot 0 + 2 \\cdot 0 + 3 \\cdot 7 + 4 \\cdot 2 + 5 \\cdot 8 + 6 \\cdot 8 + 7 \\cdot 0 + 8 \\cdot 0 + 9 \\cdot 8 (\\bmod 11)\\) 。这意味着 \\(x_{10} \\equiv 0 + 0 + 21 + 8 + 40 + 48 + 0 + 0 + 72 (\\bmod 11)\\)，所以 \\(x_{10} \\equiv 189 \\equiv 2 (\\bmod 11)\\) 。故，\\(x_{10} = 2\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.449,
                0.951,
                0.52
            ],
            "angle": 0,
            "content": "(b) 要想知道 084930149X 是否是合法的 ISBN-10，我们看看是否有 \\(\\sum_{i=1}^{10} ix_i \\equiv 0 (\\mathrm{mod} 11)\\)。因为 \\(1 \\cdot 0 + 2 \\cdot 8 + 3 \\cdot 4 + 4 \\cdot 9 + 5 \\cdot 3 + 6 \\cdot 0 + 7 \\cdot 1 + 8 \\cdot 4 + 9 \\cdot 9 + 10 \\cdot 10 = 0 + 16 + 12 + 36 + 15 + 0 + 7 + 32 + 81 + 100 = 299 \\equiv 2 \\not\\equiv 0 (\\mathrm{mod} 11)\\)。故 084930149X 不是合法的 ISBN-10。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.523,
                0.951,
                0.616
            ],
            "angle": 0,
            "content": "在标识码中经常会出现若干种错误。单错，即标识码中一位数字的错误，或许是最常见的一类错误。另一类常见错误是换位错，当两位数字不慎颠倒时就会发生这种情况。对于每一种标识码，包括校验码，我们希望能够检测这些常见的以及其他的错误。我们要研究ISBN的校验码是否可以检测单错或换位错。UPC的校验码是否可以检测这些错误留作练习26和27。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.622,
                0.951,
                0.713
            ],
            "angle": 0,
            "content": "假设 \\(x_{1}x_{2}\\dots x_{10}\\) 是合法的 \\(\\mathrm{ISBN}\\Big(\\) 所以 \\(\\sum_{i = 1}^{10}x_i\\equiv 0(\\mathrm{mod} 10)\\Big)\\) 。我们证明可以检测一个单错和两个数字的换位错（这里有可能两位数字之一是代表10的X）。假设这个ISBN由于单错而印成了 \\(y_{1}y_{2}\\dots y_{10}\\) 。如果有一个单错，则对某个整数 \\(j\\) ，当 \\(i\\neq j\\) 时 \\(y_{i} = x_{i}\\) 而 \\(y_{j} = x_{j} + a\\) ，其中\\(-10\\leqslant a\\leqslant 10\\) 且 \\(a\\neq 0\\) 。注意 \\(a = y_j - x_j\\) 是第 \\(j\\) 位的错误。因此，可以得出"
        },
        {
            "type": "equation",
            "bbox": [
                0.333,
                0.716,
                0.721,
                0.752
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {i = 1} ^ {1 0} i y _ {i} = \\left(\\sum_ {i = 1} ^ {1 0} i x _ {i}\\right) + j a \\equiv j a \\not \\equiv 0 (\\mathrm {m o d} 1 1)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.754,
                0.95,
                0.807
            ],
            "angle": 0,
            "content": "这里最后两个同余式成立是因为 \\(\\sum_{i=1}^{10} x_i \\equiv 0 (\\bmod 10)\\)，而且 \\(11 \\nmid ja\\)，因为 \\(11 \\nmid j\\) 和 \\(11 \\nmid a\\)。从而得出结论 \\(y_1y_2 \\dots y_{10}\\) 不是合法的ISBN。所以，我们能够检测出单错。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.81,
                0.95,
                0.847
            ],
            "angle": 0,
            "content": "现在假设两个不相等的数字被换位了。可知有两个不同的整数 \\(j\\) 和 \\(k\\) 使得 \\(y_{j} = x_{k}\\) 且 \\(y_{k} = x_{j}\\)，而当 \\(i \\neq j\\) 和 \\(i \\neq k\\) 时有 \\(y_{i} = x_{i}\\)。故，"
        },
        {
            "type": "equation",
            "bbox": [
                0.161,
                0.85,
                0.891,
                0.885
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {i = 1} ^ {1 0} i y _ {i} = \\left(\\sum_ {i = 1} ^ {1 0} i x _ {i}\\right) + (j x _ {k} - j x _ {j}) + (k x _ {j} - k x _ {k}) \\equiv (j - k) (x _ {k} - x _ {j}) \\not \\equiv 0 (\\mathrm {m o d} 1 1)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.888,
                0.95,
                0.94
            ],
            "angle": 0,
            "content": "因为 \\(\\sum_{i=1}^{10} x_i \\equiv 0 (\\bmod 10)\\) 而 \\(11 \\nmid (j - k)\\) 且 \\(11 \\nmid (x_k - x_j)\\) 。可知 \\(y_1 y_2 \\dots y_{10}\\) 不是合法的 ISBN。这样，我们就能检测到两个不相等的数字的换位。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.657,
                0.038,
                0.789,
                0.053
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.836,
                0.039,
                0.871,
                0.052
            ],
            "angle": 0,
            "content": "259"
        },
        {
            "type": "title",
            "bbox": [
                0.055,
                0.103,
                0.101,
                0.118
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.122,
                0.837,
                0.138
            ],
            "angle": 0,
            "content": "1. 利用散列函数 \\( h(k) = k \\mod 97 \\) 为下列社会安全号的保险公司客户记录分配的内存地址是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.14,
                0.18,
                0.154
            ],
            "angle": 0,
            "content": "a)034567981"
        },
        {
            "type": "text",
            "bbox": [
                0.298,
                0.14,
                0.402,
                0.153
            ],
            "angle": 0,
            "content": "b)183211232"
        },
        {
            "type": "text",
            "bbox": [
                0.521,
                0.141,
                0.623,
                0.153
            ],
            "angle": 0,
            "content": "c)220195744"
        },
        {
            "type": "text",
            "bbox": [
                0.707,
                0.141,
                0.81,
                0.153
            ],
            "angle": 0,
            "content": "d)987255335"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.158,
                0.845,
                0.173
            ],
            "angle": 0,
            "content": "2. 利用散列函数 \\( h(k) = k \\mod 101 \\) 为下列社会安全号的保险公司客户记录分配的内存地址是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.176,
                0.18,
                0.189
            ],
            "angle": 0,
            "content": "a)104578690"
        },
        {
            "type": "text",
            "bbox": [
                0.298,
                0.176,
                0.402,
                0.189
            ],
            "angle": 0,
            "content": "b)432222187"
        },
        {
            "type": "text",
            "bbox": [
                0.521,
                0.177,
                0.623,
                0.189
            ],
            "angle": 0,
            "content": "c)372201919"
        },
        {
            "type": "text",
            "bbox": [
                0.707,
                0.177,
                0.809,
                0.189
            ],
            "angle": 0,
            "content": "d)501338753"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.193,
                0.898,
                0.226
            ],
            "angle": 0,
            "content": "3. 停车场有 31 个车位供来访者使用，编号从 0 到 30。来访者根据散列函数 \\( h(k) = k \\mod 31 \\) 获得车位，其中 \\( k \\) 是来访者车牌前三位数。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.229,
                0.762,
                0.244
            ],
            "angle": 0,
            "content": "a) 车牌前三位数为 317、918、007、100、111、310 时, 会由散列函数分配什么车位?"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.247,
                0.662,
                0.262
            ],
            "angle": 0,
            "content": "b)描述一个过程使得来访者在发现指派车位已被占用时可以找到空车位。"
        },
        {
            "type": "list",
            "bbox": [
                0.053,
                0.229,
                0.762,
                0.262
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.265,
                0.898,
                0.316
            ],
            "angle": 0,
            "content": "消解散列冲突的另一个方法是使用双散列函数。先用一个初始散列函数 \\( h(k) = k \\mod p \\)，这里 \\( p \\) 是素数。再用第二个散列函数 \\( g(k) = (k + 1) \\mod (p - 2) \\)。当冲突发生时，使用一个探测序列 \\( h(k, i) = (h(k) + i \\cdot g(k)) \\mod p \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.318,
                0.898,
                0.369
            ],
            "angle": 0,
            "content": "4. 利用前面描述的双散列函数的过程并取 \\( p = 4969 \\) 为下列社会安全号的雇员的档案分配内存地址： \\( k_{1} = 132489971 \\)， \\( k_{2} = 509496993 \\)， \\( k_{3} = 546332190 \\)， \\( k_{4} = 034367980 \\)， \\( k_{5} = 047900151 \\)， \\( k_{6} = 329938157 \\)， \\( k_{7} = 212228844 \\)， \\( k_{8} = 325510778 \\)， \\( k_{9} = 353354519 \\)， \\( k_{10} = 053708912 \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.372,
                0.761,
                0.387
            ],
            "angle": 0,
            "content": "5. 用线性同余生成器 \\(x_{n + 1} = (3x_n + 2) \\bmod 13\\) 和种子 \\(x_0 = 1\\) 生成的伪随机数序列是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.39,
                0.752,
                0.404
            ],
            "angle": 0,
            "content": "6. 用线性同余生成器 \\(x_{n+1} \\approx (4x_n + 1) \\bmod 7\\) 和种子 \\(x_0 = 3\\) 生成的伪随机数序列是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.407,
                0.701,
                0.422
            ],
            "angle": 0,
            "content": "7. 用纯倍式生成器 \\(x_{n + 1} = 3x_n \\mod 11\\) 和种子 \\(x_0 = 2\\) 生成的伪随机数序列是什么？"
        },
        {
            "type": "list",
            "bbox": [
                0.051,
                0.318,
                0.898,
                0.422
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.425,
                0.587,
                0.44
            ],
            "angle": 0,
            "content": "8. 试用伪代码写出利用线性同余生成器生成伪随机数序列的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.444,
                0.898,
                0.493
            ],
            "angle": 0,
            "content": "平方取中法(middle-square method)从一个 \\(n\\) 位整数开始来生成伪随机数。该数取平方，需要时在前面添加0以保证结果是 \\(2n\\) 位数，然后取中间 \\(n\\) 位数字用来构成序列中的下一个数。重复这一过程以生成新的项。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.497,
                0.594,
                0.511
            ],
            "angle": 0,
            "content": "9. 找出从2357开始平方取中法生成4位数伪随机数序列的前8项。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.515,
                0.898,
                0.565
            ],
            "angle": 0,
            "content": "10. 试解释为什么在用平方取中法生成4位数伪随机数序列时以3792和2916作为起始项是不好的选择。幂次生成器是一种生成伪随机数的方法。在使用幂次生成器时，需要指定参数 \\( p \\) 和 \\( d \\)，其中 \\( p \\) 是素数，\\( d \\) 是一个正整数使得 \\( p \\nmid d \\)，以及种子 \\( x_0 \\) 。伪随机数 \\( x_1, x_2, \\ldots \\) 由递归定义函数生成 \\( x_{n+1} = x_n^d \\mod p \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.568,
                0.653,
                0.583
            ],
            "angle": 0,
            "content": "11.找出幂次生成器生成的伪随机数序列，其中 \\(p = 7\\) 、 \\(d = 3\\) 、种子 \\(x_0 = 2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.586,
                0.661,
                0.601
            ],
            "angle": 0,
            "content": "12.找出幂次生成器生成的伪随机数序列，其中 \\(p = 11\\) 、 \\(d = 2\\) 、种子 \\(x_0 = 3\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.604,
                0.896,
                0.636
            ],
            "angle": 0,
            "content": "13. 假设从通信链路接收到下列比特串，其中最后一比特是奇偶校验位。你能肯定哪个比特串有一个错误？"
        },
        {
            "type": "list",
            "bbox": [
                0.051,
                0.515,
                0.898,
                0.636
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.64,
                0.203,
                0.653
            ],
            "angle": 0,
            "content": "a)00000111111"
        },
        {
            "type": "text",
            "bbox": [
                0.296,
                0.641,
                0.417,
                0.652
            ],
            "angle": 0,
            "content": "b)10101010101"
        },
        {
            "type": "text",
            "bbox": [
                0.52,
                0.641,
                0.638,
                0.652
            ],
            "angle": 0,
            "content": "c)11111100000"
        },
        {
            "type": "text",
            "bbox": [
                0.706,
                0.641,
                0.823,
                0.652
            ],
            "angle": 0,
            "content": "d)10111101111"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.658,
                0.687,
                0.672
            ],
            "angle": 0,
            "content": "14. 证明奇偶校验位能够检测到比特串中的错误当且仅当该串包含奇数个错误。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.675,
                0.77,
                0.689
            ],
            "angle": 0,
            "content": "15. 本书第5版欧洲版本的ISBN-10的前9位数字是0-07-119881。该书的校验码是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.693,
                0.847,
                0.708
            ],
            "angle": 0,
            "content": "16.《初等数论及其应用》第6版的ISBN-10是0-321-500Q1-8，其中Q是一个数字。请找出Q的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.711,
                0.724,
                0.725
            ],
            "angle": 0,
            "content": "17. 判断出版商计算本书（《离散数学及其应用》第7版）的ISBN-10校验码是否正确。"
        },
        {
            "type": "list",
            "bbox": [
                0.051,
                0.658,
                0.847,
                0.725
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.729,
                0.896,
                0.761
            ],
            "angle": 0,
            "content": "美国邮政署(The United States Postal Service，USPS)出售由11位数字 \\(x_{1}x_{2}\\dots x_{11}\\) 标识的汇票。前10位标识汇票，\\(x_{11}\\) 是满足 \\(x_{11} = x_{1} + x_{2} + \\dots +x_{10}\\mod 9\\) 的校验码。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.764,
                0.565,
                0.779
            ],
            "angle": 0,
            "content": "18. 试找出标识码以下列10位数字开始的USPS汇票的校验码。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.782,
                0.195,
                0.795
            ],
            "angle": 0,
            "content": "a)7555618873"
        },
        {
            "type": "text",
            "bbox": [
                0.296,
                0.783,
                0.406,
                0.795
            ],
            "angle": 0,
            "content": "b)6966133421"
        },
        {
            "type": "text",
            "bbox": [
                0.518,
                0.783,
                0.629,
                0.795
            ],
            "angle": 0,
            "content": "c)8018927435"
        },
        {
            "type": "text",
            "bbox": [
                0.704,
                0.783,
                0.815,
                0.795
            ],
            "angle": 0,
            "content": "d)3289744134"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.8,
                0.482,
                0.814
            ],
            "angle": 0,
            "content": "19. 判断下列这些数是否是合法的 USPS 汇票标识码。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.818,
                0.203,
                0.831
            ],
            "angle": 0,
            "content": "a)74051489623"
        },
        {
            "type": "text",
            "bbox": [
                0.296,
                0.819,
                0.416,
                0.831
            ],
            "angle": 0,
            "content": "b)88382013445"
        },
        {
            "type": "text",
            "bbox": [
                0.518,
                0.819,
                0.637,
                0.831
            ],
            "angle": 0,
            "content": "c)56152240784"
        },
        {
            "type": "text",
            "bbox": [
                0.704,
                0.819,
                0.824,
                0.831
            ],
            "angle": 0,
            "content": "d)66606631178"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.836,
                0.839,
                0.85
            ],
            "angle": 0,
            "content": "20. 下列邮政汇票标识码中有一位数字被弄脏了。你能恢复这些数中由 Q 标记的被弄脏的数字吗？"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.854,
                0.208,
                0.867
            ],
            "angle": 0,
            "content": "a)Q1223139784"
        },
        {
            "type": "text",
            "bbox": [
                0.296,
                0.854,
                0.421,
                0.867
            ],
            "angle": 0,
            "content": "b)6702120Q988"
        },
        {
            "type": "text",
            "bbox": [
                0.518,
                0.854,
                0.641,
                0.867
            ],
            "angle": 0,
            "content": "c)27Q41007734"
        },
        {
            "type": "text",
            "bbox": [
                0.704,
                0.854,
                0.827,
                0.867
            ],
            "angle": 0,
            "content": "d)213279032Q1"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.871,
                0.838,
                0.885
            ],
            "angle": 0,
            "content": "21. 下列邮政汇票标识码中有一位数字被弄脏了。你能恢复这些数中由 Q 标记的被弄脏的数字吗？"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.89,
                0.207,
                0.903
            ],
            "angle": 0,
            "content": "a)493212Q0688"
        },
        {
            "type": "text",
            "bbox": [
                0.296,
                0.89,
                0.421,
                0.902
            ],
            "angle": 0,
            "content": "b)850Q9103858"
        },
        {
            "type": "text",
            "bbox": [
                0.518,
                0.89,
                0.641,
                0.902
            ],
            "angle": 0,
            "content": "c)2Q941007734"
        },
        {
            "type": "text",
            "bbox": [
                0.704,
                0.89,
                0.827,
                0.903
            ],
            "angle": 0,
            "content": "d)66687Q03201"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.907,
                0.555,
                0.921
            ],
            "angle": 0,
            "content": "22. 试确定 USPS 汇票码中哪位单一的数字错误能被检测出来。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.925,
                0.536,
                0.939
            ],
            "angle": 0,
            "content": "23. 试确定 USPS 汇票码中哪些位的换位错误能被检测出来。"
        },
        {
            "type": "list",
            "bbox": [
                0.05,
                0.907,
                0.555,
                0.939
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.133,
                0.037,
                0.17,
                0.05
            ],
            "angle": 0,
            "content": "260"
        },
        {
            "type": "header",
            "bbox": [
                0.215,
                0.036,
                0.28,
                0.051
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.092,
                0.521,
                0.106
            ],
            "angle": 0,
            "content": "24. 为以下列11位数字开始的UPC确定其校验码。"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.11,
                0.263,
                0.124
            ],
            "angle": 0,
            "content": "a)73232184434"
        },
        {
            "type": "text",
            "bbox": [
                0.351,
                0.11,
                0.474,
                0.123
            ],
            "angle": 0,
            "content": "b)63623991346"
        },
        {
            "type": "text",
            "bbox": [
                0.574,
                0.111,
                0.695,
                0.123
            ],
            "angle": 0,
            "content": "c)04587320720"
        },
        {
            "type": "text",
            "bbox": [
                0.759,
                0.111,
                0.882,
                0.123
            ],
            "angle": 0,
            "content": "d)93764323341"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.128,
                0.503,
                0.142
            ],
            "angle": 0,
            "content": "25. 判断下列12位数字串是否是合法的UPC码。"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.146,
                0.27,
                0.159
            ],
            "angle": 0,
            "content": "a)036000291452"
        },
        {
            "type": "text",
            "bbox": [
                0.351,
                0.147,
                0.484,
                0.158
            ],
            "angle": 0,
            "content": "b)012345678903"
        },
        {
            "type": "text",
            "bbox": [
                0.575,
                0.147,
                0.704,
                0.158
            ],
            "angle": 0,
            "content": "c)782421843014"
        },
        {
            "type": "text",
            "bbox": [
                0.759,
                0.147,
                0.891,
                0.158
            ],
            "angle": 0,
            "content": "d)726412175425"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.163,
                0.752,
                0.177
            ],
            "angle": 0,
            "content": "26. 一个UPC码的校验码能检测出所有单错吗？证明你的答案或找出一个反例。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.181,
                0.55,
                0.195
            ],
            "angle": 0,
            "content": "27. 试确定UPC码中哪些位的换位错误能被检测出来。"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.198,
                0.903,
                0.213
            ],
            "angle": 0,
            "content": "某些机票具有一个15位数字的标识码 \\(a_1a_2\\dots a_{15}\\) ，其中 \\(a_{15}\\) 是校验码，它等于 \\(a_1a_2\\dots a_{15}\\mod 7\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.216,
                0.576,
                0.23
            ],
            "angle": 0,
            "content": "28. 找出以下列14位数字开始的机票标识码的校验码 \\(a_{15}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.234,
                0.291,
                0.247
            ],
            "angle": 0,
            "content": "a)10237424413392"
        },
        {
            "type": "text",
            "bbox": [
                0.351,
                0.234,
                0.502,
                0.247
            ],
            "angle": 0,
            "content": "b)00032781811234"
        },
        {
            "type": "text",
            "bbox": [
                0.576,
                0.235,
                0.723,
                0.247
            ],
            "angle": 0,
            "content": "c)00611232134231"
        },
        {
            "type": "text",
            "bbox": [
                0.761,
                0.235,
                0.909,
                0.247
            ],
            "angle": 0,
            "content": "d)00193222543435"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.251,
                0.532,
                0.266
            ],
            "angle": 0,
            "content": "29. 判断下列15位数字串是否是合法的机票标识码。"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.269,
                0.301,
                0.282
            ],
            "angle": 0,
            "content": "a)101333341789013"
        },
        {
            "type": "text",
            "bbox": [
                0.354,
                0.27,
                0.513,
                0.282
            ],
            "angle": 0,
            "content": "b)007862342770445"
        },
        {
            "type": "text",
            "bbox": [
                0.577,
                0.27,
                0.733,
                0.282
            ],
            "angle": 0,
            "content": "c)113273438882531"
        },
        {
            "type": "text",
            "bbox": [
                0.763,
                0.27,
                0.918,
                0.282
            ],
            "angle": 0,
            "content": "d)000122347322871"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.287,
                0.643,
                0.301
            ],
            "angle": 0,
            "content": "30. 试确定15位机票标识码中哪位单一的数字错误能被检测出来。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.304,
                0.692,
                0.318
            ],
            "angle": 0,
            "content": "* 31. 机票标识码中连续两位数字不慎换位，校验码能检测出这种错误吗？"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.322,
                0.955,
                0.372
            ],
            "angle": 0,
            "content": "期刊是采用国际标准连续出版物号(International Standard Serial Number，ISSN)来标识的。一个ISSN由两组4位数字构成。第二组的最后一位是校验码。校验码的计算由同余式给出 \\(d_{8} \\equiv 3d_{1} + 4d_{2} + 5d_{3} + 6d_{4} + 7d_{5} + 8d_{6} + 9d_{7} (\\mathrm{mod} 11)\\) 。当 \\(d_{8} \\equiv 10 (\\mathrm{mod} 11)\\) 时，采用字母X来表示编码中的 \\(d_{8}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.375,
                0.643,
                0.389
            ],
            "angle": 0,
            "content": "32. 对于下列 7 位开始的 ISSN，确定其校验码（有可能是字母 X）。"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.393,
                0.237,
                0.406
            ],
            "angle": 0,
            "content": "a)1570-868"
        },
        {
            "type": "text",
            "bbox": [
                0.355,
                0.394,
                0.45,
                0.405
            ],
            "angle": 0,
            "content": "b)1553-734"
        },
        {
            "type": "text",
            "bbox": [
                0.579,
                0.394,
                0.671,
                0.406
            ],
            "angle": 0,
            "content": "c)1089-708"
        },
        {
            "type": "text",
            "bbox": [
                0.764,
                0.394,
                0.856,
                0.406
            ],
            "angle": 0,
            "content": "d)1383-811"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.41,
                0.668,
                0.425
            ],
            "angle": 0,
            "content": "33. 下列 8 位数字码有可能是 ISSN 吗？即是否以正确的校验码结尾？"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.428,
                0.246,
                0.442
            ],
            "angle": 0,
            "content": "a)1059-1027"
        },
        {
            "type": "text",
            "bbox": [
                0.356,
                0.429,
                0.459,
                0.441
            ],
            "angle": 0,
            "content": "b)0002-9890"
        },
        {
            "type": "text",
            "bbox": [
                0.579,
                0.429,
                0.68,
                0.441
            ],
            "angle": 0,
            "content": "c)1530-8669"
        },
        {
            "type": "text",
            "bbox": [
                0.764,
                0.429,
                0.871,
                0.441
            ],
            "angle": 0,
            "content": "d)1007-120X"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.445,
                0.828,
                0.46
            ],
            "angle": 0,
            "content": "34. 一个ISSN的校验码是否能检测出ISSN中每个单错？用证明或反例来解释你的答案。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.463,
                0.955,
                0.496
            ],
            "angle": 0,
            "content": "35. 一个ISSN的校验码是否能检测出所有连续两位数字被不慎调换的错误？用证明或反例来解释你的答案。"
        },
        {
            "type": "title",
            "bbox": [
                0.109,
                0.51,
                0.26,
                0.529
            ],
            "angle": 0,
            "content": "4.6 密码学"
        },
        {
            "type": "title",
            "bbox": [
                0.109,
                0.537,
                0.238,
                0.554
            ],
            "angle": 0,
            "content": "4.6.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.557,
                0.959,
                0.726
            ],
            "angle": 0,
            "content": "数论在密码学（将信息作转换使得在没有特殊知识的情况下不能很容易地恢复出来）中起着关键的作用。数论是古典密码的基础，古典密码早在几千年前就有使用，而且直到20世纪还在广泛使用。这些密码通过将每个字母变换为一个不同的字母或将一组字母变换为另一组不同的字母来对消息进行加密。我们将讨论一些古典密码，包括移位密码，即将每个字母替换为字母表中向后移动一个固定位置数的字母，并在需要时再回到字母表的开始。我们要讨论的古典密码是私钥密码的实例，其中知道如何加密的人也就能够对消息进行解密。采用私钥密码时，想要进行私密通信的双方必须共享一个密钥。我们要讨论的古典密码经受不起密码分析，就是在没有获得用来加密消息的秘密信息的情况下寻求恢复被加密的信息。我们将说明如何破译用移位密码发送的消息。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.728,
                0.96,
                0.84
            ],
            "angle": 0,
            "content": "数论在20世纪70年代发明的一种公钥密码学中也起着重要作用。在公钥密码学中，知道如何加密的人并不知道如何解密。使用最广泛的公钥系统是被称为RSA的密码系统，它采用模指数对消息加密，这里模数是两个大素数的乘积。想要知道如何加密，你需要知道该模数和一个指数（不需要知道该模数的两个素因子）。可见，想要知道如何解密，你就需要知道如何反转加密函数，而这只有当你知道这两个大素因子的情况下才能在切合实际的时间内完成。本章将解释RSA密码系统是如何工作的，包括如何加密和解密消息。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.843,
                0.962,
                0.937
            ],
            "angle": 0,
            "content": "密码学的主题还包括密码协议，这是两方或多方为了达到一个指定的安全目标而进行的消息交换。本章将讨论两个重要的协议：一个是允许两人共享一个公共密钥；另一个可用于发送签名消息使得接收者就能够确定消息来自于声称的发送者。最后，我们将介绍同态密码系统的概念，它在云计算中发挥着重要作用。如果数据必须解密后才能用于程序的输入，数据就会变得很脆弱。同态密码系统通过允许程序在加密的数据上运行来消除这种脆弱性。这些程序的输"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.644,
                0.037,
                0.776,
                0.052
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.822,
                0.038,
                0.856,
                0.051
            ],
            "angle": 0,
            "content": "261"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.093,
                0.301,
                0.11
            ],
            "angle": 0,
            "content": "出则是加密形式的期望结果。"
        },
        {
            "type": "title",
            "bbox": [
                0.043,
                0.12,
                0.238,
                0.137
            ],
            "angle": 0,
            "content": "4.6.2 古典密码学"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.14,
                0.892,
                0.214
            ],
            "angle": 0,
            "content": "已知最早使用密码学的人之一是尤利乌斯·恺撒（Julius Caesar）。他通过把字母表中的每个字母正向移动三位以加密消息（字母表中最后三个字母移到最开始的三个字母）。例如，采用这一模式，字母B移到E，而字母X移到A。这就是加密(encryption)的一个例子，加密就是对信息进行保密处理的过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.217,
                0.892,
                0.291
            ],
            "angle": 0,
            "content": "为了用数学来表达恺撒加密过程，首先将每个字母替换为 \\(\\mathbf{Z}_{26}\\) 中的元素，即等于其在字母表中位置减1的0到25之间的一个整数。例如，用0替换A，用10替换K，用25替换Z。恺撒加密方法可以表示为一个函数 \\(f\\) ，为每个非负整数 \\(p\\) ， \\(p\\leqslant 25\\) ，指派集合 \\(\\{0,1,2,\\dots ,25\\}\\) 中的一个整数 \\(f(p)\\) ，使得"
        },
        {
            "type": "equation",
            "bbox": [
                0.361,
                0.294,
                0.573,
                0.31
            ],
            "angle": 0,
            "content": "\\[\nf (p) = (p + 3) \\bmod 2 6\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.313,
                0.677,
                0.329
            ],
            "angle": 0,
            "content": "在加密信息中， \\(p\\) 所代表的字母用 \\((p + 3) \\bmod 26\\) 所代表的字母替换了。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.334,
                0.821,
                0.351
            ],
            "angle": 0,
            "content": "例1用恺撒密码从消息“MEETYOUINTHEPARK”产生的秘密消息是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.083,
                0.356,
                0.439,
                0.372
            ],
            "angle": 0,
            "content": "解 首先用数代替消息中的字母。得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.212,
                0.376,
                0.721,
                0.391
            ],
            "angle": 0,
            "content": "\\[\n1 2 4 4 1 9 \\quad 2 4 1 4 2 0 \\quad 8 1 3 \\quad 1 9 7 4 \\quad 1 5 0 1 7 1 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.395,
                0.554,
                0.411
            ],
            "angle": 0,
            "content": "现在，再把每个数 \\(p\\) 替换成 \\(f(p) = (p + 3) \\bmod 26\\)。可得"
        },
        {
            "type": "equation",
            "bbox": [
                0.208,
                0.414,
                0.727,
                0.429
            ],
            "angle": 0,
            "content": "\\[\n1 5 7 7 2 2 \\quad 1 1 7 2 3 \\quad 1 1 1 6 \\quad 2 2 1 0 7 \\quad 1 8 3 2 0 1 3\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.433,
                0.667,
                0.449
            ],
            "angle": 0,
            "content": "再把这个翻译成字母产生加密消息“PHHW BRX LQ WKH SDUN”。"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.452,
                0.892,
                0.526
            ],
            "angle": 0,
            "content": "要从恺撒密码加密的消息恢复原消息，需要用到 \\(f\\) 的逆函数 \\(f^{-1}\\) 。注意函数 \\(f^{-1}\\) 把 \\(\\mathbf{Z}_{26}\\) 中的整数 \\(p\\) 变换为 \\(f^{-1}(p) = (p - 3) \\bmod 26\\) 。换言之，要找出原始消息，每个字母在字母表中反向移三位，而字母表的前三个字母移到最后三位。从加密消息中来确定原始消息的过程称为解密（decryption）。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.529,
                0.892,
                0.564
            ],
            "angle": 0,
            "content": "有各种方法可以扩展恺撒密码。例如，可以把每个字母对应的数移动 \\(k\\) 位，而不是把每个字母对应的数移动3位，于是"
        },
        {
            "type": "equation",
            "bbox": [
                0.364,
                0.567,
                0.576,
                0.583
            ],
            "angle": 0,
            "content": "\\[\nf (p) = (p + k) \\bmod 2 6\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.586,
                0.441,
                0.602
            ],
            "angle": 0,
            "content": "这样的密码称为移位密码。注意解密可以用"
        },
        {
            "type": "equation",
            "bbox": [
                0.355,
                0.605,
                0.584,
                0.622
            ],
            "angle": 0,
            "content": "\\[\nf ^ {- 1} (p) = (p - k) \\bmod 2 6\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.625,
                0.122,
                0.64
            ],
            "angle": 0,
            "content": "来完成。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.644,
                0.643,
                0.66
            ],
            "angle": 0,
            "content": "这里整数 \\(k\\) 成为密钥(key)。例2和3解释了移位密码的使用。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.665,
                0.807,
                0.682
            ],
            "angle": 0,
            "content": "例2 用密钥为 \\(k = 11\\) 的移位密码加密明文消息“STOP GLOBAL WARMING”。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.687,
                0.895,
                0.722
            ],
            "angle": 0,
            "content": "解 要加密消息“STOP GLOBAL WARMING”，我们首先把每个字母翻译成 \\(\\mathbf{Z}_{26}\\) 中对应的元素。得到数字串"
        },
        {
            "type": "equation",
            "bbox": [
                0.236,
                0.725,
                0.705,
                0.74
            ],
            "angle": 0,
            "content": "\\[\n1 8 1 9 1 4 1 5 \\quad 6 1 1 1 4 1 0 1 1 \\quad 2 2 0 1 7 1 2 8 1 3 6\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.744,
                0.63,
                0.761
            ],
            "angle": 0,
            "content": "对数字串中的每个数应用移位函数 \\( f(p) = (p + 11) \\mod 26 \\) 。得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.231,
                0.764,
                0.711,
                0.779
            ],
            "angle": 0,
            "content": "\\[\n3 4 2 5 0 \\quad 1 7 2 2 2 5 1 2 1 1 2 2 \\quad 7 1 1 2 2 3 1 9 2 4 1 7\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.783,
                0.789,
                0.799
            ],
            "angle": 0,
            "content": "将这最后所得的数字串翻译成字母，即得到密文“DEZA RWZMLW HLCXTYR”。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.804,
                0.897,
                0.842
            ],
            "angle": 0,
            "content": "例3解密用密钥为 \\(k = 7\\) 的移位密码加密的密文消息“LEWLYPLUJL PZ H NYLHA ALHJOLY”。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.846,
                0.897,
                0.881
            ],
            "angle": 0,
            "content": "解 要解密密文消息“LEWLYPLUJL PZ H NYLHA ALHJOLY”，我们首先把字母翻译成 \\(\\mathbf{Z}_{26}\\) 中的元素。得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.107,
                0.884,
                0.84,
                0.899
            ],
            "angle": 0,
            "content": "\\[\n1 1 4 2 2 1 1 2 4 1 5 1 1 2 0 9 1 1 \\quad 1 5 2 5 \\quad 7 \\quad 1 3 2 4 1 1 7 0 \\quad 0 1 1 7 9 1 4 1 1 2 4\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.903,
                0.479,
                0.919
            ],
            "angle": 0,
            "content": "接下来，对这个数移动 \\(-k = -7\\) 模26位，得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.146,
                0.922,
                0.801,
                0.937
            ],
            "angle": 0,
            "content": "\\[\n4 2 3 1 5 4 1 7 8 4 1 3 2 4 \\quad 8. 1 8 \\quad 0 \\quad 6 1 7 4 0 1 9 \\quad 1 9 4 0 2 7 4 1 7\n\\]"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.141,
                0.038,
                0.178,
                0.052
            ],
            "angle": 0,
            "content": "262"
        },
        {
            "type": "header",
            "bbox": [
                0.223,
                0.037,
                0.29,
                0.052
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.093,
                0.916,
                0.109
            ],
            "angle": 0,
            "content": "最后，将这些数翻译回字母以获得明文。我们得到“EXPERIENCE IS A GREAT TEACHER”。"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.113,
                0.695,
                0.129
            ],
            "angle": 0,
            "content": "我们可以用下列形式的函数扩展移位密码以进一步加强安全性。"
        },
        {
            "type": "equation",
            "bbox": [
                0.425,
                0.132,
                0.646,
                0.148
            ],
            "angle": 0,
            "content": "\\[\nf (p) = (a p + b) \\bmod 2 6\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.15,
                0.959,
                0.186
            ],
            "angle": 0,
            "content": "其中 \\(a\\) 和 \\(b\\) 为整数，其选择需保证 \\(f\\) 是一个双射函数。（函数 \\(f(p) = (ap + b) \\mod 26\\) 是双射函数当且仅当 \\(\\gcd(a, 26) = 1\\)。）这样的映射称为仿射变换，这种密码称为是仿射密码。"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.19,
                0.843,
                0.208
            ],
            "angle": 0,
            "content": "例4 当用函数 \\( f(p) = (7p + 3) \\mod 26 \\) 进行加密时，用什么字母替换字母K？"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.212,
                0.96,
                0.248
            ],
            "angle": 0,
            "content": "解 首先，注意到10代表K。然后，用指定的加密函数，可得到 \\( f(10) = (7 \\cdot 10 + 3) \\mod 26 = 21 \\) 。因为21代表V，所以在加密消息中用V代表字母K。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.25,
                0.959,
                0.362
            ],
            "angle": 0,
            "content": "我们现在证明如何解密用仿射密码加密的消息。假设 \\(c = (ap + b) \\bmod 26\\) 且满足 \\(\\gcd(a, 26) = 1\\) 。为了解密，我们需要知道如何用 \\(c\\) 来表示 \\(p\\) 。为此，我们采用加密同余方程 \\(c \\equiv (ap + b) \\bmod 26\\) ，然后求解获得 \\(p\\) 。为此，首先在两边减去 \\(b\\) ，得到 \\(c - b \\equiv ap \\pmod{26}\\) 。因为 \\(\\gcd(a, 26) = 1\\) ，所以我们知道存在 \\(a\\) 模26的逆 \\(\\overline{a}\\) 。在最后的等式两边乘以 \\(\\overline{a}\\) ，可得 \\(\\overline{a} (c - b) \\equiv \\overline{a} ap \\pmod{26}\\) 。因为 \\(\\overline{a} a \\equiv 1 \\pmod{26}\\) ，所以这就说明 \\(p \\equiv \\overline{a} (c - b) \\pmod{26}\\) 。因为 \\(p\\) 属于 \\(\\mathbf{Z}_{26}\\) ，所以这就可以确定 \\(p\\) 了。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.363,
                0.959,
                0.419
            ],
            "angle": 0,
            "content": "密码分析 在不具有加密方法和密钥知识的情况下从密文中恢复出明文的过程称为密码分析或破译密码。通常，密码分析是一个很困难的过程，特别是当不知道加密方法的时候。我们不做一般性的密码分析讨论，而是要解释如何破译用移位密码加密的消息。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.42,
                0.959,
                0.646
            ],
            "angle": 0,
            "content": "如果我们知道密文消息是采用移位密码对消息加密生成的，我们就可以通过对密文中所有字母尝试26种可能的移位（包括移动零个字符）来试图恢复消息。其中之一保证是明文消息。可是，我们还可以使用更智能的方法，可以用从其他的密码所得的密文来进行密码分析。对以移位密码加密的密文进行密码分析的主要工具是利用密文中字母频率的统计。英语中最常用的9个字母及其大概的相对频率是E \\(13\\%\\) 、T \\(9\\%\\) 、A \\(8\\%\\) 、O \\(8\\%\\) 、I \\(7\\%\\) 、N \\(7\\%\\) 、S \\(7\\%\\) 、H \\(6\\%\\) 和R \\(6\\%\\) 。要破解已知是用移位密码产生的密文，首先须找出密文中字母的相对频率。将密文中最常出现的字母按频率排序。我们假设密文中最常出现的字母是由E加密而成的。然后，我们在这个假设下来确定移位的值，比如说 \\(k\\) 。如果通过将密文移一 \\(k\\) 位后具有含义，我们认为假设是正确的，并且已经得到正确的 \\(k\\) 值。如果没有含义，接下来就考虑假设密文中最常出现的字母是由T(英语中第二个最常出现的字母)加密而成的，在该假设下找到 \\(k\\) ，将消息中的字母移一 \\(k\\) 位，再看看结果消息是否有意义。如果没有，继续从最常见的字母到最不常见的字母尝试该处理过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.65,
                0.957,
                0.689
            ],
            "angle": 0,
            "content": "例5 假设我们截获了已知是采用移位密码加密的密文消息 ZNK_KGXRE_HOXJ_MKZY_ZNK_CUXS。原始的明文消息是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.691,
                0.957,
                0.784
            ],
            "angle": 0,
            "content": "解 因为已知截获的密文消息是由移位密码加密而成的，所以我们从计算密文中字母出现的频率开始。容易得到密文中最常出现的字母是K。所以，我们假设移位密码将明文字母E移位到了密文字母K。如果这个假设是正确的，可知 \\(10 = 4 + k \\mod 26\\) ，所以 \\(k = 6\\) 。接下来，将密文消息的字母移-6位，得到THE EARLY BIRD GETS THE WORM。因为这个消息是有意义的，所以我们认为 \\(k = 6\\) 的假设是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.786,
                0.957,
                0.861
            ],
            "angle": 0,
            "content": "分组密码 移位密码和仿射密码是用字母表的一个字母来替换字母表中的另一个字母来实现的。因此，这些密码被称为字符或单码密码。这种加密方法面对基于密文中字母频率分析的攻击是很脆弱的，正如前面解释的。通过用一组字母替换另一组字母而不是用单独的字母替换另一个字母的方式可以强化成功破译密文的难度，这样的密码被称为分组密码(block cipher)。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.862,
                0.957,
                0.937
            ],
            "angle": 0,
            "content": "现在介绍一种简单的分组密码，称为换位密码。我们用作密钥的集合是 \\(\\{1,2,\\dots ,m\\}\\) 上的一个置换 \\(\\sigma\\) ，即从 \\(\\{1,2,\\dots ,m\\}\\) 到 \\(\\{1,2,\\dots ,m\\}\\) 的一个一对一函数，这里 \\(m\\) 是正整数。要加密消息，先将其字母分成大小为 \\(m\\) 的分组。（如果消息中字母数不能被 \\(m\\) 整除，可以在结尾加上一些随机的字母填充构成最后一个分组。）将分组 \\(p_1p_2\\dots p_m\\) 加密为 \\(c_{1}c_{2}\\dots c_{m} = p_{\\sigma (1)}p_{\\sigma (2)}\\dots\\)"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.646,
                0.039,
                0.778,
                0.055
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.825,
                0.041,
                0.861,
                0.054
            ],
            "angle": 0,
            "content": "263"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.096,
                0.889,
                0.131
            ],
            "angle": 0,
            "content": "\\(p_{\\sigma(m)}\\) 。要解密密文分组 \\(c_1 c_2 \\cdots c_m\\) 时，用 \\(\\sigma\\) 的逆置换 \\(\\sigma^{-1}\\) 对其字母进行换位。例6解释换位密码的加密和解密。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.137,
                0.889,
                0.176
            ],
            "angle": 0,
            "content": "例6 利用基于集合 \\(\\{1, 2, 3, 4\\}\\) 上的置换 \\(\\sigma\\) 的换位密码，其中 \\(\\sigma(1) = 3\\) ，\\((2) = 1\\) ，\\(\\sigma(3) = 4\\) ，\\(\\sigma(4) = 2\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.179,
                0.43,
                0.194
            ],
            "angle": 0,
            "content": "(a)加密明文消息PIRATETACK。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.198,
                0.645,
                0.214
            ],
            "angle": 0,
            "content": "(b)解密密文消息SWUE TRAE OEHS，这是由该密码加密的。"
        },
        {
            "type": "list",
            "bbox": [
                0.082,
                0.179,
                0.645,
                0.214
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.218,
                0.889,
                0.273
            ],
            "angle": 0,
            "content": "解（a)首先将明文中的字母划分为4个字母一组。得到PIRATETATTACK。要加密每个分组，我们把第一个字母移到第三位，把第二个字母移到第一位，把第三个字母移到第四位，再把第四个字母移到第二位。得到IAPRETTAAKTC。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.276,
                0.889,
                0.331
            ],
            "angle": 0,
            "content": "(b) 注意，\\(\\sigma\\) 的逆置换 \\(\\sigma^{-1}\\) 把 1 变为 2，2 变为 4，3 变为 1，4 变为 3。对每个分组应用 \\(\\sigma^{-1}(m)\\) 可得明文 USEWATER HOSE。（将这些字母重新分组形成常用词汇，我们猜测明文是 USE WATER HOSE。）"
        },
        {
            "type": "list",
            "bbox": [
                0.043,
                0.218,
                0.889,
                0.331
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.334,
                0.886,
                0.37
            ],
            "angle": 0,
            "content": "密码系统 我们已经定义了两类密码：移位密码和仿射密码。现在介绍密码系统的概念，它提供一个通用结构来定义一系列新的密码。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.378,
                0.88,
                0.456
            ],
            "angle": 0,
            "content": "定义1 密码系统(cryptosystem)是一个五元组 \\((\\mathcal{P}, \\mathcal{C}, \\mathcal{K}, \\mathcal{E}, \\mathcal{D})\\)，这里 \\(\\mathcal{P}\\) 明文串的集合，\\(\\mathcal{C}\\) 是密文串的集合，\\(\\mathcal{K}\\) 是密钥空间（所有可能的密钥的集合），\\(\\mathcal{E}\\) 是加密函数的集合，而 \\(\\mathcal{D}\\) 是解密函数的集合。我们用 \\(E_{k}\\) 表示在 \\(\\mathcal{E}\\) 中相对于密钥 \\(k\\) 的加密函数而 \\(D_{k}\\) 是 \\(\\mathcal{D}\\) 中用来解密由 \\(E_{k}\\) 加密的密文的解密函数，即对于所有明文串 \\(p\\) 有 \\(D_{k}(E_{k}(p)) = p\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.464,
                0.401,
                0.481
            ],
            "angle": 0,
            "content": "现在解释一下密码系统定义的应用。"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.487,
                0.474,
                0.504
            ],
            "angle": 0,
            "content": "例7 将移位密码系列描述为一个密码系统。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.509,
                0.889,
                0.643
            ],
            "angle": 0,
            "content": "解要用移位密码对英文字母串加密，首先将每个字母翻译成0到26的整数，即 \\(\\mathbf{Z}_{26}\\) 中的元素。然后，把这些中的每一个整数移动一个固定整数模26位，最后，将整数翻译回字母。要用密码系统的定义来描述移位密码，我们假设消息已经是整数了，即 \\(\\mathbf{Z}_{26}\\) 中的元素。即我们假设字母和整数之间的翻译处于密码系统的外部。因此，明文串的集合P和密文串的集合C都是 \\(\\mathbf{Z}_{26}\\) 中的元素串的集合。密钥集合K是所有可能的移位，所以 \\(\\kappa = \\mathbf{Z}_{26}\\) 。集合 \\(E\\) 由所有这样的函数 \\(E_{k}(p) = (p + k)\\bmod 26\\) 构成，而解密函数的集合D和加密函数的集合一样，其中 \\(D_{k}(p) = (p - k)\\bmod 26\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.079,
                0.645,
                0.728,
                0.663
            ],
            "angle": 0,
            "content": "密码系统的概念在讨论密码的系列时非常有用，并广泛应用于密码学中。"
        },
        {
            "type": "title",
            "bbox": [
                0.041,
                0.672,
                0.234,
                0.69
            ],
            "angle": 0,
            "content": "4.6.3 公钥密码学"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.693,
                0.889,
                0.767
            ],
            "angle": 0,
            "content": "所有古典密码，包括移位密码和仿射密码，都是私钥密码系统（private key cryptosystem）的实例。在私钥密码系统中，一旦你知道加密密钥，你就能很快找到解密密钥。所以，知道如何用一个特定的密钥加密消息就能让你解密用该密钥加密的消息。例如，当使用以 \\(k\\) 为密钥的移位密码时，明文整数 \\(p\\) 就发送为"
        },
        {
            "type": "equation",
            "bbox": [
                0.375,
                0.77,
                0.548,
                0.787
            ],
            "angle": 0,
            "content": "\\[\nc = (p + k) \\bmod 2 6\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.039,
                0.789,
                0.374,
                0.806
            ],
            "angle": 0,
            "content": "解密可以通过移 \\(-k\\) 位来实现的，即，"
        },
        {
            "type": "equation",
            "bbox": [
                0.375,
                0.809,
                0.548,
                0.826
            ],
            "angle": 0,
            "content": "\\[\np = (c - k) \\mathrm {m o d} 2 6\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.037,
                0.828,
                0.503,
                0.844
            ],
            "angle": 0,
            "content": "所以知道如何用移位密码加密也就知道如何解密了。"
        },
        {
            "type": "text",
            "bbox": [
                0.039,
                0.847,
                0.888,
                0.941
            ],
            "angle": 0,
            "content": "当采用私钥密码系统时，希望秘密通信的双方必须共享一个密钥。由于知道该密钥的任何人都可以轻易地为消息加密和解密，所以希望安全通信的双方就需要安全地交换该密钥。（我们在本节稍后介绍密钥交换的方法。）移位密码和仿射密码都是私钥密码系统。它们相当简单，但是面对密码分析也非常脆弱。可是，许多现代私钥密码系统却不然。特别是，现在私钥密码学的美国政府标准——高级加密标准（Advanced Encryption Standard，AES)是非常复杂的，并"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.145,
                0.042,
                0.18,
                0.056
            ],
            "angle": 0,
            "content": "264"
        },
        {
            "type": "header",
            "bbox": [
                0.227,
                0.042,
                0.291,
                0.057
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.097,
                0.965,
                0.171
            ],
            "angle": 0,
            "content": "被认为能很好地抵御密码分析。（关于AES的细节和其他现代私钥密码系统可参见[St06]。)AES广泛用于美国政府和商业通信。可是，它仍然具有共享安全通信密钥的特性。再者，为了更加安全，双方每次通信会话都需要用一个新密钥，这就需要一种能生成并安全分享密钥的方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.174,
                0.965,
                0.21
            ],
            "angle": 0,
            "content": "为了避免每对希望安全通信的双方都需要共享密钥，20世纪70年代密码学家引入了公钥密码系统(public key cryptosystem)的概念。当使用这种密码系统时，知道怎样发送加密消息的"
        },
        {
            "type": "image",
            "bbox": [
                0.12,
                0.225,
                0.189,
                0.248
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.123,
                0.261,
                0.26,
                0.369
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.123,
                0.374,
                0.236,
                0.394
            ],
            "angle": 0,
            "content": "Attribution: The Royal Society"
        },
        {
            "type": "text",
            "bbox": [
                0.28,
                0.261,
                0.969,
                0.399
            ],
            "angle": 0,
            "content": "克利福德·柯克斯（Clifford Cock，1950—）柯克斯出生于英国柴郡，是一个有才华的数学学生。他曾就读于曼彻斯特文法学校。1968年他赢得了国际数学奥林匹克竞赛银牌。柯克斯在剑桥大学国王学院上学，主修数学。他还在牛津大学工作了很短的时间研究数论。1973年，他决定放弃他的研究生学业，而在英国情报部门的政府通信总部（Government Communication Headquarter，GCHQ）从事数学方面的工作。加入GCHQ的两个月后，柯克斯从詹姆斯·埃利斯撰写的GCHQ内部报告了解到公共密钥加密系统。柯克斯利用他的数论知识发明了现在称为RSA的密码系统。他很快就意识到公共密钥加密系统可以基于两个大素数相乘其逆过程的难度。1997"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.402,
                0.972,
                0.471
            ],
            "angle": 0,
            "content": "年，他被允许披露已解密的GCHQ内部文件，其中描述了其发现。柯克斯还以其发明基于安全身份的加密模式而闻名，该模式使用用户的身份信息作为公钥。2001年柯克斯成为GCHQ英国情报中心的首席数学家。他还成立了海尔布隆数学研究所（Heilbronn Institute for Mathematical Research），这是GCHQ和布里斯托尔大学之间的一种伙伴关系。"
        },
        {
            "type": "image",
            "bbox": [
                0.126,
                0.494,
                0.267,
                0.605
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.127,
                0.609,
                0.272,
                0.62
            ],
            "angle": 0,
            "content": "Courtesy of Ronald L. Rivest"
        },
        {
            "type": "text",
            "bbox": [
                0.284,
                0.493,
                0.972,
                0.598
            ],
            "angle": 0,
            "content": "罗纳德·李维斯特（Ronald Rivest，1948—）1969年罗纳德·李维斯特获得耶鲁大学学士学位，1974年他获得斯坦福大学计算机科学博士学位。李维斯特是麻省理工学院计算机科学教授，也是RSA数据安全公司的合作创始人，该公司拥有他与沙米尔和阿德曼一起发明的RSA密码系统的专利。李维斯特的研究领域除了密码学外，还有机器学习、VLSI设计和计算机算法。他是一本流行的算法教材（[CoLeRiSt09]）的作者之一。"
        },
        {
            "type": "image",
            "bbox": [
                0.128,
                0.648,
                0.269,
                0.759
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.128,
                0.762,
                0.259,
                0.783
            ],
            "angle": 0,
            "content": "©The Asahi Shimbun via Getty Images"
        },
        {
            "type": "text",
            "bbox": [
                0.286,
                0.647,
                0.975,
                0.751
            ],
            "angle": 0,
            "content": "阿迪·沙米尔（Adi Shamir，1952—）阿迪·沙米尔出生在以色列特拉维夫。他的学士学位是在特拉维夫大学（1972年）完成的，而博士学位则是在魏茨曼科学研究院（1977年）完成的。沙米尔曾任Warwick大学的助理研究员和麻省理工学院的助理教授。他现在是魏茨曼研究院应用数学系的教授，并领导一个计算机安全研究小组。沙米尔对密码学的贡献除了RSA外，还有破解背包密码系统、数据加密标准（DES）的密码学分析，以及许多密码协议的设计。"
        },
        {
            "type": "image",
            "bbox": [
                0.132,
                0.802,
                0.271,
                0.911
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.13,
                0.915,
                0.237,
                0.935
            ],
            "angle": 0,
            "content": "Courtesy of Leonard Adleman"
        },
        {
            "type": "text",
            "bbox": [
                0.288,
                0.801,
                0.977,
                0.94
            ],
            "angle": 0,
            "content": "伦纳德·阿德曼(Leonard Adleman, 1945—) 伦纳德·阿德曼出生在加州的旧金山。他在加州大学伯克利分校获得数学学士学位(1968年)和计算机科学博士学位(1976年)。1976～1880年阿德曼是麻省理工学院数学系教员之一，那里他是RSA密码系统共同发明人，而1980年他在南加州大学(USC)计算机科学系任职。1985年他在USC获得有头衔的职位(Henry Salvatori教授)。阿德曼主要研究计算机安全、计算复杂度、免疫学和分子生物学。他发明了“计算机病毒”这个术语。最近阿德曼对DNA计算的研究工作引发了人们极大的兴趣。他是电影《偷窥者》(Sneakers)的技术顾问，影片中计算机安全扮演了重要角色。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.645,
                0.04,
                0.776,
                0.055
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.823,
                0.041,
                0.858,
                0.054
            ],
            "angle": 0,
            "content": "265"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.096,
                0.892,
                0.151
            ],
            "angle": 0,
            "content": "人并不能解密消息。在这样的系统中，每个人都可以有一个众所周知的加密密钥。只有解密密钥是保密的，而且只有消息的预期接收人能解密。这是因为，迄今为止，如果不做非常大量的计算（例如几十亿年计算机时间），即使具有加密密钥的知识也不能恢复出明文消息。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.153,
                0.892,
                0.248
            ],
            "angle": 0,
            "content": "第一个公钥密码系统是20世纪70年代中期发明的。在随后的几十年里又有更多的公钥密码系统被开发出来。在本书中，我们将介绍最常用的公钥密码系统，即RSA系统。除了RSA，现在很多应用系统中还会使用一些其他的公钥密码系统。随着计算技术的发展，RSA也可能像其他密码系统一样被淘汰，这些公钥密码系统将会发挥更重要的作用。我们将解释为什么会这么短暂。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.25,
                0.892,
                0.306
            ],
            "angle": 0,
            "content": "尽管公钥密码系统的优势是保密通信的双方不需要交换密钥，但其劣势是加密解密都会非常耗时。对许多应用而言，这将使得公钥密码系统变得不实用。在这种情形下，通常是私钥密码系统取而代之。然而，公钥密码系统仍可以用于密钥的交换过程。"
        },
        {
            "type": "title",
            "bbox": [
                0.045,
                0.316,
                0.265,
                0.334
            ],
            "angle": 0,
            "content": "4.6.4 RSA密码系统"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.336,
                0.892,
                0.488
            ],
            "angle": 0,
            "content": "1976年，麻省理工学院的三位研究人员——罗纳德·李维斯特、阿迪·沙米尔和伦纳德·阿德曼——给这个世界带来了一种公钥密码系统，即由发明者首字母命名的RSA系统。正如在密码学领域经常会发生的事，RSA系统早些年在英国政府的秘密研究中已经被发现了。为英国政府通信总部（Government Communications Headquarters，GCHQ）秘密工作的克利福德·柯克斯(Clifford Cocks)早在1973年就发现了这个密码系统。可是，直到20世纪90年代后期，当他被允许分享20世纪70年代早期的GCHQ秘密档案时，他的发明才为外部世界所知。（一个关于这个早期发现的很有趣的故事，以及李维斯特、沙米尔和阿德曼的工作，可以在[Si99]中找到。）"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.49,
                0.892,
                0.603
            ],
            "angle": 0,
            "content": "在 RSA 密码系统中，每个人都有一个加密密钥 \\((n, e)\\)，这里 \\( n = pq \\) 是一个由两个大素数，比如各有 300 位数字的 \\( p \\) 和 \\( q \\) 的乘积构成的模数，\\( e \\) 是与 \\((p - 1)(q - 1)\\) 互素的指数。要生成可用的密钥，必须找到两个大素数。这可以在一台计算机上借助本节前面提到的随机性素数性测试迅速完成。可是，这些素数的乘积 \\( n = pq \\) 大约有 600 位数字，迄今为止不可能在合理的时间内被因子分解。我们将看到，这正是迄今为止在没有另一个解密密钥时就不可能迅速解密的重要原因。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.606,
                0.892,
                0.719
            ],
            "angle": 0,
            "content": "评注 随着计算机运算速度的不断提升，用于生成 RSA 公钥的素数 \\( p \\) 和 \\( q \\) 的建议位数也在不断增加。但是，\\( n \\) 越大，RSA 的加密解密就会变得越慢。当折中考虑到这个因素时，消息需要被保密的年限就显得很重要了。一个更重要的考虑则是量子计算的发展直接威胁到 RSA 密码系统的安全，因为为量子计算机开发的因子分解算法能够用于快速分解大素数因子。因此，一旦量子计算成为现实，也许就在今后的二三十年内，那时就需要不能被量子计算破解的其他公钥密码系统了。"
        },
        {
            "type": "title",
            "bbox": [
                0.049,
                0.73,
                0.223,
                0.747
            ],
            "angle": 0,
            "content": "4.6.5 RSA加密"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.749,
                0.897,
                0.863
            ],
            "angle": 0,
            "content": "为了用特定的密钥 \\((n, e)\\) 对消息加密，首先将明文消息 \\(M\\) 翻译成整数序列。为此，可以先将每个明文字母翻译成两位数，正如在移位密码中所做的翻译，只有一点不同。即对于字母A到J增加开始的0，所以A被翻译为00，B为01，…，J为09。然后，将这些两位数连接起来构成数字串。接下来，将这个串再分成 \\(2N\\) 位数字等长的分组，这里 \\(2N\\) 是一个大偶数使得\\(2N\\) 位数字的整数 \\(2525\\dots 25\\) 不超过 \\(n\\)。（必要时，可以在明文消息后填充无意义的 \\(X\\) 使得最后一组的大小和其他分组一样。）"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.865,
                0.897,
                0.902
            ],
            "angle": 0,
            "content": "经过这些步骤，我们已经将明文消息 \\(M\\) 翻译成了一个整数序列 \\(m_{1}\\)，\\(m_{2}\\)，…，\\(m_{k}\\)，\\(k\\) 为整数。加密过程是将每个分组 \\(m_{i}\\) 转换成密文分组 \\(c_{i}\\)。这由下列函数实现"
        },
        {
            "type": "equation",
            "bbox": [
                0.408,
                0.906,
                0.54,
                0.921
            ],
            "angle": 0,
            "content": "\\[\nC = M ^ {e} \\bmod n\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.924,
                0.897,
                0.941
            ],
            "angle": 0,
            "content": "（为了执行加密，可以使用快速模指数算法，如4.2节的算法5。)所得加密后的消息依然是数的"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.129,
                0.038,
                0.164,
                0.052
            ],
            "angle": 0,
            "content": "266"
        },
        {
            "type": "header",
            "bbox": [
                0.211,
                0.037,
                0.275,
                0.052
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.093,
                0.946,
                0.129
            ],
            "angle": 0,
            "content": "分组形式，并发送给预期的接收者。因为RSA密码系统将字符分组加密成字符分组，所以这是一种分组密码。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.131,
                0.946,
                0.186
            ],
            "angle": 0,
            "content": "例8说明RSA加密是怎样进行的。为了方便实际操作，我们在例8中选用小素数 \\(p\\) 和 \\(q\\) 而不是200多位的大素数。尽管例8中描述的密码并不安全，但可以解释RSA密码中使用的技术。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.191,
                0.946,
                0.229
            ],
            "angle": 0,
            "content": "例8 用RSA密码系统及密钥(2537，13)为消息STOP加密。注意 \\(2537 = 43\\cdot 59\\) ， \\(p = 43\\) 和 \\(q = 59\\) 是素数，并且"
        },
        {
            "type": "equation",
            "bbox": [
                0.313,
                0.233,
                0.732,
                0.249
            ],
            "angle": 0,
            "content": "\\[\n\\operatorname * {g c d} (e, (p - 1) (q - 1)) = \\operatorname * {g c d} (1 3, 4 2 \\cdot 5 8) = 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.251,
                0.945,
                0.286
            ],
            "angle": 0,
            "content": "解为了加密，先把STOP的字母翻译成等价的数字。然后按4位数字一组对这些数字分组（因为 \\(2525 < 2537 < 252525\\)），得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.47,
                0.29,
                0.578,
                0.305
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{c c} 1 8 1 9 & 1 4 1 5 \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.308,
                0.329,
                0.325
            ],
            "angle": 0,
            "content": "用下面的映射对每组加密"
        },
        {
            "type": "equation",
            "bbox": [
                0.438,
                0.327,
                0.606,
                0.342
            ],
            "angle": 0,
            "content": "\\[\nC = M ^ {1 3} \\mod 2 5 3 7\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.345,
                0.945,
                0.381
            ],
            "angle": 0,
            "content": "用快速模乘法计算，可得 \\(1819^{13} \\mod 2537 = 2081\\) 及 \\(1415^{13} \\mod 2537 = 2182\\) 。加密后的消息为 20812182。"
        },
        {
            "type": "title",
            "bbox": [
                0.099,
                0.392,
                0.273,
                0.408
            ],
            "angle": 0,
            "content": "4.6.6 RSA解密"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.412,
                0.945,
                0.466
            ],
            "angle": 0,
            "content": "当已知解密密钥 \\(d\\) 即 \\(e\\) 模 \\((p - 1)(q - 1)\\) 的逆时，就可以很快地从密文消息恢复出明文消息。[由于 \\(\\gcd(e, (p - 1)(q - 1) = 1\\) ，所以逆存在。]为了说明这一点，注意如果 \\(de \\equiv 1 (\\mod (p - 1)(q - 1))\\) ，则有整数 \\(k\\) 使得 \\(de = 1 + k(p - 1)(q - 1)\\) 。由此可知"
        },
        {
            "type": "equation",
            "bbox": [
                0.333,
                0.468,
                0.71,
                0.485
            ],
            "angle": 0,
            "content": "\\[\nC ^ {d} \\equiv (M ^ {e}) ^ {d} \\equiv M ^ {d e} \\equiv M ^ {1 + k (p - 1) (q - 1)} (\\mathrm {m o d} n)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.487,
                0.945,
                0.523
            ],
            "angle": 0,
            "content": "根据费马小定理[假定 \\(\\gcd (M,p) = \\gcd (M,q) = 1\\) ，这一关系只有在极罕见的情况不成立，在练习28中会论及]，可得 \\(M^{p - 1}\\equiv 1(\\mathrm{mod} p)\\) 及 \\(M^{q - 1}\\equiv 1(\\mathrm{mod} q)\\) 。因此，"
        },
        {
            "type": "equation",
            "bbox": [
                0.323,
                0.525,
                0.719,
                0.542
            ],
            "angle": 0,
            "content": "\\[\nC ^ {d} \\equiv M \\cdot (M ^ {p - 1}) ^ {k (q - 1)} \\equiv M \\cdot 1 \\equiv M (\\mathrm {m o d} p)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.545,
                0.123,
                0.56
            ],
            "angle": 0,
            "content": "且"
        },
        {
            "type": "equation",
            "bbox": [
                0.323,
                0.563,
                0.717,
                0.58
            ],
            "angle": 0,
            "content": "\\[\nC ^ {d} \\equiv M \\cdot (M ^ {q - 1}) ^ {k (p - 1)} \\equiv M \\cdot 1 \\equiv M (\\mathrm {m o d} q)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.583,
                0.518,
                0.599
            ],
            "angle": 0,
            "content": "由于 \\(\\gcd (p,q) = 1\\) ，所以由中国剩余定理可得"
        },
        {
            "type": "equation",
            "bbox": [
                0.439,
                0.601,
                0.602,
                0.618
            ],
            "angle": 0,
            "content": "\\[\nC ^ {d} \\equiv M (\\mathrm {m o d} p q)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.62,
                0.573,
                0.637
            ],
            "angle": 0,
            "content": "例9说明怎样解密由RSA密码系统发送的消息。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.641,
                0.945,
                0.68
            ],
            "angle": 0,
            "content": "例9 收到的加密消信是09810461。如果这是用例8中的RSA密码加密的，解密后的消信息是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.682,
                0.945,
                0.736
            ],
            "angle": 0,
            "content": "解 该消息是用RSA密码系统以 \\(n = 43 \\cdot 59\\) 和指数13加密的。如4.4节练习2所证明的，\\(d = 937\\) 是13模 \\(42 \\cdot 58 = 2436\\) 的逆。可以利用937作为解密指数。因此，为解密数字分组 \\(C\\) 需要计算"
        },
        {
            "type": "equation",
            "bbox": [
                0.434,
                0.739,
                0.609,
                0.755
            ],
            "angle": 0,
            "content": "\\[\nM = C ^ {9 3 7} \\bmod 2 5 3 7\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.757,
                0.945,
                0.794
            ],
            "angle": 0,
            "content": "为解密该消息，利用快速模指数算法计算 \\(0981^{937} \\mod 2537 = 0704\\) 及 \\(0461^{937} \\mod 2537 = 1115\\)。因此，原始消息的数字形式是07041115。翻译成英文字母，可知消信息是HELP。"
        },
        {
            "type": "title",
            "bbox": [
                0.099,
                0.804,
                0.392,
                0.821
            ],
            "angle": 0,
            "content": "4.6.7 用RSA作为公钥系统"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.824,
                0.946,
                0.937
            ],
            "angle": 0,
            "content": "为什么RSA密码系统适合作为公钥密码呢？首先，通过找寻两个各有300多位的大素数 \\( p \\) 和 \\( q \\)，再找寻一个与 \\( (p - 1)(q - 1) \\) 互素的整数 \\( e \\)，就可能迅速构造一个公钥。当知道模数 \\( n \\) 的因子分解，即知道素数 \\( p \\) 和 \\( q \\) 时，我们就可以迅速找到 \\( e \\) 模 \\( (p - 1)(q - 1) \\) 的逆 \\( d \\) 。[这可以利用欧几里得算法寻找 \\( d \\) 和 \\( (p - 1)(q - 1) \\) 的贝祖系数 \\( s \\) 和 \\( t \\) 来完成，这表明 \\( d \\) 模 \\( (p - 1)(q - 1) \\) 的逆是 \\( s \\bmod (p - 1)(q - 1) \\) 。]有了 \\( d \\) 就使得我们可以解密用加密密钥发送的消息。可是，没有一种已知的解密方法不是基于寻找 \\( n \\) 的因子分解式的，或者说也不导致 \\( n \\) 的因子分解。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.653,
                0.035,
                0.785,
                0.051
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.832,
                0.037,
                0.868,
                0.049
            ],
            "angle": 0,
            "content": "267"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.091,
                0.897,
                0.166
            ],
            "angle": 0,
            "content": "因子分解被认为是一个困难的问题，与之相反的是寻找大素数 \\( p \\) 和 \\( q \\)，这可以迅速完成。迄今为止（截至2017年）已知最有效的因子分解方法需要数十亿年才能分解600位的整数。因此，当 \\( p \\) 和 \\( q \\) 都是300位的素数时，我们相信采用 \\( n = pq \\) 为模加密的消息不可能在合理的时间内被解密，除非已知素数 \\( p \\) 和 \\( q \\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.167,
                0.897,
                0.28
            ],
            "angle": 0,
            "content": "尽管没有已知的多项式时间算法来实现大整数因子分解，但人们正在积极研究以求发现能有效分解整数的新方法。几年以前还被认为由于太大而不可能在合理的时间内分解的整数，现在做因子分解已经成为例行常事了。超过300位的整数，已经可以在团队努力下被因子分解了。当新的分解技术问世时，就必须使用更大的素数以确保消息安全。不幸的是，先前认为安全的消息可能被非预期接收者所保存，并在稍后当RSA加密所用密钥中的 \\(n = pq\\) 的因子分解变得可行时而得以解密。（注意，一旦量子计算可用，RSA系统就不再安全了。）"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.282,
                0.897,
                0.356
            ],
            "angle": 0,
            "content": "RSA方法现在得到了广泛使用。可是，最常用的密码系统仍是私钥密码系统。借助RSA系统，公钥密码系统的使用也在不断增长。尽管如此，有些应用既使用私钥又使用公钥。例如，像RSA这样的公钥系统可以用来为希望通信的双方分发私钥。然后这些人利用私钥系统来为消息加密和解密。"
        },
        {
            "type": "title",
            "bbox": [
                0.05,
                0.367,
                0.218,
                0.383
            ],
            "angle": 0,
            "content": "4.6.8 密码协议"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.386,
                0.897,
                0.479
            ],
            "angle": 0,
            "content": "至此，我们已经展示了密码学如何可以使得消息更安全。可是，密码学还有许多其他重要的应用。其中就有密码协议（cryptographic protocol），这是两方或多方为了达到一个特定的安全目标而进行的消息交换。特别是，我们将证明密码学如何能让双方在一个不安全的通信信道上交换密钥。我们还将证明密码学可以用来发送签名的秘密消息使得接收者能确定消息来自声称的发送者。关于各种密码协议的深入讨论读者可以参考[St05]。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.481,
                0.897,
                0.613
            ],
            "angle": 0,
            "content": "密钥交换 现在讨论在双方以往没有共享过任何信息的情况下可以用来在不安全的通信信道上交换密钥的协议。生成一个双方可以共享的密钥对于密码学的很多应用都非常重要。例如，两个人为了要用私钥密码系统相互发送秘密消息，他们就需要共享一个公共的密钥。我们要描述的协议称为是迪菲-赫尔曼密钥协商协议（Diffie-Hellman key agreement protocol），由惠特菲尔德·迪菲和马丁·赫尔曼的名字命名，他们在1976年描述了该协议。可是，这个协议早在1974年就由为英国GCHQ秘密工作的马尔科姆·威廉姆森（Malcolm Williamson）发明。直到1997年他的发现才公诸于世。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.614,
                0.894,
                0.651
            ],
            "angle": 0,
            "content": "假设 Alice 和 Bob 希望共享一个公共密钥。该协议执行以下步骤，其中的计算在 \\(\\mathbf{Z}_p\\) 中进行。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.654,
                0.581,
                0.668
            ],
            "angle": 0,
            "content": "1) Alice 和 Bob 同意使用一个素数 \\( p \\) 和 \\( p \\) 的一个原根 \\( a \\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.673,
                0.609,
                0.687
            ],
            "angle": 0,
            "content": "2) Alice 选择一个秘密整数 \\(k_{1}\\), 并将 \\(a^{k_{1}} \\bmod p\\) 发送给 Bob。"
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.692,
                0.605,
                0.706
            ],
            "angle": 0,
            "content": "3) Bob 选择一个秘密整数 \\(k_{2}\\), 并将 \\(a^{k_{2}} \\bmod p\\) 发送给 Alice。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.712,
                0.322,
                0.726
            ],
            "angle": 0,
            "content": "4) Alice 计算 \\((a^{k_2})^{k_1} \\bmod p\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.73,
                0.312,
                0.745
            ],
            "angle": 0,
            "content": "5) Bob 计算 \\((a^{k_1})^{k_2} \\bmod p\\)。"
        },
        {
            "type": "list",
            "bbox": [
                0.084,
                0.654,
                0.609,
                0.745
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.748,
                0.594,
                0.765
            ],
            "angle": 0,
            "content": "在协议的最后，Alice和Bob已经计算了他们共享的密钥，即"
        },
        {
            "type": "equation",
            "bbox": [
                0.341,
                0.767,
                0.601,
                0.785
            ],
            "angle": 0,
            "content": "\\[\n\\left(a ^ {k _ {2}}\\right) ^ {k _ {1}} \\boldsymbol {\\operatorname {m o d}} p = \\left(a ^ {k _ {1}}\\right) ^ {k _ {2}} \\boldsymbol {\\operatorname {m o d}} p\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.786,
                0.897,
                0.937
            ],
            "angle": 0,
            "content": "为了分析这个协议的安全性，注意在步骤1、2和3中并不假定是安全发送的。我们甚至可以假设这些通信是明文的，且其内容也是公开的信息。所以， \\( p \\) 、 \\( a \\) 、 \\( a^{k_1} \\mod p \\) 和 \\( a^{k_2} \\mod p \\) 都可以假设为公开的信息。协议确保 \\( k_1 \\) 、 \\( k_2 \\) 以及公共密钥 \\( (a^{k_2})^{k_1} \\mod p = (a^{k_1})^{k_2} \\mod p \\) 是保密的。要从这个公开信息中找出秘密信息就要求对手能够求解离散对数问题的实例，因为对手需要从 \\( a^{k_1} \\mod p \\) 和 \\( a^{k_2} \\mod p \\) 中分别找出 \\( k_1 \\) 和 \\( k_2 \\) 。再者，已知没有其他方法可以从这些公开信息中找出共享密钥。我们已经注意到当 \\( p \\) 和 \\( a \\) 足够大时从计算角度来说这被认为是不可行的。以现有的计算能力来看，当 \\( p \\) 超过300位十进制数字而 \\( k_1 \\) 和 \\( k_2 \\) 又各有超过100位的十进制数字时，这个系统被认为是不可破解的。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.137,
                0.038,
                0.173,
                0.051
            ],
            "angle": 0,
            "content": "268"
        },
        {
            "type": "header",
            "bbox": [
                0.218,
                0.036,
                0.284,
                0.052
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.093,
                0.959,
                0.166
            ],
            "angle": 0,
            "content": "数字签名 密码学不仅可以用来确保消息的保密性，还可以用来使得消息的接收者知道消息来自那个该来自的人。我们首先证明如何发送一个消息使得消息的接收者能够肯定消息来自于声称该消息的发送者。特别是，我们可以证明这个可以利用 RSA 密码系统对消息施加数字签名来完成。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.17,
                0.96,
                0.283
            ],
            "angle": 0,
            "content": "假设 Alice 的 RSA 公钥是 \\((n, e)\\) 而她的私钥是 \\(d\\)。Alice 用加密函数 \\(E_{(n,e)}(x) = x^e \\bmod n\\) 加密明文消息 \\(x\\)。她用解密函数 \\(D_{(n,e)}(x) = x^d \\bmod n\\) 解密密文消息 \\(y\\)。Alice 想要发送消息 \\(M\\) 使得每个收到该消息的人都知道来自于她。就像 RSA 加密一样，她将字母翻译成对应的数值并将所得的串分割成分组 \\(m_1, m_2, \\dots, m_k\\) 使得每个分组具有相同大小，并且其大小在满足 \\(0 \\leqslant m_i \\leqslant n\\) 时尽可能大，\\(i = 1, 2, \\dots, k\\)。然后她针对每个分组应用她的解密函数 \\(D_{(n,e)}\\)，得到 \\(D_{n,e}(m_i)\\)，\\(i = 1, 2, \\dots, k\\)。她将结果发送给所有预期的消息接收者。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.286,
                0.96,
                0.36
            ],
            "angle": 0,
            "content": "当接收者收到她的消息时，他们针对每个分组应用Alice的加密函数 \\(E_{(n,e)}\\) ，因为Alice的密钥 \\((n,e)\\) 是公开信息，所以每个人都有。因为 \\(E_{(n,e)}(D_{(n,e)}(x)) = x\\) ，所以结果就是原始的明文消息。所以，Alice可以将她的消息发送给她愿意给的许多人，并用这种方式签名，每个接收者可以确信它来自于Alice。例10解释这个协议。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.365,
                0.96,
                0.423
            ],
            "angle": 0,
            "content": "例10 假设Alice的RSA公钥和例8中一样。即 \\(n = 2537 = 43 \\cdot 59\\) 和 \\(e = 13\\) 。她的解密密钥是 \\(d = 937\\) ，如例9所示。她想发送消息“MEET AT NOON”给她朋友使得他们能确信消息来自于她。她该如何发送？"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.426,
                0.96,
                0.5
            ],
            "angle": 0,
            "content": "解 Alice 首先将消息翻译成数字分组，得到 12040419001913141413（读者自行检验）。然后她对每个分组应用她的解密变换 \\( D_{(2537,13)}(x) = x^{937} \\mod 2537 \\)。利用快速模指数算法（可借助于计算机），她得出 \\( 1204^{937} \\mod 2537 = 817 \\)，\\( 419^{937} \\mod 2537 = 555 \\)，\\( 19^{937} \\mod 2537 = 1310 \\)，\\( 1314^{937} \\mod 2537 = 2173 \\) 和 \\( 1413^{937} \\mod 2537 = 1026 \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.503,
                0.96,
                0.558
            ],
            "angle": 0,
            "content": "所以，她发送的消息成分组就是08170555131021731026。当她的朋友收到该消息时，他们针对每个分组应用她的加密变换 \\(E_{(2537,13)}\\) 。这样做之后，他们获得原始消息的数字分组，然后再翻译回英文字母。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.561,
                0.96,
                0.635
            ],
            "angle": 0,
            "content": "我们已经展示了可以利用 RSA 密码系统发送签名消息。我们还可以进一步发送签名的秘密消息。为此，发送者首先用自己的解密变换加密分组，再用一个预期接收者公开的加密密钥对这些分组进行 RSA 加密。接收者首先应用他的私有解密变换，然后再应用发送者的公开的加密变换。（练习 32 要求实现该协议。）"
        },
        {
            "type": "title",
            "bbox": [
                0.114,
                0.646,
                0.289,
                0.662
            ],
            "angle": 0,
            "content": "4.6.9 同态加密"
        },
        {
            "type": "text",
            "bbox": [
                0.154,
                0.666,
                0.962,
                0.683
            ],
            "angle": 0,
            "content": "RSA这样的密码系统可以用于加密文档以使之处于保密状态。如今，很多用户把加密的"
        },
        {
            "type": "title",
            "bbox": [
                0.116,
                0.692,
                0.162,
                0.706
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.118,
                0.724,
                0.26,
                0.836
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.117,
                0.84,
                0.241,
                0.869
            ],
            "angle": 0,
            "content": "Source: John D. & Catherine T. MacArthur Foundation"
        },
        {
            "type": "text",
            "bbox": [
                0.275,
                0.724,
                0.965,
                0.81
            ],
            "angle": 0,
            "content": "克雷格·金特里(Craig B. Gentry，1972—）金特里于1993年获得杜克大学学士学位，1998年获得哈佛大学法学院法学博士。他做了两年的知识产权律师。2000年到2005年他在NTT DoCoMo美国实验室任高级研究工程师。后来他决定重返校园，2009年他获得了斯坦福大学计算机科学博士学位。2009年金特里加入IBM Watson研究院的密码研究小组，工作至今。"
        },
        {
            "type": "text",
            "bbox": [
                0.275,
                0.813,
                0.965,
                0.881
            ],
            "angle": 0,
            "content": "金特里发明的全同态模式解决了1978年提出的一个开放问题，也为他赢得了2010年ACM的Grace Murray Hopper奖。2013年，金特里与人合作构建了第一个加密多线性图，并用它构建了第一个加密程序混淆方案，这是一个很多人曾认为可能不存在的东西。金特里关于全同态加密和加密多线性图的工作是在格密码学的基础"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.883,
                0.965,
                0.934
            ],
            "angle": 0,
            "content": "上进行的。格密码学与 RSA 密码系统不同，它不能被量子计算所破解。金特里和同事一起推进了可验证计算领域的发展，它允许计算机卸载计算功能到其他计算机，同时保持可验证的结果。2014 年金特里获得了麦克阿瑟奖（即天才奖）。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.654,
                0.038,
                0.785,
                0.052
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.832,
                0.039,
                0.867,
                0.051
            ],
            "angle": 0,
            "content": "269"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.094,
                0.902,
                0.264
            ],
            "angle": 0,
            "content": "文档存放在云(cloud)上，驻留在远端计算机中。运行程序时，经常需要用到存储在云端的数据。如果我们在云上运行程序而不下载这些数据，它们就很容易受到能访问存储数据的远程计算机的攻击。如果我们下载文档并在自己的计算机上运行程序，然后再上载结果到云上，数据也容易受到窃听者的攻击。如果直接在加密的数据上运行程序，是否可能避免遭受攻击呢？虽然初看起来有些牵强，但在RSA推出后不久的1979年，人们就提出了这个问题，即是否有这样一个密码系统，允许在加密数据上做任何计算并能够产生由该非加密输入所得的非加密输出的加密形式。有了这样的密码系统，就不需要解密数据了，因为程序可以在远端系统上运行而不必解密输入或输出数据。因此，人们开始研究全同态密码系统（fully homomorphic cryptosystem），允许在远端加密数据上运行任意计算。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.266,
                0.902,
                0.302
            ],
            "angle": 0,
            "content": "在讨论全同态加密的研究进展之前，我们先证明一下RSA密码系统不是全同态的，虽然它也允许某些计算在加密数据上进行。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.307,
                0.9,
                0.345
            ],
            "angle": 0,
            "content": "例11 RSA是偏同态的（partially homomorphic）令 \\((n,e)\\) 是RSA密码系统的一个公钥，并假设 \\(M_{1}\\) 和 \\(M_{2}\\) 是明文消息，因而 \\(0\\leqslant M_1 < n\\) 且 \\(0\\leqslant M_2 < n\\) 。则"
        },
        {
            "type": "equation",
            "bbox": [
                0.199,
                0.349,
                0.754,
                0.384
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} E _ {(n, e)} \\left(M _ {1}\\right) E _ {(n, e)} \\left(M _ {2}\\right) \\mod m = \\left(M _ {1} ^ {e} \\mod m \\cdot M _ {2} ^ {e} \\mod m\\right) \\mod m \\\\ = \\left(M _ {1} M _ {2}\\right) ^ {e} \\boldsymbol {\\operatorname {m o d}} m = E _ {(n, e)} \\left(M _ {1} M _ {2}\\right) \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.387,
                0.902,
                0.442
            ],
            "angle": 0,
            "content": "从该等式可知在 \\(\\mathbf{Z}_n\\) 中有 \\(E(n, e)(M_1) \\cdot {}_n E_{(n, e)}(M_2) = E_{(n, e)}(M_1 M_2)\\) 。因此，我们说RSA是乘法同态的。用RSA加密时，可以不必先解码而直接进行乘法运算，因为明文乘积的密文等于各自密文的乘积。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.445,
                0.904,
                0.537
            ],
            "angle": 0,
            "content": "可是，当对 \\(\\mathbf{Z}_n\\) 中所有的 \\(M_{1}\\) 和 \\(M_2\\) 有 \\(E_{(n,e)}(M_1) + _nE_{(n,e)}(M_2) = E_{(n,e)}(M_1 + M_2)\\) 时，则结论不成立。（比如，当 \\(M_2 = 1\\) 时很容易看明白了。）也就是说，当我们用RSA加密时，不能通过两个数的密文相加来获得它们的和的密文。再者，如果不先解密两个密文，目前还没有已知的方法能够从 \\(E_{(n,e)}(M_1)\\) 和 \\(E_{(n,e)}(M_2)\\) 来确定 \\(E_{(n,e)}(M_1 + M_2)\\) 。我们说RSA不是加法同态的。因为它是乘法同态的，但不是加法同态的，所以RSA是偏同态的。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.539,
                0.904,
                0.595
            ],
            "angle": 0,
            "content": "2009年，克雷格·金特里阐述了第一个全同态密码系统，它是基于格密码学的。遗憾的是，目前还没有开发出实用的全同态密码系统，因为需要非常大量的计算处理和存储。我们希望在不久的将来，新的发展会引领出实际可用的全同态密码系统。"
        },
        {
            "type": "title",
            "bbox": [
                0.058,
                0.606,
                0.102,
                0.621
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.625,
                0.905,
                0.657
            ],
            "angle": 0,
            "content": "1. 试通过把字母翻译成数字，再应用给定的加密函数，再将数字翻译回字母来加密消息 DO NOT PAAS GO。"
        },
        {
            "type": "text",
            "bbox": [
                0.079,
                0.661,
                0.365,
                0.676
            ],
            "angle": 0,
            "content": "a) \\( f(p) = (p + 3) \\mod 26 \\) （恺撒密码）"
        },
        {
            "type": "text",
            "bbox": [
                0.4,
                0.661,
                0.603,
                0.675
            ],
            "angle": 0,
            "content": "b) \\(f(p) = (p + 13)\\mod 26\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.656,
                0.661,
                0.856,
                0.675
            ],
            "angle": 0,
            "content": "c) \\(f(p) = (3p + 7)\\bmod 26\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.678,
                0.905,
                0.71
            ],
            "angle": 0,
            "content": "2. 试通过把字母翻译成数字，再应用给定的加密函数，再将数字翻译回字母，来加密消息 STOP POLLUTION。"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.714,
                0.273,
                0.728
            ],
            "angle": 0,
            "content": "a) \\(f(p) = (p + 4)\\mathrm{mod}26\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.4,
                0.714,
                0.603,
                0.727
            ],
            "angle": 0,
            "content": "b) \\(f(p) = (p + 21)\\mod 26\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.657,
                0.714,
                0.875,
                0.727
            ],
            "angle": 0,
            "content": "c) \\( f(p) = (17p + 22) \\mod 26 \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.731,
                0.905,
                0.762
            ],
            "angle": 0,
            "content": "3. 试通过把字母翻译成数字，再应用给定的加密函数，再将数字翻译回字母来加密消息 WATCH YOUR STEP。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.767,
                0.29,
                0.781
            ],
            "angle": 0,
            "content": "a） \\(f(p) = (p + 14)\\mathrm{mod}26\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.402,
                0.767,
                0.621,
                0.781
            ],
            "angle": 0,
            "content": "b) \\( f(p) = (14p + 21) \\mod 26 \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.658,
                0.767,
                0.876,
                0.781
            ],
            "angle": 0,
            "content": "c) \\(f(p) = (-7p + 1)\\mod 26\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.784,
                0.371,
                0.798
            ],
            "angle": 0,
            "content": "4. 试解密下列用恺撒密码加密的消息。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.802,
                0.235,
                0.815
            ],
            "angle": 0,
            "content": "a)EOXH MHDQV"
        },
        {
            "type": "text",
            "bbox": [
                0.402,
                0.802,
                0.561,
                0.815
            ],
            "angle": 0,
            "content": "b)WHVW WRGDB"
        },
        {
            "type": "text",
            "bbox": [
                0.658,
                0.802,
                0.808,
                0.815
            ],
            "angle": 0,
            "content": "c) HDW GLP VXP"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.82,
                0.562,
                0.834
            ],
            "angle": 0,
            "content": "5. 试解密下列用移位密码 \\( f(p) = (p + 10) \\mod 26 \\) 加密的消息。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.837,
                0.259,
                0.85
            ],
            "angle": 0,
            "content": "a)CEBBOXNOB XYG"
        },
        {
            "type": "text",
            "bbox": [
                0.402,
                0.838,
                0.557,
                0.85
            ],
            "angle": 0,
            "content": "b)LO WI PBSOXN"
        },
        {
            "type": "text",
            "bbox": [
                0.658,
                0.838,
                0.815,
                0.85
            ],
            "angle": 0,
            "content": "c)DSWO PYB PEX"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.854,
                0.905,
                0.886
            ],
            "angle": 0,
            "content": "6. 假设当一个很长的文本串是用移位密码 \\( f(p) = (p + k) \\mod 26 \\) 加密的，在密文中最常出现的字母是 X。假设文本中字母的分布具有典型的英文文本特性，\\( k \\) 最有可能的值是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.889,
                0.907,
                0.921
            ],
            "angle": 0,
            "content": "7. 假设当英文文本串是用移位密码 \\( f(p) = (p + k) \\mod 26 \\) 加密的，结果密文是 DY CVOOZ ZOBMRKXMO DY NBOKW。请问原始明文串是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.924,
                0.907,
                0.939
            ],
            "angle": 0,
            "content": "8. 假设密文DVE CFMV KF NFEUVI，REU KYRK ZJ KYV JVVU FW JTZVETV是用移位密码对明文"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.127,
                0.038,
                0.164,
                0.051
            ],
            "angle": 0,
            "content": "270"
        },
        {
            "type": "header",
            "bbox": [
                0.21,
                0.036,
                0.275,
                0.052
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.093,
                0.452,
                0.108
            ],
            "angle": 0,
            "content": "消息加密而成的。请问原始明文是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.111,
                0.949,
                0.144
            ],
            "angle": 0,
            "content": "9. 假设密文 ERC WYJJMGMIRXPC EHZERGIH XIGLRSPSKC MW MRHMWXMRKYMWLEFPI JVSQ QEKMG 是用移位密码对明文消息加密而成的。请问原始明文是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.146,
                0.7,
                0.16
            ],
            "angle": 0,
            "content": "10. 判断是否存在这样一个密钥使得移位密码的加密函数和解密函数相同。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.163,
                0.781,
                0.178
            ],
            "angle": 0,
            "content": "11. 如果一个仿射密码的加密函数是 \\( c = (15p + 13) \\mod 26 \\)，请问其解密函数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.181,
                0.891,
                0.195
            ],
            "angle": 0,
            "content": "* 12. 找出仿射密码的所有整数对 \\((a, b)\\) 使得其加密函数 \\(c = (ap + b) \\bmod 26\\) 与相应的解密函数相同。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.198,
                0.945,
                0.23
            ],
            "angle": 0,
            "content": "13. 假设在用仿射密码 \\( f(p) = (ap + b) \\mod 26 \\) 加密明文产生的一个长密文中最常出现和次常出现的字母分别是 Z 和 J。请问 \\( a \\) 和 \\( b \\) 的值最有可能是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.234,
                0.945,
                0.284
            ],
            "angle": 0,
            "content": "14. 采用5个字母的分组以及基于{1，2，3，4，5}上的置换 \\(\\sigma\\) 的换位密码对消息GRIZZLYBEARS进行加密，其中 \\(\\sigma (1) = 3\\) ， \\(\\sigma (2) = 5\\) ， \\(\\sigma (3) = 1\\) ， \\(\\sigma (4) = 2\\) ， \\(\\sigma (5) = 4\\) 。这个练习中需要时用字母X填充最后一个少于5个字母的分组。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.287,
                0.945,
                0.319
            ],
            "angle": 0,
            "content": "15. 试解密由4个字母的分组和基于 \\(\\{1,2,3,4\\}\\) 上的置换 \\(\\sigma\\) 的换位密码加密明文消息产生的密文消息EABWEFROATMRASIN，其中 \\(\\sigma (1) = 3\\) ， \\(\\sigma (2) = 1\\) ， \\(\\sigma (3) = 4\\) ， \\(\\sigma (4) = 2\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.322,
                0.683,
                0.337
            ],
            "angle": 0,
            "content": "* 16. 假设你知道密文是由换位密码加密明文产生的。你会如何去破解它？"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.339,
                0.945,
                0.372
            ],
            "angle": 0,
            "content": "17. 假设你截获了一则密文消息，并且当你在判定这则消息中的字母频率时，发现频率和英文文本的字母频率类似。你会怀疑这里使用了哪种密码？"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.375,
                0.945,
                0.477
            ],
            "angle": 0,
            "content": "维吉尼亚密码（Vigenère cipher）是分组密码，密钥是一字母串，其对应的数值是 \\(k_{1}k_{2}\\dots k_{m}\\)，这里 \\(k_{i}\\in \\mathbf{Z}_{26}\\)，\\(i = 1,2,\\dots ,m\\)。假设明文分组中字母对应的数值是 \\(p_1p_2\\dots p_m\\)。密文分组对应的数值是\\((p_{1} + k_{1})\\bmod 26(p_{2} + k_{2})\\bmod 26\\dots (p_{m} + k_{m})\\bmod 26\\)。最后翻译回字母。例如，假设密钥是RED，其数值为1743。明文是ORANGE，其数值为141700130604，首先分成两组141700和130604，然后再加密。对每个分组中的第一个字母移17位，第二个4位，第三个3位。我们得到052103和041007。密文就是FVDEKH。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.48,
                0.605,
                0.495
            ],
            "angle": 0,
            "content": "18. 利用维吉尼亚密码以及密钥 BLUE 加密消息 SNOWFALL。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.498,
                0.945,
                0.53
            ],
            "angle": 0,
            "content": "19. 利用维吉尼亚密码以及密钥 HOT 加密明文消息所生成的密文是 OIKYWVHBX。请问明文消息是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.533,
                0.42,
                0.547
            ],
            "angle": 0,
            "content": "20. 试将维吉尼亚密码表述为密码系统。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.551,
                0.945,
                0.583
            ],
            "angle": 0,
            "content": "为了在没有密钥的情况下破解维吉尼亚密码，从密文消息中恢复出明文消息，首先要找出密钥的长度。然后通过判定相应的移位来找出密钥的每个字符。练习21和22就涉及这两方面。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.586,
                0.945,
                0.618
            ],
            "angle": 0,
            "content": "21. 假设当一个很长的文本串用维吉尼亚密码加密时，在密文的不同位置开始可以找到相同的串。试解释这个信息如何能有助于确定密钥的长度。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.621,
                0.945,
                0.653
            ],
            "angle": 0,
            "content": "22. 一旦已知维吉尼亚密码的密钥长度，试解释如何确定其每个字符。假设明文足够长，这样其字母的频率合理地接近典型英文文本中的字母频率。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.656,
                0.945,
                0.688
            ],
            "angle": 0,
            "content": "* 23. 证明当我们知道 \\( n \\) 是两个素数 \\( p \\) 和 \\( q \\) 的乘积，并且知道 \\( (p - 1)(q - 1) \\) 的值时，就可以很容易地分解 \\( n \\) 的因子。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.691,
                0.896,
                0.706
            ],
            "angle": 0,
            "content": "在练习 \\(24\\sim 27\\) 中，首先无须计算模指数而直接表达你的答案，然后借助于计算工具执行这些计算。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.709,
                0.945,
                0.741
            ],
            "angle": 0,
            "content": "24. 利用 RSA 系统加密消息 ATTACK，其中 \\( n = 43 \\cdot 59 \\) 且 \\( e = 13 \\)，如例 8 所示，将每个字母翻译成整数，再按整数对分组。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.744,
                0.945,
                0.776
            ],
            "angle": 0,
            "content": "25. 利用 RSA 系统加密消息 uploadAD，其中 \\( n = 53 \\cdot 61 \\) 且 \\( e = 17 \\)，如例 8 所示，将每个字母翻译成整数，再按整数对分组。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.779,
                0.945,
                0.811
            ],
            "angle": 0,
            "content": "26. 如果采用 RSA 系统以及 \\( n = 53 \\cdot 61 \\) 且 \\( e = 17 \\) 加密的消息是 3185203824602550，则原始消息是什么？（为了解密，首先找出解密指数 \\( d \\)，这是 \\( e = 17 \\) 模 52·60 的逆。）"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.814,
                0.945,
                0.846
            ],
            "angle": 0,
            "content": "27. 如果采用 RSA 系统以及 \\( n = 43 \\cdot 59 \\) 且 \\( e = 13 \\) 加密的消息是 066719470671，则原始消息是什么？（为了解密，首先找出解密指数 \\( d \\)，这是 \\( e = 13 \\) 模 \\( 42 \\cdot 58 \\) 的逆。）"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.85,
                0.945,
                0.917
            ],
            "angle": 0,
            "content": "* 28. 假设 \\((n, e)\\) 是 RSA 的加密密钥，\\(n = pq\\)，这里 \\(p\\) 和 \\(q\\) 是大素数且 \\(\\gcd(e, (p-1)(q-1)) = 1\\)。再者，假设 \\(d\\) 是 \\(e\\) 模 \\((p-1)(q-1)\\) 的逆。假设 \\(C \\equiv M^e (\\bmod pq)\\)。在前文中我们证明了当 \\(\\gcd(M, pq) = 1\\) 时 RSA 解密函数，即同余式 \\(C^d \\equiv M (\\bmod pq)\\) 成立。证明解密同余式当 \\(\\gcd(M, pq) > 1\\) 时也成立。[提示：利用模 \\(p\\) 和模 \\(q\\) 的同余式，应用中国剩余定理。]"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.92,
                0.945,
                0.935
            ],
            "angle": 0,
            "content": "29. 试描述当 Alice 和 Bob 利用迪菲-赫尔曼密钥交换协议来生成一个共享密钥时的步骤。假设采用素数"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.655,
                0.037,
                0.787,
                0.052
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.833,
                0.038,
                0.868,
                0.051
            ],
            "angle": 0,
            "content": "271"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.093,
                0.898,
                0.125
            ],
            "angle": 0,
            "content": "\\(p = 23\\) ， \\(a = 5\\) ，即23的一个原根，并且Alice选择 \\(k_{1} = 8\\) 而Bob选择 \\(k_{2} = 5\\) 。（可能需要借助计算工具。）"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.128,
                0.899,
                0.178
            ],
            "angle": 0,
            "content": "30. 试描述当 Alice 和 Bob 利用迪菲-赫尔曼密钥交换协议来生成一个共享密钥时的步骤。假设采用素数 \\( p = 101 \\)，\\( a = 2 \\)，即 101 的一个原根，并且 Alice 选择 \\( k_{1} = 7 \\) 而 Bob 选择 \\( k_{2} = 9 \\)。（可能需要借助计算工具。）"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.181,
                0.899,
                0.232
            ],
            "angle": 0,
            "content": "在练习 \\(31\\sim 32\\) 中假设Alice和Bob拥有公钥和相应的私钥： \\((n_{\\mathrm{Alice}},e_{\\mathrm{Alice}}) = (2867,7) = (61\\cdot 47,7)\\) \\(d_{\\mathrm{Alice}} = 1183\\) 和 \\((n_{\\mathrm{Bob}},e_{\\mathrm{Bob}}) = (3127,21) = (59\\cdot 53,21),d_{\\mathrm{Bob}} = 1149\\) 。首先不做计算写出你的答案。然后，可能的话利用计算工具执行计算以获得数字答案。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.235,
                0.899,
                0.268
            ],
            "angle": 0,
            "content": "31. Alice 想要给她所有朋友包括 Bob 发送消息“SELL EVERYTHING”以便他知道是她发送的。假设她利用 RSA 密码系统在消息上签名，她应该给她的朋友发送什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.271,
                0.899,
                0.303
            ],
            "angle": 0,
            "content": "32. Alice 想要给 Bob 发送消息“BUY NOW”以便他知道是她发送的并且只有 Bob 能够阅读。假设她在消息上签名并利用 Bob 的公钥加密，她应该给 Bob 发送什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.306,
                0.899,
                0.374
            ],
            "angle": 0,
            "content": "33. 我们现在描述采用私钥密码学的一个基本密钥交换协议，许多更复杂的密钥交换协议都基于此。协议中的加密是采用被认为是安全的私钥密码系统（如AES）完成的。协议涉及三方：Alice和Bob、他们希望交换的密钥，以及一个可信的第三方Cathy。假设Alice拥有只有她和Cathy知道的密钥 \\(k_{\\text{Alice}}\\) 而Bob拥有只有他和Cathy知道的密钥 \\(k_{\\text{Bob}}\\) 。协议分三个步骤："
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.377,
                0.884,
                0.392
            ],
            "angle": 0,
            "content": "(i) Alice 给可信的第三方 Cathy 发送一则用 Alice 的密钥 \\(k_{\\text{Alice}}\\) 加密的消息“请求与 Bob 共享一个密钥”。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.395,
                0.896,
                0.427
            ],
            "angle": 0,
            "content": "(ii) Cathy 返回 Alice 一个密钥 \\( k_{\\text{Alice, Bob}} \\)，这是她生成并用密钥 \\( k_{\\text{Alice}} \\) 加密的，接着发送同一个密钥 \\( k_{\\text{Alice, Bob}} \\)，这次是用 Bob 的密钥 \\( k_{\\text{Bob}} \\) 加密的。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.431,
                0.712,
                0.446
            ],
            "angle": 0,
            "content": "(iii) Alice 给 Bob 发送密钥 \\( k_{\\text{Alice, Bob}} \\)，是用只有 Bob 和 Cathy 知道的 \\( k_{\\text{Bob}} \\) 加密的。"
        },
        {
            "type": "list",
            "bbox": [
                0.081,
                0.377,
                0.896,
                0.446
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.449,
                0.76,
                0.463
            ],
            "angle": 0,
            "content": "试解释为什么这个协议允许Alice和Bob共享只有他们和Cathy知道的私钥 \\(k_{\\mathrm{Alice,Bob}}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.466,
                0.899,
                0.538
            ],
            "angle": 0,
            "content": "Paillier密码系统是P.Paillier在1999年设计的公钥密码系统，用于某些电子投票系统。随机选择素数 \\(p\\) 和 \\(q\\) 满足 \\(\\gcd (pq,\\lambda) = 1\\) ，其中 \\(\\lambda = (p - 1)(q - 1)\\) ； \\(\\mathbf{Z}_{n^2}\\) 中的非零元素 \\(g\\) 满足 \\(\\gcd ((g^{\\lambda \\bmod n^2} - 1) / n,n) = 1\\) 以此生成公钥 \\((n,g)\\) 和相应的私钥 \\((p,q)\\) 。为了加密消息 \\(m\\in \\mathbf{Z}_n\\) ，首先随机选择 \\(\\mathbf{Z}_n\\) 的一个非零元素 \\(r\\) 然后计算 \\(c = g^{m}r^{n}\\mod n^{2}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.541,
                0.899,
                0.574
            ],
            "angle": 0,
            "content": "34. a) 令 \\( p = 149 \\)，\\( q = 179 \\)，\\( g = 5 \\)，通过检查这些参数满足所有条件来证明可以用来生成 Paillier 密码系统的一个公钥，并求出这些参数生成的公钥和私钥。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.577,
                0.498,
                0.591
            ],
            "angle": 0,
            "content": "b)求出对应于明文 \\(m = 67\\) 的密文，这里选择 \\(r = 81\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.594,
                0.398,
                0.609
            ],
            "angle": 0,
            "content": "35. 试证明Paillier密码系统是加法同态的。"
        },
        {
            "type": "title",
            "bbox": [
                0.051,
                0.643,
                0.236,
                0.662
            ],
            "angle": 0,
            "content": "关键术语和结论"
        },
        {
            "type": "title",
            "bbox": [
                0.051,
                0.671,
                0.097,
                0.687
            ],
            "angle": 0,
            "content": "术语"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.691,
                0.468,
                0.707
            ],
            "angle": 0,
            "content": "\\(a \\mid b (a\\) 整除 \\(b, a\\) divides \\(b)\\) ：存在整数 \\(c\\) 使得 \\(b = ac\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.71,
                0.699,
                0.726
            ],
            "angle": 0,
            "content": "\\(a\\) 和 \\(b\\) 模 \\(m\\) 同余 \\((a\\) and \\(b\\) are congruent modulo m: m divides \\(a - b\\)): \\(m\\) 整除 \\(a - b\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.728,
                0.59,
                0.743
            ],
            "angle": 0,
            "content": "模算术（modular arithmetic）：以一个整数 \\(m \\geq 2\\) 为模数所做的计算。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.746,
                0.466,
                0.761
            ],
            "angle": 0,
            "content": "素数（prim）：大于1且恰有两个正整数因子的整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.764,
                0.414,
                0.778
            ],
            "angle": 0,
            "content": "合数（composite）：大于1又不是素数的整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.781,
                0.574,
                0.796
            ],
            "angle": 0,
            "content": "梅森素数（Mersenne prime）：形如 \\(2^{p} - 1\\) 的素数，其中 \\(p\\) 为素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.799,
                0.831,
                0.814
            ],
            "angle": 0,
            "content": "\\(\\gcd (a,b)(a\\) 和 \\(b\\) 的最大公约数，greatest common divisor of \\(a\\) and \\(b)\\) ：能整除 \\(a\\) 和 \\(b\\) 的最大整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.817,
                0.619,
                0.832
            ],
            "angle": 0,
            "content": "互素整数(relatively prime integers)：满足 \\(\\gcd(a, b) = 1\\) 的整数 \\(a\\) 和 \\(b\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.835,
                0.799,
                0.849
            ],
            "angle": 0,
            "content": "两两互素的整数（pairwise relatively prime integers）：其中任何两个整数都是互素的一组整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.852,
                0.855,
                0.867
            ],
            "angle": 0,
            "content": "\\(\\operatorname{lcm}(a, b)\\) （\\(a\\) 和 \\(b\\) 的最小公倍数，least common multiple of \\(a\\) and \\(b\\)）：能被 \\(a\\) 和 \\(b\\) 整除的最小正整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.87,
                0.398,
                0.884
            ],
            "angle": 0,
            "content": "\\(a \\mod b\\) ：当整数 \\(a\\) 除以正整数 \\(b\\) 时的余数。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.888,
                0.712,
                0.903
            ],
            "angle": 0,
            "content": "\\(a \\equiv b (\\bmod m) (a \\text{ 模 } m \\text{ 同余于 } b, a \\text{ is congruent to } b \\bmod u; a - b \\text{ 能被 } m \\text{ 整除。}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.906,
                0.357,
                0.92
            ],
            "angle": 0,
            "content": "\\(n = (a_{k}a_{k - 1}\\dots a_{1}a_{0})_{b}\\) ： \\(n\\) 的 \\(b\\) 进制表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.923,
                0.537,
                0.938
            ],
            "angle": 0,
            "content": "二进制表示（binary representation）：整数以2为基数的表示。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.139,
                0.036,
                0.177,
                0.05
            ],
            "angle": 0,
            "content": "272"
        },
        {
            "type": "header",
            "bbox": [
                0.221,
                0.035,
                0.288,
                0.051
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.092,
                0.62,
                0.106
            ],
            "angle": 0,
            "content": "十六进制表示(octal representation)：整数以16为基数的表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.11,
                0.65,
                0.124
            ],
            "angle": 0,
            "content": "八进制表示（hexadecimal representation）：整数以8为基数的表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.128,
                0.96,
                0.16
            ],
            "angle": 0,
            "content": "\\(a\\) 和 \\(b\\) 的整系数线性组合（linear combination of \\(a\\) and \\(b\\) with integer coefficients）：形如 \\(sa + tb\\) 的表达式，其中 \\(s\\) 和 \\(t\\) 为整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.163,
                0.962,
                0.195
            ],
            "angle": 0,
            "content": "\\(a\\) 和 \\(b\\) 的贝祖系数(Bézout coefficients of \\(a\\) and \\(b\\)): 使得贝祖恒等式(Bézout identity) \\(sa + tb = \\gcd(a, b)\\) 成立的整数 \\(s\\) 和 \\(t\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.199,
                0.695,
                0.213
            ],
            "angle": 0,
            "content": "\\(a\\) 模 \\(m\\) 的逆(inverse of \\(a\\) modulo \\(m\\)): 使得 \\(\\overline{a} a \\equiv 1 (\\bmod m)\\) 成立的整数 \\(\\overline{a}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.216,
                0.81,
                0.231
            ],
            "angle": 0,
            "content": "线性同余方程（linear congruence）：形如 \\(ax \\equiv b (\\bmod m)\\) 的同余式，其中 \\(x\\) 为整数变量。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.234,
                0.806,
                0.248
            ],
            "angle": 0,
            "content": "以 \\(b\\) 为基数的伪素数(pseudoprime to the base \\(b\\)): 使得 \\(b^{n-1} \\equiv 1 (\\mathrm{mod} n)\\) 成立的合数 \\(n\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.252,
                0.962,
                0.284
            ],
            "angle": 0,
            "content": "卡米切尔数(Carmichael number)：合数 \\(n\\) 使得对所有满足 \\(\\gcd (b,n) = 1\\) 的正整数 \\(b\\) ， \\(n\\) 是以 \\(b\\) 为基数的伪素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.287,
                0.962,
                0.32
            ],
            "angle": 0,
            "content": "素数 \\(p\\) 的原根(primitive root of a prime \\(p\\)): \\(\\mathbf{Z}_p\\) 中的整数 \\(r\\) 使得每个不能被 \\(p\\) 整除的整数模 \\(p\\) 同余 \\(r\\) 的一个幂次。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.323,
                0.962,
                0.355
            ],
            "angle": 0,
            "content": "以 \\(r\\) 为底 \\(a\\) 模 \\(p\\) 的离散对数(discrete logarithm of \\(a\\) to the base \\(r\\) modulo \\(p\\)): 满足 \\(0 \\leqslant e \\leqslant p - 1\\) 使得 \\(r^e \\equiv a \\pmod{p}\\) 的整数 \\(e\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.358,
                0.468,
                0.373
            ],
            "angle": 0,
            "content": "加密(encryption)：使消息成为秘密的过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.376,
                0.58,
                0.391
            ],
            "angle": 0,
            "content": "解密(decryption)：将秘密消息还原到它原始形式的过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.394,
                0.65,
                0.409
            ],
            "angle": 0,
            "content": "加密密钥(encryption key)：确定选用加密函数系列中哪一个的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.412,
                0.753,
                0.427
            ],
            "angle": 0,
            "content": "移位密码（shift cipher）：将明文字母 \\( p \\) 加密成 \\( (p + k) \\bmod m \\) 的密码， \\( k \\) 为整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.43,
                0.956,
                0.445
            ],
            "angle": 0,
            "content": "仿射密码(affinecipher)：将明文字母 \\(p\\) 加密成 \\((ap + b)\\bmod m\\) 的密码， \\(a\\) 和 \\(b\\) 是整数且满足 \\(\\gcd (a,26) = 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.448,
                0.531,
                0.462
            ],
            "angle": 0,
            "content": "字符密码(character cipher)：逐个字符加密的密码。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.465,
                0.557,
                0.48
            ],
            "angle": 0,
            "content": "分组密码(block cipher)：按等长字符分组加密的密码。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.483,
                0.962,
                0.515
            ],
            "angle": 0,
            "content": "密码分析（crytanalysis）：在没有加密方法的知识或有加密方法但没有密钥的情况下，试图从密文恢复出明文的过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.518,
                0.962,
                0.551
            ],
            "angle": 0,
            "content": "密码系统(cryptosystem)：一个五元组 \\((\\mathcal{P},\\mathcal{C},\\mathcal{K},\\mathcal{E},\\mathcal{D})\\) ，这里 \\(\\mathcal{P}\\) 明文消息的集合， \\(\\mathcal{C}\\) 是密文消息的集合， \\(\\kappa\\) 是密钥的集合， \\(\\varepsilon\\) 是加密函数的集合，而 \\(\\mathcal{D}\\) 是解密函数的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.554,
                0.729,
                0.569
            ],
            "angle": 0,
            "content": "私钥加密(private key encryption)：加密密钥和解密密钥均须保密的加密法。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.571,
                0.724,
                0.586
            ],
            "angle": 0,
            "content": "公钥加密（public key encryption）：加密密钥公开，解密密钥保密的加密法。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.589,
                0.965,
                0.64
            ],
            "angle": 0,
            "content": "RSA密码系统(RSACryptosystem)：密码系统，其中 \\(\\mathcal{P}\\) 和 \\(\\mathcal{C}\\) 均为 \\(\\mathbf{Z}_{26}\\)，\\(\\mathcal{K}\\) 是整数对 \\(k = (n,e)\\) 的集合，\\(n = pq\\)，\\(p\\) 和 \\(q\\) 是大素数，而 \\(e\\) 是正整数，\\(E_{k}(p) = p^{e} \\mod n\\)，\\(D_{k}(c) = c^{d} \\mod n\\)，这里 \\(d\\) 是 \\(e\\) 模 \\((p - 1)(q - 1)\\) 的逆。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.643,
                0.711,
                0.658
            ],
            "angle": 0,
            "content": "密钥交换协议（key exchange protocol）：用来为双方生成共享密钥的协议。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.66,
                0.922,
                0.676
            ],
            "angle": 0,
            "content": "数字签名（digital signature）：接收者可以用来判定消息声称的发送者确实发送了该消息的一种方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.678,
                0.965,
                0.711
            ],
            "angle": 0,
            "content": "全同态密码系统（fully homomorphic cryptosystem）：一个密码系统，允许在加密数据上进行任何计算，以使得输出是非加密输入对应的非加密输出的加密形式。"
        },
        {
            "type": "title",
            "bbox": [
                0.119,
                0.722,
                0.168,
                0.737
            ],
            "angle": 0,
            "content": "结论"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.741,
                0.967,
                0.775
            ],
            "angle": 0,
            "content": "整除算法(division algorithm)：令 \\(a\\) 和 \\(d\\) 为整数，\\(d\\) 为正整数。则存在唯一的整数 \\(q\\) 和 \\(r\\)，满足 \\(0 \\leqslant r < d\\) 使得 \\(a = dq + r\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.777,
                0.946,
                0.811
            ],
            "angle": 0,
            "content": "令 \\(b\\) 是大于1的正整数。则如果 \\(n\\) 是正整数，\\(n\\) 就能唯一表示为 \\(n = a_{k}b^{k} + a_{k - 1}b^{k - 1} + \\dots +a_{1}b + a_{0}\\) 的形式。计算整数的 \\(b\\) 进制展开式的算法（参见4.2节算法1）。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.813,
                0.448,
                0.828
            ],
            "angle": 0,
            "content": "整数加法和乘法的传统算法（见4.2节）。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.831,
                0.406,
                0.846
            ],
            "angle": 0,
            "content": "快速模指数算法（见4.2节算法5）。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.848,
                0.87,
                0.864
            ],
            "angle": 0,
            "content": "欧几里得算法(Euclidean algorithm)：通过连续使用除法算法求最大公约数(参见4.3节算法1)。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.866,
                0.87,
                0.881
            ],
            "angle": 0,
            "content": "贝祖定理(Bézout's theorem)：如果 \\(a\\) 和 \\(b\\) 是正整数，则 \\(\\gcd(a, b)\\) 是 \\(a\\) 和 \\(b\\) 的一个线性组合。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.884,
                0.945,
                0.899
            ],
            "angle": 0,
            "content": "埃拉托斯特尼筛法（sieve of Eratosthenes）：寻找不超过指定整数 \\(n\\) 的所有素数的过程，如4.3节所述。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.901,
                0.967,
                0.934
            ],
            "angle": 0,
            "content": "算术基本定理(fundamental theorem of arithmetic)：每个正整数都可以写成素数的乘积，其中素因子以递增序排列。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.65,
                0.035,
                0.782,
                0.05
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.829,
                0.036,
                0.865,
                0.049
            ],
            "angle": 0,
            "content": "273"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.091,
                0.472,
                0.105
            ],
            "angle": 0,
            "content": "如果 \\(a, b\\) 为正整数，则 \\(ab = \\gcd(a, b) \\cdot \\operatorname{lcm}(a, b)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.109,
                0.52,
                0.124
            ],
            "angle": 0,
            "content": "如果 \\(m\\) 是正整数且 \\(\\gcd (a,m) = 1\\) ，则 \\(a\\) 有唯一的模 \\(m\\) 逆。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.127,
                0.895,
                0.159
            ],
            "angle": 0,
            "content": "中国剩余定理(孙子定理)(Chinese remainder theorem)：以一组两两互素的整数为模的线性同余方程组在以模数之积为模的意义下有唯一解。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.162,
                0.714,
                0.177
            ],
            "angle": 0,
            "content": "费马小定理(Fermat's little theorem)：如果 \\(p\\) 为素数且 \\(p \\nmid a\\)，则 \\(a^{p-1} \\equiv 1 (\\mathrm{mod} p)\\)。"
        },
        {
            "type": "title",
            "bbox": [
                0.05,
                0.192,
                0.131,
                0.211
            ],
            "angle": 0,
            "content": "复习题"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.219,
                0.322,
                0.233
            ],
            "angle": 0,
            "content": "1. 找出 210 div 17 和 210 mod 17。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.237,
                0.34,
                0.251
            ],
            "angle": 0,
            "content": "2. a) 试定义 \\(a\\) 和 \\(b\\) 模7同余是什么。"
        },
        {
            "type": "text",
            "bbox": [
                0.068,
                0.255,
                0.607,
                0.269
            ],
            "angle": 0,
            "content": "b) \\(-11, -8, -7, -1, 0, 3\\) 和 17 中哪些整数对是模 7 同余的？"
        },
        {
            "type": "text",
            "bbox": [
                0.069,
                0.273,
                0.639,
                0.288
            ],
            "angle": 0,
            "content": "c) 证明如果 \\(a\\) 和 \\(b\\) 模7同余，则 \\(10a + 13\\) 和 \\(-4b + 20\\) 也是模7同余的。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.291,
                0.605,
                0.305
            ],
            "angle": 0,
            "content": "3. 证明如果 \\(a \\equiv b (\\bmod m)\\) 且 \\(c \\equiv d (\\bmod m)\\)，则 \\(a + c \\equiv b + d (\\bmod m)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.309,
                0.704,
                0.323
            ],
            "angle": 0,
            "content": "4. 试描述将整数的十进制（以10为基数的）展开式转换成十六进制展开式的过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.327,
                0.54,
                0.341
            ],
            "angle": 0,
            "content": "5. 将 \\((1101100101011011)_{2}\\) 转换成八进制和十六进制表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.345,
                0.415,
                0.359
            ],
            "angle": 0,
            "content": "6.将 \\((7206)_{8}\\) 和 \\(\\mathrm{(A0EB)}_{16}\\) 转换成二进制表示。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.363,
                0.232,
                0.377
            ],
            "angle": 0,
            "content": "7.叙述算术基本定理。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.381,
                0.435,
                0.394
            ],
            "angle": 0,
            "content": "8. a) 描述寻找一个整数的素因子分解式的过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.07,
                0.399,
                0.422,
                0.413
            ],
            "angle": 0,
            "content": "b)用这一过程找出80707的素因子分解式。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.417,
                0.325,
                0.431
            ],
            "angle": 0,
            "content": "9. a) 定义两个整数的最大公约数。"
        },
        {
            "type": "text",
            "bbox": [
                0.07,
                0.435,
                0.717,
                0.449
            ],
            "angle": 0,
            "content": "b)给出至少三种求两个整数最大公约数的方法。每种方法在什么情况下最有效？"
        },
        {
            "type": "text",
            "bbox": [
                0.071,
                0.453,
                0.415,
                0.467
            ],
            "angle": 0,
            "content": "c)求1234567和7654321的最大公约数。"
        },
        {
            "type": "text",
            "bbox": [
                0.071,
                0.47,
                0.442,
                0.485
            ],
            "angle": 0,
            "content": "d)求 \\(2^{3}3^{5}5^{7}7^{9}11\\) 和 \\(2^{9}3^{7}5^{5}7^{3}13\\) 的最大公约数。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.488,
                0.614,
                0.502
            ],
            "angle": 0,
            "content": "10. a)如何求两个整数的(整系数)线性组合，使之等于其最大公约数？"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.506,
                0.476,
                0.521
            ],
            "angle": 0,
            "content": "b)把gcd(84，119)表达为84和119的线性组合。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.524,
                0.337,
                0.538
            ],
            "angle": 0,
            "content": "11. a) \\(\\overline{a}\\) 为 \\(a\\) 模 \\(m\\) 的逆是什么意思？"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.542,
                0.563,
                0.557
            ],
            "angle": 0,
            "content": "b)当 \\(m\\) 是正整数且 \\(\\gcd (a,m) = 1\\) 时，怎样求 \\(a\\) 模 \\(m\\) 的逆？"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.56,
                0.232,
                0.574
            ],
            "angle": 0,
            "content": "c)求7模19的逆。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.578,
                0.717,
                0.592
            ],
            "angle": 0,
            "content": "12. a) 当 \\(\\gcd(a, m) = 1\\) 时，怎样用 \\(a\\) 模 \\(m\\) 的逆求解线性同余方程 \\(ax \\equiv b (\\bmod m)\\)?"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.596,
                0.399,
                0.61
            ],
            "angle": 0,
            "content": "b)求解线性同余方程 \\(7x\\equiv 13(\\mathrm{mod}19)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.614,
                0.261,
                0.628
            ],
            "angle": 0,
            "content": "13. a)叙述中国剩余定理"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.632,
                0.624,
                0.646
            ],
            "angle": 0,
            "content": "b)求同余方程组 \\(x\\equiv 1(\\mathrm{mod}4)\\) ， \\(x\\equiv 2(\\mathrm{mod}5)\\) 和 \\(x\\equiv 3(\\mathrm{mod}7)\\) 的解。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.65,
                0.411,
                0.664
            ],
            "angle": 0,
            "content": "14. 假定 \\(2^{n - 1} \\equiv 1 (\\mathrm{mod} n)\\) 。\\(n\\) 一定是素数吗？"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.668,
                0.357,
                0.682
            ],
            "angle": 0,
            "content": "15. 利用费马小定理计算 \\(9^{200} \\mod 19\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.686,
                0.434,
                0.7
            ],
            "angle": 0,
            "content": "16. 试解释如何找出 10 位数的 ISBN 的校验码。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.704,
                0.61,
                0.717
            ],
            "angle": 0,
            "content": "17. 试用移位密码和密钥 \\(k = 13\\) 加密消息APPLESANDORANGES。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.721,
                0.395,
                0.735
            ],
            "angle": 0,
            "content": "18. a) 公钥和私钥密码系统的区别是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.739,
                0.394,
                0.754
            ],
            "angle": 0,
            "content": "b)试解释为什么移位密码是私钥系统。"
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.757,
                0.438,
                0.772
            ],
            "angle": 0,
            "content": "c)试解释为什么RSA密码系统是公钥系统。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.776,
                0.496,
                0.789
            ],
            "angle": 0,
            "content": "19. 试解释 RSA 密码系统中加密和解密是如何实现的。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.793,
                0.551,
                0.808
            ],
            "angle": 0,
            "content": "20. 试描述双方如何利用迪菲-赫尔曼密钥交换协议共享密钥。"
        },
        {
            "type": "title",
            "bbox": [
                0.059,
                0.823,
                0.164,
                0.841
            ],
            "angle": 0,
            "content": "补充练习"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.849,
                0.905,
                0.9
            ],
            "angle": 0,
            "content": "1. 汽车里程表的最高读数是 100000 英里。当里程表读数是 43179 英里时，车主买了该车。现在他想卖掉它。当你检查车况时，注意到里程表读数是 89697 英里。假设里程表工作一直正常，关于该车行驶了多少英里能得出什么结论？"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.904,
                0.523,
                0.917
            ],
            "angle": 0,
            "content": "2. a) 试解释为什么 \\( n \\) div 7 等于 \\( n \\) 天中所含的完整星期数。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.921,
                0.533,
                0.936
            ],
            "angle": 0,
            "content": "b) 试解释为什么 \\( n \\) div 24 等于 \\( n \\) 小时中所含的完整天数。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.129,
                0.038,
                0.164,
                0.052
            ],
            "angle": 0,
            "content": "274"
        },
        {
            "type": "header",
            "bbox": [
                0.211,
                0.037,
                0.277,
                0.052
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.094,
                0.368,
                0.108
            ],
            "angle": 0,
            "content": "3. 找出四个与5模17同余的数。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.112,
                0.8,
                0.126
            ],
            "angle": 0,
            "content": "4. 证明如果 \\(a\\) 和 \\(d\\) 为正整数，则存在整数 \\(q\\) 和 \\(r\\) 使得 \\(a = dq + r\\) ，其中 \\(-d / 2 < r \\leqslant d / 2\\) 。"
        },
        {
            "type": "list",
            "bbox": [
                0.099,
                0.094,
                0.8,
                0.126
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.13,
                0.926,
                0.144
            ],
            "angle": 0,
            "content": "*5. 证明如果 \\(ac \\equiv bc (\\bmod m)\\), 其中 \\(a, b, c\\) 和 \\(m\\) 是整数且 \\(m > 2\\), \\(d = \\gcd(m, c)\\), 则 \\(a \\equiv b (\\bmod m / d)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.148,
                0.527,
                0.162
            ],
            "angle": 0,
            "content": "6. 证明两个奇数的平方和不可能是一个整数的平方。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.165,
                0.58,
                0.18
            ],
            "angle": 0,
            "content": "7. 证明如果 \\( n^2 + 1 \\) 是完全数，其中 \\( n \\) 是整数，则 \\( n \\) 是偶数。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.183,
                0.759,
                0.198
            ],
            "angle": 0,
            "content": "8. 证明方程 \\( x^{2} - 5y^{2} = 2 \\) 没有 \\( x \\) 和 \\( y \\) 的整数解。[提示：考虑该方程模5的情况。]"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.201,
                0.619,
                0.216
            ],
            "angle": 0,
            "content": "9. 基于二进制展开式设计一个正整数能被8整除的整除性测试。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.219,
                0.628,
                0.234
            ],
            "angle": 0,
            "content": "10. 基于二进制展开式设计一个正整数能被3整除的整除性测试。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.237,
                0.847,
                0.252
            ],
            "angle": 0,
            "content": "11. 设计一个算法通过连续猜测二进制展开式中的每个比特来猜测一个 1 和 \\(2^{n} - 1\\) 之间的数。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.255,
                0.947,
                0.287
            ],
            "angle": 0,
            "content": "12. 在通过连续猜测二进制展开式中的每个比特来猜测一个 1 和 \\(2^{n} - 1\\) 之间的数的过程中，试按所需猜测次数确定其复杂度。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.291,
                0.665,
                0.306
            ],
            "angle": 0,
            "content": "13. 证明一个整数能被9整除当且仅当其十进制数字之和能被9整除。"
        },
        {
            "type": "list",
            "bbox": [
                0.099,
                0.148,
                0.947,
                0.306
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.309,
                0.949,
                0.341
            ],
            "angle": 0,
            "content": "** 14. 证明如果 \\( a \\) 和 \\( b \\) 是正无理数使得 \\( 1 / a + 1 / b = 1 \\)，则每个正整数都可以唯一表示为 \\( \\lfloor ka \\rfloor \\) 或 \\( \\lfloor kb \\rfloor \\)，其中 \\( k \\) 是正整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.344,
                0.897,
                0.36
            ],
            "angle": 0,
            "content": "15. 通过证明 \\( Q_{n} = n! + 1 \\) 必定有大于 \\( n \\) 的素因子，其中 \\( n \\) 是正整数，从而证明存在无限多个素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.363,
                0.527,
                0.377
            ],
            "angle": 0,
            "content": "16. 试找出一个正整数 \\( n \\) 使得 \\( Q_{n} = n! + 1 \\) 不是素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.38,
                0.947,
                0.413
            ],
            "angle": 0,
            "content": "17. 利用狄利克雷定理，即在算术级数 \\(ak + b\\) 中存在无限多个素数，其中 \\(\\gcd(a, b) = 1\\) ，证明存在无限多个其十进制展开式最后一位是1的素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.416,
                0.668,
                0.431
            ],
            "angle": 0,
            "content": "18. 证明如果 \\( n \\) 是一个正整数使得 \\( n \\) 的因子之和是 \\( n + 1 \\)，则 \\( n \\) 是素数。"
        },
        {
            "type": "list",
            "bbox": [
                0.099,
                0.344,
                0.947,
                0.431
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.435,
                0.469,
                0.449
            ],
            "angle": 0,
            "content": "* 19. 证明每个大于 11 的整数是两个合数之和。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.452,
                0.385,
                0.467
            ],
            "angle": 0,
            "content": "20. 试找出五个最小的连续的合数。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.47,
                0.947,
                0.502
            ],
            "angle": 0,
            "content": "21. 证明哥德巴赫猜想（即每个大于 2 的偶数是两个素数之和）等价于语句每个大于 5 的整数是三个素数之和。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.506,
                0.533,
                0.521
            ],
            "angle": 0,
            "content": "22. 试找出以7开始长度为6只包含素数的算术级数。"
        },
        {
            "type": "list",
            "bbox": [
                0.099,
                0.452,
                0.947,
                0.521
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.524,
                0.947,
                0.574
            ],
            "angle": 0,
            "content": "* 23. 证明如果 \\( f(x) \\) 是整系数非常量多项式，则存在整数 \\( y \\) 使得 \\( f(y) \\) 是合数。[提示：假设 \\( f(x_0) = p \\) 是素数。证明 \\( p \\) 整除 \\( f(x_0 + kp) \\) 对所有 \\( k \\) 成立。从而得到与下列事实矛盾，即 \\( n \\) 次多项式在每个值最多取 \\( n \\) 次，其中 \\( n > 1 \\)。]"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.578,
                0.502,
                0.592
            ],
            "angle": 0,
            "content": "* 24. 在 \\(100_{10}\\)！的二进制展开式中尾部有多少个 0？"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.596,
                0.542,
                0.611
            ],
            "angle": 0,
            "content": "25. 用欧几里得算法求10233和33341的最大公约数。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.614,
                0.546,
                0.629
            ],
            "angle": 0,
            "content": "26. 用欧几里得算法求 gcd(144, 233) 要做多少次除法？"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.632,
                0.694,
                0.647
            ],
            "angle": 0,
            "content": "27. 求 \\(\\gcd (2n + 1,3n + 2)\\) ，其中 \\(n\\) 是正整数。[提示：用欧几里得算法。]"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.65,
                0.947,
                0.699
            ],
            "angle": 0,
            "content": "28. a) 证明如果 \\(a\\) 和 \\(b\\) 为正整数，且 \\(a \\geq b\\)，则当 \\(a = b\\) 时 \\(\\gcd(a, b) = a\\)；当 \\(a\\) 和 \\(b\\) 都是偶数时 \\(\\gcd(a, b) = 2\\gcd(a/2, b/2)\\)；当 \\(a\\) 为偶数 \\(b\\) 为奇数时 \\(\\gcd(a, b) = \\gcd(a/2, b)\\)；当 \\(a\\) 和 \\(b\\) 都是奇数时 \\(\\gcd(a, b) = \\gcd(a - b, b)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.13,
                0.703,
                0.947,
                0.736
            ],
            "angle": 0,
            "content": "b)试解释如何利用a来构造一个算法，不用除法，只用二进制展开式的比较、减法和移位来求两个正整数的最大公约数。"
        },
        {
            "type": "text",
            "bbox": [
                0.13,
                0.739,
                0.413,
                0.754
            ],
            "angle": 0,
            "content": "c)用这一算法求 \\(\\gcd (1202,4848)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.757,
                0.938,
                0.772
            ],
            "angle": 0,
            "content": "29.改编(4.3节定理3)存在无限多个素数的证明来证明存在无限多个形如 \\(6k + 5\\) 的素数， \\(k = 1\\) ，2，…。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.775,
                0.947,
                0.807
            ],
            "angle": 0,
            "content": "30. 试解释为什么不能直接改编(4.3节定理3)存在无限多个素数的证明来证明在算术级数 \\(3k + 1\\) 中存在无限多个素数，\\(k = 1, 2, \\dots\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.811,
                0.947,
                0.843
            ],
            "angle": 0,
            "content": "31. 试解释为什么不能直接改编(4.3节定理3)存在无限多个素数的证明来证明在算术级数 \\(4k + 1\\) 中存在无限多个素数，\\(k = 1, 2, \\dots\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.849,
                0.681,
                0.864
            ],
            "angle": 0,
            "content": "32. 证明如果正整数 \\(n\\) 的最小素因子 \\(p\\) 大于 \\(\\sqrt[3]{n}\\)，则 \\(n / p\\) 是素数或等于1。"
        },
        {
            "type": "list",
            "bbox": [
                0.099,
                0.757,
                0.947,
                0.864
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.868,
                0.709,
                0.882
            ],
            "angle": 0,
            "content": "一组整数称为是互素的(mutually relatively prime)，如果其最大公约数是1。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.885,
                0.403,
                0.9
            ],
            "angle": 0,
            "content": "33. 判断下列各组整数是否是互素的。"
        },
        {
            "type": "text",
            "bbox": [
                0.13,
                0.904,
                0.236,
                0.917
            ],
            "angle": 0,
            "content": "a)8，10，12"
        },
        {
            "type": "text",
            "bbox": [
                0.491,
                0.904,
                0.605,
                0.917
            ],
            "angle": 0,
            "content": "b)12，15，25"
        },
        {
            "type": "text",
            "bbox": [
                0.13,
                0.922,
                0.243,
                0.934
            ],
            "angle": 0,
            "content": "c)15，21，28"
        },
        {
            "type": "text",
            "bbox": [
                0.491,
                0.922,
                0.642,
                0.934
            ],
            "angle": 0,
            "content": "d)21，24，28，32"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.658,
                0.04,
                0.792,
                0.056
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.836,
                0.041,
                0.872,
                0.055
            ],
            "angle": 0,
            "content": "275"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.096,
                0.543,
                0.112
            ],
            "angle": 0,
            "content": "34. 找一组 4 个互素的整数使得其中任何两个都不是互素的。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.116,
                0.366,
                0.129
            ],
            "angle": 0,
            "content": "* 35. 哪些正整数能使得 \\(n^4 + 4^n\\) 是素数？"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.133,
                0.502,
                0.146
            ],
            "angle": 0,
            "content": "36. 证明同余方程组 \\(x \\equiv 2(\\bmod 6)\\) 和 \\(x \\equiv 3(\\bmod 9)\\) 无解。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.151,
                0.557,
                0.164
            ],
            "angle": 0,
            "content": "37. 找出同余方程组 \\(x \\equiv 4(\\bmod 6)\\) 和 \\(x \\equiv 13(\\bmod 15)\\) 的所有解。"
        },
        {
            "type": "list",
            "bbox": [
                0.043,
                0.116,
                0.557,
                0.164
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.169,
                0.81,
                0.185
            ],
            "angle": 0,
            "content": "* 38. a) 证明同余方程组 \\(x \\equiv a_{1} (\\bmod m_{1})\\) 和 \\(x \\equiv a_{2} (\\bmod m_{2})\\) 有解当且仅当 \\(\\gcd(m_{1}, m_{2}) \\mid a_{1} - a_{2}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.189,
                0.615,
                0.202
            ],
            "angle": 0,
            "content": "b) 证明如果 a 中方程组有解，则解在模 \\(\\operatorname{lcm}(m_1, m_2)\\) 下是唯一的。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.207,
                0.434,
                0.221
            ],
            "angle": 0,
            "content": "39. 证明对于每个非负整数 \\( n \\) 有 30 整除 \\( n^9 - n \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.225,
                0.59,
                0.24
            ],
            "angle": 0,
            "content": "40. 证明每个满足 \\(\\gcd(n, 35) = 1\\) 的整数 \\(n\\) 有 \\(n^{12} - 1\\) 可被 35 整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.244,
                0.572,
                0.258
            ],
            "angle": 0,
            "content": "41. 证明如果 \\( p \\) 和 \\( q \\) 是不同的素数，则 \\( p^{q-1} + q^{p-1} \\equiv 1 (\\bmod pq) \\)。"
        },
        {
            "type": "list",
            "bbox": [
                0.053,
                0.207,
                0.59,
                0.258
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.261,
                0.899,
                0.294
            ],
            "angle": 0,
            "content": "以 \\(a_1a_2\\cdots a_{12}\\) 开始的ISBN-13的校验码 \\(a_{13}\\) 由同余式 \\((a_1 + a_3 + \\dots + a_{13}) + _3(a_2 + a_4 + \\dots + a_{12}) \\equiv 0 (\\mod 10)\\) 确定。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.297,
                0.453,
                0.311
            ],
            "angle": 0,
            "content": "42. 试判定下列13位数字是否是合法的ISBN-13。"
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.315,
                0.262,
                0.328
            ],
            "angle": 0,
            "content": "a)978-0-073-20679-1"
        },
        {
            "type": "text",
            "bbox": [
                0.445,
                0.316,
                0.622,
                0.328
            ],
            "angle": 0,
            "content": "b)978-0-45424-521-1"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.334,
                0.262,
                0.346
            ],
            "angle": 0,
            "content": "c)978-3-16-148410-0"
        },
        {
            "type": "text",
            "bbox": [
                0.445,
                0.334,
                0.622,
                0.346
            ],
            "angle": 0,
            "content": "d)978-0-201-10179-9"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.351,
                0.468,
                0.365
            ],
            "angle": 0,
            "content": "43. 试证明ISBN-13的校验码总是可以检测出单错。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.369,
                0.542,
                0.383
            ],
            "angle": 0,
            "content": "44. 试证明存在两个数字的换位错误不能被ISBN-13检测到。"
        },
        {
            "type": "list",
            "bbox": [
                0.053,
                0.351,
                0.542,
                0.383
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.387,
                0.899,
                0.437
            ],
            "angle": 0,
            "content": "路由号码（routing transit number，RTN）是美国使用的出现在支票底部的一个银行代码。RTN最常见的形式是9位数字，其中最后一位数字是校验码。如果 \\(d_{1}d_{2}\\dots d_{9}\\) 是合法的RTN，则同余式 \\(3(d_{1} + d_{4} + d_{7}) + 7(d_{2} + d_{5} + d_{8}) + (d_{3} + d_{6} + d_{9}) \\equiv 0 (\\mathrm{mod} 10)\\) 一定成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.441,
                0.899,
                0.473
            ],
            "angle": 0,
            "content": "45. 证明如果 \\(d_{1}d_{2}\\dots d_{9}\\) 是合法的 RTN，则 \\(d_{9} = 7(d_{1} + d_{4} + d_{7}) + 3(d_{2} + d_{5} + d_{8}) + 9(d_{3} + d_{6})\\bmod 10\\)。再者，利用这个公式寻找一个合法 RTN 8 位数字 11100002 后面的校验码。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.476,
                0.899,
                0.509
            ],
            "angle": 0,
            "content": "46. 证明 RTN 的校验码能够检测出所有单错。试判断 RTN 校验码能检测出哪些换位错，不能检测出哪些换位错。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.513,
                0.899,
                0.545
            ],
            "angle": 0,
            "content": "47. 一则消息加密后是 LJMKG MGMXF QEXMW。如果它是用仿射密码 \\( f(p) = (7p + 10) \\mod 26 \\) 加密的，请问原始消息是什么？"
        },
        {
            "type": "list",
            "bbox": [
                0.053,
                0.441,
                0.899,
                0.545
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.548,
                0.899,
                0.635
            ],
            "angle": 0,
            "content": "自动密钥密码(autokeycipher)，其中明文的第 \\(n\\) 个字母移位数由密钥串中第 \\(n\\) 个字母的等效数值决定。密钥串以一个种子字母开始，其后续字母则利用或者明文或者密文构成。当使用明文时，密钥串的每个字符，第一个除外，是明文中的前一个字母。当使用密文时，密钥串后续的每个字符（第一个除外）是计算至此所得密文的前一个字母。在这两种情况下，明文都是通过移位加密的，每个字符移位数是密钥串相应字符对应的数值。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.638,
                0.735,
                0.653
            ],
            "angle": 0,
            "content": "48.利用自动密钥密码加密消息NOWISTHTHETIMETODECIDE(忽略空格)，使用"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.656,
                0.367,
                0.67
            ],
            "angle": 0,
            "content": "a)密钥串是种子X加明文中的字母"
        },
        {
            "type": "text",
            "bbox": [
                0.444,
                0.657,
                0.726,
                0.67
            ],
            "angle": 0,
            "content": "b)密钥串是种子X加密文中的字母"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.674,
                0.689,
                0.688
            ],
            "angle": 0,
            "content": "49.利用自动密钥密码加密消息THE DREAM OF REASON（忽略空格），使用"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.692,
                0.367,
                0.706
            ],
            "angle": 0,
            "content": "a)密钥串是种子X加明文中的字母"
        },
        {
            "type": "text",
            "bbox": [
                0.444,
                0.692,
                0.726,
                0.706
            ],
            "angle": 0,
            "content": "b)密钥串是种子X加密文中的字母"
        },
        {
            "type": "title",
            "bbox": [
                0.053,
                0.722,
                0.186,
                0.74
            ],
            "angle": 0,
            "content": "计算机课题"
        },
        {
            "type": "title",
            "bbox": [
                0.053,
                0.748,
                0.286,
                0.763
            ],
            "angle": 0,
            "content": "按给定的输入与输出写程序。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.766,
                0.536,
                0.78
            ],
            "angle": 0,
            "content": "1. 给定整数 \\(n\\) 和 \\(b\\) ，均大于1，求这个整数的 \\(b\\) 进制展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.784,
                0.475,
                0.797
            ],
            "angle": 0,
            "content": "2. 给定正整数 \\(a, b\\) 和 \\(m\\)，且 \\(m > 1\\)，计算 \\(a^b \\mod m\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.802,
                0.649,
                0.816
            ],
            "angle": 0,
            "content": "3. 给定一个正整数，找出其康托尔展开式（参见4.2节练习54的前导文）。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.82,
                0.474,
                0.834
            ],
            "angle": 0,
            "content": "4. 给定一个正整数，利用试除法判断其是否为素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.838,
                0.4,
                0.851
            ],
            "angle": 0,
            "content": "5. 给定一个正整数，找出其素因子分解式。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.856,
                0.511,
                0.869
            ],
            "angle": 0,
            "content": "6. 给定两个正整数，用欧几里得算法找出其最大公约数。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.874,
                0.381,
                0.887
            ],
            "angle": 0,
            "content": "7. 给定两个正整数，找出其最小公倍数。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.892,
                0.474,
                0.905
            ],
            "angle": 0,
            "content": "8. 给定正整数 \\(a\\) 和 \\(b\\)，找出 \\(a\\) 和 \\(b\\) 的贝祖系数 \\(s\\) 和 \\(t\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.91,
                0.429,
                0.923
            ],
            "angle": 0,
            "content": "9. 给定互素的正整数 \\(a\\) 和 \\(b\\)，找出 \\(a\\) 模 \\(b\\) 的逆。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.927,
                0.76,
                0.941
            ],
            "angle": 0,
            "content": "10. 给定 \\( n \\) 个模数两两互素的线性同余式，找出同余方程组的以这些模数乘积为模的解。"
        },
        {
            "type": "list",
            "bbox": [
                0.053,
                0.766,
                0.76,
                0.941
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.128,
                0.04,
                0.164,
                0.054
            ],
            "angle": 0,
            "content": "276"
        },
        {
            "type": "header",
            "bbox": [
                0.209,
                0.039,
                0.275,
                0.054
            ],
            "angle": 0,
            "content": "第4章"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.096,
                0.948,
                0.129
            ],
            "angle": 0,
            "content": "11. 给定正整数 \\(N\\) 、模数 \\(m\\) 、倍数 \\(a\\) 、增量 \\(c\\) 和种子 \\(x_0\\) ，其中 \\(0 \\leqslant a < m\\) ，\\(0 \\leqslant c < m\\) ，\\(0 \\leqslant x_0 < m\\) ，利用线性同余生成器 \\(x_{n+1} = (ax_n + c) \\bmod m\\) 生成一列 \\(N\\) 个伪随机数。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.132,
                0.812,
                0.146
            ],
            "angle": 0,
            "content": "12. 给定一组标识数的集合，利用散列函数为其分配内存地址，这里共有 \\(k\\) 个内存地址。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.15,
                0.499,
                0.163
            ],
            "angle": 0,
            "content": "13. 当给定 ISBN-10 的前 9 位数字时计算校验码。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.167,
                0.948,
                0.2
            ],
            "angle": 0,
            "content": "14. 给定一则消息以及小于26的整数 \\(k\\)，利用移位密码及密钥 \\(k\\) 加密该消息。给定一则用移位密码及密钥 \\(k\\) 加密的消息，解密之。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.203,
                0.948,
                0.255
            ],
            "angle": 0,
            "content": "15. 给定一则消息以及小于26的正整数 \\(a\\) 和 \\(b\\), \\(\\gcd(a, 26) = 1\\), 利用仿射密码及密钥 \\((a, b)\\) 加密该消息。给定一则用仿射密码及密钥 \\((a, b)\\) 加密的消息, 首先寻找解密密钥然后应用适当的解密函数解密该消息。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.257,
                0.868,
                0.272
            ],
            "angle": 0,
            "content": "16. 从用移位密码对明文加密而成的密文中找出原始明文。利用密文中字母频率统计来做该题。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.275,
                0.948,
                0.308
            ],
            "angle": 0,
            "content": "* 17. 通过寻找两个各有 200 位数字的素数 \\( p \\) 和 \\( q \\)，以及大于 1 且与 \\((p - 1)(q - 1)\\) 互素的整数 \\( e \\) 来构造一个有效的 RSA 加密密钥。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.311,
                0.948,
                0.343
            ],
            "angle": 0,
            "content": "18. 给定一则消息和整数 \\( n = pq \\)，其中 \\( p \\) 和 \\( q \\) 是奇素数，以及大于 1 且与 \\((p - 1)(q - 1)\\) 互素的整数 \\( e \\)，利用 RSA 密码系统及密钥 \\((n, e)\\) 加密该消息。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.346,
                0.867,
                0.362
            ],
            "angle": 0,
            "content": "19. 给定一个有效的 RSA 密钥 \\((n, e)\\)，以及素数 \\(p\\) 和 \\(q\\)，满足 \\(n = pq\\)，找出相应的解密密钥 \\(d\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.365,
                0.872,
                0.379
            ],
            "angle": 0,
            "content": "20. 给定一则用 RSA 密码系统及密钥 \\((n, e)\\) 加密的消息，以及相应的解密密钥 \\(d\\) ，解密该消息。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.383,
                0.545,
                0.397
            ],
            "angle": 0,
            "content": "21. 利用迪菲-赫尔曼密钥交换协议生成一个共享密钥。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.401,
                0.675,
                0.415
            ],
            "angle": 0,
            "content": "22. 给定双方的 RSA 公钥和私钥，一方发送签名的秘密消息给另一方。"
        },
        {
            "type": "list",
            "bbox": [
                0.088,
                0.096,
                0.948,
                0.415
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.105,
                0.431,
                0.24,
                0.449
            ],
            "angle": 0,
            "content": "计算和探索"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.457,
                0.581,
                0.471
            ],
            "angle": 0,
            "content": "使用一个计算程序或你自己编写的计算程序做下面的练习。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.475,
                0.562,
                0.489
            ],
            "angle": 0,
            "content": "1. 对不超过 100 的每个素数 \\( p \\)，判断 \\( 2^p - 1 \\) 是否为素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.492,
                0.928,
                0.507
            ],
            "angle": 0,
            "content": "2. 在大梅森数 \\( 2^{p} - 1 \\) 的某个范围内做测试以判断其是否为素数。（可能需要使用GIMPS项目的软件。）"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.51,
                0.953,
                0.542
            ],
            "angle": 0,
            "content": "3. 判断 \\( Q_{n} = p_{1}p_{2}\\dots p_{n} + 1 \\) 是否是素数，其中 \\( p_1,p_2,\\dots ,p_n \\) 是 \\( n \\) 个最小的素数，对尽可能多的正整数 \\( n \\) 做该题。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.546,
                0.641,
                0.56
            ],
            "angle": 0,
            "content": "4. 寻找单变量多项式，使得其在很长的连续整数上的值均为素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.564,
                0.935,
                0.578
            ],
            "angle": 0,
            "content": "5. 尽可能多地寻找形如 \\( n^2 + 1 \\) 的素数，其中 \\( n \\) 是正整数。现在还不知道是否存在无限多个这样的素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.582,
                0.484,
                0.596
            ],
            "angle": 0,
            "content": "6. 试找出10个不同的各有100位数字的素数。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.6,
                0.951,
                0.632
            ],
            "angle": 0,
            "content": "7. 小于 1000000 的素数有多少个？小于 1000000 的呢？小于 10000000 的呢？你能否提出小于 \\( x \\) 的素数个数的估算值，这里 \\( x \\) 是正整数？"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.635,
                0.951,
                0.668
            ],
            "angle": 0,
            "content": "8. 找出随机选取的10个不同的20位数的奇数的一个素因子。记录找出每个整数的因子所消耗的时间。对10个30位数的奇数、40位数的奇数等尽可能多地做同样的计算。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.671,
                0.516,
                0.686
            ],
            "angle": 0,
            "content": "9. 找出所有不超过 10000 的以 2 为基数的伪素数。"
        },
        {
            "type": "list",
            "bbox": [
                0.103,
                0.475,
                0.953,
                0.686
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.108,
                0.701,
                0.216,
                0.719
            ],
            "angle": 0,
            "content": "写作课题"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.727,
                0.473,
                0.742
            ],
            "angle": 0,
            "content": "用本教材以外的资料，按下列要求写成论文。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.745,
                0.953,
                0.776
            ],
            "angle": 0,
            "content": "1. 试描述用于判断梅森数是否为素数的卢卡斯-莱默尔测试。讨论GIMPS项目在用这一测试来寻找梅森素数方面的进展。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.781,
                0.953,
                0.812
            ],
            "angle": 0,
            "content": "2. 试解释随机性素数性测试如何在实践中用来生成几乎肯定是素数的非常大的数。这种测试是否有任何潜在的弊端？"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.817,
                0.953,
                0.848
            ],
            "angle": 0,
            "content": "3. 早在75年前提出的是存在无限多个卡米切尔数的问题近期得到了解答。试描述存在无限多个这种数的证明中所涉及的要点。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.853,
                0.953,
                0.883
            ],
            "angle": 0,
            "content": "4. 就复杂度和目前能分解的数的大小而言，试总结因子分解算法的现状。你认为什么时候分解200位的数将是可行的？"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.888,
                0.625,
                0.902
            ],
            "angle": 0,
            "content": "5. 试描述现代计算机中实际使用的正整数加、减、乘、除算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.906,
                0.953,
                0.937
            ],
            "angle": 0,
            "content": "6. 试描述中国剩余定理(孙子定理)的历史。描述在中国和印度著作中提出的一些相关问题以及怎样将中国剩余定理用于求解这些问题。"
        },
        {
            "type": "list",
            "bbox": [
                0.106,
                0.745,
                0.953,
                0.937
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.652,
                0.042,
                0.782,
                0.056
            ],
            "angle": 0,
            "content": "数论和密码学"
        },
        {
            "type": "page_number",
            "bbox": [
                0.83,
                0.043,
                0.865,
                0.055
            ],
            "angle": 0,
            "content": "277"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.098,
                0.894,
                0.13
            ],
            "angle": 0,
            "content": "7. 什么时候序列中的数是真正的随机数，而非伪随机数？用伪随机数做仿真或试验时观察到了什么样的缺陷？伪随机数有哪些性质是随机数不该有的？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.134,
                0.895,
                0.166
            ],
            "angle": 0,
            "content": "8. 试解释国际银行账户号码(International Bank Account Number，IBAN)的校验码是如何得到的，并讨论哪些类错误能通过这个校验码发现。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.169,
                0.782,
                0.184
            ],
            "angle": 0,
            "content": "9. 试描述计算信用卡号的校验码的 Luhn 算法，并讨论哪些类错误能通过这个校验码发现。"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.187,
                0.483,
                0.201
            ],
            "angle": 0,
            "content": "10. 试阐述如何利用同余式来告诉任意一天是星期几。"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.204,
                0.895,
                0.237
            ],
            "angle": 0,
            "content": "11. 试描述公钥密码学是如何应用的。就因子分解算法的现状而言，这种应用方式安全吗？现在用公钥密码加密的信息在将来会变得不安全吗？"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.24,
                0.895,
                0.272
            ],
            "angle": 0,
            "content": "12. 试描述怎样用公钥密码生成签名的保密消息，使得接收方有相当把握确认这个消息是由声称发送消息的人所发送的。"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.276,
                0.895,
                0.308
            ],
            "angle": 0,
            "content": "13. 试描述拉宾(Rabin)公钥密码系统，解释如何加密和解密消息，以及为什么它适合用做公钥密码系统。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.311,
                0.897,
                0.344
            ],
            "angle": 0,
            "content": "* 14. 试解释为什么选用大素数 \\( p \\) 作为 RSA 密码系统中加密用的模数是不合适的。即，解释如果模数是一个大素数而不是两个大素数的乘积，则有人如何能在不需要过多计算的情况下从相应的公钥找出私钥。"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.347,
                0.708,
                0.362
            ],
            "angle": 0,
            "content": "15. 试解释加密散列函数意味着什么？这样一个函数必须具有的重要性质是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.365,
                0.466,
                0.38
            ],
            "angle": 0,
            "content": "16. 试解释金特里用于构建全同态密码系统的步骤。"
        },
        {
            "type": "list",
            "bbox": [
                0.041,
                0.098,
                0.897,
                0.38
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "title",
            "bbox": [
                0.116,
                0.099,
                0.195,
                0.117
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.12,
                0.406,
                0.133
            ],
            "angle": 0,
            "content": "Discrete Mathematics and Its Applications, 8E"
        },
        {
            "type": "title",
            "bbox": [
                0.107,
                0.142,
                0.292,
                0.168
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.237,
                0.951,
                0.292
            ],
            "angle": 0,
            "content": "许多数学命题都这样的断言：某种性质对所有正整数来说，都为真。这种命题的例子有：对于每个正整数 \\( n \\)，\\( n! \\leqslant n^n \\)；\\( n^3 - n \\) 能被 3 整除；\\( n \\) 个元素的集合有 \\( 2^n \\) 个子集；前 \\( n \\) 个正整数之和是 \\( n(n + 1) / 2 \\) 等。本章和本书的一个主要目标是让学生彻底理解证明这类结果的数学归纳法。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.295,
                0.951,
                0.368
            ],
            "angle": 0,
            "content": "数学归纳法分两部分来证明。首先，证明命题对于正整数1成立。其次，证明如果命题对于一个正整数成立，那么对于下一个正整数它也必然成立。数学归纳法基于推理规则：如果对于正整数域来说， \\(P(1)\\) 和 \\(\\forall k(P(k)\\rightarrow P(k + 1))\\) 均成立，那么 \\(\\forall nP(n)\\) 也成立。数学归纳法可以用来证明结论的巨大变化情况。理解如何阅读和构造采用数学归纳法的证明是学习离散数学的一个关键目标。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.37,
                0.951,
                0.483
            ],
            "angle": 0,
            "content": "第2章已明确定义了集合和函数，即通过列举集合元素或给出刻画集合元素的某种性质来描述集合；对函数值则给出公式。基于数学归纳法，我们则有另一种重要方式来定义这些对象。要定义函数，就要规定某些初始项，从而给出由已知值求后续值的规则。（我们在第2章中用递推关系定义序列时遇到过这种定义方式。）定义集合是通过列举某些集合元素，给出从集合中已知元素来构造其他元素的规则。这样的定义称为递归定义，在离散数学和计算机科学中大量使用。一旦递归定义了集合，就可用所谓的结构归纳法来证明关于这个集合的结论。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.485,
                0.951,
                0.56
            ],
            "angle": 0,
            "content": "当一个问题的解题过程被指定之后，该过程就必须总能得出正确的解。仅仅测试出一组输入值结果正确，并不能说明这个过程总是正确地工作。只有证明过程总是产生正确结果，才保证了这个过程的正确性。本章最后一节介绍一种程序验证技巧，这是验证过程正确性的形式化技巧。程序验证是一种以机械形式证明程序正确的现行尝试的基础。"
        },
        {
            "type": "title",
            "bbox": [
                0.105,
                0.573,
                0.305,
                0.593
            ],
            "angle": 0,
            "content": "5.1 数学归纳法"
        },
        {
            "type": "title",
            "bbox": [
                0.105,
                0.601,
                0.23,
                0.618
            ],
            "angle": 0,
            "content": "5.1.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.621,
                0.951,
                0.656
            ],
            "angle": 0,
            "content": "假如有一个如图1所示的无限高的梯子，想知道是否能到达梯子上的每一个阶梯。我们所知道的两件事情是："
        },
        {
            "type": "text",
            "bbox": [
                0.144,
                0.659,
                0.444,
                0.675
            ],
            "angle": 0,
            "content": "① 可以到达梯子上的第一个阶梯。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.678,
                0.647,
                0.713
            ],
            "angle": 0,
            "content": "② 如果能到达梯子上某个特定阶梯，那么就能到达它的下一个阶梯。"
        },
        {
            "type": "list",
            "bbox": [
                0.104,
                0.659,
                0.647,
                0.713
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.715,
                0.647,
                0.941
            ],
            "angle": 0,
            "content": "那么，是否能得到可以到达梯子上的每一个阶梯的结论？由①知道，我们能到达第1个阶梯。此外，由于能到达第1个阶梯，由②可知，我们能到达第2个阶梯，因为它是第1个阶梯的下一个阶梯；再应用②，由于能到达第2个阶梯，我们也能到达第3个阶梯；继续这个过程，可证明我们能到达第4个阶梯，以此类推。例如，当应用100次②之后，我们到达了第101个阶梯。那么是否能得到我们能到达这个无限梯子上的每一个阶梯的结论？答案是肯定的，利用一个重要的证明技巧，即所谓的数学归纳法，就能验证这样的结论。也就是说，我们能够证明：对每一个正整数 \\(n\\) ，\\(P(n)\\) 都是正确的，其中 \\(P(n)\\) 是我们能够到达梯子上的第 \\(n\\) 个阶梯这一命题。"
        },
        {
            "type": "image",
            "bbox": [
                0.666,
                0.65,
                0.948,
                0.92
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.706,
                0.925,
                0.887,
                0.94
            ],
            "angle": 0,
            "content": "图1 爬无限高的梯子"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.687,
                0.043,
                0.796,
                0.058
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.843,
                0.044,
                0.879,
                0.057
            ],
            "angle": 0,
            "content": "279"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.099,
                0.907,
                0.153
            ],
            "angle": 0,
            "content": "数学归纳法是证明这种断言的极其重要的证明技术。在本节和后面的章节中，数学归纳法将被大量用来证明关于各种各样离散对象的结果。例如用来证明关于算法的复杂度、特定类型计算机程序的正确性、有关图与树的定理，以及各种恒等式和不等式的结论。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.156,
                0.907,
                0.192
            ],
            "angle": 0,
            "content": "本节描述如何使用数学归纳法，并说明为什么数学归纳法是有效的证明技巧。一定要注意的是：数学归纳法只能证明通过其他方式获得的结论，它不是发现公式或定理的工具。"
        },
        {
            "type": "title",
            "bbox": [
                0.064,
                0.202,
                0.254,
                0.219
            ],
            "angle": 0,
            "content": "5.1.2 数学归纳法"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.223,
                0.907,
                0.297
            ],
            "angle": 0,
            "content": "一般而言，数学归纳法可用来证明这样一类命题：对于所有正整数 \\(n\\) ， \\(P(n)\\) 为真，其中\\(P(n)\\) 是命题函数。数学归纳法的证明包含两个步骤：一是基础步骤，在基础步骤中要证明\\(P(1)\\) 为真；二是归纳步骤，在归纳步骤中要证明对所有的正整数 \\(k\\) ，如果 \\(P(k)\\) 为真，则 \\(P(k + 1)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.071,
                0.305,
                0.896,
                0.34
            ],
            "angle": 0,
            "content": "数学归纳法的原理 为证明对所有的正整数 \\(n\\)，\\(P(n)\\) 为真，其中 \\(P(n)\\) 是一个命题函数，需要完成两个步骤："
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.344,
                0.397,
                0.359
            ],
            "angle": 0,
            "content": "基础步骤：证明命题 \\(P(1)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.363,
                0.717,
                0.379
            ],
            "angle": 0,
            "content": "归纳步骤：证明对每个正整数 \\(k\\) 来说，蕴含式 \\(P(k) \\rightarrow P(k + 1)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.389,
                0.906,
                0.482
            ],
            "angle": 0,
            "content": "为了使用数学归纳法的原理完成一个证明的归纳步骤，我们需要假定对任意一个正整数 \\(k\\) ， \\(P(k)\\) 为真，并证明在此假定下， \\(P(k + 1)\\) 必为真。 \\(P(k)\\) 为真的假设叫作归纳假设。一旦用数学归纳法完成了一个证明中的两个步骤，那么就已经证明对所有的正整数而言 \\(P(n)\\) 为真。也就是说，已经证明了 \\(\\forall n P(n)\\) 为真，其中的量词是全体正整数的集合。在归纳步骤中，要证明 \\(\\forall k(P(k)\\rightarrow P(k + 1))\\) 为真，其中的论域仍是正整数集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.485,
                0.595,
                0.501
            ],
            "angle": 0,
            "content": "作为推理规则的一种表达方式，这一证明技巧可描述为"
        },
        {
            "type": "equation",
            "bbox": [
                0.278,
                0.504,
                0.684,
                0.519
            ],
            "angle": 0,
            "content": "\\[\n(P (1) \\wedge \\forall k (P (k) \\rightarrow P (k + 1))) \\rightarrow \\forall n P (n)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.522,
                0.906,
                0.634
            ],
            "angle": 0,
            "content": "其中的论域是正整数集合。由于数学归纳法是如此重要的证明技术，所以值得详细解释使用这个技术的证明步骤。为了证明对所有正整数 \\( n \\) 来说，\\( P(n) \\) 为真，首先证明 \\( P(1) \\) 为真。这等于证明当在 \\( P(n) \\) 里用1替换 \\( n \\) 时所得到的特殊命题为真。然后必须证明对每个正整数 \\( k \\) 来说，都有 \\( P(k) \\rightarrow P(k + 1) \\) 为真。为了证明对每个正整数 \\( k \\) 来说这个蕴含式为真，需要证明当 \\( P(k) \\) 为真时 \\( P(k + 1) \\) 不能为假。可以通过假设 \\( P(k) \\) 为真，而且证明在此假设下 \\( P(k + 1) \\) 也必然为真来完成这个证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.637,
                0.904,
                0.672
            ],
            "angle": 0,
            "content": "评注 在数学归纳法证明里并不假定对所有正整数来说 \\(P(k)\\) 为真！只是证明：若假定 \\(P(k)\\) 为真，则 \\(P(k + 1)\\) 也为真。因此，数学归纳法证明不属于回避问题或循环论证的情形。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.675,
                0.906,
                0.711
            ],
            "angle": 0,
            "content": "在证明完成基础步骤和归纳步骤之后，即证明 \\(P(n)\\) 对于所有正整数 \\(n\\) 都成立之后，我们知道 \\(P(1)\\) 为真。这是在基础步骤中证明的。接着可以得到 \\(P(2)\\) 为真，因为我们知道 \\(P(1)\\) 为真"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.719,
                0.125,
                0.741
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.745,
                0.906,
                0.868
            ],
            "angle": 0,
            "content": "历史注解 已知最早的对数学归纳法的使用，是在16世纪数学家弗朗西斯科·毛洛利可（Francesco Maurolico，1494—1575）的著作里。毛洛利可写过大量关于经典数学的著作，并且对几何学和光学做出过许多贡献。在他的著作《Arithmeticorum Libri Duo》里，毛洛利可给出了整数的各种性质和对这些性质的证明。为了证明其中的某些性质，他设计出数学归纳法这个方法。在这本书里，他对数学归纳法的第一次使用是为了证明前 \\(n\\) 个正奇数之和等于 \\(n^2\\) 。奥古斯塔·德·摩根被誉为在1838年第一个使用数学归纳法表示正式证明的人，并且引入了“数学归纳法”这一术语。毛洛利可的证明是非正式的，他从未使用“归纳”这个词。更多关于数学归纳法的历史参见[Gu11]。"
        },
        {
            "type": "page_footnote",
            "bbox": [
                0.104,
                0.897,
                0.904,
                0.944
            ],
            "angle": 0,
            "content": "不幸的是，“数学归纳法”这一术语与用于描述其他类型推理中的术语是冲突的。在逻辑学中，演绎推理使用推理规则从前提导出结论；归纳推理是通过证据来支持结论，而不是确定结论。数学证明，包括使用数学归纳法的论据，都是演绎推理，而不是归纳推理。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.139,
                0.044,
                0.176,
                0.058
            ],
            "angle": 0,
            "content": "280"
        },
        {
            "type": "header",
            "bbox": [
                0.221,
                0.043,
                0.286,
                0.058
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.099,
                0.959,
                0.154
            ],
            "angle": 0,
            "content": "并且从归纳步骤可知 \\(P(1) \\rightarrow P(2)\\) 。进一步，我们知道 \\(P(3)\\) 为真，因为 \\(P(2)\\) 为真且从归纳步骤可知 \\(P(2) \\rightarrow P(3)\\) 。使用有限次数的推导继续这一方法，可知对于任一特定正整数 \\(n\\) ，\\(P(n)\\) 成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.156,
                0.962,
                0.25
            ],
            "angle": 0,
            "content": "数学归纳法工作原理的记忆方法 考虑前面那个无限高的梯子以及到达每个阶梯的规则，可以帮助我们记住数学归纳法是如何工作的。注意，无限高梯子中的命题1)和2)恰好分别是证明对所有的正整数 \\(n\\) 而言，\\(P(n)\\) 为真时的基础步骤和归纳步骤，其中 \\(P(n)\\) 是命题“我们能够到达第 \\(n\\) 个阶梯”。因此，可以应用数学归纳法得出“我们能够到达每个阶梯”的结论。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.252,
                0.962,
                0.287
            ],
            "angle": 0,
            "content": "另一种描述数学归纳法原理的方法是考虑一个排列无限长的多米诺骨牌，分别标有号码1，2，3，…， \\(n\\) ，…，其中每张多米诺骨牌都直立着。设 \\(P(n)\\) 是命题：多米诺骨牌 \\(n\\) 被撞倒。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.29,
                0.596,
                0.383
            ],
            "angle": 0,
            "content": "如果第一张多米诺骨牌被撞倒，即 \\(P(1)\\) 为真，并且如果每当第 \\(k\\) 张多米诺骨牌被撞倒时，它也撞倒第\\(k + 1\\) 张多米诺骨牌，即对所有的整数 \\(k\\) 如果 \\(P(k)\\rightarrow\\) \\(P(k + 1)\\) 为真，那么所有的多米诺骨牌都被撞倒。图2解释了这一点。"
        },
        {
            "type": "title",
            "bbox": [
                0.116,
                0.393,
                0.469,
                0.41
            ],
            "angle": 0,
            "content": "5.1.3 为什么数学归纳法是有效的"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.413,
                0.599,
                0.582
            ],
            "angle": 0,
            "content": "为什么数学归纳法是一种有效的证明技术？原因来自附录A中所列出的正整数集合的一个良序性公理：正整数集合的任何非空子集都有最小元素。假定知道 \\(P(1)\\) 为真，而且对所有正整数 \\(k\\) 来说，命题 \\(P(k) \\rightarrow P(k + 1)\\) 为真。为了证明对所有正整数 \\(n\\) 来说 \\(P(n)\\) 必为真，可以假定至少存在一个正整数 \\(n\\) 使 \\(P(n)\\) 为假，那么使 \\(P(n)\\) 为假的正整数集合 \\(S\\) 非空。因此，根据良序性公理，\\(S\\) 中必有一个最小元素，把它表示成 \\(m\\)。可以知道 \\(m\\) 不可能是1，因为 \\(P(1)\\) 为"
        },
        {
            "type": "image",
            "bbox": [
                0.614,
                0.293,
                0.967,
                0.553
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.622,
                0.561,
                0.957,
                0.577
            ],
            "angle": 0,
            "content": "图2 用多米诺骨牌解释数学归纳法原理"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.587,
                0.966,
                0.642
            ],
            "angle": 0,
            "content": "真。因为 \\(m\\) 是正的而且大于1，所以 \\(m - 1\\) 是一个正整数。另外，因为 \\(m - 1\\) 小于 \\(m\\) ，且 \\(m - 1\\) 不属于S，所以 \\(P(m - 1)\\) 必然为真。因为蕴含式 \\(P(m - 1)\\rightarrow P(m)\\) 也为真，所以 \\(P(m)\\) 必为真。这与 \\(m\\) 属于 \\(S\\) 相矛盾。因此，对所有正整数 \\(n\\) 而言， \\(P(n)\\) 必为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.645,
                0.967,
                0.72
            ],
            "angle": 0,
            "content": "评注 在本书中，我们将正整数的良序性当作公理。我们证明了数学归纳法是一种有效的证明技术。然而，我们本可以将数学归纳法原理当作公理，并证明正整数是良序的。这样，正整数的良序性与数学归纳法原理就是等价的。（在5.2节，我们将给出直接使用良序性的证明实例。本节的练习41要求证明正整数的良序性是数学归纳法原理的一个推论。）"
        },
        {
            "type": "title",
            "bbox": [
                0.121,
                0.731,
                0.408,
                0.748
            ],
            "angle": 0,
            "content": "5.1.4 选择正确的基础步骤"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.75,
                0.97,
                0.903
            ],
            "angle": 0,
            "content": "数学归纳法可以用于证明的定理并不限于“对于所有正整数 \\(n\\)，\\(P(n)\\) 为真”这样的形式。有时需要证明“对于 \\(n = b\\)，\\(b + 1\\)，\\(b + 2\\)，…，\\(P(n)\\) 为真”，其中 \\(b\\) 是不等于1的整数。只要改变基础步骤，将 \\(p(1)\\) 变为 \\(p(b)\\)，就可以用数学归纳法来完成这个证明。换言之，要用数学归纳法证明“对于 \\(n = b\\)，\\(b + 1\\)，\\(b + 2\\)，…，\\(b\\) 是不等于1的整数，\\(P(n)\\) 为真”，我们需要做的是：在基础步骤时证明 \\(p(b)\\) 为真；在归纳步骤时证明对于 \\(k = b\\)，\\(b + 1\\)，\\(b + 2\\)，…，蕴含式 \\(P(k) \\rightarrow P(k + 1)\\) 为真。注意 \\(b\\) 可以为负、为零或为正。回忆前面使用的比喻，想象在多米诺骨牌中，首先撞倒第 \\(b\\) 张多米诺骨牌（基础步骤），当每张多米诺骨牌倒下时，它就撞倒下一张多米诺骨牌（归纳步骤）。请读者证明这种形式的归纳是有效的（见练习85）。"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.906,
                0.97,
                0.943
            ],
            "angle": 0,
            "content": "稍后我们将用例3来说明这个问题。例3描述的是一个求和公式对所有非负整数的有效性。我们只需要证明“对于 \\(n = 0\\) ，1，2，…， \\(p(n)\\) 为真”，所以基础步骤是证明 \\(p(0)\\) 为真。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.685,
                0.043,
                0.793,
                0.058
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.841,
                0.044,
                0.874,
                0.057
            ],
            "angle": 0,
            "content": "281"
        },
        {
            "type": "title",
            "bbox": [
                0.062,
                0.107,
                0.455,
                0.125
            ],
            "angle": 0,
            "content": "5.1.5 运用数学归纳法进行证明的原则"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.127,
                0.907,
                0.183
            ],
            "angle": 0,
            "content": "例1～例14将说明如何运用数学归纳法来证明不同的定理，每道例题都包含数学归纳法需要的所有元素。此外，我们也提供了一个无效的数学归纳法证明的例子。在给出这些证明之前，我们先讨论一些运用数学归纳法构造正确证明的有用原则。"
        },
        {
            "type": "title",
            "bbox": [
                0.112,
                0.193,
                0.299,
                0.209
            ],
            "angle": 0,
            "content": "数学归纳法证明模板"
        },
        {
            "type": "text",
            "bbox": [
                0.071,
                0.212,
                0.896,
                0.284
            ],
            "angle": 0,
            "content": "1. 将需要证明的命题表示为“对于所有的 \\(n \\geq b\\)，\\(P(n)\\)”的形式，\\(b\\) 为一个固定的整数。对于“\\(P(n)\\)，\\(n\\) 为所有正整数”这种形式，设 \\(b = 1\\)；对于“\\(P(n)\\)，\\(n\\) 为所有非负整数”这种形式，设 \\(b = 0\\)。对于 \\(P(n)\\) 的某些形式，如不等式，你需要通过用较小的 \\(n\\) 检查 \\(P(n)\\) 为真的值来确定 \\(b\\)，如同在例6中所做的。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.289,
                0.88,
                0.303
            ],
            "angle": 0,
            "content": "2.写下“基础步骤”，证明 \\(P(b)\\) 为真，注意选择正确的 \\(b\\) ，这就完成了证明的第一步。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.308,
                0.896,
                0.341
            ],
            "angle": 0,
            "content": "3.写下“归纳步骤”，明确列出归纳假设，形式是“假设 \\(P(k)\\) 为真，对于任意确定的整数 \\(k\\geq b\\) ”。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.346,
                0.743,
                0.36
            ],
            "angle": 0,
            "content": "4. 列出在归纳假设的前提下需要证明的命题，即写出 \\(P(k + 1)\\) 的含义。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.365,
                0.896,
                0.417
            ],
            "angle": 0,
            "content": "5. 利用 \\(P(k)\\) 证明 \\(P(k + 1)\\)。（一般来讲，这是数学归纳法证明中最难的部分。确定最有希望的证明策略，并参考如何利用前面的归纳假设来完成证明的归纳步骤。确保对于所有 \\(k\\)，\\(k \\geq b\\)，证明是有效的，特别注意 \\(k\\) 值较小的时候，包括 \\(k = b\\)。）"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.423,
                0.612,
                0.436
            ],
            "angle": 0,
            "content": "6. 在归纳步骤明确结论，如写下“至此归纳步骤完成”。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.442,
                0.896,
                0.475
            ],
            "angle": 0,
            "content": "7. 在基础步骤和归纳步骤之后明确结论，即“依据数学归纳法，对于所有的 \\(n \\geqslant b\\)，\\(P(n)\\) 为真。”"
        },
        {
            "type": "list",
            "bbox": [
                0.071,
                0.212,
                0.896,
                0.475
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.066,
                0.485,
                0.911,
                0.541
            ],
            "angle": 0,
            "content": "在以下14个例题中，你将看到我们如何完成模板中所描述的步骤。在需要运用数学归纳法的练习中遵循这些原则是很有帮助的。在练习和后面章节中的其他各种数学归纳法中，这些原则也是适用的。"
        },
        {
            "type": "title",
            "bbox": [
                0.067,
                0.551,
                0.394,
                0.569
            ],
            "angle": 0,
            "content": "5.1.6 数学归纳法的优点与缺点"
        },
        {
            "type": "text",
            "bbox": [
                0.066,
                0.572,
                0.912,
                0.667
            ],
            "angle": 0,
            "content": "在开始使用数学归纳法之前有一点非常重要。数学归纳法的优点在于它能用于证明已经构造好的猜想（是正确的）。缺点是它不能用于发现新定理。数学家有时对使用数学归纳法证明不是非常满意，因为这种方法不能提供关于这些定理为什么是正确的启示。许多定理可以使用包括数学归纳法在内的方法证明。而数学家更愿意选择其他方法而不是数学归纳法，因为其他方法能带来关于正确性的启示。（见例8及其后的“评注”。）"
        },
        {
            "type": "title",
            "bbox": [
                0.067,
                0.676,
                0.416,
                0.694
            ],
            "angle": 0,
            "content": "5.1.7 利用数学归纳法证明的例子"
        },
        {
            "type": "text",
            "bbox": [
                0.066,
                0.697,
                0.914,
                0.81
            ],
            "angle": 0,
            "content": "许多定理都阐述了这样的事实：对所有的正整数 \\(n\\) 而言，\\(P(n)\\) 为真，其中 \\(P(n)\\) 是命题函数。数学归纳法是证明此类定理的一种方法。换句话说，数学归纳法可用来证明形如 \\(\\forall np(n)\\) 的一类定理，其中的论域是正整数集合。数学归纳法可用来证明非常广泛的一类定理，其中的每个定理都具有上述形式。（注意，有些命题隐式包含了全称量词。命题“如果 \\(n\\) 是一个正整数，那么 \\(n^3 - n\\) 能被3整除”就是这样的例子。显式表达其隐含的全称量词就是“对于每一个正整数 \\(n\\) ，\\(n^3 - n\\) 能被3整除”。）"
        },
        {
            "type": "text",
            "bbox": [
                0.066,
                0.813,
                0.917,
                0.926
            ],
            "angle": 0,
            "content": "我们将给出大量的例子来阐述如何使用数学归纳法进行证明。将要证明的定理包括求和公式、不等式、关于集合的组合恒等式、整除性结论、关于算法的定理，以及其他一些创新性的结论。在本节和后面各节中，将利用数学归纳法证明许多其他类型的结论，包括计算机程序和算法的正确性。数学归纳法可用来证明大量的定理，这些定理可能与本书中所给出的例子相似，或者形式完全不同。（要了解数学归纳法更有趣和更多的证明结果，可以参看DaivdGunderson[Gu11]写的《数学归纳法手册》（HandbookofMathematicalEnduction)一书。）"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.928,
                0.915,
                0.945
            ],
            "angle": 0,
            "content": "在归纳法证明中，会经常犯各种错误。我们将会在本节的最后以及本节练习中给出一些不"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.134,
                0.043,
                0.172,
                0.057
            ],
            "angle": 0,
            "content": "282"
        },
        {
            "type": "header",
            "bbox": [
                0.216,
                0.042,
                0.282,
                0.058
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.097,
                0.953,
                0.134
            ],
            "angle": 0,
            "content": "正确的证明，以示说明。为了避免在数学归纳法证明时犯错误，可以遵循5.1.5节给出的指导原则。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.136,
                0.953,
                0.191
            ],
            "angle": 0,
            "content": "了解在什么情况下使用归纳假设 为了帮助读者理解本节中数学归纳法的证明例题，我们将注明归纳假设使用的地方。我们将采用三种方式表示：在文字中明显标注，在等式或者不等式上插入缩写IH（表示归纳假设），或者在多行显示中指出归纳假设是推理的一个步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.193,
                0.953,
                0.268
            ],
            "angle": 0,
            "content": "证明求和公式 通过证明几个不同的求和公式开始使用数学归纳法。我们将会看到，数学归纳法尤其适用于证明这类公式的有效性。不过，求和公式也可以用其他方法来证明，这一点并不奇怪，因为一个定理的证明通常有许多种方法。使用数学归纳法的一个主要缺点是不能用它来导出一个求和公式。也就是说，在用数学归纳法证明一个公式之前，该公式已经存在了。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.269,
                0.953,
                0.305
            ],
            "angle": 0,
            "content": "例 \\(1\\sim 4\\) 举例说明了怎么用数学归纳法证明求和公式。第一个数学归纳法的例子是证明一个求和公式：最小的 \\(n\\) 个正整数之和的闭公式。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.307,
                0.65,
                0.336
            ],
            "angle": 0,
            "content": "例1 证明：若 \\(n\\) 是正整数，则 \\(1 + 2 + \\dots + n = \\frac{n(n + 1)}{2}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.344,
                0.953,
                0.412
            ],
            "angle": 0,
            "content": "解设 \\(P(n)\\) 是命题：前 \\(n\\) 个正整数之和是 \\(\\frac{n(n + 1)}{2}\\) 。要证明对 \\(n = 1, 2, 3, \\dots, P(n)\\) 为真必须做两件事情，即必须证明 \\(P(1)\\) 为真，以及对 \\(k = 1, 2, 3, \\dots\\) 来说条件语句 \\(P(k)\\) 蕴含 \\(P(k + 1)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.414,
                0.953,
                0.476
            ],
            "angle": 0,
            "content": "基础步骤： \\(P(1)\\) 为真，因为 \\(1 = \\frac{1(1 + 1)}{2}\\) （等式左边为1是因为第一个正整数之和为1，等式右边为1是因为1代入 \\(n\\) 后， \\(\\frac{n(n + 1)}{2}\\) 为1）。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.481,
                0.805,
                0.499
            ],
            "angle": 0,
            "content": "归纳步骤：关于归纳假设，假定对任意一个正整数 \\(k\\) ， \\(P(k)\\) 成立，即假定"
        },
        {
            "type": "equation",
            "bbox": [
                0.408,
                0.501,
                0.648,
                0.53
            ],
            "angle": 0,
            "content": "\\[\n1 + 2 + \\dots + k = \\frac {k (k + 1)}{2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.535,
                0.476,
                0.551
            ],
            "angle": 0,
            "content": "在这个假设之下，必有 \\(P(k + 1)\\) 为真，即"
        },
        {
            "type": "equation",
            "bbox": [
                0.223,
                0.553,
                0.831,
                0.583
            ],
            "angle": 0,
            "content": "\\[\n1 + 2 + \\dots + k + (k + 1) = \\frac {(k + 1) [ (k + 1) + 1 ]}{2} = \\frac {(k + 1) (k + 2)}{2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.589,
                0.179,
                0.604
            ],
            "angle": 0,
            "content": "也为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.607,
                0.953,
                0.661
            ],
            "angle": 0,
            "content": "我们看一下如何利用前面的归纳假设 \\(P(k)\\) 为真来证明 \\(P(k + 1)\\) 成立。观察一下，\\(P(k + 1)\\) 的左边求和比 \\(P(k)\\) 的左边求和多 \\(k + 1\\)，因此，我们的策略是在 \\(P(k)\\) 等式的两边同时加上 \\(k + 1\\)，并通过简化代数形式来完成归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.664,
                0.611,
                0.68
            ],
            "angle": 0,
            "content": "回到归纳步骤， \\(P(k)\\) 等式的两边都加上 \\(k + 1\\) ，得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.317,
                0.685,
                0.739,
                0.78
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} 1 + 2 + \\dots + k + (k + 1) \\equiv \\frac {m}{2} \\frac {k (k + 1)}{2} + (k + 1) \\\\ = \\frac {k (k + 1) + 2 (k + 1)}{2} \\\\ = \\frac {(k + 1) (k + 2)}{2} \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.785,
                0.859,
                0.802
            ],
            "angle": 0,
            "content": "最后这个等式证明了在 \\(P(k)\\) 为真的假设下，\\(P(k + 1)\\) 为真。这样就完成了归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.805,
                0.953,
                0.84
            ],
            "angle": 0,
            "content": "我们已经完成了基础步骤和归纳步骤，因此，根据数学归纳法知道对所有的 \\(n\\) ， \\(P(n)\\) 为真。也就是说，已经证明了对所有的 \\(n\\) ， \\(1 + 2 + \\dots + n = n(n + 1) / 2\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.842,
                0.953,
                0.878
            ],
            "angle": 0,
            "content": "正如前面所说明的，数学归纳法不是一种寻求所有正整数定理的工具。相反，它是一种证明一类猜想结论的方法。在例2中，将利用数学归纳法生成一个公式，同时证明一个猜想。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.882,
                0.848,
                0.9
            ],
            "angle": 0,
            "content": "例2 为前 \\(n\\) 个奇数猜想一个求和公式，然后利用数学归纳法来证明你的猜想。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.905,
                0.584,
                0.921
            ],
            "angle": 0,
            "content": "解 对 \\(n = 1\\) ，2，3，4，5，前 \\(n\\) 个正奇数之和为"
        },
        {
            "type": "equation",
            "bbox": [
                0.218,
                0.924,
                0.838,
                0.94
            ],
            "angle": 0,
            "content": "\\[\n1 = 1, 1 + 3 = 4, 1 + 3 + 5 = 9, 1 + 3 + 5 + 7 = 1 6, 1 + 3 + 5 + 7 + 9 = 2 5\n\\]"
        },
        {
            "type": "image",
            "bbox": [
                0.029,
                0.307,
                0.092,
                0.324
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.671,
                0.04,
                0.781,
                0.055
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.828,
                0.042,
                0.864,
                0.055
            ],
            "angle": 0,
            "content": "283"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.096,
                0.893,
                0.132
            ],
            "angle": 0,
            "content": "根据上述这些值猜想前 \\(n\\) 个正奇数之和为 \\(n^2\\) 是合理的，即 \\(1 + 3 + 5 + \\dots + (2n - 1) = n^2\\)。我们需要一个方法来证明这个猜想是正确的，如果事实确实如此。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.134,
                0.893,
                0.19
            ],
            "angle": 0,
            "content": "设 \\(P(n)\\) 表示命题：前 \\(n\\) 个正奇数之和是 \\(n^2\\) 。我们的猜想是：对所有正整数而言 \\(P(n)\\) 为真。为了使用数学归纳法来证明该猜想，必须首先完成基础步骤，即必须证明 \\(P(1)\\) 为真；然后必须完成归纳步骤，即必须证明当假定 \\(P(k)\\) 为真时 \\(P(k + 1)\\) 为真。现在我们来完成这两个步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.192,
                0.892,
                0.228
            ],
            "angle": 0,
            "content": "基础步骤：\\(P(1)\\) 表示第1个正奇数之和是 \\(1^2\\) 。这是真的，因为第1个正奇数之和是1。基础步骤完成。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.231,
                0.892,
                0.267
            ],
            "angle": 0,
            "content": "归纳步骤：为了完成归纳步骤，必须证明对所有正整数 \\(k\\) 来说，命题 \\(P(k) \\rightarrow P(k + 1)\\) 为真。为了做到这一点，假定对正整数 \\(k\\) 来说，\\(P(k)\\) 为真，即"
        },
        {
            "type": "equation",
            "bbox": [
                0.345,
                0.269,
                0.59,
                0.286
            ],
            "angle": 0,
            "content": "\\[\n1 + 3 + 5 + \\dots + (2 k - 1) = k ^ {2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.289,
                0.892,
                0.326
            ],
            "angle": 0,
            "content": "（注意第 \\(k\\) 个正奇数是 \\((2k - 1)\\) ，因为该整数是由2倍的 \\((k - 1)\\) 加1而得到的。）为证明 \\(\\forall k(P(k)\\rightarrow\\) \\(P(k + 1))\\) 为真，必须证明：假定 \\(P(k)\\) 为真(归纳假设)，则 \\(P(k + 1)\\) 为真。注意 \\(P(k + 1)\\) 是命题"
        },
        {
            "type": "equation",
            "bbox": [
                0.271,
                0.327,
                0.66,
                0.344
            ],
            "angle": 0,
            "content": "\\[\n1 + 3 + 5 + \\dots + (2 k - 1) + (2 k + 1) = (k + 1) ^ {2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.347,
                0.892,
                0.422
            ],
            "angle": 0,
            "content": "在完成归纳步骤之前，我们先想一下证明策略。数学归纳法证明的这个阶段要找到一种方法来从归纳假设证明 \\(P(k + 1)\\) 为真。这里我们发现 \\(1 + 3 + 5 + \\dots +(2k - 1) + (2k + 1)\\) 是前 \\(k\\) 项和 \\(1 + 3 + 5 + \\dots +(2k - 1)\\) 加上最后一项 \\((2k + 1)\\) 。所以我们可以用归纳假设将 \\(1 + 3 + 5 + \\dots +(2k - 1)\\) 换为 \\(k^2\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.083,
                0.424,
                0.382,
                0.44
            ],
            "angle": 0,
            "content": "现在返回我们的证明，可以发现："
        },
        {
            "type": "equation",
            "bbox": [
                0.13,
                0.445,
                0.798,
                0.52
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} 1 + 3 + 5 + \\dots + (2 k - 1) + (2 k + 1) = [ 1 + 3 + \\dots + (2 k - 1) ] + (2 k + 1) \\\\ \\stackrel {\\text {H}} {=} k ^ {2} + (2 k + 1) \\\\ = k ^ {2} + 2 k + 1 \\\\ = (k + 1) ^ {2} \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.525,
                0.89,
                0.561
            ],
            "angle": 0,
            "content": "这就证明了 \\(P(k + 1)\\) 可以从 \\(P(k)\\) 导出。注意在第二个等式里使用了归纳假设 \\(P(k)\\)，即用 \\(k^2\\) 代替前 \\(k\\) 个正奇数之和。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.563,
                0.89,
                0.62
            ],
            "angle": 0,
            "content": "现在已经完成了基础步骤和归纳步骤。也就是说，我们已经证明了 \\(P(1)\\) 为真，而且对所有正整数 \\(k\\) 来说，蕴含式 \\(P(k) \\rightarrow P(k + 1)\\) 为真。所以，根据数学归纳法原理，可以得出结论：对所有正整数 \\(n\\) 来说 \\(P(n)\\) 为真。即对所有正整数 \\(n\\) ，\\(1 + 3 + 5 + \\dots + (2n - 1) = n^2\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.625,
                0.538,
                0.642
            ],
            "angle": 0,
            "content": "例3 用数学归纳法证明：对所有非负整数 \\(n\\) 来说，"
        },
        {
            "type": "equation",
            "bbox": [
                0.34,
                0.647,
                0.589,
                0.664
            ],
            "angle": 0,
            "content": "\\[\n1 + 2 + 2 ^ {2} + \\dots + 2 ^ {n} = 2 ^ {n + 1} - 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.667,
                0.759,
                0.684
            ],
            "angle": 0,
            "content": "解设 \\(P(n)\\) 是命题：对所有非负整数 \\(n\\) 来说， \\(1 + 2 + 2^{2} + \\dots +2^{n} = 2^{n + 1} - 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.687,
                0.673,
                0.704
            ],
            "angle": 0,
            "content": "基础步骤： \\(P(0)\\) 为真，因为 \\(2^{0} = 1 = 2^{1} - 1\\) 。这就完成了基础步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.706,
                0.564,
                0.723
            ],
            "angle": 0,
            "content": "归纳步骤：由归纳假设，我们假定 \\(P(k)\\) 为真。即假定"
        },
        {
            "type": "equation",
            "bbox": [
                0.34,
                0.725,
                0.589,
                0.742
            ],
            "angle": 0,
            "content": "\\[\n1 + 2 + 2 ^ {2} + \\dots + 2 ^ {k} = 2 ^ {k + 1} - 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.745,
                0.889,
                0.78
            ],
            "angle": 0,
            "content": "为了利用该假定来完成归纳步骤，必须证明：如果 \\(P(k)\\) 为真，则 \\(P(k + 1)\\) 也为真。即在归纳假设 \\(P(k)\\) 下，必须证明"
        },
        {
            "type": "equation",
            "bbox": [
                0.256,
                0.782,
                0.673,
                0.8
            ],
            "angle": 0,
            "content": "\\[\n1 + 2 + 2 ^ {2} + \\dots + 2 ^ {k} + 2 ^ {k + 1} = 2 ^ {(k + 1) + 1} - 1 = 2 ^ {k + 2} - 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.803,
                0.235,
                0.819
            ],
            "angle": 0,
            "content": "在 \\(P(k)\\) 的假设下，有"
        },
        {
            "type": "equation",
            "bbox": [
                0.205,
                0.824,
                0.718,
                0.897
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} 1 + 2 + 2 ^ {2} + \\dots + 2 ^ {k} + 2 ^ {k + 1} = (1 + 2 + 2 ^ {2} + \\dots + 2 ^ {k}) + 2 ^ {k + 1} \\\\ \\equiv (2 ^ {k + 1} - 1) + 2 ^ {k + 1} \\\\ = 2 \\cdot 2 ^ {k + 1} - 1 \\\\ = 2 ^ {k + 2} - 1 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.904,
                0.889,
                0.94
            ],
            "angle": 0,
            "content": "注意，在第二个等式中，利用了归纳假设，用 \\(2^{k + 1} - 1\\) 代替了 \\(1 + 2 + 2^2 + \\dots + 2^k\\) 。这样就完成了归纳步骤。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.136,
                0.042,
                0.172,
                0.056
            ],
            "angle": 0,
            "content": "284"
        },
        {
            "type": "header",
            "bbox": [
                0.217,
                0.04,
                0.282,
                0.056
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.097,
                0.957,
                0.132
            ],
            "angle": 0,
            "content": "因为已经完成了基础步骤和归纳步骤，所以根据数学归纳法知道，对所有非负整数 \\(n\\) 而言，\\(P(n)\\) 为真，即对所有非负整数 \\(n\\)，\\(1 + 2 + \\dots + 2^n = 2^{n+1} - 1\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.136,
                0.957,
                0.171
            ],
            "angle": 0,
            "content": "例3中给出的公式是几何级数项一般求和结果的一种特殊情况（2.4节中的定理1）。我们将利用数学归纳法给出该公式的另外一种证明方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.177,
                0.917,
                0.194
            ],
            "angle": 0,
            "content": "例4几何级数的求和 用数学归纳法证明一个几何级数的有限项之和具有如下形式："
        },
        {
            "type": "equation",
            "bbox": [
                0.294,
                0.199,
                0.775,
                0.232
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {j = 0} ^ {n} a r ^ {j} = a + a r + a r ^ {2} + \\dots + a r ^ {n} = \\frac {a r ^ {n + 1} - a}{r - 1} \\quad r \\neq 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.234,
                0.329,
                0.251
            ],
            "angle": 0,
            "content": "其中 \\(n\\) 是一个非负整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.254,
                0.957,
                0.289
            ],
            "angle": 0,
            "content": "解为了用数学归纳法来证明这个公式，设 \\(P(n)\\) 是命题：一个几何级数的前 \\(n + 1\\) 项之和的上述公式是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.292,
                0.407,
                0.308
            ],
            "angle": 0,
            "content": "基础步骤： \\(P(0)\\) 为真，因为"
        },
        {
            "type": "equation",
            "bbox": [
                0.375,
                0.311,
                0.697,
                0.341
            ],
            "angle": 0,
            "content": "\\[\n\\frac {a r ^ {0 + 1} - a}{r - 1} = \\frac {a r - a}{r - 1} = \\frac {a (r - 1)}{r - 1} = a\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.346,
                0.928,
                0.362
            ],
            "angle": 0,
            "content": "归纳步骤：归纳假设是命题： \\(P(k)\\) 为真，其中 \\(k\\) 是一个非负整数。即 \\(P(k)\\) 为如下命题"
        },
        {
            "type": "equation",
            "bbox": [
                0.374,
                0.365,
                0.698,
                0.395
            ],
            "angle": 0,
            "content": "\\[\na + a r + a r ^ {2} + \\dots + a r ^ {k} = \\frac {a r ^ {k + 1} - a}{r - 1}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.4,
                0.96,
                0.436
            ],
            "angle": 0,
            "content": "为了完成归纳步骤，必须证明：如果 \\(P(k)\\) 为真，则 \\(P(k + 1)\\) 也为真。要证明 \\(P(k + 1)\\) 为真，先将这个等式的两边都加上 \\(ar^{k + 1}\\)，得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.306,
                0.439,
                0.765,
                0.468
            ],
            "angle": 0,
            "content": "\\[\na + a r + a r ^ {2} + \\dots + a r ^ {k} + a r ^ {k + 1} \\stackrel {\\mathrm {I I I}} {=} \\frac {a r ^ {k + 1} - a}{r - 1} + a r ^ {k + 1}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.474,
                0.344,
                0.49
            ],
            "angle": 0,
            "content": "改写这个等式的右边可得"
        },
        {
            "type": "equation",
            "bbox": [
                0.281,
                0.492,
                0.794,
                0.523
            ],
            "angle": 0,
            "content": "\\[\n\\frac {a r ^ {k + 1} - a}{r - 1} + a r ^ {k + 1} = \\frac {a r ^ {k + 1} - a}{r - 1} + \\frac {a r ^ {k + 2} - a r ^ {k + 1}}{r - 1} = \\frac {a r ^ {k + 2} - a}{r - 1}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.528,
                0.364,
                0.544
            ],
            "angle": 0,
            "content": "把这些等式组合起来就给出"
        },
        {
            "type": "equation",
            "bbox": [
                0.341,
                0.547,
                0.734,
                0.577
            ],
            "angle": 0,
            "content": "\\[\na + a r + a r ^ {2} + \\dots + a r ^ {k} + a r ^ {k + 1} = \\frac {a r ^ {k + 2} - a}{r - 1}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.582,
                0.936,
                0.598
            ],
            "angle": 0,
            "content": "这就证明了：如果归纳假设 \\(P(k)\\) 为真，则 \\(P(k + 1)\\) 也必为真。这就完成了归纳步骤的证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.601,
                0.96,
                0.636
            ],
            "angle": 0,
            "content": "现在已经完成了基础步骤和归纳步骤，根据数学归纳法知，对所有的非负整数 \\(n\\) ， \\(P(n)\\) 为真。这就证明了关于几何级数项的求和公式是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.64,
                0.96,
                0.674
            ],
            "angle": 0,
            "content": "正如前面所提到的，例3中的公式是例4公式中 \\(a = 1\\) 、 \\(r = 2\\) 时的特殊情况。读者可以验证，将 \\(a\\) 和 \\(r\\) 的值代入上述一般公式，所得结果与例3应该是相同的。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.678,
                0.962,
                0.713
            ],
            "angle": 0,
            "content": "证明不等式 数学归纳法可用于证明大量的不等式，这些不等式对于所有大于某个特定正整数的整数来说都成立，参见例 \\(5 \\sim 7\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.153,
                0.719,
                0.775,
                0.736
            ],
            "angle": 0,
            "content": "例5 用数学归纳法证明：不等式 \\(n < 2^{n}\\) 对所有正整数 \\(n\\) 都是成立的。"
        },
        {
            "type": "text",
            "bbox": [
                0.154,
                0.742,
                0.414,
                0.758
            ],
            "angle": 0,
            "content": "解设 \\(P(n)\\) 是命题： \\(n <   2^{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.155,
                0.761,
                0.711,
                0.777
            ],
            "angle": 0,
            "content": "基础步骤： \\(P(1)\\) 为真，因为 \\(1 <   2^{1} = 2\\) 。这就完成了基础步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.781,
                0.964,
                0.856
            ],
            "angle": 0,
            "content": "归纳步骤：首先给出归纳假设，假定对正整数 \\(k\\) 而言，\\(P(k)\\) 为真。即归纳假设 \\(P(k)\\) 是命题 \\(k < 2^k\\) 。为了完成归纳步骤，需要证明：如果 \\(P(k)\\) 为真，那么 \\(P(k + 1)\\) 为真，即命题 \\(k + 1 < 2^{k + 1}\\) 为真。也就是说，需要证明：如果 \\(k < 2^k\\) ，则 \\(k + 1 < 2^{k + 1}\\) 。为了证明对所有正整数 \\(k\\) ，上面的蕴含式为真，先在 \\(k < 2^k\\) 的两端都加1，由于 \\(1 \\leqslant 2^k\\) ，于是有"
        },
        {
            "type": "equation",
            "bbox": [
                0.381,
                0.859,
                0.697,
                0.881
            ],
            "angle": 0,
            "content": "\\[\nk + 1 <   2 ^ {k} + 1 \\leqslant 2 ^ {k} + 2 ^ {k} = 2 \\cdot 2 ^ {k} = 2 ^ {k + 1}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.884,
                0.641,
                0.9
            ],
            "angle": 0,
            "content": "这就证明了 \\(P(k + 1)\\) 为真，即 \\(k + 1 < 2^{k + 1}\\) 。归纳步骤完毕。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.904,
                0.964,
                0.94
            ],
            "angle": 0,
            "content": "由于完成了基础步骤和归纳步骤，因此，根据数学归纳法，我们已经证明了：对所有的正整数 \\(n\\) ， \\(n < 2^{n}\\) 成立。"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.038,
                0.716,
                0.102,
                0.733
            ],
            "angle": 0,
            "content": "Extra Examples"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.687,
                0.041,
                0.796,
                0.056
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.844,
                0.043,
                0.879,
                0.055
            ],
            "angle": 0,
            "content": "285"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.1,
                0.909,
                0.139
            ],
            "angle": 0,
            "content": "例6 用数学归纳法证明：对每个满足 \\(n \\geqslant 4\\) 的正整数 \\(n\\) 来说，有 \\(2^n < n!\\)。（注意，该不等式对 \\(n = 1, 2, 3\\) 是不成立的。）"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.142,
                0.368,
                0.158
            ],
            "angle": 0,
            "content": "解设 \\(P(n)\\) 是命题： \\(2^{n} <   n!\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.161,
                0.91,
                0.197
            ],
            "angle": 0,
            "content": "基础步骤：为了证明对 \\(n \\geqslant 4\\) 来说这个不等式成立，基础步骤应该是 \\(P(4)\\) 。注意 \\(P(4)\\) 为真，因为 \\(2^4 = 16 < 24 = 4!\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.2,
                0.912,
                0.256
            ],
            "angle": 0,
            "content": "归纳步骤：对归纳步骤，假定对 \\(k \\geqslant 4\\) 的正整数而言，\\(P(k)\\) 为真。即假定对 \\(k \\geqslant 4\\) 的正整数 \\(k\\)，\\(2^k < k!\\) 成立。必须证明在此假设下，\\(P(k + 1)\\) 也为真。也就是说，必须证明：如果对 \\(k \\geqslant 4\\) 的正整数而言，\\(2^k < k!\\) 为真，则有 \\(2^{k + 1} < (k + 1)!\\)。因为"
        },
        {
            "type": "equation",
            "bbox": [
                0.291,
                0.259,
                0.719,
                0.332
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} 2 ^ {k + 1} = 2 \\cdot 2 ^ {k} \\quad \\text {根 据 指 数 的 定 义} \\\\ <   2 \\cdot k! \\quad \\text {根 据 归 纳 假 设} \\\\ <   (k + 1) k! \\quad \\text {因 为} 2 <   k + 1 \\\\ = (k + 1)! \\quad \\text {根 据 阶 乘 函 数 的 定 义} \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.336,
                0.514,
                0.352
            ],
            "angle": 0,
            "content": "所以当 \\(P(k)\\) 为真时 \\(P(k + 1)\\) 为真。归纳步骤完成。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.355,
                0.912,
                0.391
            ],
            "angle": 0,
            "content": "我们已经完成了基础步骤和归纳步骤。因此，根据数学归纳法，对所有 \\(n \\geqslant 4\\) 的正整数而言，\\(P(n)\\) 为真，即已经证明了对所有 \\(n \\geqslant 4\\) 的正整数，\\(2^n < n!\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.394,
                0.632,
                0.41
            ],
            "angle": 0,
            "content": "例7将证明一个重要的关于正整数集的倒数之和的不等式。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.416,
                0.743,
                0.433
            ],
            "angle": 0,
            "content": "例7 关于调和数的一个不等式 调和数 \\(H_{j}(j = 1,2,3,\\dots)\\) 的定义为"
        },
        {
            "type": "equation",
            "bbox": [
                0.359,
                0.439,
                0.617,
                0.47
            ],
            "angle": 0,
            "content": "\\[\nH _ {j} = 1 + \\frac {1}{2} + \\frac {1}{3} + \\dots + \\frac {1}{j}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.474,
                0.15,
                0.49
            ],
            "angle": 0,
            "content": "例如"
        },
        {
            "type": "equation",
            "bbox": [
                0.356,
                0.493,
                0.622,
                0.523
            ],
            "angle": 0,
            "content": "\\[\nH _ {4} = 1 + \\frac {1}{2} + \\frac {1}{3} + \\frac {1}{4} = \\frac {2 5}{1 2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.528,
                0.232,
                0.544
            ],
            "angle": 0,
            "content": "用数学归纳法证明"
        },
        {
            "type": "equation",
            "bbox": [
                0.426,
                0.551,
                0.553,
                0.576
            ],
            "angle": 0,
            "content": "\\[\nH _ {2 ^ {n}} \\geqslant 1 + \\frac {n}{2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.582,
                0.283,
                0.598
            ],
            "angle": 0,
            "content": "其中 \\(n\\) 是一个非负整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.606,
                0.607,
                0.631
            ],
            "angle": 0,
            "content": "解为了完成这个证明，设 \\(P(n)\\) 是命题： \\(H_{2^n}\\geqslant 1 + \\frac{n}{2}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.636,
                0.571,
                0.653
            ],
            "angle": 0,
            "content": "基础步骤： \\(P(0)\\) 为真，因为 \\(H_{2^0} = H_1 = 1\\geqslant 1 + 0 / 2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.656,
                0.915,
                0.71
            ],
            "angle": 0,
            "content": "归纳步骤：归纳假设是命题 \\(P(k)\\) 为真，即 \\(H_{2^k} \\geqslant 1 + k / 2\\) ，其中 \\(k\\) 是非负整数。必须证明：如果 \\(P(k)\\) 为真，则 \\(P(k + 1)\\) 也为真，即命题 \\(H_{2^{k + 1}} \\geqslant 1 + (k + 1) / 2\\) 为真。因此，由归纳假设，有"
        },
        {
            "type": "equation",
            "bbox": [
                0.136,
                0.715,
                0.889,
                0.92
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} H _ {2 ^ {k + 1}} = 1 + \\frac {1}{2} + \\frac {1}{3} + \\dots + \\frac {1}{2 ^ {k}} + \\frac {1}{2 ^ {k} + 1} + \\dots + \\frac {1}{2 ^ {k + 1}} \\quad \\text {根 据 调 和 数 的 定 义} \\\\ = H _ {2 ^ {k}} + \\frac {1}{2 ^ {k} + 1} + \\dots + \\frac {1}{2 ^ {k + 1}} \\quad \\text {根 据 第} 2 ^ {k} \\text {个 调 和 数 的 定 义} \\\\ \\geqslant \\left(1 + \\frac {k}{2}\\right) + \\frac {1}{2 ^ {k} + 1} + \\dots + \\frac {1}{2 ^ {k + 1}} \\quad \\text {根 据 归 纳 假 设} \\\\ \\geqslant \\left(1 + \\frac {k}{2}\\right) + 2 ^ {k} \\cdot \\frac {1}{2 ^ {k + 1}} \\quad \\text {因 为 有} 2 ^ {k} \\text {项 ， 每 项} \\geqslant 1 / 2 ^ {k + 1} \\\\ \\geqslant \\left(1 + \\frac {k}{2}\\right) + \\frac {1}{2} \\quad \\text {第 2 项 中 消 去 公 共 因 子} 2 ^ {k} \\\\ = 1 + \\frac {k + 1}{2} \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.07,
                0.926,
                0.348,
                0.942
            ],
            "angle": 0,
            "content": "这样就完成了归纳步骤的证明。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.13,
                0.04,
                0.167,
                0.054
            ],
            "angle": 0,
            "content": "286"
        },
        {
            "type": "header",
            "bbox": [
                0.212,
                0.039,
                0.278,
                0.054
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.096,
                0.95,
                0.146
            ],
            "angle": 0,
            "content": "我们已经完成了基础步骤和归纳步骤。因此，根据数学归纳法，对所有的非负整数 \\(n\\) \\(P(n)\\) 为真。也就是说，对所有非负整数 \\(n\\) ，关于调和数的不等式 \\(H_{2^{n}}\\geqslant 1 + \\frac{n}{2}\\) 都成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.149,
                0.581,
                0.165
            ],
            "angle": 0,
            "content": "评注 可以用这里证明的不等式去证明调和级数"
        },
        {
            "type": "equation",
            "bbox": [
                0.413,
                0.169,
                0.637,
                0.198
            ],
            "angle": 0,
            "content": "\\[\n1 + \\frac {1}{2} + \\frac {1}{3} + \\dots + \\frac {1}{n} + \\dots\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.203,
                0.733,
                0.219
            ],
            "angle": 0,
            "content": "是一个发散的无穷级数。该级数是无穷级数研究中的一个重要的例子。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.222,
                0.951,
                0.276
            ],
            "angle": 0,
            "content": "证明整除性结论 数学归纳法可用来证明整数的整除性结论。尽管整数的整除性问题用数论中的基本结论更容易证明，但了解如何利用数学归纳法来证明这种问题将具有一定的指导意义，请参见例8和例9。"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.281,
                0.714,
                0.299
            ],
            "angle": 0,
            "content": "例8 用数学归纳法证明：当 \\(n\\) 是正整数时，\\(n^3 - n\\) 可被3整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.304,
                0.7,
                0.319
            ],
            "angle": 0,
            "content": "解为了构造这个证明，设 \\(P(n)\\) 是命题 \\(\"n^{3} - n\\) 可被3整除”。"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.323,
                0.848,
                0.339
            ],
            "angle": 0,
            "content": "基础步骤：命题 \\(P(1)\\) 为真，因为 \\(1^{3} - 1 = 0\\) 可被3整除，这就完成了基础步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.342,
                0.949,
                0.377
            ],
            "angle": 0,
            "content": "归纳步骤：关于归纳假设，假定 \\(P(k)\\) 为真，即 \\(k^3 - k\\) 可被3整除。为了完成归纳步骤，必须证明在归纳假设下，\\(P(k + 1)\\) 为真。即证明 \\((k + 1)^3 - (k + 1)\\) 可被3整除。注意"
        },
        {
            "type": "equation",
            "bbox": [
                0.294,
                0.38,
                0.753,
                0.415
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} (k + 1) ^ {3} - (k + 1) = (k ^ {3} + 3 k ^ {2} + 3 k + 1) - (k + 1) \\\\ = (k ^ {3} - k) + 3 (k ^ {2} + k) \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.419,
                0.949,
                0.453
            ],
            "angle": 0,
            "content": "因为在这个和里的两项都可被3整除（第一项是根据归纳假设，第二项是因为它是一个整数的3倍），由此得出 \\((k + 1)^{3} - (k + 1)\\) 也可被3整除。这样就完成了归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.457,
                0.949,
                0.492
            ],
            "angle": 0,
            "content": "因为我们既完成了基础步骤，又完成了归纳步骤，所以根据数学归纳法原理可知，当 \\(n\\) 是正整数时，\\(n^3 - n\\) 可被3整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.495,
                0.949,
                0.568
            ],
            "angle": 0,
            "content": "评注：我们用例8说明了如何用数学归纳法来证明整除性结论。但是，也有一些更简单的证明方法。例如，要证明对于所有的正整数 \\(n\\) ， \\(n^3 - n\\) 可被3整除，可用因式分解方法，即 \\(n^3 - n = n(n^2 - 1) = n(n - 1)(n + 1) = (n - 1)n(n + 1)\\) 。因为三个连续整数之积一定能被3整除（因为其中一个一定能被3整除），所以 \\(n^3 - n\\) 可被3整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.571,
                0.711,
                0.587
            ],
            "angle": 0,
            "content": "下一个例题是一个更有挑战性的关于整除的数学归纳法证明题。"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.592,
                0.744,
                0.609
            ],
            "angle": 0,
            "content": "例9 使用数学归纳法证明 \\(7^{n + 2} + 8^{2n + 1}\\) 能被57整除，\\(n\\) 为非负整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.615,
                0.691,
                0.631
            ],
            "angle": 0,
            "content": "解为了证明，设 \\(P(n)\\) 表示命题 \\(\"7^{n + 2} + 8^{2n + 1}\\) 能被57整除”。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.634,
                0.949,
                0.688
            ],
            "angle": 0,
            "content": "基础步骤：为了完成基础步骤，我们必须证明 \\(P(0)\\) 为真，因为我们要证明 \\(P(n)\\) 对于所有的非负整数为真。我们可以看到 \\(P(0)\\) 为真，因为 \\(7^{0 + 2} + 8^{0 + 1} = 7^2 + 8^1 = 57\\) ，能被57整除。这样就完成了基础步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.691,
                0.949,
                0.745
            ],
            "angle": 0,
            "content": "归纳步骤：对归纳假设，我们假设对于任意非负整数 \\(k\\) ， \\(P(k)\\) 成立。即假设 \\(7^{k + 2} + 8^{2k + 1}\\) 能被57整除。为了完成归纳步骤，我们必须证明当假设归纳假设 \\(P(k)\\) 为真时， \\(P(k + 1)\\) ，即\\(7^{(k + 1) + 2} + 8^{2(k + 1) + 1}\\) 能被57整除成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.748,
                0.812,
                0.764
            ],
            "angle": 0,
            "content": "证明中难的一部分是如何应用归纳假设。基于归纳假设，我们有如下几步："
        },
        {
            "type": "equation",
            "bbox": [
                0.319,
                0.767,
                0.724,
                0.84
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} 7 ^ {(k + 1) + 2} + 8 ^ {2 (k + 1) + 1} = 7 ^ {k + 3} + 8 ^ {2 k + 3} \\\\ = 7 \\cdot 7 ^ {k + 2} + 8 ^ {2} \\cdot 8 ^ {2 k + 1} \\\\ = 7 \\cdot 7 ^ {k + 2} + 6 4 \\cdot 8 ^ {2 k + 1} \\\\ = 7 \\left(7 ^ {k + 2} + 8 ^ {2 k + 1}\\right) + 5 7 \\cdot 8 ^ {2 k + 1} \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.844,
                0.949,
                0.918
            ],
            "angle": 0,
            "content": "现在我们可以应用归纳假设，\\(7^{k+2} + 8^{2k+1}\\) 能被57整除。我们运用4.1节定理1中的(i)和(ii)。由定理1中的(ii)和归纳假设，我们最后和式中的第一项 \\(7(7^{k+2} + 8^{2k+1})\\) 能被57整除；由定理1中的(ii)，和式中的第二项 \\(57 \\cdot 8^{2k+1}\\) 能被57整除。因此，由定理1中的(i)，我们可以得到 \\(7(7^{k+2} + 8^{2k+1}) + 57 \\cdot 8^{2k+1} = 7^{(k+1)+2} + 8^{2(k+1)+1}\\) 能被57整除。这样就完成了归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.921,
                0.949,
                0.937
            ],
            "angle": 0,
            "content": "因为我们已经完成了基础步骤和归纳步骤，所以根据数学归纳法，对所有的非负整数 \\(n\\)"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.023,
                0.278,
                0.087,
                0.296
            ],
            "angle": 0,
            "content": "Extra Examples"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.662,
                0.04,
                0.772,
                0.055
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.819,
                0.041,
                0.856,
                0.055
            ],
            "angle": 0,
            "content": "287"
        },
        {
            "type": "text",
            "bbox": [
                0.037,
                0.097,
                0.25,
                0.113
            ],
            "angle": 0,
            "content": "\\(7^{n + 2} + 8^{2n + 1}\\) 能被57整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.037,
                0.116,
                0.884,
                0.152
            ],
            "angle": 0,
            "content": "证明有关集合的结论 数学归纳法可用来证明许多有关集合的结论。在下面的例10中将证明一个关于有限集合子集个数的结论，而在例11中将建立一个集合恒等式。"
        },
        {
            "type": "text",
            "bbox": [
                0.038,
                0.156,
                0.885,
                0.195
            ],
            "angle": 0,
            "content": "例10有限集合子集的个数用数学归纳法证明：若 \\(S\\) 是有 \\(_n\\) 个元素的有限集合，其中 \\(n\\) 是一个非负整数，则 \\(S\\) 有 \\(2^{n}\\) 个子集。（在第6章里我们将以多种方式直接证明这个结果。）"
        },
        {
            "type": "text",
            "bbox": [
                0.077,
                0.198,
                0.558,
                0.214
            ],
            "angle": 0,
            "content": "解设 \\(P(n)\\) 是命题：有 \\(n\\) 个元素的集合有 \\(2^{n}\\) 个子集。"
        },
        {
            "type": "text",
            "bbox": [
                0.077,
                0.217,
                0.87,
                0.234
            ],
            "angle": 0,
            "content": "基础步骤： \\(P(0)\\) 为真，因为有0个元素的集合，即空集，恰有 \\(2^{0} = 1\\) 个子集，即它自身。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.237,
                0.464,
                0.482
            ],
            "angle": 0,
            "content": "归纳步骤：关于归纳假设，假定对所有非负整数 \\(k\\) ， \\(P(k)\\) 为真，即假定所有 \\(k\\) 个元素的集合都有 \\(2^{k}\\) 个子集。必须证明在此假定下，命题 \\(P(k + 1)\\) （具有 \\(k + 1\\) 个元素的集合都有 \\(2^{k + 1}\\) 个子集）也为真。为此，设 \\(T\\) 是一个具有 \\(k + 1\\) 个元素的集合，于是 \\(T\\) 可以写成 \\(T = S\\bigcup \\{a\\}\\) ，其中 \\(a\\) 是 \\(T\\) 中的一个元素，且 \\(S = T - \\{a\\}\\) （因此，\\(|S| = k\\)）。\\(T\\) 的子集可以用如下方式得到：对 \\(S\\) 的每个子集 \\(X\\) 而言，恰好存在 \\(T\\) 的两个子集，即 \\(X\\) 和 \\(X\\bigcup \\{a\\}\\) 。（图3将对此给出解释。）这些集体构成了 \\(T\\) 的所有子集，且这些子集都不相同。因为 \\(S\\) 有 \\(2^{k}\\) 个子集，所以 \\(T\\) 有 \\(2\\cdot 2^{k} = 2^{k + 1}\\) 个子集。这就完成了归纳步骤的论证。"
        },
        {
            "type": "image",
            "bbox": [
                0.48,
                0.239,
                0.865,
                0.414
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.489,
                0.422,
                0.851,
                0.455
            ],
            "angle": 0,
            "content": "图3具有 \\(k + 1\\) 个元素的集合的子集的生成过程，这里 \\(T = S\\cup \\{a\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.485,
                0.884,
                0.539
            ],
            "angle": 0,
            "content": "因为我们既完成了基础步骤，又完成了归纳步骤，所以根据数学归纳法原理可知：对所有非负整数 \\(n\\) 而言，\\(P(n)\\) 为真。也就是说，我们已经证明了具有 \\(n\\) 个元素的集合有 \\(2^n\\) 个子集，无论 \\(n\\) 是一个怎样的非负整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.077,
                0.543,
                0.584,
                0.56
            ],
            "angle": 0,
            "content": "例11 用数学归纳法证明下述对德·摩根律之一的推广："
        },
        {
            "type": "equation",
            "bbox": [
                0.385,
                0.564,
                0.531,
                0.602
            ],
            "angle": 0,
            "content": "\\[\n\\overline {{\\bigcap_ {j = 1} ^ {n} A _ {j}}} = \\bigcup_ {j = 1} ^ {n} \\overline {{A}} _ {j}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.602,
                0.524,
                0.619
            ],
            "angle": 0,
            "content": "其中 \\(A_{1}, A_{2}, \\dots, A_{n}\\) 是全集 \\(U\\) 的任意子集，且 \\(n \\geqslant 2\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.077,
                0.62,
                0.486,
                0.637
            ],
            "angle": 0,
            "content": "解设 \\(P(n)\\) 是对 \\(n\\) 个集合来说的上述恒等式。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.639,
                0.883,
                0.674
            ],
            "angle": 0,
            "content": "基础步骤：命题 \\(P(2)\\) 断言 \\(\\overline{A_1\\cap A_2} = \\overline{A_1}\\cup \\overline{A_2}\\) 。这是德·摩根律之一，在2.2节里证明过该定律。"
        },
        {
            "type": "text",
            "bbox": [
                0.077,
                0.676,
                0.867,
                0.693
            ],
            "angle": 0,
            "content": "归纳步骤：归纳假设是命题： \\(P(k)\\) 为真，其中 \\(k\\) 是正整数，且 \\(k\\geqslant 2\\) 。即归纳假设是命题"
        },
        {
            "type": "equation",
            "bbox": [
                0.385,
                0.696,
                0.531,
                0.732
            ],
            "angle": 0,
            "content": "\\[\n\\overline {{\\bigcap_ {j = 1} ^ {k} A _ {j}}} = \\bigcup_ {j = 1} ^ {k} \\overline {{A}} _ {j}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.733,
                0.883,
                0.787
            ],
            "angle": 0,
            "content": "其中 \\(A_{1}, A_{2}, \\cdots, A_{k}\\) 是全集 \\(U\\) 的任意子集。要完成归纳步骤，需要证明：归纳假设蕴含 \\(P(k + 1)\\) 为真。也就是说，需要证明：如果上述等式对 \\(U\\) 的任意 \\(k\\) 个子集都成立，那么该等式对 \\(U\\) 的任意 \\(k + 1\\) 个子集也成立。假定 \\(A_{1}, A_{2}, \\cdots, A_{k}, A_{k + 1}\\) 是 \\(U\\) 的子集，则根据归纳假设，有"
        },
        {
            "type": "equation",
            "bbox": [
                0.078,
                0.79,
                0.846,
                0.944
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} \\bigcap_ {j = 1} ^ {k + 1} A _ {j} = \\overline {{\\left(\\bigcap_ {j = 1} ^ {k} A _ {j}\\right) \\cap A _ {k + 1}}} \\quad \\text {根 据 交 的 定 义} \\\\ = \\left(\\overline {{\\bigcap_ {j = 1} ^ {k} A _ {j}}}\\right) \\cup \\overline {{A _ {k + 1}}} \\qquad \\text {根 据 德} \\bullet \\text {摩 根 律}, \\text {其 中 的 两 个 集 合 分 别 为} \\bigcap_ {j = 1} ^ {k} A _ {j} \\text {和} A _ {k + 1} \\\\ = \\left(\\bigcup_ {j = 1} ^ {k} \\overline {{A _ {j}}}\\right) \\cup \\overline {{A _ {k + 1}}} \\quad \\text {根 据 归 纳 假 设} \\\\ = \\bigcup_ {j = 1} ^ {k + 1} \\overline {{A _ {j}}} \\quad \\text {根 据 并 的 定 义} \\\\ \\end{array}\n\\]"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.136,
                0.041,
                0.172,
                0.055
            ],
            "angle": 0,
            "content": "288"
        },
        {
            "type": "header",
            "bbox": [
                0.218,
                0.04,
                0.284,
                0.055
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.097,
                0.308,
                0.113
            ],
            "angle": 0,
            "content": "这就完成了归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.116,
                0.959,
                0.152
            ],
            "angle": 0,
            "content": "因为我们既完成了基础步骤，又完成了归纳步骤，所以根据数学归纳法原理可知：对任意的正整数 \\(n\\) ，且 \\(n \\geqslant 2\\) 时，\\(P(n)\\) 为真。即"
        },
        {
            "type": "equation",
            "bbox": [
                0.463,
                0.155,
                0.608,
                0.191
            ],
            "angle": 0,
            "content": "\\[\n\\overline {{\\bigcap_ {j = 1} ^ {n} A _ {j}}} = \\bigcup_ {j = 1} ^ {n} \\overline {{A}} _ {j}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.192,
                0.603,
                0.208
            ],
            "angle": 0,
            "content": "其中 \\(A_{1}\\) ， \\(A_{2}\\) ，…， \\(A_{n}\\) 是全集 \\(U\\) 的任意子集，且 \\(n\\geqslant 2\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.21,
                0.959,
                0.266
            ],
            "angle": 0,
            "content": "证明有关算法的结论下面证明一个阐述数学归纳法在算法研究中应用的例子（此例子要比前面的例子难一些）。我们将说明如何利用数学归纳法证明一个贪婪算法，并由此产生一个优化解，在3.1节有关于贪婪算法的介绍。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.27,
                0.96,
                0.346
            ],
            "angle": 0,
            "content": "例12 回顾3.1节例7中讨论的讲座计划的算法。算法输入是一组 \\(m\\) 个预先确定开始和结束时间的讲座。目标是在主讲座厅尽量安排更多的讲座而不出现重叠。设讲座 \\(t_j\\) 的开始时间为 \\(b_j\\)，结束时间为 \\(e_j\\)（不允许两个讲座同时进行，但允许一个讲座在另一个讲座结束时马上进行）。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.349,
                0.962,
                0.461
            ],
            "angle": 0,
            "content": "解 不失一般性，假定把讲座列成一个表，以保证各讲座的结束时间是非降序的，即保证 \\( e_1 \\leqslant e_2 \\leqslant \\dots \\leqslant e_m \\) 。贪婪算法是这样进行的：在算法中的每个阶段，都从可以开始进行的讲座中选择一个最早结束的讲座来安排。注意算法总是选择一个最早结束的讲座来安排下一个讲座。我们将证明，从在主讲座厅尽量安排更多讲座的意义上，这种贪婪算法是一种最优算法。为了证明该算法的最优性，对变量 \\( n \\) 应用数学归纳法，其中 \\( n \\) 是算法中的讲座数。设 \\( P(n) \\) 是命题：如果贪婪算法安排了 \\( n \\) 个讲座，那么不可能安排更多的讲座。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.463,
                0.962,
                0.555
            ],
            "angle": 0,
            "content": "基础步骤：设贪婪算法在主讲座厅只安排一个讲座 \\( t_1 \\) 。这意味着任何其他讲座都不能在 \\( t_1 \\) 的结束时间 \\( e_1 \\) 或之后进行了。否则，根据讲座结束时间非降序顺序的要求，就应该存在一个讲座，它应该在 \\( t_1 \\) 讲座之前进行。因此，在 \\( e_1 \\) 时刻，每个剩余的讲座都要求使用讲座厅，因为它们都要求在 \\( e_1 \\) 时刻或 \\( e_1 \\) 时刻之前开始，并在 \\( e_1 \\) 时刻之后结束。这就导致了主讲座厅不能安排两个讲座，因为它们都要求在 \\( e_1 \\) 时刻使用讲座厅。这就证明了 \\( P(1) \\) 为真，因此基础步骤证毕。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.557,
                0.962,
                0.631
            ],
            "angle": 0,
            "content": "归纳步骤：归纳假设是 \\(P(k)\\) 为真，其中 \\(k\\) 是一个正整数。也就是说，对给定的一组讲座，无论讲座个数有多少，当从中选择 \\(k\\) 个讲座时（\\(k\\) 是正整数），贪婪算法总是安排了最多的讲座。必须证明：在 \\(P(k)\\) 为真的假设下，\\(P(k + 1)\\) 也为真，即在 \\(P(k)\\) 为真的假设下，当需要选择 \\(k + 1\\) 个讲座时，贪婪算法也总是安排了最多的讲座。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.633,
                0.962,
                0.706
            ],
            "angle": 0,
            "content": "现在假定算法已经选择了 \\(k + 1\\) 个讲座。要完成归纳步骤的第一步是：证明存在一个包含讲座 \\(t_1\\) 且安排了最多讲座的计划表，其中 \\(t_1\\) 代表最先结束的那个讲座。容易看出，由于一个开始于讲座 \\(t_i (i > 1)\\) 的计划表是可以改变的，使得 \\(t_1\\) 成为第一个讲座。为了说明这一点，注意：因为 \\(e_1 \\leqslant e_i\\) ，所以 \\(t_i\\) 之后的讲座仍然可以被安排。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.708,
                0.962,
                0.801
            ],
            "angle": 0,
            "content": "一旦包含了讲座 \\(t_1\\)，计划表就可以归结为：在 \\(e_1\\) 时刻或 \\(e_1\\) 之后，安排尽可能多的讲座。因此，如果已经安排了尽可能多的讲座，那么除了讲座 \\(t_1\\) 之外，以 \\(t_1\\) 结束时开始的计划表就是原始计划表的一个最优安排。这是因为贪婪算法在建立这个计划表时已经安排了 \\(k\\) 个讲座，根据归纳假设，当算法安排 \\(k + 1\\) 个讲座时，它已经安排了最多的讲座。因此，\\(P(k + 1)\\) 也为真。这就完成了归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.803,
                0.964,
                0.857
            ],
            "angle": 0,
            "content": "现在已经完成了基础步骤和归纳步骤，根据数学归纳法原理可知：对所有正整数 \\(n\\) ， \\(P(n)\\) 为真。这就完成了最优性的证明。也就是说，我们已经证明了：当用贪婪算法安排了 \\(n\\) 个讲座时，其中 \\(n\\) 是一个正整数，那么不可能存在多于 \\(n\\) 个讲座的安排。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.86,
                0.964,
                0.914
            ],
            "angle": 0,
            "content": "数学归纳法的创新性用法 数学归纳法经常出现意想不到的用法。下面将给出两个具体的巧妙用法，第一个是关于馅饼战斗中的幸存者问题，第二个是关于缺失一方角的规则棋盘的三联覆盖问题。"
        },
        {
            "type": "footer",
            "bbox": [
                0.044,
                0.917,
                0.107,
                0.935
            ],
            "angle": 0,
            "content": "Extra Examples"
        },
        {
            "type": "footer",
            "bbox": [
                0.159,
                0.92,
                0.965,
                0.937
            ],
            "angle": 0,
            "content": "例13奇数个馅饼的战斗有奇数个人站在一个院子里，彼此之间的距离不同，每个人都"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.656,
                0.04,
                0.767,
                0.055
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.813,
                0.041,
                0.848,
                0.054
            ],
            "angle": 0,
            "content": "289"
        },
        {
            "type": "text",
            "bbox": [
                0.032,
                0.095,
                0.88,
                0.15
            ],
            "angle": 0,
            "content": "同时用一个馅饼抛向并击打离他最近的人。利用数学归纳法证明：人群中至少有一个幸存者，即至少有一个人没有被馅饼攻击（此问题是由Carmony[Ca79]提出的。注意此结果对偶数个人不成立，参见练习77）。"
        },
        {
            "type": "text",
            "bbox": [
                0.032,
                0.153,
                0.88,
                0.229
            ],
            "angle": 0,
            "content": "解设 \\(P(n)\\) 是命题：当 \\(2n + 1\\) 个人站在院中，彼此之间距离不同，每个人都同时用一个馅饼抛向并击打离他最近的人时，至少存在一个幸存者。为了证明此结果，将证明对所有的正整数 \\(n\\) ， \\(P(n)\\) 为真。这是可行的，因为当 \\(n\\) 取遍所有正整数时， \\(2n + 1\\) 则取遍了所有大于等于3的奇数。注意，一个人的馅饼战斗是不存在的，因为不存在另外一个人成为他攻击的对象。"
        },
        {
            "type": "text",
            "bbox": [
                0.032,
                0.231,
                0.88,
                0.306
            ],
            "angle": 0,
            "content": "基础步骤：当 \\( n = 1 \\) 时，共有 \\( 2n + 1 = 3 \\) 个人参与战斗。在这3个人中，假设距离最近的两个人是 \\( A \\) 和 \\( B \\)，而 \\( C \\) 是第三个人。因为三人中两两之间的距离是不同的， \\( A \\) 与 \\( C \\) 之间的距离以及 \\( B \\) 与 \\( C \\) 之间的距离都不同于且大于 \\( A \\) 与 \\( B \\) 之间的距离，因此， \\( C \\) 不会受到馅饼的攻击。这表明，三个人中至少有一个人不会受到馅饼的攻击，这就完成了基础步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.032,
                0.309,
                0.882,
                0.403
            ],
            "angle": 0,
            "content": "归纳步骤：关于归纳步骤，假定 \\(P(k)\\) 为真。即当 \\(2k + 1\\) 个人站在院中，彼此之间距离不同，每个人都同时用一个馅饼抛向并击打离他最近的人时，至少存在一个幸存者。必须证明：如果归纳假设 \\(P(k)\\) 为真，那么 \\(P(k + 1)\\)，即命题“当 \\(2(k + 1) + 1 = 2k + 3\\) 个人站在院中，彼此之间距离不同，每个人都同时用一个馅饼抛向并击打离他最近的人时，至少存在一个幸存者”也为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.034,
                0.405,
                0.884,
                0.461
            ],
            "angle": 0,
            "content": "下面假设有 \\(2(k + 1) + 1 = 2k + 3\\) 个人站在院中，彼此之间距离不同。设 \\(A\\) 和 \\(B\\) 是这 \\(2k + 3\\) 个人中距离最近的两个人，当每个人都向其最近者抛击馅饼时，则 \\(A\\) 和 \\(B\\) 必相互抛击。我们考虑两种情况：(i)其他某人向 \\(A\\) 或 \\(B\\) 抛击馅饼；(ii)没有其他人向 \\(A\\) 或 \\(B\\) 抛击馅饼。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.463,
                0.884,
                0.539
            ],
            "angle": 0,
            "content": "(i) 如果 \\(A\\) 和 \\(B\\) 相互抛击且其他某人向 \\(A\\) 或 \\(B\\) 抛击时，至少有三个馅饼抛击了 \\(A\\) 和 \\(B\\)，最多有 \\((2k + 3) - 3 = 2k\\) 个馅饼抛击了其余 \\(2k + 1\\) 个人。这就保证了至少有一个人是幸存者，因为如果这 \\(2k + 1\\) 个人都至少被一个馅饼攻击，那么总共至少要有 \\(2k + 1\\) 个馅饼来攻击他们（最后一步所用的推理是6.2节将要讨论的鸽巢原理的一个例子）。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.541,
                0.885,
                0.616
            ],
            "angle": 0,
            "content": "(ii)假定没有其他人向 \\(A\\) 或 \\(B\\) 抛击馅饼。除了 \\(A\\) 和 \\(B\\) 之外，共有 \\(2k + 1\\) 个人。由于这些人之间的距离彼此不同，可利用归纳假设得出结论：当每个人都向其最近者抛击馅饼时，至少存在一个幸存者 \\(S\\) 。此外，由于 \\(A\\) 和 \\(B\\) 必相互抛击，因此 \\(S\\) 也不会受到 \\(A\\) 或 \\(B\\) 的抛击，所以 \\(S\\) 是个幸存者，因为他没有受到 \\(2k + 3\\) 个人中任何一个人的抛击。"
        },
        {
            "type": "list",
            "bbox": [
                0.036,
                0.463,
                0.885,
                0.616
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.619,
                0.884,
                0.674
            ],
            "angle": 0,
            "content": "因为既完成了基础步骤，又完成了归纳步骤，所以根据数学归纳法可知：对所有的正整数 \\(n\\) ， \\(P(n)\\) 为真。因此，得出结论：奇数个人站在院子里，彼此之间的距离不同，每个人都同时用一个馅饼抛向并击打离他最近的人时，至少存在一个幸存者。"
        },
        {
            "type": "text",
            "bbox": [
                0.038,
                0.677,
                0.884,
                0.714
            ],
            "angle": 0,
            "content": "1.8节曾经讨论过用多联骨牌覆盖棋盘的问题。例14将阐述如何利用数学归纳法证明一个结论：关于用右三联骨牌，即形如字母 \\(L\\) 的碎片去覆盖一个棋盘问题的结论。"
        },
        {
            "type": "text",
            "bbox": [
                0.038,
                0.719,
                0.884,
                0.758
            ],
            "angle": 0,
            "content": "例14设 \\(n\\) 是正整数。证明：可以用右三联骨牌去覆盖任何一个去掉1个格的 \\(2n \\times 2n\\) 格的棋盘，其中每一个右三联骨牌都能覆盖棋盘中的3个格子，如图4所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.038,
                0.761,
                0.884,
                0.797
            ],
            "angle": 0,
            "content": "解设 \\(P(n)\\) 是命题：可以用右三联骨牌覆盖任何一个去掉1个格的 \\(2n\\times 2n\\) 格的棋盘。可以用数学归纳法证明对所有正整数 \\(n\\) 来说， \\(P(n)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.038,
                0.8,
                0.884,
                0.836
            ],
            "angle": 0,
            "content": "基础步骤：命题 \\(P(1)\\) 为真，因为对任何一个去掉1个格的 \\(2 \\times 2\\) 格棋盘而言，用一个右三联骨牌就能将它覆盖，如图5所示。"
        },
        {
            "type": "image",
            "bbox": [
                0.109,
                0.842,
                0.216,
                0.916
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.072,
                0.925,
                0.256,
                0.94
            ],
            "angle": 0,
            "content": "图4一个右三联骨牌"
        },
        {
            "type": "image",
            "bbox": [
                0.321,
                0.844,
                0.43,
                0.916
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.474,
                0.844,
                0.583,
                0.916
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.626,
                0.844,
                0.734,
                0.916
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.777,
                0.844,
                0.886,
                0.916
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.378,
                0.925,
                0.832,
                0.941
            ],
            "angle": 0,
            "content": "图5 用一个右三联骨牌覆盖去掉1个格的 \\(2 \\times 2\\) 格棋盘"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.139,
                0.04,
                0.176,
                0.054
            ],
            "angle": 0,
            "content": "290"
        },
        {
            "type": "header",
            "bbox": [
                0.221,
                0.039,
                0.287,
                0.054
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.095,
                0.959,
                0.15
            ],
            "angle": 0,
            "content": "归纳步骤：归纳假设是对正整数 \\(k\\)，\\(P(k)\\) 为真，即，假定对去掉1个格的 \\(2^k \\times 2^k\\) 格棋盘而言，可以用右三联骨牌将其覆盖。必须证明：在归纳假设下，\\(P(k + 1)\\) 也必为真，即可以用右三联骨牌覆盖任何去掉1个格的 \\(2^{k + 1} \\times 2^{k + 1}\\) 格的棋盘。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.152,
                0.959,
                0.284
            ],
            "angle": 0,
            "content": "为此，我们考虑一个去掉1个格的 \\(2^{k + 1} \\times 2^{k + 1}\\) 格棋盘，把这个棋盘从中间切开，分成大小为 \\(2^k \\times 2^k\\) 个格的4个棋盘，如图6所示。在这4个棋盘中，有3个不缺失任何一格，第四个 \\(2^k \\times 2^k\\) 格棋盘缺失1个格，根据数学归纳法，可以用右三联骨牌将其覆盖。现在暂时将另外三个 \\(2^k \\times 2^k\\) 格的棋盘都去掉1个格，被去掉的这3个格是原来大棋盘的中心，如图7所示。根据归纳假设，可以用右三联骨牌将这3个去掉1个格的 \\(2^k \\times 2^k\\) 格棋盘覆盖。此外，被暂时去掉的3个格可以用一个右三联骨牌将其覆盖。因此，整个 \\(2^{k + 1} \\times 2^{k + 1}\\) 格的棋盘可以用右三联骨牌来覆盖。"
        },
        {
            "type": "image",
            "bbox": [
                0.191,
                0.29,
                0.442,
                0.459
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.189,
                0.468,
                0.444,
                0.501
            ],
            "angle": 0,
            "content": "图6 把一个 \\(2^{k + 1}\\times 2^{k + 1}\\) 格棋盘分成4个 \\(2^{k}\\times 2^{k}\\) 格棋盘"
        },
        {
            "type": "image",
            "bbox": [
                0.626,
                0.291,
                0.879,
                0.46
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.631,
                0.468,
                0.872,
                0.5
            ],
            "angle": 0,
            "content": "图7 用一个右三联骨牌覆盖 \\(2^{k + 1}\\times 2^{k + 1}\\) 格棋盘"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.507,
                0.959,
                0.562
            ],
            "angle": 0,
            "content": "我们已经完成了基础步骤和归纳步骤。因此，根据数学归纳法知：对所有的正整数 \\(n\\)，\\(P(n)\\) 为真。这就证明了能够用右三联骨牌将任何一个去掉1个格的 \\(2n \\times 2n\\) 格的棋盘覆盖，其中 \\(n\\) 是一个正整数。"
        },
        {
            "type": "title",
            "bbox": [
                0.109,
                0.572,
                0.463,
                0.589
            ],
            "angle": 0,
            "content": "5.1.8 使用数学归纳法时犯的错误"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.593,
                0.957,
                0.647
            ],
            "angle": 0,
            "content": "和任何证明方法一样，使用数学归纳法有时也会犯错误。许多著名的甚至有些滑稽的假命题都可以通过数据归纳法推导出来，如例15和练习 \\(49\\sim 51\\) 。在这类错误采用数学归纳法的证明中，有时候还不太容易找到错误。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.649,
                0.959,
                0.742
            ],
            "angle": 0,
            "content": "为了发现数学归纳法中的错误，要记住在每一个这样的证明中，基础步骤和归纳步骤都必须是正确的。在使用数学归纳法证明时，不完整的基础步骤会导致如“对于正整数 \\(n\\) ， \\(n = n + 1\\) ”这样明显荒谬的结论。（我们将这个证明留给读者，通过构造正确的归纳步骤容易完成这个命题的尝试性证明。）如下面的例15所展示的，当错误隐藏在基础步骤时，发现错误之处是非常诡秘的。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.747,
                0.956,
                0.786
            ],
            "angle": 0,
            "content": "例15 找出一个明显为错误断言的“证明”中的错误：平面上的任何一组相互之间都不平行的直线，必相交于一个公共点。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.788,
                0.956,
                0.824
            ],
            "angle": 0,
            "content": "“证”设 \\(P(n)\\) 是命题：平面上的任何 \\(n\\) 条相互之间都不平行的直线必相交于一个公共点。我们将试图证明：对所有的正整数 \\(n \\geqslant 2\\)，\\(P(n)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.826,
                0.952,
                0.843
            ],
            "angle": 0,
            "content": "基础步骤：命题 \\(P(2)\\) 为真，因为平面上相交的两条直线是不平行的（根据平行线的定义）。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.845,
                0.957,
                0.939
            ],
            "angle": 0,
            "content": "归纳步骤：归纳假设是命题：对正整数 \\(k\\)，\\(P(k)\\) 为真，即假定平面上的任意 \\(k\\) 条不平行的直线相交于一个公共点。为了完成归纳步骤，必须证明：如果 \\(P(k)\\) 为真，则 \\(P(k + 1)\\) 也必为真。也就是说，必须证明：如果平面上任意 \\(k\\) 条不平行的直线相交于一个公共点，那么平面上任意 \\(k + 1\\) 条不平行的直线也相交于一个公共点。因此，考虑平面上 \\(k + 1\\) 条不同的直线，根据归纳假设，这些直线中的前 \\(k\\) 条相交于一个公共点 \\(p_1\\)。此外，根据归纳假设，这些直线中的后"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.663,
                0.037,
                0.772,
                0.052
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.82,
                0.038,
                0.853,
                0.051
            ],
            "angle": 0,
            "content": "291"
        },
        {
            "type": "text",
            "bbox": [
                0.037,
                0.093,
                0.885,
                0.205
            ],
            "angle": 0,
            "content": "\\(k\\) 条也相交于一个公共点 \\(p_2\\) 。我们将证明：\\(p_1\\) 和 \\(p_2\\) 必为同一个点。如果 \\(p_1\\) 和 \\(p_2\\) 是不同的点，则包含这两个点的所有直线必是同一条直线，这是因为两点确定一条直线。这与我们的假设“这些直线是不同的直线”相矛盾。因此，\\(p_1\\) 和 \\(p_2\\) 必是同一个点。为此得到结论：\\(p_1 = p_2\\) 在所有 \\(k + 1\\) 条直线上。这样就证明了在 \\(P(k)\\) 为真的假设下，\\(P(k + 1)\\) 也为真。也就是说，已经证明了：如果任意 \\(k (k \\geqslant 2)\\) 条不同直线交于一个公共点，那么任意 \\(k + 1\\) 条不同的直线也交于一个公共点。这就完成了归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.208,
                0.812,
                0.224
            ],
            "angle": 0,
            "content": "我们已经完成了基础步骤和归纳步骤，似乎用数学归纳法完成了一个正确的证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.037,
                0.227,
                0.885,
                0.34
            ],
            "angle": 0,
            "content": "解 检查这个似乎是利用了数学归纳法的证明，看起来一切都是合情合理的。然而，证明中有一个错误，也必然是这样。这个错误相当微妙。仔细检查归纳步骤可以看出，归纳步骤必须要求 \\(k \\geq 3\\) 。我们不能证明 \\(P(2)\\) 蕴含 \\(P(3)\\) 。当 \\(k = 2\\) 时，我们的目标是证明任意三条不同的直线交于一点。前两条直线必相交于一点 \\(p_1\\) ，后两条直线必相交于一点 \\(p_2\\) 。但在此情况下，\\(p_1\\) 和 \\(p_2\\) 不必是同一个点，因为只有第二条直线是两组直线中的公共直线。这就是归纳步骤中所犯的错误。"
        },
        {
            "type": "title",
            "bbox": [
                0.039,
                0.351,
                0.085,
                0.367
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.037,
                0.371,
                0.883,
                0.404
            ],
            "angle": 0,
            "content": "1. 在一条火车线路上有无穷多个车站。假设火车在第一站停车，又假设如果火车在一个站停车，则它在下一站必停车。证明：火车在所有的车站都停车。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.407,
                0.884,
                0.441
            ],
            "angle": 0,
            "content": "2. 在有无限个洞的高尔夫线路上，如果你知道一个选手能够打入第一个洞，且如果他打入第一个洞，那么他一定能打入下一个洞。证明：此选手能够打入线路上的每一个洞。"
        },
        {
            "type": "list",
            "bbox": [
                0.036,
                0.371,
                0.884,
                0.441
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.444,
                0.697,
                0.458
            ],
            "angle": 0,
            "content": "利用数学归纳法证明练习 \\(3\\sim 17\\) 中的求和公式。注意明确在何处使用了归纳假设。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.462,
                0.65,
                0.476
            ],
            "angle": 0,
            "content": "3. 设 \\(P(n)\\) 是命题：对正整数 \\(n\\) 而言，\\(1^2 + 2^2 + \\dots + n^2 = n(n + 1)(2n + 1)/6\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.48,
                0.23,
                0.495
            ],
            "angle": 0,
            "content": "a) 命题 \\(P(1)\\) 是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.306,
                0.48,
                0.642,
                0.495
            ],
            "angle": 0,
            "content": "b) 证明 \\(P(1)\\) 为真，完成基础步骤的证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.498,
                0.22,
                0.513
            ],
            "angle": 0,
            "content": "c)归纳假设是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.305,
                0.499,
                0.58,
                0.513
            ],
            "angle": 0,
            "content": "d)在归纳步骤中你需要证明什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.516,
                0.199,
                0.531
            ],
            "angle": 0,
            "content": "e)完成归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.305,
                0.516,
                0.871,
                0.531
            ],
            "angle": 0,
            "content": "f)解释为什么只要 \\(n\\) 是一个正整数，则上述步骤就可以证明公式为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.535,
                0.61,
                0.548
            ],
            "angle": 0,
            "content": "4. 设 \\(P(n)\\) 是命题：对正整数 \\(n\\) 而言，\\(1^3 + 2^3 + \\dots + n^3 = (n(n + 1) / 2)^2\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.552,
                0.228,
                0.567
            ],
            "angle": 0,
            "content": "a) 命题 \\(P(1)\\) 是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.305,
                0.552,
                0.642,
                0.567
            ],
            "angle": 0,
            "content": "b) 证明 \\(P(1)\\) 为真，完成基础步骤的证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.571,
                0.22,
                0.585
            ],
            "angle": 0,
            "content": "c)归纳假设是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.305,
                0.571,
                0.58,
                0.585
            ],
            "angle": 0,
            "content": "d)在归纳步骤中你需要证明什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.589,
                0.199,
                0.603
            ],
            "angle": 0,
            "content": "e)完成归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.305,
                0.589,
                0.871,
                0.603
            ],
            "angle": 0,
            "content": "f)解释为什么只要 \\(n\\) 是一个正整数，则上述步骤就可以证明公式为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.607,
                0.34,
                0.621
            ],
            "angle": 0,
            "content": "5. 证明：只要 \\(n\\) 是一个非负整数，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.25,
                0.624,
                0.692,
                0.639
            ],
            "angle": 0,
            "content": "\\[\n1 ^ {2} + 3 ^ {2} + 5 ^ {2} + \\dots + (2 n + 1) ^ {2} = (n + 1) (2 n + 1) (2 n + 3) / 3\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.643,
                0.321,
                0.657
            ],
            "angle": 0,
            "content": "6. 证明：只要 \\(n\\) 是一个正整数，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.275,
                0.661,
                0.642,
                0.675
            ],
            "angle": 0,
            "content": "\\[\n1 \\cdot 1! + 2 \\cdot 2! + \\dots + n \\cdot n! = (n + 1)! - 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.679,
                0.34,
                0.693
            ],
            "angle": 0,
            "content": "7. 证明：只要 \\(n\\) 是一个非负整数，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.279,
                0.696,
                0.638,
                0.711
            ],
            "angle": 0,
            "content": "\\[\n3 + 3 \\cdot 5 + 3 \\cdot 5 ^ {2} + \\dots + 3 \\cdot 5 ^ {n} = 3 (5 ^ {n + 1} - 1) / 4\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.715,
                0.339,
                0.729
            ],
            "angle": 0,
            "content": "8. 证明：只要 \\(n\\) 是一个非负整数，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.256,
                0.732,
                0.66,
                0.747
            ],
            "angle": 0,
            "content": "\\[\n2 - 2 \\cdot 7 + 2 \\cdot 7 ^ {2} - \\dots + 2 (- 7) ^ {n} = (1 - (- 7) ^ {n + 1}) / 4\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.751,
                0.328,
                0.765
            ],
            "angle": 0,
            "content": "9. a) 猜想前 \\(n\\) 个正偶数之和的公式。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.77,
                0.255,
                0.784
            ],
            "angle": 0,
            "content": "b) 证明你所猜想的公式。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.788,
                0.504,
                0.802
            ],
            "angle": 0,
            "content": "10. a) 通过对较小的 \\(n\\) 值进行考查，猜想下面的求和公式："
        },
        {
            "type": "equation",
            "bbox": [
                0.363,
                0.806,
                0.586,
                0.834
            ],
            "angle": 0,
            "content": "\\[\n\\frac {1}{1 \\times 2} + \\frac {1}{2 \\times 3} + \\dots + \\frac {1}{n (n + 1)}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.066,
                0.837,
                0.264,
                0.852
            ],
            "angle": 0,
            "content": "b) 证明你所猜想的公式。"
        },
        {
            "type": "text",
            "bbox": [
                0.036,
                0.856,
                0.504,
                0.869
            ],
            "angle": 0,
            "content": "11. a) 通过对较小的 \\( n \\) 值进行考查，猜想下面的求和公式："
        },
        {
            "type": "equation",
            "bbox": [
                0.382,
                0.874,
                0.567,
                0.901
            ],
            "angle": 0,
            "content": "\\[\n\\frac {1}{2} + \\frac {1}{4} + \\frac {1}{8} + \\dots + \\frac {1}{2 ^ {n}}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.066,
                0.906,
                0.264,
                0.92
            ],
            "angle": 0,
            "content": "b) 证明你所猜想的公式。"
        },
        {
            "type": "text",
            "bbox": [
                0.037,
                0.924,
                0.348,
                0.938
            ],
            "angle": 0,
            "content": "12. 证明：只要 \\(n\\) 是一个非负整数，则"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.898,
                0.246,
                0.928,
                0.272
            ],
            "angle": 0,
            "content": "2"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.146,
                0.037,
                0.183,
                0.051
            ],
            "angle": 0,
            "content": "292"
        },
        {
            "type": "header",
            "bbox": [
                0.229,
                0.036,
                0.294,
                0.051
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "equation",
            "bbox": [
                0.423,
                0.095,
                0.664,
                0.127
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {j = 0} ^ {n} \\left(- \\frac {1}{2}\\right) ^ {j} = \\frac {2 ^ {n + 1} + (- 1) ^ {n}}{3 \\cdot 2 ^ {n}}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.128,
                0.414,
                0.142
            ],
            "angle": 0,
            "content": "13. 证明：只要 \\(n\\) 是一个正整数，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.34,
                0.145,
                0.746,
                0.16
            ],
            "angle": 0,
            "content": "\\[\n1 ^ {2} - 2 ^ {2} + 3 ^ {2} - \\dots + (- 1) ^ {n - 1} n ^ {2} = (- 1) ^ {n - 1} n (n + 1) / 2\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.164,
                0.432,
                0.178
            ],
            "angle": 0,
            "content": "14. 证明：对所有正整数 \\(n\\) 而言，都有"
        },
        {
            "type": "equation",
            "bbox": [
                0.44,
                0.184,
                0.649,
                0.215
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {k = 1} ^ {n} k 2 ^ {k} = (n - 1) 2 ^ {n + 1} + 2\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.216,
                0.432,
                0.23
            ],
            "angle": 0,
            "content": "15. 证明：对所有正整数 \\(n\\) 而言，都有"
        },
        {
            "type": "equation",
            "bbox": [
                0.356,
                0.234,
                0.731,
                0.248
            ],
            "angle": 0,
            "content": "\\[\n1 \\cdot 2 + 2 \\cdot 3 + \\dots + n (n + 1) = n (n + 1) (n + 2) / 3\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.252,
                0.433,
                0.266
            ],
            "angle": 0,
            "content": "16. 证明：对所有正整数 \\(n\\) 而言，都有"
        },
        {
            "type": "equation",
            "bbox": [
                0.273,
                0.269,
                0.815,
                0.283
            ],
            "angle": 0,
            "content": "\\[\n1 \\cdot 2 \\cdot 3 + 2 \\cdot 3 \\cdot 4 + \\dots + n (n + 1) (n + 2) = n (n + 1) (n + 2) (n + 3) / 4\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.287,
                0.416,
                0.302
            ],
            "angle": 0,
            "content": "17. 证明：只要 \\(n\\) 是一个正整数，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.379,
                0.307,
                0.739,
                0.338
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {i = 1} ^ {n} j ^ {4} = n (n + 1) (2 n + 1) (3 n ^ {2} + 3 n - 1) / 3 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.34,
                0.495,
                0.354
            ],
            "angle": 0,
            "content": "利用数学归纳法证明练习 \\(18\\sim 30\\) 中的不等式。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.357,
                0.571,
                0.372
            ],
            "angle": 0,
            "content": "18. 设 \\(P(n)\\) 是命题：\\(n! < n^n\\)，其中 \\(n\\) 是大于 1 的整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.152,
                0.376,
                0.324,
                0.388
            ],
            "angle": 0,
            "content": "a)命题 \\(P(2)\\) 是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.152,
                0.393,
                0.488,
                0.405
            ],
            "angle": 0,
            "content": "b)证明 \\(P(2)\\) 为真，完成基础步骤的证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.152,
                0.411,
                0.314,
                0.423
            ],
            "angle": 0,
            "content": "c)归纳假设是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.152,
                0.429,
                0.427,
                0.441
            ],
            "angle": 0,
            "content": "d)在归纳步骤中你需要证明什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.152,
                0.447,
                0.294,
                0.458
            ],
            "angle": 0,
            "content": "e)完成归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.152,
                0.464,
                0.792,
                0.476
            ],
            "angle": 0,
            "content": "f)解释为什么只要 \\(n\\) 是一个大于1的整数，则上述步骤就可以证明不等式为真。"
        },
        {
            "type": "list",
            "bbox": [
                0.152,
                0.376,
                0.792,
                0.476
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.482,
                0.287,
                0.496
            ],
            "angle": 0,
            "content": "19. 设 \\(P(n)\\) 是命题："
        },
        {
            "type": "equation",
            "bbox": [
                0.442,
                0.499,
                0.682,
                0.527
            ],
            "angle": 0,
            "content": "\\[\n1 + \\frac {1}{4} + \\frac {1}{9} + \\dots + \\frac {1}{n ^ {2}} <   2 - \\frac {1}{n}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.154,
                0.531,
                0.353,
                0.545
            ],
            "angle": 0,
            "content": "其中 \\(n\\) 是大于1的整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.153,
                0.548,
                0.325,
                0.563
            ],
            "angle": 0,
            "content": "a) 命题 \\(P(2)\\) 是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.394,
                0.548,
                0.729,
                0.563
            ],
            "angle": 0,
            "content": "b) 证明 \\(P(2)\\) 为真，完成基础步骤的证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.154,
                0.566,
                0.317,
                0.58
            ],
            "angle": 0,
            "content": "c)归纳假设是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.394,
                0.566,
                0.668,
                0.58
            ],
            "angle": 0,
            "content": "d)在归纳步骤中你需要证明什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.154,
                0.584,
                0.295,
                0.597
            ],
            "angle": 0,
            "content": "e)完成归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.153,
                0.602,
                0.794,
                0.616
            ],
            "angle": 0,
            "content": "f)解释为什么只要 \\(n\\) 是一个大于1的整数，则上述步骤就可以证明不等式为真。"
        },
        {
            "type": "list",
            "bbox": [
                0.153,
                0.548,
                0.794,
                0.616
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.62,
                0.542,
                0.634
            ],
            "angle": 0,
            "content": "20. 证明：如果 \\( n \\) 是一个大于6的整数，则 \\( 3^n < n! \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.638,
                0.54,
                0.651
            ],
            "angle": 0,
            "content": "21. 证明：如果 \\(n\\) 是一个大于4的整数，则 \\(2^{n} > n^{2}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.655,
                0.556,
                0.668
            ],
            "angle": 0,
            "content": "22. 对怎样的非负整数 \\( n \\)，有 \\( n^2 \\leqslant n! \\)？证明你的答案。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.672,
                0.583,
                0.686
            ],
            "angle": 0,
            "content": "23. 对怎样的非负整数 \\(n\\)，有 \\(2n + 3 \\leqslant 2^n\\)？证明你的答案。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.691,
                0.42,
                0.704
            ],
            "angle": 0,
            "content": "24. 证明：只要 \\(n\\) 是一个正整数，则"
        },
        {
            "type": "list",
            "bbox": [
                0.123,
                0.638,
                0.583,
                0.704
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "equation",
            "bbox": [
                0.338,
                0.708,
                0.758,
                0.722
            ],
            "angle": 0,
            "content": "\\[\n1 / (2 n) \\leqslant [ 1 \\cdot 3 \\cdot 5 \\cdot \\dots \\cdot (2 n - 1) ] / (2 \\cdot 4 \\cdot \\dots \\cdot 2 n)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.726,
                0.893,
                0.74
            ],
            "angle": 0,
            "content": "* 25. 证明：对所有非负整数 \\( n \\)，如果 \\( h > -1 \\)，则 \\( 1 + nh \\leqslant (1 + h)^n \\)。该不等式称为伯努利不等式。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.744,
                0.851,
                0.758
            ],
            "angle": 0,
            "content": "*26. 设 \\(a\\) 和 \\(b\\) 为实数，且 \\(0 < b < a\\)。证明：如果 \\(a\\) 是一个正整数，则 \\(a^n - b^n \\leqslant na^{n-1}(a - b)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.762,
                0.378,
                0.775
            ],
            "angle": 0,
            "content": "* 27. 证明：对每个正整数 \\( n \\)，有"
        },
        {
            "type": "list",
            "bbox": [
                0.109,
                0.726,
                0.893,
                0.775
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "equation",
            "bbox": [
                0.398,
                0.78,
                0.699,
                0.811
            ],
            "angle": 0,
            "content": "\\[\n1 + \\frac {1}{\\sqrt {2}} + \\frac {1}{\\sqrt {3}} + \\dots + \\frac {1}{\\sqrt {n}} > 2 (\\sqrt {n + 1} - 1)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.814,
                0.714,
                0.827
            ],
            "angle": 0,
            "content": "28. 证明：只要 \\(n\\) 是一个大于等于3的整数，则 \\(n^2 - 7n + 12\\) 就是非负的。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.832,
                0.482,
                0.845
            ],
            "angle": 0,
            "content": "在练习29和30中， \\(H_{n}\\) 表示第 \\(n\\) 个调和数。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.849,
                0.539,
                0.863
            ],
            "angle": 0,
            "content": "* 29. 证明：只要 \\( n \\) 是一个非负整数，则 \\( H_{2^n} \\leqslant 1 + n \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.867,
                0.5,
                0.88
            ],
            "angle": 0,
            "content": "* 30. 证明: \\( H_{1} + H_{2} + \\dots + H_{n} = (n + 1)H_{n} - n \\)。"
        },
        {
            "type": "list",
            "bbox": [
                0.11,
                0.849,
                0.539,
                0.88
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.124,
                0.885,
                0.555,
                0.898
            ],
            "angle": 0,
            "content": "在练习 \\(31\\sim 37\\) 中，利用数学归纳法证明整除性问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.124,
                0.902,
                0.576,
                0.916
            ],
            "angle": 0,
            "content": "31. 证明：只要 \\(n\\) 是一个正整数，则 \\(n^2 + n\\) 可被2整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.124,
                0.921,
                0.585,
                0.934
            ],
            "angle": 0,
            "content": "32. 证明：只要 \\(n\\) 是一个正整数，则 \\(n^3 + 2n\\) 可被3整除。"
        },
        {
            "type": "list",
            "bbox": [
                0.124,
                0.902,
                0.585,
                0.934
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.675,
                0.037,
                0.785,
                0.052
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.83,
                0.038,
                0.867,
                0.052
            ],
            "angle": 0,
            "content": "293"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.093,
                0.518,
                0.108
            ],
            "angle": 0,
            "content": "33. 证明：只要 \\( n \\) 是一个非负整数，则 \\( n^5 - n \\) 可被 5 整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.111,
                0.518,
                0.125
            ],
            "angle": 0,
            "content": "34. 证明：只要 \\(n\\) 是一个非负整数，则 \\(n^3 - n\\) 可被6整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.128,
                0.5,
                0.142
            ],
            "angle": 0,
            "content": "35. 证明：只要 \\(n\\) 是一个正奇数，则 \\(n^2 - 1\\) 可被8整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.146,
                0.548,
                0.16
            ],
            "angle": 0,
            "content": "36. 证明：只要 \\(n\\) 是一个正整数，则 \\(4^{n+1} + 5^{2n-1}\\) 可被21整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.163,
                0.576,
                0.177
            ],
            "angle": 0,
            "content": "37. 证明：只要 \\(n\\) 是一个正整数，则 \\(11^{n + 1} + 12^{2n - 1}\\) 可被133整除。"
        },
        {
            "type": "list",
            "bbox": [
                0.048,
                0.093,
                0.576,
                0.177
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.18,
                0.518,
                0.194
            ],
            "angle": 0,
            "content": "在练习 \\(38\\sim 46\\) 中，利用数学归纳法证明集合的有关结论。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.198,
                0.889,
                0.213
            ],
            "angle": 0,
            "content": "38. 证明：如果 \\(A_{1}, A_{2}, \\cdots, A_{n}\\) 和 \\(B_{1}, B_{2}, \\cdots, B_{n}\\) 都是集合，且对 \\(j = 1, 2, \\cdots, n\\) 满足 \\(A_{j} \\leqslant B_{j}\\)，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.413,
                0.217,
                0.536,
                0.252
            ],
            "angle": 0,
            "content": "\\[\n\\bigcup_ {j = 1} ^ {n} A _ {j} \\subseteq \\bigcup_ {j = 1} ^ {n} B _ {j}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.253,
                0.889,
                0.269
            ],
            "angle": 0,
            "content": "39. 证明：如果 \\(A_{1}, A_{2}, \\cdots, A_{n}\\) 和 \\(B_{1}, B_{2}, \\cdots, B_{n}\\) 都是集合，且对 \\(j = 1, 2, \\cdots, n\\) 满足 \\(A_{j} \\leqslant B_{j}\\)，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.414,
                0.273,
                0.536,
                0.307
            ],
            "angle": 0,
            "content": "\\[\n\\bigcap_ {j = 1} ^ {n} A _ {j} \\subseteq \\bigcap_ {j = 1} ^ {n} B _ {j}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.308,
                0.478,
                0.322
            ],
            "angle": 0,
            "content": "40. 证明：如果 \\(A_{1}, A_{2}, \\cdots, A_{n}\\) 和 \\(B\\) 都是集合，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.226,
                0.324,
                0.721,
                0.34
            ],
            "angle": 0,
            "content": "\\[\n(A _ {1} \\cap A _ {2} \\cap \\dots \\cap A _ {n}) \\cup B = (A _ {1} \\cup B) \\cap (A _ {2} \\cup B) \\cap \\dots \\cap (A _ {n} \\cup B)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.342,
                0.478,
                0.356
            ],
            "angle": 0,
            "content": "41. 证明：如果 \\(A_{1}, A_{2}, \\cdots, A_{n}\\) 和 \\(B\\) 都是集合，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.226,
                0.359,
                0.721,
                0.374
            ],
            "angle": 0,
            "content": "\\[\n(A _ {1} \\bigcup A _ {2} \\bigcup \\dots \\bigcup A _ {n}) \\cap B = (A _ {1} \\cap B) \\cup (A _ {2} \\cap B) \\cup \\dots \\bigcup (A _ {n} \\cap B)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.377,
                0.478,
                0.391
            ],
            "angle": 0,
            "content": "42. 证明：如果 \\(A_{1}, A_{2}, \\cdots, A_{n}\\) 和 \\(B\\) 都是集合，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.226,
                0.394,
                0.724,
                0.409
            ],
            "angle": 0,
            "content": "\\[\n(A _ {1} - B) \\cap (A _ {2} - B) \\cap \\dots \\cap (A _ {n} - B) = (A _ {1} \\cap A _ {2} \\cap \\dots \\cap A _ {n}) - B\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.412,
                0.498,
                0.427
            ],
            "angle": 0,
            "content": "43. 证明：如果 \\(A_{1}, A_{2}, \\dots, A_{n}\\) 是全集 \\(U\\) 的子集，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.412,
                0.431,
                0.54,
                0.466
            ],
            "angle": 0,
            "content": "\\[\n\\overline {{\\bigcup_ {k = 1} ^ {n} A _ {k}}} = \\bigcup_ {k = 1} ^ {n} \\bar {A} _ {k}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.468,
                0.478,
                0.482
            ],
            "angle": 0,
            "content": "44. 证明：如果 \\(A_{1}, A_{2}, \\cdots, A_{n}\\) 和 \\(B\\) 都是集合，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.226,
                0.485,
                0.726,
                0.5
            ],
            "angle": 0,
            "content": "\\[\n(A _ {1} - B) \\cup (A _ {2} - B) \\cup \\dots \\cup (A _ {n} - B) = (A _ {1} \\cup A _ {2} \\cup \\dots \\cup A _ {n}) - B\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.503,
                0.901,
                0.535
            ],
            "angle": 0,
            "content": "45. 证明：只要 \\( n \\) 是一个大于等于2的整数，则具有 \\( n \\) 个元素的集合中有 \\( n(n - 1) / 2 \\) 个子集恰好含有2个元素。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.538,
                0.901,
                0.569
            ],
            "angle": 0,
            "content": "* 46. 证明：只要 \\( n \\) 是一个大于等于3的整数，则具有 \\( n \\) 个元素的集合中有 \\( n(n - 1)(n - 2) / 6 \\) 个子集恰好含有3个元素。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.572,
                0.901,
                0.604
            ],
            "angle": 0,
            "content": "练习 \\(47\\sim 48\\) 关注在一条直路上设置基站塔问题，使得这条路上的建筑都可以获得蜂窝通信服务。假设建筑物位于塔1英里范围之内就可以获得服务。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.607,
                0.901,
                0.657
            ],
            "angle": 0,
            "content": "47. 设计一种贪心算法，此算法可以从路的起点开始在 \\(x_{1}, x_{2}, \\cdots, x_{d}\\) 位置上设置尽可能少的塔为 \\(d\\) 个建筑物提供通信服务。[提示：在每一步，在离尽可能远的位置设置通信塔，只要保证没有建筑物超出通信覆盖范围。]"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.66,
                0.901,
                0.692
            ],
            "angle": 0,
            "content": "* 48. 使用数学归纳法证明你设计的算法能为练习 47 产生一个优化解：即算法可以得到最少的塔为所有的建筑物提供蜂窝通信服务。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.694,
                0.781,
                0.709
            ],
            "angle": 0,
            "content": "练习 \\(49\\sim 51\\) 给出了错误的利用数学归纳法的证明，请在每个习题中都找出一个推理错误。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.712,
                0.528,
                0.726
            ],
            "angle": 0,
            "content": "49. 下面的“证明”错在哪儿？所有的马都有相同的颜色。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.729,
                0.557,
                0.744
            ],
            "angle": 0,
            "content": "设 \\(P(n)\\) 是命题“\\(n\\) 匹马的集合中所有马都有相同的颜色”。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.746,
                0.312,
                0.761
            ],
            "angle": 0,
            "content": "基础步骤：显然 \\(P(1)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.764,
                0.905,
                0.831
            ],
            "angle": 0,
            "content": "归纳步骤：假设 \\(P(k)\\) 为真，即 \\(k\\) 匹马的集合中所有马都有相同的颜色。考虑任意 \\(k + 1\\) 匹马，将这些马编号为1，2，3，…，\\(k\\)，\\(k + 1\\)。我们有前 \\(k\\) 匹马必具有相同的颜色，而后 \\(k\\) 匹马也必具有相同的颜色。因为前 \\(k\\) 匹马的集合与后 \\(k\\) 匹马的集合是重叠的，因此，所有 \\(k + 1\\) 匹马必有相同的颜色。这就证明了 \\(P(k + 1)\\) 为真，归纳步骤证毕。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.834,
                0.307,
                0.848
            ],
            "angle": 0,
            "content": "50. 下面的“证明”错在哪儿？"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.852,
                0.576,
                0.885
            ],
            "angle": 0,
            "content": "“定理”：对每个正整数 \\(n\\) 而言，都有 \\(\\sum_{i=1}^{n} i = \\left(n + \\frac{1}{2}\\right)^{2}/2\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.886,
                0.352,
                0.9
            ],
            "angle": 0,
            "content": "基础步骤：当 \\(n = 1\\) 时公式为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.904,
                0.767,
                0.937
            ],
            "angle": 0,
            "content": "归纳步骤：假设 \\(\\sum_{i=1}^{n} i = \\left(n + \\frac{1}{2}\\right)^{2} / 2\\)，则 \\(\\sum_{i=1}^{n+1} i = \\left(\\sum_{i=1}^{n} i\\right) + (n+1)\\)。根据归纳假设，"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.131,
                0.04,
                0.167,
                0.054
            ],
            "angle": 0,
            "content": "294"
        },
        {
            "type": "header",
            "bbox": [
                0.212,
                0.039,
                0.278,
                0.054
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "equation",
            "bbox": [
                0.399,
                0.099,
                0.655,
                0.254
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} \\sum_ {i = 1} ^ {n + 1} i = \\left(n + \\frac {1}{2}\\right) ^ {2} / 2 + n + 1 \\\\ = \\left(n ^ {2} + n + \\frac {1}{4}\\right) / 2 + n + 1 \\\\ = \\left(n ^ {2} + 3 n + \\frac {9}{4}\\right) / 2 \\\\ = \\left(n + \\frac {3}{2}\\right) ^ {2} / 2 \\\\ = \\left((n + 1) + \\frac {1}{2}\\right) ^ {2} / 2 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.26,
                0.258,
                0.275
            ],
            "angle": 0,
            "content": "归纳步骤证毕。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.278,
                0.352,
                0.292
            ],
            "angle": 0,
            "content": "51. 下面的“证明”错在哪儿？"
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.295,
                0.813,
                0.311
            ],
            "angle": 0,
            "content": "“定理”：对每个正整数 \\(n\\) 而言，如果 \\(x\\) 和 \\(y\\) 是正整数，且 \\(\\max (x,y) = n\\) ，则 \\(x = y\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.314,
                0.775,
                0.328
            ],
            "angle": 0,
            "content": "基础步骤：设 \\(n = 1\\) 。如果 \\(\\max (x,y) = 1\\) 且 \\(x\\) 和 \\(y\\) 是正整数，有 \\(x = 1\\) 和 \\(y = 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.331,
                0.948,
                0.382
            ],
            "angle": 0,
            "content": "归纳步骤：设 \\(k\\) 是一个正整数。假定只要 \\(\\max(x, y) = k\\) 且 \\(x\\) 和 \\(y\\) 是正整数，则必有 \\(x = y\\) 。现在令 \\(\\max(x, y) = k + 1\\) ，其中 \\(x\\) 和 \\(y\\) 是正整数。于是有 \\(\\max(x - 1, y - 1) = k\\) ，因此，根据归纳假设有 \\(x - 1 = y - 1\\) 。由此得 \\(x = y\\) ，归纳步骤证毕。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.385,
                0.948,
                0.418
            ],
            "angle": 0,
            "content": "52. 设 \\(m, n\\) 是正整数且 \\(m > n\\), \\(f\\) 是集合 \\(\\{1, 2, \\dots, m\\}\\) 到集合 \\(\\{1, 2, \\dots, n\\}\\) 的函数。采用数学归纳法对变量 \\(n\\) 归纳证明 \\(f\\) 不是一个一对一函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.421,
                0.949,
                0.508
            ],
            "angle": 0,
            "content": "53. 采用数学归纳法证明 \\(n\\) 个人能划分一个蛋糕（每一个人取得1份或者多块蛋糕）以保证蛋糕能公平分配。即每一个人至少取得蛋糕的 \\(1/n\\)。[提示：在归纳步骤，在前 \\(k\\) 个人中得到一个公平的划分，每一个人将自己的那份划分为 \\(k+1\\) 等份，第 \\(k+1\\) 个人从这前 \\(k\\) 个人中得到的份额中选取一部分。证明这样能对 \\(k+1\\) 个人产生一个公平的划分，假设第 \\(k+1\\) 个人认为第 \\(i\\) 个人得到了 \\(p_i\\) 份，\\(\\sum_{i=1}^{k} p_i = 1\\)。]"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.51,
                0.949,
                0.542
            ],
            "angle": 0,
            "content": "54. 用数学归纳法证明：给定一个具有 \\( n + 1 \\) 个正整数的集合，其中每个数都不超过 \\( 2n \\)，则该集合中至少存在一个整数可以整除集合中的另一个整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.545,
                0.949,
                0.633
            ],
            "angle": 0,
            "content": "* 55. 棋盘上的骑士可以一次沿水平方向(任意两个方向)移动一格，沿垂直方向(任意两个方向)移动两格，或者他可以一次沿水平方向(任意两个方向)移动两格，沿垂直方向(任意两个方向)移动一格。假设我们有一个无限大的棋盘，它是由所有格子 \\((m, n)\\) 所构成的，其中 \\( m, n \\) 都是非负整数。用数学归纳法证明：从 \\((0, 0)\\) 格开始，经过有限次移动，该骑士可以访问到棋盘中的每一个格子。[提示：对变量 \\( s = m + n \\) 用归纳法。]"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.636,
                0.155,
                0.65
            ],
            "angle": 0,
            "content": "56. 设"
        },
        {
            "type": "equation",
            "bbox": [
                0.486,
                0.655,
                0.593,
                0.685
            ],
            "angle": 0,
            "content": "\\[\n\\mathbf {A} = \\left[ \\begin{array}{c c} a & 0 \\\\ 0 & b \\end{array} \\right]\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.13,
                0.688,
                0.571,
                0.704
            ],
            "angle": 0,
            "content": "其中 \\(a\\) 、 \\(b\\) 是实数。证明：对每个正整数 \\(n\\) 而言，都有"
        },
        {
            "type": "equation",
            "bbox": [
                0.459,
                0.708,
                0.589,
                0.739
            ],
            "angle": 0,
            "content": "\\[\n\\mathbf {A} ^ {n} = \\left[ \\begin{array}{c c} a ^ {n} & 0 \\\\ 0 & b ^ {n} \\end{array} \\right]\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.743,
                0.948,
                0.776
            ],
            "angle": 0,
            "content": "57. (需要微积分知识) 用数学归纳法证明: 只要 \\(n\\) 是一个正整数, 则 \\(f(x) = x^{n}\\) 的导数就等于 \\(nx^{n-1}\\)。（在归纳步骤中使用导数乘积的规则。）"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.779,
                0.814,
                0.794
            ],
            "angle": 0,
            "content": "58. 设 \\(A\\) 、 \\(B\\) 都是方阵，且满足 \\(AB = BA\\) 。证明：对每个正整数 \\(n\\) 而言，都有 \\(AB^n = BA^n\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.797,
                0.948,
                0.83
            ],
            "angle": 0,
            "content": "59. 设 \\( m \\) 是一个正整数。用数学归纳法证明：如果 \\( a, b \\) 都是整数，且 \\( a \\equiv b (\\bmod m) \\)，则当 \\( k \\) 是任意一个非负整数时，就有 \\( a^k \\equiv b^k (\\bmod m) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.833,
                0.936,
                0.849
            ],
            "angle": 0,
            "content": "60. 用数学归纳法证明：当 \\(p_1, p_2, \\dots, p_n\\) 都是命题时，则 \\(\\neg (p_1 \\vee p_2 \\vee \\dots \\vee p_n)\\) 等价于 \\(\\neg p_1 \\wedge \\neg p_2 \\wedge \\dots \\wedge \\neg p_n\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.851,
                0.54,
                0.866
            ],
            "angle": 0,
            "content": "* 61. 证明：只要 \\( p_1, p_2, \\dots, p_n \\) 都是命题且 \\( n \\geqslant 2 \\)，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.202,
                0.868,
                0.876,
                0.885
            ],
            "angle": 0,
            "content": "\\[\n[ (p _ {1} \\rightarrow p _ {2}) \\wedge (p _ {2} \\rightarrow p _ {3}) \\wedge \\dots \\wedge (p _ {n - 1} \\rightarrow p _ {n}) ] \\rightarrow [ (p _ {1} \\wedge p _ {2} \\wedge \\dots \\wedge p _ {n - 1}) \\rightarrow p _ {n} ]\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.887,
                0.236,
                0.901
            ],
            "angle": 0,
            "content": "就是重言式。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.904,
                0.948,
                0.937
            ],
            "angle": 0,
            "content": "*62. 证明：如果 \\(n\\) 条直线中任何两条都不平行，任何三条都不共点，则这些直线就能把平面分成 \\((n^{2} + n + 2) / 2\\) 个区域。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.687,
                0.039,
                0.796,
                0.054
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.843,
                0.04,
                0.879,
                0.054
            ],
            "angle": 0,
            "content": "295"
        },
        {
            "type": "text",
            "bbox": [
                0.037,
                0.095,
                0.909,
                0.128
            ],
            "angle": 0,
            "content": "**63. 设 \\(a_1, a_2, \\cdots, a_n\\) 都是正实数，这些数的算术均值定义为 \\(A = (a_1 + a_2 + \\cdots + a_n) / n\\)，而这些数的几何均值定义为 \\(G = (a_1 a_2 \\cdots a_n)^{1/n}\\)。用数学归纳法证明：\\(A \\geq G\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.132,
                0.907,
                0.168
            ],
            "angle": 0,
            "content": "64. 用数学归纳法证明 4.3 节中的引理 3，其命题为：如果 \\( p \\) 是素数，且 \\( p \\mid a_1a_2 \\cdots a_n \\)，其中 \\( a_i (i = 1, 2, 3, \\cdots, n) \\) 都是整数，则必存在某个整数 \\( i \\)，使得 \\( p \\mid a_i \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.171,
                0.355,
                0.186
            ],
            "angle": 0,
            "content": "65. 证明：只要 \\( n \\) 是一个正整数，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.379,
                0.19,
                0.621,
                0.222
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {\\left\\{a _ {1}, \\dots , a _ {k} \\right\\} \\subseteq (1, 2, \\dots , n \\}} \\frac {1}{a _ {1} a _ {2} \\cdots a _ {k}} = n\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.224,
                0.697,
                0.239
            ],
            "angle": 0,
            "content": "（这里的求和是对前 \\(n\\) 个最小正整数所构成的集合的所有非空子集进行的。）"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.242,
                0.905,
                0.274
            ],
            "angle": 0,
            "content": "* 66. 利用良序性公理证明下列形式的数学归纳法的证明是有效的。证明：对所有正整数 \\( n \\) 而言，\\( P(n) \\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.278,
                0.354,
                0.292
            ],
            "angle": 0,
            "content": "基础步骤： \\(P(1)\\) 和 \\(P(2)\\) 都为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.296,
                0.714,
                0.311
            ],
            "angle": 0,
            "content": "归纳步骤：对每个正整数 \\(k\\) ，如果 \\(P(k)\\) 和 \\(P(k + 1)\\) 都为真，则 \\(P(k + 2)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.314,
                0.905,
                0.365
            ],
            "angle": 0,
            "content": "67. 证明：如果 \\(A_{1}, A_{2}, \\cdots, A_{n}\\) 是集合，其中 \\(n \\geqslant 2\\)，且对所有满足 \\(1 \\leqslant i < j \\leqslant n\\) 的整数对 \\(i\\) 和 \\(j\\)，要么 \\(A_{i}\\) 是 \\(A_{j}\\) 的子集，要么 \\(A_{j}\\) 是 \\(A_{i}\\) 的子集，则必存在一个整数 \\(i\\)，\\(1 \\leqslant i \\leqslant n\\)，使得对所有的整数 \\(j\\)，\\(1 \\leqslant j \\leqslant n\\)，都有 \\(A_{i}\\) 是 \\(A_{j}\\) 的子集。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.368,
                0.906,
                0.527
            ],
            "angle": 0,
            "content": "* 68. 在一个聚会上，如果所有客人都认识其中的一位客人，而这个人却不认识其他任何一个人，则这个人就称为名人。在一个聚会上，最多只有一个名人，因为如果有两个名人，则他们必然相互认识。某个特定的聚会上也可能没有名人。你的任务是在一个聚会上寻找一个名人，如果该聚会上确实有名人，而你只允许向每个客人提问一种类型的问题——询问他是否认识另一个客人。每个客人必须如实回答你的问题。也就是说，如爱丽斯和鲍勃是聚会上的两个客人，你可以询问爱丽斯是否认识鲍勃，她必须如实回答。利用数学归纳法证明：如果聚会上有 \\( n \\) 位客人，且有一位名人，那么你只需要询问 \\( 3(n - 1) \\) 次客人，你就能找到这位名人。[提示：你首先提出一次问题，以排除一位客人是名人的可能。然后用归纳假设去识别一个可能的名人。最后再问两次问题，以确定这位可能的名人是否是真正的名人。]"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.53,
                0.904,
                0.599
            ],
            "angle": 0,
            "content": "假设人群中有 \\(n\\) 个人，每个人都知道一件其他人都不知道的丑闻。这些人相互之间用电话交流。当两个人在电话中交流时，他们就共享了两人所知道的所有丑闻。例如，在第一个电话中，两个人共享信息后，他们都知道了两件丑闻。流言问题是求 \\(G(n)\\) ：使 \\(n\\) 个人都知道全部丑闻所需要的最少电话次数。练习\\(69\\sim 71\\) 所涉及的问题都是流言问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.602,
                0.343,
                0.617
            ],
            "angle": 0,
            "content": "69. 求 \\(G(1), G(2), G(3)\\) 和 \\(G(4)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.62,
                0.903,
                0.653
            ],
            "angle": 0,
            "content": "70. 利用数学归纳法证明：对 \\(n \\geqslant 4\\)，有 \\(G(n) \\leqslant 2n - 4\\)。[提示：在归纳步骤的开始和结束时刻，让一个第一次打电话的人向某个特定的人打电话。]"
        },
        {
            "type": "text",
            "bbox": [
                0.035,
                0.656,
                0.361,
                0.67
            ],
            "angle": 0,
            "content": "**71. 证明：对 \\( n \\geqslant 4 \\)，有 \\( G(n) = 2n - 4 \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.674,
                0.903,
                0.725
            ],
            "angle": 0,
            "content": "*72. 证明我们一定能做到下面的事情：将数 \\(1, 2, \\cdots, n\\) 排成一排，使得这些数中任何两个数的均值都不会出现在这两个数之间。[提示：证明当 \\(n\\) 是 2 的整数次幂时结论成立就足够了，然后用数学归纳法证明当 \\(n\\) 是 2 的整数次幂时结论成立。]"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.728,
                0.903,
                0.78
            ],
            "angle": 0,
            "content": "*73. 证明：如果 \\(I_1, I_2, \\dots, I_n\\) 是实数轴上的一组开区间，其中 \\(n \\geqslant 2\\)，且这些区间中任意两区间的交非空，即对任意的 \\(1 \\leqslant i \\leqslant n\\) 和 \\(1 \\leqslant j \\leqslant n\\)，都有 \\(I_i \\cap I_j \\neq \\emptyset\\)，那么所有这些集合的交非空，即 \\(I_1 \\cap I_2 \\cap \\dots \\cap I_n \\neq \\emptyset\\)。（回顾开区间的概念：开区间是实数 \\(x\\) 的集合，其中 \\(a < x < b\\)，且 \\(a, b\\) 都是实数。）"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.782,
                0.901,
                0.815
            ],
            "angle": 0,
            "content": "有时用数学归纳法不能证明我们认为是真的结论，但可以用数学归纳法证明一个更强的结论。因为较强结论的归纳假设提供了更多可做的事情，这一过程称为归纳载入。练习 \\(74\\sim 76\\) 中将使用归纳载入。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.82,
                0.901,
                0.868
            ],
            "angle": 0,
            "content": "74. 证明我们不能使用数学归纳法来证明对于所有的正整数 \\(n\\), \\(\\sum_{j=1}^{n} 1 / j^2 < 2\\), 但这个不等式是练习 19 中通过数学归纳法证明的不等式的一个推论。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.871,
                0.427,
                0.886
            ],
            "angle": 0,
            "content": "75. 假设我们需要证明：对于所有的正整数 \\(n\\)"
        },
        {
            "type": "equation",
            "bbox": [
                0.416,
                0.891,
                0.571,
                0.922
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {i = 1} ^ {n} j / (j + 1)! <   1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.083,
                0.924,
                0.783,
                0.939
            ],
            "angle": 0,
            "content": "a) 证明如果尝试用数学归纳法来证明这个不等式，基础步骤可以，但归纳步骤不可以。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.136,
                0.04,
                0.172,
                0.054
            ],
            "angle": 0,
            "content": "296"
        },
        {
            "type": "header",
            "bbox": [
                0.217,
                0.039,
                0.282,
                0.054
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.137,
                0.096,
                0.685,
                0.111
            ],
            "angle": 0,
            "content": "b)用数学归纳法证明一个更强一些的不等式：对于所有的正整数 \\(n\\)"
        },
        {
            "type": "equation",
            "bbox": [
                0.417,
                0.116,
                0.68,
                0.148
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {j = 1} ^ {n} j / (j + 1)! \\leqslant 1 - 1 / (n + 1)!\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.148,
                0.506,
                0.163
            ],
            "angle": 0,
            "content": "而这个不等式蕴含前面条件弱一些的不等式。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.166,
                0.381,
                0.18
            ],
            "angle": 0,
            "content": "76.假如对所有正整数 \\(n\\) ，要证明"
        },
        {
            "type": "equation",
            "bbox": [
                0.443,
                0.184,
                0.655,
                0.214
            ],
            "angle": 0,
            "content": "\\[\n\\frac {1}{2} \\cdot \\frac {3}{4} \\dots \\frac {2 n - 1}{2 n} <   \\frac {1}{\\sqrt {3 n}}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.218,
                0.817,
                0.233
            ],
            "angle": 0,
            "content": "a) 证明：如果用数学归纳法证明上述不等式，则基础步骤有效，但归纳步骤却无效。"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.236,
                0.81,
                0.251
            ],
            "angle": 0,
            "content": "b)证明：用数学归纳法可以证明一个更强的不等式——对所有大于1的整数，都有"
        },
        {
            "type": "equation",
            "bbox": [
                0.43,
                0.254,
                0.672,
                0.284
            ],
            "angle": 0,
            "content": "\\[\n\\frac {1}{2} \\cdot \\frac {3}{4} \\dots \\frac {2 n - 1}{2 n} <   \\frac {1}{\\sqrt {3 n + 1}}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.287,
                0.848,
                0.302
            ],
            "angle": 0,
            "content": "结合 \\(n = 1\\) 时的结果，就可以建立起上述那个不能用数学归纳法证明的较弱的不等式了。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.305,
                0.955,
                0.337
            ],
            "angle": 0,
            "content": "77. 设 \\( n \\) 是一个正的偶数。证明：当 \\( n \\) 个人站在院子中，彼此之间距离不同，每个人都同时用一个馅饼抛向并击打离他最近的人时，每个人都可能受到馅饼的攻击。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.34,
                0.573,
                0.355
            ],
            "angle": 0,
            "content": "78. 用右三联骨牌覆盖一个去掉左上角格子的 \\(4 \\times 4\\) 棋盘。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.358,
                0.573,
                0.372
            ],
            "angle": 0,
            "content": "79. 用右三联骨牌覆盖一个去掉左上角格子的 \\(8 \\times 8\\) 棋盘。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.375,
                0.84,
                0.39
            ],
            "angle": 0,
            "content": "80. 证明或反驳：只要 \\( n \\) 是一个正整数，就可用右三联骨牌完全覆盖下述形状的所有棋盘。"
        },
        {
            "type": "list",
            "bbox": [
                0.107,
                0.305,
                0.955,
                0.39
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.393,
                0.21,
                0.407
            ],
            "angle": 0,
            "content": "a) \\(3 \\times 2^{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.383,
                0.393,
                0.447,
                0.407
            ],
            "angle": 0,
            "content": "b) \\(6 \\times 2^{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.144,
                0.411,
                0.215,
                0.424
            ],
            "angle": 0,
            "content": "c) \\(3^{n}\\times 3^{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.383,
                0.411,
                0.455,
                0.424
            ],
            "angle": 0,
            "content": "d) \\(6^{n}\\times 6^{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.428,
                0.956,
                0.46
            ],
            "angle": 0,
            "content": "*81. 证明：用去掉了一个 \\(1 \\times 1 \\times 1\\) 立方体块的 \\(2 \\times 2 \\times 2\\) 立方体，可以完全覆盖去掉了一个 \\(1 \\times 1 \\times 1\\) 立方体块的三维 \\(2^{n} \\times 2^{n} \\times 2^{n}\\) 棋盘。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.463,
                0.955,
                0.478
            ],
            "angle": 0,
            "content": "* 82. 证明：如果 \\( n \\) 大于 5，且 \\( n \\) 不能被 3 整除，则可以用右三联骨牌完全覆盖去掉一个格子的 \\( n \\times n \\) 棋盘。"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.481,
                0.667,
                0.496
            ],
            "angle": 0,
            "content": "83. 证明：可以用右三联骨牌覆盖去掉了一个角上格子的 \\(5 \\times 5\\) 棋盘。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.499,
                0.957,
                0.531
            ],
            "angle": 0,
            "content": "*84. 找出一个不能用右三联骨牌覆盖去掉了一个格子的 \\(5 \\times 5\\) 棋盘。证明：对这样的棋盘，不存在右三联骨牌的覆盖。"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.534,
                0.957,
                0.566
            ],
            "angle": 0,
            "content": "85. 利用数学归纳法原理证明：如果 \\(P(b)\\) 为真，且对满足 \\(k \\geq b\\) 的所有正整数 \\(k\\)，蕴含式 \\(P(k) \\rightarrow P(k + 1)\\) 为真，则对 \\(n = b, b + 1, b + 2, \\dots, P(n)\\) 为真，其中 \\(b\\) 是一个整数。"
        },
        {
            "type": "list",
            "bbox": [
                0.096,
                0.428,
                0.957,
                0.566
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.113,
                0.581,
                0.396,
                0.6
            ],
            "angle": 0,
            "content": "5.2 强归纳法与良序性"
        },
        {
            "type": "title",
            "bbox": [
                0.113,
                0.608,
                0.242,
                0.625
            ],
            "angle": 0,
            "content": "5.2.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.628,
                0.964,
                0.777
            ],
            "angle": 0,
            "content": "5.1节介绍了数学归纳法，并说明了如何用它来证明许多定理。本节将介绍另外一种形式的数学归纳法——强归纳法，这种方法通常在不能用数学归纳法轻易证明一个结论的时候使用。强归纳法证明中的基础步骤与数学归纳法证明中的基础步骤相同，即在强归纳法证明中，要证明对所有的正整数 \\(n\\) 而言 \\(P(n)\\) 为真，基础步骤中必须证明 \\(P(1)\\) 为真。但在这两种证明方法中，归纳步骤是不同的。在数学归纳法的证明中，归纳步骤是要证明：如果归纳假设 \\(P(k)\\) 为真，那么 \\(P(k + 1)\\) 也为真。而在强归纳法的证明中，归纳步骤是要证明：如果对所有不超过 \\(k\\) 的正整数而言，\\(P(j)\\) 为真，那么 \\(P(k + 1)\\) 也为真，即关于归纳假设，假定对 \\(j = 1,2,\\dots ,k\\) 而言，\\(P(j)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.78,
                0.964,
                0.891
            ],
            "angle": 0,
            "content": "数学归纳法和强归纳法的有效性是由附录A中的良序性公理来保证的。事实上，数学归纳法、强归纳法以及良序性三者是等价的原理（见练习41、42和43）。也就是说，三者中任何一种原理的有效性都可以用另外两种原理的有效性推导出来。这也意味着三者中的任何一种原理，都可以用另外两种原理来证明。正如在某些情况下，我们所看到的用强归纳法证明一个结论，比用数学归纳法证明容易得多一样，有时用良序性证明一个结论，也要比用两种形式的数学归纳法容易。本节将举一些例子来说明如何使用良序性来证明定理。"
        },
        {
            "type": "title",
            "bbox": [
                0.116,
                0.902,
                0.29,
                0.918
            ],
            "angle": 0,
            "content": "5.2.2 强归纳法"
        },
        {
            "type": "text",
            "bbox": [
                0.156,
                0.922,
                0.665,
                0.938
            ],
            "angle": 0,
            "content": "在阐述如何使用强归纳法之前，再来说明一下它的原理。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.681,
                0.039,
                0.792,
                0.053
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.837,
                0.04,
                0.874,
                0.053
            ],
            "angle": 0,
            "content": "297"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.101,
                0.893,
                0.136
            ],
            "angle": 0,
            "content": "强归纳法 要证明对所有的正整数 \\(n\\) 而言，都有 \\(P(n)\\) 为真，其中 \\(P(n)\\) 为命题函数，我们要完成如下两个步骤："
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.14,
                0.354,
                0.155
            ],
            "angle": 0,
            "content": "基础步骤：证明 \\(P(1)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.068,
                0.159,
                0.893,
                0.194
            ],
            "angle": 0,
            "content": "归纳步骤：要证明对所有正整数 \\(k\\) 来说，蕴含式 \\([P(1) \\wedge P(2) \\wedge \\dots \\wedge P(k)] \\rightarrow P(k + 1)\\) 也为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.204,
                0.905,
                0.299
            ],
            "angle": 0,
            "content": "注意，当用强归纳法证明对所有的正整数 \\(n\\) 而言，都有 \\(P(n)\\) 为真时，归纳假设是：对 \\(j = 1,2,\\dots ,k\\) 而言， \\(P(j)\\) 为真。也就是说，归纳假设包含了 \\(k\\) 个命题 \\(P(1),P(2),\\dots ,P(k)\\) 。由于我们是利用所有 \\(k\\) 个命题 \\(P(1),P(2),\\dots ,P(k)\\) 来证明 \\(P(k + 1)\\) ，而不是像在数学归纳法中那样只利用 \\(P(k)\\) 一个命题，因此，强归纳法的证明技巧更加灵活。因为这个原因，一些数学家更倾向采用加强数学归纳法来证明，即使数学归纳法也能容易获得结果。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.301,
                0.906,
                0.452
            ],
            "angle": 0,
            "content": "你可能会感到奇怪，为什么强归纳法和数学归纳法是等价的，即每一种技巧的有效性都可以用另外一种技巧的有效性来证明。特别地，任何使用数学归纳法的证明也可以认为是使用强归纳法的证明，这是因为数学归纳法证明中的归纳假设是强归纳法证明中的归纳假设的一个部分。也就是说，如果使用数学归纳法对每个正整数 \\(k\\) ，都证明了 \\(P(k)\\) 蕴含 \\(P(k + 1)\\) 我们就完成了证明中的归纳步骤。然而，上述蕴含关系也等价于所有命题 \\(P(1), P(2), \\dots, P(k)\\) 蕴含 \\(P(k + 1)\\) ，这是因为我们不仅假定 \\(P(k)\\) 真，还假定了更多的条件，即 \\(k - 1\\) 个命题 \\(P(1), P(2), \\dots, P(k - 1)\\) 也为真。然而，将一个用强归纳法的证明转化为一个用数学归纳法的证明却困难得多（见练习42）。"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.455,
                0.906,
                0.51
            ],
            "angle": 0,
            "content": "强归纳法有时也称为数学归纳法第二原理，或称为完全归纳法。当使用“完全归纳法”这一术语时，数学归纳法原理就称为不完全归纳法。这一术语只是一种无奈的选择，因为数学归纳法根本就不是不完全的，毕竟它是一种有效的证明技巧。"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.513,
                0.906,
                0.549
            ],
            "angle": 0,
            "content": "强归纳法与无限高的梯子为了更好地理解强归纳法，考虑5.1节中那个无限高的梯子。强归纳法告诉我们，我们能到达每一个阶梯，如果："
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.551,
                0.341,
                0.567
            ],
            "angle": 0,
            "content": "1)我们能到达第1个阶梯；"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.571,
                0.874,
                0.587
            ],
            "angle": 0,
            "content": "2)对于每一个整数 \\(k\\) ，如果能到达所有前 \\(k\\) 个阶梯，那么我们就能到达第 \\(k + 1\\) 个阶梯。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.59,
                0.907,
                0.644
            ],
            "angle": 0,
            "content": "也就是说，如果 \\(P(n)\\) 是命题“我们能够到达第 \\(n\\) 个阶梯”，那么根据强归纳法知道，对所有正整数 \\(n\\) ， \\(P(n)\\) 为真。因为由1)可知， \\(P(1)\\) 为真，这就完成了基础步骤；再由2)，知道\\(P(1)\\wedge P(2)\\wedge \\dots \\wedge P(k)\\) 蕴含着 \\(P(k + 1)\\) ，这就完成了归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.648,
                0.907,
                0.683
            ],
            "angle": 0,
            "content": "下面的例1阐述了强归纳法如何帮助我们证明一个用数学归纳法不能轻易证明出来的结论。"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.688,
                0.909,
                0.747
            ],
            "angle": 0,
            "content": "例1 假设我们能到达无限高梯子的第1个和第2个阶梯，且知道如果我们能到达某个阶梯，那么就能到达高出两阶的那个阶梯。我们能用数学归纳法证明“我们能到达每一个阶梯”吗？我们又能用强归纳法证明“我们能到达每一个阶梯”吗？"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.75,
                0.485,
                0.766
            ],
            "angle": 0,
            "content": "解 首先用数学归纳法试着证明这个结论。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.77,
                0.791,
                0.786
            ],
            "angle": 0,
            "content": "基础步骤：该证明的基础步骤是成立的，这里只需验证我们到达第1个阶梯。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.789,
                0.909,
                0.882
            ],
            "angle": 0,
            "content": "尝试归纳步骤：归纳假设是命题“我们能到达第 \\(k\\) 个阶梯”。为了能完成归纳步骤，需要证明：如果假定归纳假设是对正整数 \\(k\\) 而言的，也就是说，如果假定我们能够到达第 \\(k\\) 个阶梯，那么就能证明我们能到达第 \\(k + 1\\) 个阶梯。然而，并没有明显的方式来完成这一归纳步骤，这是因为从所给信息来看，我们不知道是否能从第 \\(k\\) 个阶梯到达第 \\(k + 1\\) 个阶梯。毕竟我们只知道“如果我们能到达一个阶梯，则我们能到达高出两阶的那个阶梯”。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.885,
                0.301,
                0.9
            ],
            "angle": 0,
            "content": "现在用强归纳法证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.905,
                0.731,
                0.92
            ],
            "angle": 0,
            "content": "基础步骤：基础步骤和前面是相同的，只需验证我们到达第1个阶梯。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.923,
                0.909,
                0.94
            ],
            "angle": 0,
            "content": "归纳步骤：归纳假设是命题“我们能到达前 \\(k\\) 个阶梯中的每个阶梯”。为了能完成归纳步"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.143,
                0.038,
                0.181,
                0.052
            ],
            "angle": 0,
            "content": "298"
        },
        {
            "type": "header",
            "bbox": [
                0.225,
                0.037,
                0.291,
                0.052
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.093,
                0.962,
                0.168
            ],
            "angle": 0,
            "content": "骤，需要证明：在归纳假设为真的情况下，即如果我们能到达前 \\(k\\) 个阶梯中的每个阶梯，那么我们就能到达第 \\(k + 1\\) 个阶梯。已经证明了我们能到达第2个阶梯。这里只需注意：只要 \\(k > 2\\) 那么就可从第 \\(k - 1\\) 个阶梯到达第 \\(k + 1\\) 个阶梯，因为知道我们可以从某个阶梯到达高出两阶的那个阶梯。这样就由强归纳法完成了归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.17,
                0.962,
                0.207
            ],
            "angle": 0,
            "content": "我们已经证明了：如果我们能到达一个无限高梯子的前两个阶梯，且对每个整数 \\(k\\) ，如果我们能到达所有前 \\(k\\) 个阶梯，那么我们就能到达第 \\(k + 1\\) 个阶梯，于是也就能到达所有的阶梯。"
        },
        {
            "type": "title",
            "bbox": [
                0.114,
                0.217,
                0.445,
                0.235
            ],
            "angle": 0,
            "content": "5.2.3 利用强归纳法证明的例子"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.237,
                0.963,
                0.389
            ],
            "angle": 0,
            "content": "现在既有了数学归纳法又有了强归纳法，那么在某种特定的情况下，如何确定到底使用哪种方法呢？尽管不存在什么固定的答案，但仍可利用一些有用的建议。在实际中，要直截了当地证明对所有的正整数 \\(k\\) ， \\(P(k)\\rightarrow P(k + 1)\\) 为真时，就应该使用数学归纳法。5.1节中的所有例子都是这种情况。一般情况下，我们应该尽量限制数学归纳法的使用。除非已经看出数学归纳法的归纳步骤证明是明显成立的，否则应该尽量用强归纳法。也就是说，当看出如何利用对所有不超过 \\(k\\) 的正整数 \\(j\\) ，试图从 \\(P(j)\\) 为真来证明 \\(P(k + 1)\\) 为真，而我们却看不出如何只利用 \\(P(k)\\) 来证明 \\(P(k + 1)\\) 时，就用强归纳法，而不用数学归纳法。在本节的证明中，请将这一点记在脑子里，以便印证。对本节证明中的每一个例子，考虑为什么强归纳法比数学归纳法更好用。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.392,
                0.962,
                0.447
            ],
            "angle": 0,
            "content": "例 \\(2\\sim 4\\) 将阐述如何使用强归纳法。这些例子将证明多种不同类型的结论。在每个例子中要特别注意归纳步骤，因为在此步骤中，要证明对所有不超过 \\(k\\) 的正整数 \\(j\\) ，如果 \\(P(j)\\) 为真，则 \\(P(k + 1)\\) 为真，其中 \\(P(n)\\) 是命题函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.45,
                0.962,
                0.524
            ],
            "angle": 0,
            "content": "在给这些例题之前，注意，只要对强归纳法稍加改变，就可以处理更为广泛的一类问题。特别是在强归纳步骤只对大于某个特定的整数有效时，可以改变强归纳法来适应这种情况。设 \\(b\\) 是一个固定的整数，而 \\(j\\) 是一个固定的正整数。如果能完成如下两个步骤，那么强归纳法就可以断言：对所有 \\(n \\geqslant b\\) 的整数 \\(n\\) 而言，\\(P(n)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.154,
                0.527,
                0.672,
                0.544
            ],
            "angle": 0,
            "content": "基础步骤：验证命题 \\(P(b)\\) ， \\(P(b + 1)\\) ，…， \\(P(b + j)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.546,
                0.96,
                0.582
            ],
            "angle": 0,
            "content": "归纳步骤：证明对所有 \\(k \\geqslant b + j\\) 的整数而言，\\([P(b) \\wedge P(b + 1) \\wedge \\dots \\wedge P(k)] \\rightarrow P(k + 1)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.154,
                0.585,
                0.708,
                0.601
            ],
            "angle": 0,
            "content": "这种变形的强归纳法与强归纳法的等效性的证明留作练习28。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.604,
                0.96,
                0.64
            ],
            "angle": 0,
            "content": "我们从一个最著名的强归纳法证明（算术基本定理之一）的证明开始，该定理断言：每个正整数都可写成素数的乘积。"
        },
        {
            "type": "text",
            "bbox": [
                0.154,
                0.645,
                0.692,
                0.663
            ],
            "angle": 0,
            "content": "例2 证明：若 \\(n\\) 是大于1的整数，则 \\(n\\) 可以写成素数之积。"
        },
        {
            "type": "text",
            "bbox": [
                0.154,
                0.668,
                0.543,
                0.684
            ],
            "angle": 0,
            "content": "解设 \\(P(n)\\) 是命题： \\(n\\) 可以写成素数之积。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.687,
                0.96,
                0.723
            ],
            "angle": 0,
            "content": "基础步骤：\\(P(2)\\) 为真，因为2可以写成一个素数之积，即它自身。（注意 \\(P(2)\\) 是需要证明的第一个情形。）"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.726,
                0.96,
                0.781
            ],
            "angle": 0,
            "content": "归纳步骤：假定对所有满足 \\(2 \\leqslant j \\leqslant k\\) 的正整数 \\(j\\) 来说 \\(P(j)\\) 为真。即假设对于大于等于2并不大于 \\(k\\) 的正整数，可以写成素数积的形式。要完成归纳步骤，就必须证明在这个假定下 \\(P(k + 1)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.784,
                0.962,
                0.877
            ],
            "angle": 0,
            "content": "有两种要考虑的情形，即 \\(k + 1\\) 是素数和 \\(k + 1\\) 是合数。若 \\(k + 1\\) 是素数，则立即看出 \\(P(k + 1)\\) 为真。否则，\\(k + 1\\) 是合数并且可以写成满足 \\(2 \\leqslant a \\leqslant b < k + 1\\) 的两个整数 \\(a\\) 和 \\(b\\) 之积。因为 \\(a\\) 和 \\(b\\) 是大于等于 2 并不大于 \\(k\\) 的正整数，所以根据归纳假设，\\(a\\) 和 \\(b\\) 都可以写成素数之积。因此，若 \\(k + 1\\) 是合数，则它可以写成素数之积，即在 \\(a\\) 的因子分解中的那些素数与在 \\(b\\) 的因子分解中的那些素数之积。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.88,
                0.96,
                0.916
            ],
            "angle": 0,
            "content": "评注 因为1是素数之积，即不包含任何素数的空积，所以可以在例2里用 \\(P(1)\\) 作为基础步骤来开始证明。没有选择这样做是因为许多人对此感到迷惑不解。"
        },
        {
            "type": "text",
            "bbox": [
                0.154,
                0.919,
                0.962,
                0.936
            ],
            "angle": 0,
            "content": "例2完成了对算术基本定理的证明，该定理断言：每个非负整数可以唯一地写成以非降顺"
        },
        {
            "type": "image",
            "bbox": [
                0.038,
                0.643,
                0.1,
                0.66
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.683,
                0.038,
                0.793,
                0.052
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.84,
                0.039,
                0.876,
                0.052
            ],
            "angle": 0,
            "content": "299"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.094,
                0.905,
                0.129
            ],
            "angle": 0,
            "content": "序排列的素数之积。在4.3节里证明过整数最多有一种这样的素因子分解。例2证明至少有一种这样的分解。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.132,
                0.791,
                0.148
            ],
            "angle": 0,
            "content": "下面来看看如何利用强归纳法证明：在一场游戏中一个选手具有获胜的策略。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.153,
                0.905,
                0.211
            ],
            "angle": 0,
            "content": "例3 考虑一种游戏，其中两名选手轮流从两堆火柴中的一堆取出任意正整数的火柴。取走最后一根火柴的选手获胜。证明：如果开始时两堆火柴的数目相同，则第二名选手总是可以保证获胜。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.214,
                0.905,
                0.248
            ],
            "angle": 0,
            "content": "解设 \\(n\\) 是每堆火柴的数目。将用强归纳法来证明 \\(P(n)\\)，即命题：当每堆开始有 \\(n\\) 根火柴时，第二名选手可以获胜。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.252,
                0.905,
                0.287
            ],
            "angle": 0,
            "content": "基础步骤：当 \\(n = 1\\) 时，先拿火柴的选手只有一种选择，从某一堆中取走一根火柴，剩下一堆只有一根，第二名选手可以取走这根火柴而获胜。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.289,
                0.905,
                0.458
            ],
            "angle": 0,
            "content": "归纳步骤：归纳假设是命题：对于所有 \\(1 \\leqslant j \\leqslant k\\) 的 \\(j\\) 来说，\\(P(j)\\) 为真，也就是说，只要游戏开始时两堆各有 \\(j\\) 根火柴，其中 \\(1 \\leqslant j \\leqslant k\\)，第二名选手就总是可以获胜。需要证明 \\(P(k + 1)\\) 为真，即，开始时每堆火柴都有 \\(k + 1\\) 根火柴，且在 \\(P(j) (j = 1, 2, \\dots, k)\\) 为真的条件下，第二个选手获胜。因此，现在假设游戏开始时两堆火柴中都有 \\(k + 1\\) 根火柴，且第一个选手从其中的一堆中拿走 \\(r (1 \\leqslant r \\leqslant k)\\) 根火柴，那么此堆中剩下 \\(k + 1 - r\\) 根火柴。如果第二个选手从另一堆中也拿走同样数量的火柴，那么两堆火柴中就都剩下了 \\(k + 1 - r\\) 根火柴。因为 \\(1 \\leqslant k + 1 - r \\leqslant k\\)，使用归纳假设，可以得到第二个选手获胜。注意如果第一个选手从其中的一堆中拿走全部 \\(k + 1\\) 根火柴，那么第二个选手也从另外一堆中拿走全部火柴，因此仍然是第二个选手获胜。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.461,
                0.904,
                0.496
            ],
            "angle": 0,
            "content": "如果用数学归纳法而不是用强归纳法来证明例2和例3的结论，将是非常困难的。但是，正如例4所示，有些结论用两种方法证明都比较容易。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.501,
                0.768,
                0.518
            ],
            "angle": 0,
            "content": "例4 证明：仅用4分和5分邮票就可以组成大于或等于12分的每种邮资。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.523,
                0.904,
                0.558
            ],
            "angle": 0,
            "content": "解 将要用数学归纳法原理来证明这个结果，然后用强归纳法证明。设 \\(P(n)\\) 是命题：可以用4分和5分邮票来组成 \\(n\\) 分邮资。首先使用数学归纳法原理。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.561,
                0.548,
                0.577
            ],
            "angle": 0,
            "content": "基础步骤：可以用3个4分邮票来组成12分邮资。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.58,
                0.905,
                0.748
            ],
            "angle": 0,
            "content": "归纳步骤：归纳假设是命题 \\(P(k)\\) 为真。即，在归纳假设下，可以用4分和5分邮票来构成 \\(k\\) 分邮资。为了完成归纳步骤，需要证明：当 \\(P(k)\\) 为真时，\\(P(k + 1)\\) 也为真，其中 \\(k \\geqslant 12\\)。也就是说，需要证明：如果能构成 \\(k\\) 分邮资，那么也能构成 \\(k + 1\\) 分邮资。这样，假设归纳假设为真，即假设 \\(k\\) 分邮资能用4分和5分邮票来构成。考虑两种情况：至少用了1个4分邮票和没有用到任何4分邮票。首先，至少用了1个4分邮票来构成 \\(k\\) 分邮资。于是可以用1个5分邮票取而代之来构成 \\(k + 1\\) 分邮资。但是，如果 \\(k\\) 分邮资中没有用到任何4分邮票，则说明 \\(k\\) 分邮资中只用到了5分的邮票。又由于 \\(k \\geqslant 12\\)，所以至少需要3个5分的邮票来构成这 \\(k\\) 分邮资。因此，用4个4分的邮票来代替3个5分的邮票就可以构成 \\(k + 1\\) 分邮资。这就完成了归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.751,
                0.904,
                0.786
            ],
            "angle": 0,
            "content": "因为已经完成了基础步骤和归纳步骤，所以我们知道对所有的 \\(n \\geqslant 12\\) ，\\(P(n)\\) 为真。即，当 \\(n \\geqslant 12\\) 时，就可以只用4分和5分邮票来构成 \\(n\\) 分邮资。这样完成了通过数学归纳法的证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.789,
                0.904,
                0.843
            ],
            "angle": 0,
            "content": "接下来，再用强归纳法来证明上述结论。在该证明的基础步骤中，要证明 \\(P(12)、P(13)、P(14)\\) 和 \\(P(15)\\) 都为真，即12、13、14和15分的邮资都可以用4分和5分的邮票来构成。在归纳步骤，要证明：对 \\(k \\geq 15\\) 时，如何从 \\(k - 3\\) 分邮资来得到 \\(k + 1\\) 分邮资。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.846,
                0.904,
                0.9
            ],
            "angle": 0,
            "content": "基础步骤：可以分别用3个4分的邮票来构成12分的邮资、2个4分邮票和1个5分邮票来构成13分的邮资、1个4分邮票和2个5分邮票来构成14分的邮资，以及3个5分的邮票来构成15分的邮资。这说明 \\(P(12), P(13), P(14)\\) 和 \\(P(15)\\) 都为真。因此完成了基础步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.903,
                0.904,
                0.939
            ],
            "angle": 0,
            "content": "归纳步骤：归纳假设是命题：当 \\(12 \\leqslant j \\leqslant k\\) 时，\\(P(j)\\) 为真，其中 \\(k\\) 是满足 \\(k \\geqslant 15\\) 的整数。为了完成归纳步骤，假定能构成 \\(j\\) 分的邮资，其中 \\(12 \\leqslant j \\leqslant k\\) 。需要证明在此假设下，\\(P(k + 1)\\)"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.136,
                0.04,
                0.172,
                0.054
            ],
            "angle": 0,
            "content": "300"
        },
        {
            "type": "header",
            "bbox": [
                0.218,
                0.039,
                0.284,
                0.054
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.095,
                0.957,
                0.169
            ],
            "angle": 0,
            "content": "为真，即能构成 \\(k + 1\\) 分的邮资。利用归纳假设，可以假定 \\(P(k - 3)\\) 为真，这是因为 \\(k - 3 \\geqslant 12\\) 即只用4分和5分的邮票就能构成 \\(k - 3\\) 分的邮资。为了构成 \\(k + 1\\) 分的邮资，只需对构成 \\(k - 3\\) 分邮资的邮票中增加一张4分的邮票就可以了，即已经证明了“如果归纳假设为真，那么\\(P(k + 1)\\) 也为真”。这就完成了归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.172,
                0.957,
                0.226
            ],
            "angle": 0,
            "content": "因为已经完成了强归纳法中的基础步骤和归纳步骤，所以根据强归纳法可知：对所有 \\(n \\geq 12\\) 的整数 \\(n\\)，\\(P(n)\\) 为真，即，证明了对所有满足不小于12分的邮资，都可以用4分和5分的邮票来构成。这样完成了利用加强归纳法的证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.229,
                0.957,
                0.264
            ],
            "angle": 0,
            "content": "（除了这里描述的方法以外，还有处理这个问题的其他方法。读者能否找出不使用数学归纳法的解答？）"
        },
        {
            "type": "title",
            "bbox": [
                0.108,
                0.275,
                0.465,
                0.292
            ],
            "angle": 0,
            "content": "5.2.4 计算几何学中使用强归纳法"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.295,
                0.962,
                0.368
            ],
            "angle": 0,
            "content": "下一个强归纳法的例子来自计算几何学。计算几何学是离散数学的一部分，它涉及几何对象的计算问题。计算几何广泛应用于计算机图形学、计算机游戏、机器人技术、科学计算，以及许多其他领域。在给出结论之前，先介绍一些术语，这些术语在以往学过的几何学中可能已经遇到过了。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.371,
                0.962,
                0.501
            ],
            "angle": 0,
            "content": "多边形是一个封闭的图形，它是由一系列叫作边的线段 \\(s_1\\) ， \\(s_2\\) ，…， \\(s_n\\) 所构成的。图形中每一对相邻的边 \\(s_i\\) 和 \\(s_{i + 1}(i = 1\\) ，2，…， \\(n - 1)\\) 以及最后一条边 \\(s_n\\) 和第一条边 \\(s_1\\) 都相交于一个公共的端点，称其为顶点。如果两条不相邻的边没有交点，则称该多边形为简单多边形。每个简单多边形都把整个平面划分为两个区域：内部区域和外部区域，内部区域是由曲线内部的点构成的，外部区域是由曲线外部的点构成的。后一个事实的证明相当复杂，它是著名的若尔当(Jordan)曲线定理的一种特殊情况，该定理告诉我们：每一条简单曲线都把平面划分成两个区域。例如，参见[Or00]。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.504,
                0.964,
                0.598
            ],
            "angle": 0,
            "content": "如果连接多边形内部任意两点的线段都整个包含在该多边形内，则称该多边形是凸的。（不是凸多边形的多边形称为非凸的。）图1给出了4个多边形，其中图1a和图1b是凸的，而图1c和图1d是非凸的。简单多边形的对角线是连接多边形两个不相邻顶点的线段，如果一条对角线除了两个端点外，整个包含在多边形内部，则称该对角线为内部对角线。例如，在多边形图1d中，连接a和f的线段是一条内部对角线，而连接a和d的线段是对角线，但不是内部对角线。"
        },
        {
            "type": "image",
            "bbox": [
                0.161,
                0.615,
                0.287,
                0.702
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.218,
                0.706,
                0.237,
                0.72
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "image",
            "bbox": [
                0.303,
                0.613,
                0.455,
                0.702
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.375,
                0.706,
                0.394,
                0.719
            ],
            "angle": 0,
            "content": "b)"
        },
        {
            "type": "image",
            "bbox": [
                0.468,
                0.608,
                0.596,
                0.703
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.531,
                0.707,
                0.549,
                0.72
            ],
            "angle": 0,
            "content": "c)"
        },
        {
            "type": "image",
            "bbox": [
                0.613,
                0.605,
                0.805,
                0.702
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.71,
                0.706,
                0.728,
                0.72
            ],
            "angle": 0,
            "content": "d)"
        },
        {
            "type": "image_footnote",
            "bbox": [
                0.775,
                0.676,
                0.916,
                0.704
            ],
            "angle": 0,
            "content": "\\(af\\) 是内部对角线 \\(ad\\) 不是内部对角线"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.419,
                0.73,
                0.662,
                0.745
            ],
            "angle": 0,
            "content": "图1 凸多边形与非凸多边形"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.756,
                0.564,
                0.925
            ],
            "angle": 0,
            "content": "计算几何学中最基本的操作之一，是通过加入不相交的对角线把一个简单多边形划分成多个三角形，这个过程叫作三角形化。注意，一个简单多边形可以有许多不同的三角形划分，如图2所示。计算几何学中最基本的事实或许就是下面的定理1所叙述的：每个简单多边形都可以三角形化。此外，定理1还告诉我们：具有 \\(n\\) 条边的简单多边形的任何一种三角形化，都包含 \\(n - 2\\) 个三角形。"
        },
        {
            "type": "image",
            "bbox": [
                0.575,
                0.758,
                0.787,
                0.908
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_footnote",
            "bbox": [
                0.786,
                0.789,
                0.938,
                0.86
            ],
            "angle": 0,
            "content": "由7条边构成的简单多边形分成5个三角形的两种不同的三角化，分别由虚线和点线表示"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.659,
                0.917,
                0.864,
                0.932
            ],
            "angle": 0,
            "content": "图2 多边形的三角形化"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.673,
                0.039,
                0.783,
                0.054
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.829,
                0.041,
                0.864,
                0.054
            ],
            "angle": 0,
            "content": "301"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.102,
                0.885,
                0.138
            ],
            "angle": 0,
            "content": "定理1具有 \\(n\\) 条边的简单多边形能够被三角形化为 \\(n - 2\\) 个三角形，其中 \\(n\\) 是大于等于3的整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.147,
                0.895,
                0.183
            ],
            "angle": 0,
            "content": "结论看起来似乎很明显：通过不断加入内部对角线，就可以将一个简单多边形三角形化。因此，用强归纳法证明该定理似乎很有希望。然而，这种证明却需要如下一个关键的引理。"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.192,
                0.662,
                0.209
            ],
            "angle": 0,
            "content": "引理1 每个简单的至少四边的多边形都存在一条内部对角线。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.218,
                0.898,
                0.273
            ],
            "angle": 0,
            "content": "尽管引理1看起来非常简单，但证明起来却非常困难。事实上，就在30年以前，曾经有许多被认为是正确而其实是不正确的证明，它们经常出现在教科书或文章中。先用引理1证明定理1，然后再证明引理1，这在证明定理时是一种常见手法。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.276,
                0.898,
                0.311
            ],
            "angle": 0,
            "content": "证明（定理1）用强归纳法来证明这个定理。设 \\(T(n)\\) 是命题：具有 \\(n\\) 条边的简单多边形能够被三角形化为 \\(n - 2\\) 个三角形。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.314,
                0.898,
                0.368
            ],
            "angle": 0,
            "content": "基础步骤：\\(T(3)\\) 为真，因为具有三条边的多边形是一个三角形。不需要对一个三角形加入任何对角线。该三角形已经被三角形化了，即它自身。因此，对于简单多边形 \\(n = 3\\) 可以分为 \\(n - 2 = 3 - 2 = 1\\) 个三角形。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.371,
                0.898,
                0.445
            ],
            "angle": 0,
            "content": "归纳步骤：关于归纳假设，假定对所有 \\(3 \\leqslant j \\leqslant k\\) 的 \\(j\\) 而言，\\(T(j)\\) 为真。也就是说，假定只要 \\(3 \\leqslant j \\leqslant k\\)，就能将具有 \\(j\\) 条边的简单多边形三角形化为 \\(j - 2\\) 个三角形。为了完成归纳步骤，必须证明：当归纳假设为真时，\\(T(k + 1)\\) 为真，也就是说，具有 \\(k + 1\\) 条边的任意简单多边形都能被三角形化为 \\((k + 1) - 2 = k - 1\\) 个三角形。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.447,
                0.9,
                0.578
            ],
            "angle": 0,
            "content": "因此，假定有一个具有 \\(k + 1\\) 条边的简单多边形 \\(P\\)。因为 \\(k + 1 \\geqslant 4\\)，所以由引理1，\\(P\\) 中存在一条内部对角线 \\(ab\\)。现在，\\(ab\\) 将 \\(P\\) 分成了两个简单多边形 \\(Q\\) 和 \\(R\\)，且 \\(Q\\) 有 \\(s\\) 条边，\\(R\\) 有 \\(t\\) 条边。\\(Q\\) 和 \\(R\\) 的边都是 \\(P\\) 的边，还有一条边 \\(ab\\)，它是 \\(Q\\) 和 \\(R\\) 的公共边。注意由于 \\(Q\\) 和 \\(R\\) 都至少比 \\(P\\) 少一条边（因为它们都是由 \\(P\\) 通过去掉至少两条边，同时增加了对角线 \\(ab\\) 而形成的），因此有 \\(3 \\leqslant s \\leqslant k\\) 和 \\(3 \\leqslant t \\leqslant k\\)。此外，\\(P\\) 的边数比 \\(Q\\) 和 \\(R\\) 的边数之和少两条，因为 \\(P\\) 的每条边要么是 \\(Q\\) 的一条边，要么是 \\(R\\) 的一条边，但不能既是 \\(Q\\) 的一条边又是 \\(R\\) 的一条边，而对角线 \\(ab\\) 是 \\(Q\\) 和 \\(R\\) 的一条公共边，但却不是 \\(P\\) 的一条边。即，\\(k + 1 = s + t - 2\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.581,
                0.904,
                0.674
            ],
            "angle": 0,
            "content": "根据归纳假设，由于 \\(3 \\leqslant s \\leqslant k\\) 和 \\(3 \\leqslant t \\leqslant k\\) 都成立，所以可以将 \\(Q\\) 和 \\(R\\) 分别三角形化为 \\(s - 2\\) 个和 \\(t - 2\\) 个三角形。其次，注意 \\(Q\\) 和 \\(R\\) 的三角形化合在一起构成了 \\(P\\) 的一个三角形化。（在 \\(Q\\) 和 \\(R\\) 中加入的每个对角线都是 \\(P\\) 的一条对角线。）因此，可以将 \\(P\\) 三角形化为总数为 \\((s - 2) + (t - 2) = s + t - 4 = (k + 1) - 2\\) 个三角形。这就完成了强归纳法的证明。即已经证明了：具有 \\(n\\) 条边的简单多边形能够被三角形化为 \\(n - 2\\) 个三角形，其中 \\(n \\geqslant 3\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.676,
                0.904,
                0.732
            ],
            "angle": 0,
            "content": "下面再来证明引理1。这里给出由Chung-Wu Ho所发表的证明[Ho75]。注意尽管这个证明可以忽略，且不会影响学习的连续性，但该证明说明的问题是：一个看起来非常明显的结论，证明起来有时是多么困难。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.733,
                0.904,
                0.827
            ],
            "angle": 0,
            "content": "证明 假设 \\(P\\) 是平面上画出的一个简单多边形。另外，设 \\(b\\) 是 \\(P\\) 上或 \\(P\\) 内的一点，该点是 \\(x\\) 坐标最小的顶点中 \\(y\\) 坐标最小的一点。于是，\\(b\\) 一定是 \\(P\\) 的一个顶点，因为如果 \\(b\\) 是 \\(P\\) 的一个内部点，那么 \\(P\\) 中将存在一个顶点，其 \\(x\\) 坐标比 \\(b\\) 的 \\(x\\) 坐标还小。设另外两个顶点 \\(a\\) 和 \\(c\\) 与 \\(b\\) 是邻接点，于是由 \\(ab\\) 和 \\(bc\\) 所构成的 \\(P\\) 内的角必小于 \\(180^{\\circ}\\)（否则，\\(P\\) 中必有一点，其 \\(x\\) 坐标要比 \\(b\\) 的 \\(x\\) 坐标还小）。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.829,
                0.905,
                0.942
            ],
            "angle": 0,
            "content": "现在设 \\(T\\) 是三角形 \\(\\triangle abc\\)。如果 \\(P\\) 中没有顶点在 \\(T\\) 上或 \\(T\\) 内，那么可以连接 \\(ac\\) 而得到一条内部对角线。另一方面，如果 \\(P\\) 中有顶点在 \\(T\\) 内，那么可以找到 \\(P\\) 的一个顶点 \\(p\\)，它在 \\(T\\) 上或在 \\(T\\) 内，使得 \\(b_{p}\\) 是一条内部对角线。（这是个难点，Ho曾注释过：在许多已发表的该引理的证明中，这样的顶点 \\(p\\) 是可以找到的，只要 \\(b_{p}\\) 不一定非得是 \\(P\\) 的一条内部对角线就行，见练习21。）问题的关键是选择一个顶点 \\(p\\)，使得 \\(\\angle bap\\) 最小。为了说明能做到这一点，注意从 \\(a\\) 点出发经过 \\(p\\) 点的射线必与线段 \\(bc\\) 相交于一点，比如说相交于 \\(q\\) 点。于是 \\(\\triangle baq\\) 内部不可能含有 \\(P\\) 中的"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.147,
                0.038,
                0.186,
                0.052
            ],
            "angle": 0,
            "content": "302"
        },
        {
            "type": "header",
            "bbox": [
                0.229,
                0.037,
                0.295,
                0.053
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.094,
                0.917,
                0.11
            ],
            "angle": 0,
            "content": "任何顶点。因此，可以连接 \\(b\\) 和 \\(p\\) 而形成 \\(P\\) 的一条内部对角线。图3给出了 \\(p\\) 点位置的说明。"
        },
        {
            "type": "image",
            "bbox": [
                0.284,
                0.117,
                0.524,
                0.279
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.564,
                0.141,
                0.686,
                0.155
            ],
            "angle": 0,
            "content": "T是三角形△abc"
        },
        {
            "type": "text",
            "bbox": [
                0.564,
                0.158,
                0.802,
                0.172
            ],
            "angle": 0,
            "content": "\\(p\\) 是 \\(T\\) 内 \\(P\\) 的顶点，使得 \\(\\angle bap\\) 最小"
        },
        {
            "type": "text",
            "bbox": [
                0.564,
                0.175,
                0.777,
                0.188
            ],
            "angle": 0,
            "content": "bp必定是 \\(P\\) 的一条内部对角线"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.365,
                0.288,
                0.72,
                0.303
            ],
            "angle": 0,
            "content": "图3 在简单多边形中建立一条内部对角线"
        },
        {
            "type": "title",
            "bbox": [
                0.116,
                0.323,
                0.357,
                0.339
            ],
            "angle": 0,
            "content": "5.2.5 利用良序性证明"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.343,
                0.967,
                0.456
            ],
            "angle": 0,
            "content": "数学归纳法原理和强归纳法的有效性源于整数集合的基本公理——良序性公理（见附录A）。良序性公理断言：任意一个非空的非负整数集合都有最小元素。我们将会看到，良序性公理是怎样直接应用于证明中的。此外，可以证明：良序性公理、数学归纳法原理以及强归纳法之间是等价的（见练习 \\(41\\sim 43\\)）。也就是说，给定三种技巧中的任何一种，其有效性都可以用另外两种技巧中的任何一种来证明。在5.1节中，我们曾证明过良序性公理蕴含着数学归纳法原理，关于它们等价性的另一半证明，在本节最后留作练习，见练习31、42和43。"
        },
        {
            "type": "text",
            "bbox": [
                0.157,
                0.459,
                0.685,
                0.474
            ],
            "angle": 0,
            "content": "良序性公理 任意一个非空的非负整数集合都有最小元素。"
        },
        {
            "type": "text",
            "bbox": [
                0.157,
                0.478,
                0.521,
                0.493
            ],
            "angle": 0,
            "content": "良序性公理经常可以直接应用于证明中。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.499,
                0.964,
                0.537
            ],
            "angle": 0,
            "content": "例5 用良序性证明整除算法。回忆一下，整除算法说：若 \\(a\\) 是整数且 \\(d\\) 是正整数，则存在唯一的整数 \\(q\\) 和 \\(r\\) 满足 \\(0 \\leqslant r < d\\) 和 \\(a = dq + r\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.541,
                0.964,
                0.576
            ],
            "angle": 0,
            "content": "解设 \\(S\\) 是形如 \\(a - dq\\) 的非负整数的集合，其中 \\(q\\) 是整数。这个集合非空，因为 \\(-dq\\) 可以任意大（取 \\(q\\) 是绝对值很大的负整数）。根据良序性，\\(S\\) 有最小元 \\(r = a - dq_0\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.579,
                0.964,
                0.634
            ],
            "angle": 0,
            "content": "整数 \\(r\\) 非负且 \\(r < d\\) 。若不是这样，则 \\(S\\) 里存在更小的非负整数，即 \\(a - d(q_0 + 1)\\) 。为了看出这一点，假设 \\(r \\geqslant d\\) 。因为 \\(a = dq_0 + r\\) ，所以 \\(a - d(q_0 + 1) = (a - dq_0) - d = r - d \\geqslant 0\\) 。因此，存在满足 \\(0 \\leqslant r < d\\) 的整数 \\(r\\) 和 \\(q\\) 。证明 \\(q\\) 和 \\(r\\) 都是唯一的，留给读者作为练习37。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.64,
                0.964,
                0.716
            ],
            "angle": 0,
            "content": "例6 在一种主客场循环赛中，每个选手与其他每个选手恰好比赛一次并且每次比赛分出胜负。所谓选手 \\( p_1, p_2, \\dots, p_m \\) 形成回路，就是 \\( p_1 \\) 战胜 \\( p_2 \\)，\\( p_2 \\) 战胜 \\( p_3 \\)，…，\\( p_{m-1} \\) 战胜 \\( p_m \\)，\\( p_m \\) 战胜 \\( p_1 \\)。用良序性公理证明：如果在主客场循环赛的选手中存在长度为 \\( m (m \\geqslant 3) \\) 的回路，则必定存在这些选手中三个选手的回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.72,
                0.964,
                0.774
            ],
            "angle": 0,
            "content": "解 假设不存在三个选手的回路。因为在主客场循环赛中至少有一个回路，所以存在长度为 \\(n\\) 的回路的所有正整数 \\(n\\) 的集合是非空的。根据良序性，这个正整数集合有最小元 \\(k\\) ，假设 \\(k\\) 必定大于3。因此，存在选手回路 \\(p_1, p_2, p_3, \\dots, p_k\\) 并且不存在更短的回路。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.778,
                0.964,
                0.871
            ],
            "angle": 0,
            "content": "现在假设不存在这些选手中三个选手的回路，所以 \\(k > 3\\) 。考虑这个回路的前三个元素 \\(p_1, p_2, p_3\\) 。在 \\(p_1\\) 与 \\(p_3\\) 之间的比赛有两种可能的结果。如果 \\(p_3\\) 战胜 \\(p_1\\) ，那么 \\(p_1, p_2, p_3\\) 就是长度为3的回路，与不存在三个选手的回路的假设相矛盾。因此，必定是 \\(p_1\\) 战胜 \\(p_3\\) 。这意味着可以从回路 \\(p_1, p_2, p_3, \\dots, p_k\\) 中忽略 \\(p_2\\) 来获得长度为 \\(k - 1\\) 的回路 \\(p_1, p_3, p_4, \\dots, p_k\\) ，与最短回路长度为 \\(k\\) 的假设相矛盾。结论是必定存在长度为3的回路。"
        },
        {
            "type": "title",
            "bbox": [
                0.116,
                0.882,
                0.165,
                0.898
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.902,
                0.964,
                0.936
            ],
            "angle": 0,
            "content": "1. 用强归纳法证明：如果你能跑一英里或两英里，且如果你能跑一个特定的英里数，那你就还能多跑两英里，证明你能跑任意的英里数。"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.041,
                0.496,
                0.102,
                0.514
            ],
            "angle": 0,
            "content": "Extra Examples"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.673,
                0.039,
                0.783,
                0.054
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.829,
                0.041,
                0.866,
                0.054
            ],
            "angle": 0,
            "content": "303"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.095,
                0.893,
                0.128
            ],
            "angle": 0,
            "content": "2. 用强归纳法证明：如果你知道排列着无限长的多米诺骨牌中的前3个会倒下，且如果1个多米诺骨牌倒下，那么排在它后面的3个骨牌也会倒下，证明所有的多米诺骨牌都会倒下。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.131,
                0.893,
                0.164
            ],
            "angle": 0,
            "content": "3. 设 \\(P(n)\\) 是命题：一份 \\(n\\) 分邮资可以只用3分和5分的邮票来构成。此练习简述了用强归纳法证明对 \\(n \\geq 8\\)，\\(P(n)\\) 为真时的要点。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.167,
                0.571,
                0.181
            ],
            "angle": 0,
            "content": "a) 证明 \\(P(8)\\)、\\(P(9)\\) 和 \\(P(10)\\) 为真，从而完成基础步骤的证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.185,
                0.304,
                0.199
            ],
            "angle": 0,
            "content": "b) 证明中的归纳假设是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.203,
                0.301,
                0.217
            ],
            "angle": 0,
            "content": "c)在归纳步骤需要证明什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.221,
                0.297,
                0.236
            ],
            "angle": 0,
            "content": "d)对 \\(k\\geqslant 10\\) ，完成归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.239,
                0.527,
                0.253
            ],
            "angle": 0,
            "content": "e)解释为什么上述步骤证明了：只要 \\(n\\geq 8\\) ，命题就为真。"
        },
        {
            "type": "list",
            "bbox": [
                0.067,
                0.167,
                0.571,
                0.253
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.257,
                0.893,
                0.29
            ],
            "angle": 0,
            "content": "4. 设 \\(P(n)\\) 是命题：一份 \\(n\\) 分邮资可以只用 4 分和 7 分的邮票来构成。此练习简述了用强归纳法证明对 \\(n \\geqslant 18\\)，\\(P(n)\\) 为真时的要点。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.293,
                0.656,
                0.308
            ],
            "angle": 0,
            "content": "a) 证明 \\(P(18)\\) 、 \\(P(19)\\) 、 \\(P(20)\\) 和 \\(P(21)\\) 为真，从而完成基础步骤的证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.311,
                0.304,
                0.326
            ],
            "angle": 0,
            "content": "b) 证明中的归纳假设是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.329,
                0.301,
                0.344
            ],
            "angle": 0,
            "content": "c)在归纳步骤需要证明什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.347,
                0.297,
                0.362
            ],
            "angle": 0,
            "content": "d)对 \\(k\\geqslant 21\\) ，完成归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.067,
                0.365,
                0.558,
                0.38
            ],
            "angle": 0,
            "content": "e)解释为什么上述步骤证明了：只要 \\(n\\geqslant 18\\) 时，命题就为真。"
        },
        {
            "type": "list",
            "bbox": [
                0.067,
                0.293,
                0.656,
                0.38
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.383,
                0.532,
                0.397
            ],
            "angle": 0,
            "content": "5. a) 确定只用 4 分和 11 分的邮票可以构成多少数量的邮资。"
        },
        {
            "type": "text",
            "bbox": [
                0.066,
                0.401,
                0.744,
                0.416
            ],
            "angle": 0,
            "content": "b)用数学归纳法原理证明你对a的回答。注意必须明确陈述归纳步骤中的归纳假设。"
        },
        {
            "type": "text",
            "bbox": [
                0.066,
                0.419,
                0.89,
                0.451
            ],
            "angle": 0,
            "content": "c)用强归纳法证明你对a的回答。在该证明中，归纳假设与用数学归纳法原理证明中的归纳假设有什么不同？"
        },
        {
            "type": "list",
            "bbox": [
                0.066,
                0.401,
                0.89,
                0.451
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.455,
                0.531,
                0.469
            ],
            "angle": 0,
            "content": "6. a) 确定只用 3 分和 10 分的邮票可以构成多少数量的邮资。"
        },
        {
            "type": "text",
            "bbox": [
                0.066,
                0.473,
                0.744,
                0.488
            ],
            "angle": 0,
            "content": "b)用数学归纳法原理证明你对a的回答。注意必须明确陈述归纳步骤中的归纳假设。"
        },
        {
            "type": "text",
            "bbox": [
                0.066,
                0.491,
                0.89,
                0.523
            ],
            "angle": 0,
            "content": "c)用强归纳法证明你对a的回答。在该证明中，归纳假设与用数学归纳法原理证明中的归纳假设有什么不同？"
        },
        {
            "type": "list",
            "bbox": [
                0.066,
                0.473,
                0.89,
                0.523
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.526,
                0.708,
                0.541
            ],
            "angle": 0,
            "content": "7. 只用2美元和5美元的钞票可以构成多少数量的钱？用强归纳法证明你的回答。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.544,
                0.89,
                0.578
            ],
            "angle": 0,
            "content": "8. 假设商店提供面额为 25 美元和 40 美元的礼券，确定用这些礼券可以构成多少可能的总量。用强归纳法证明你的回答。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.583,
                0.739,
                0.598
            ],
            "angle": 0,
            "content": "9. 用强归纳法证明 \\(\\sqrt{2}\\) 是无理数。[提示：设 \\(P(n)\\) 是命题：对任意正整数 \\(b, \\sqrt{2} \\neq n / b\\)]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.602,
                0.89,
                0.652
            ],
            "angle": 0,
            "content": "10. 假设一种巧克力棒由排列成长方形的 \\(n\\) 个方块组成。整个棒或棒的较小的长方形块可以沿着分隔方块的垂直线或水平线折断。假设一次只能折断一块，确定为了把整个棒折断成 \\(n\\) 个分开的方块，必须先后折断多少次。用强归纳法证明你的答案。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.656,
                0.89,
                0.724
            ],
            "angle": 0,
            "content": "11. 考虑 Nim 游戏的如下变种。这个游戏从 \\( n \\) 根火柴开始。两名选手轮流取走火柴，每次取一根、两根或三根。取走最后一根火柴的选手落败。用强归纳法证明：如果每名选手按照最好可能的策略来玩游戏，那么若对于某个非负整数 \\( j \\) 来说，\\( n = 4j \\)、\\( 4j + 2 \\) 或 \\( 4j + 3 \\) 时，则第一名选手获胜，而在 \\( n = 4j + 1 \\) 的其他情形下第二名选手获胜。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.727,
                0.89,
                0.779
            ],
            "angle": 0,
            "content": "12. 用强归纳法证明：任意正整数 \\( n \\) 都可以写成 2 的不同幂次之和，即可以写成整数的一个子集 \\( 2^0 = 1 \\)、\\( 2^1 = 2 \\)、\\( 2^2 = 4 \\) 等的和。[提示：对归纳步骤，分别考虑 \\( k + 1 \\) 是偶数和奇数时的情况。当 \\( k + 1 \\) 是偶数时，注意 \\( (k + 1)/2 \\) 是整数。]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.782,
                0.889,
                0.814
            ],
            "angle": 0,
            "content": "13.拼板游戏是将拼板相继拼在一起而形成一块。每一步都将一片拼板拼到块上去或者将两块拼接在一起。用强归纳法证明：无论采用什么样的步骤，要拼成 \\(n\\) 片拼板的一块，都恰好需要 \\(n - 1\\) 步才能完成。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.818,
                0.89,
                0.885
            ],
            "angle": 0,
            "content": "14. 假设从一堆 \\( n \\) 块石头开始，通过连续地把一堆石头分成较小的两堆石头，把开始的这堆石头分成 \\( n \\) 堆，每堆只有 1 块石头。每次分开一堆石头时，就把所分出的较小的两堆石头的数目相乘，即如果分出的这两堆分别有 \\( r \\) 和 \\( s \\) 块石头，则计算出 \\( rs \\) 。证明：无论如何分这些堆，每一步计算出来的乘积之和等于 \\( n(n - 1) / 2 \\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.889,
                0.89,
                0.941
            ],
            "angle": 0,
            "content": "15. 证明：在1.8节例12的蚕食游戏中，如果初始格子是方形，那么第一选手具有一个获胜的策略。[提示：用强归纳法证明下面的策略是有效的。第一步，第一个选手咬掉除了左边和上边以外的所有饼干。在接下来的步骤中，当第二个选手咬掉上边或左边的饼干以后，第一个选手分别在左边或上边"
        },
        {
            "type": "list",
            "bbox": [
                0.047,
                0.526,
                0.89,
                0.941
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.145,
                0.038,
                0.182,
                0.052
            ],
            "angle": 0,
            "content": "304"
        },
        {
            "type": "header",
            "bbox": [
                0.227,
                0.037,
                0.292,
                0.052
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.093,
                0.395,
                0.108
            ],
            "angle": 0,
            "content": "以相同的相对位置咬掉饼干。]"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.111,
                0.965,
                0.161
            ],
            "angle": 0,
            "content": "* 16. 证明：在 1.8 节例 12 的蚕食游戏中，如果初始格子是两个方形，即台子是 \\(2 \\times n\\) 的格子，那么第一选手具有获胜的策略。[提示：用强归纳法证明。第一个选手的第一步应该先咬掉最底层最右端的那块饼干。]"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.164,
                0.964,
                0.197
            ],
            "angle": 0,
            "content": "17. 用强归纳法证明：如果对一个具有4条边的简单多边形进行三角形化，那么三角形化时至少有两个三角形都有两条边是该多边形的外部边界。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.2,
                0.965,
                0.25
            ],
            "angle": 0,
            "content": "* 18. 用强归纳法证明：当把一个具有相邻顶点 \\( v_{1}, v_{2}, \\cdots, v_{n} \\) 的凸多边形 \\( P \\) 三角形化为 \\( n - 2 \\) 个三角形时，这 \\( n - 2 \\) 个三角形可以编号为 1，2，…，\\( n - 2 \\)，使得对 \\( i = 1, 2, \\cdots, n - 2 \\)，都有 \\( v_{i} \\) 是三角形的一个顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.254,
                0.965,
                0.34
            ],
            "angle": 0,
            "content": "* 19. Pick 定理断言：平面上顶点都在格点上（即顶点都具有整数坐标）的简单多边形的面积等于 \\( I(P) + B(P) / 2 - 1 \\)，其中 \\( I(P) \\) 和 \\( B(P) \\) 分别是 \\( P \\) 内和 \\( P \\) 的边界上格点的个数。利用强归纳法证明关于 \\( P \\) 的顶点数来证明 Pick 定理。[提示：关于基础步骤，首先对矩形证明定理成立，然后对直角三角形证明定理成立，最后注意到：一个三角形区域是由包含该三角形在内的一个较大的矩形区域减去至多三个角形区域所得到的结果。关于归纳步骤，利用引理 1 即可。]"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.343,
                0.969,
                0.43
            ],
            "angle": 0,
            "content": "**20. 设 \\(P\\) 是简单多边形，其顶点分别为 \\(v_{1}, v_{2}, \\cdots, v_{n}\\)，相邻顶点之间都有一条边，且 \\(v_{1}\\) 和 \\(v_{n}\\) 之间也有一条边。如果连接 \\(v_{i}\\) 的两个邻接的线段是该简单多边形的一条内部对角线，则称顶点 \\(v_{i}\\) 是一只耳朵。如果具有耳朵 \\(v_{i}\\) 和它的两个邻接顶点所构成的三角形内部与耳朵 \\(v_{j}\\) 和它的两个邻接顶点所构成的三角形内部不相交，则称耳朵 \\(v_{i}\\) 和耳朵 \\(v_{j}\\) 是不重叠的。证明：任何具有至少4个顶点的简单多边形都具有至少两只不重叠的耳朵。"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.432,
                0.969,
                0.484
            ],
            "angle": 0,
            "content": "21. 在引理 1 的证明中曾提到过：关于寻找顶点 \\( p \\)，使得线段 \\( b_{p} \\) 是 \\( P \\) 的一条内部对角线的许多不正确的方法也都得到了发表。该练习给出了一些错误证明中选择 \\( p \\) 的方法。考虑下图所示的两个多边形，证明对如下每种关于 \\( p \\) 的错误选择，线段 \\( b_{p} \\) 不一定是 \\( P \\) 的一条内部对角线。"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.487,
                0.46,
                0.5
            ],
            "angle": 0,
            "content": "a) \\(p\\) 是 \\(P\\) 的满足角 \\(\\angle abp\\) 最小的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.504,
                0.515,
                0.518
            ],
            "angle": 0,
            "content": "b) \\(p\\) 是 \\(P\\) 的具有最小 \\(x\\) 坐标 \\((b\\) 除外)的顶点。"
        },
        {
            "type": "text",
            "bbox": [
                0.152,
                0.522,
                0.424,
                0.536
            ],
            "angle": 0,
            "content": "c) \\(p\\) 是 \\(P\\) 的与 \\(b\\) 距离最近的顶点。"
        },
        {
            "type": "list",
            "bbox": [
                0.151,
                0.487,
                0.515,
                0.536
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.298,
                0.555,
                0.543,
                0.741
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.572,
                0.559,
                0.796,
                0.74
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.76,
                0.714,
                0.774
            ],
            "angle": 0,
            "content": "练习22和23给出了归纳载入可用于证明计算几何学中一些结论的例子。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.778,
                0.971,
                0.811
            ],
            "angle": 0,
            "content": "* 22. 设 \\( P(n) \\) 是命题：当不相交的对角线画于具有 \\( n \\) 条边的凸多边形内部时，多边形中至少有两个顶点不是这些对角线的端点。"
        },
        {
            "type": "text",
            "bbox": [
                0.154,
                0.814,
                0.918,
                0.828
            ],
            "angle": 0,
            "content": "a) 证明：当利用强归纳法对所有大于等于3的整数 \\(n\\) 证明 \\(P(n)\\) 为真时，归纳步骤是行不通的。"
        },
        {
            "type": "text",
            "bbox": [
                0.155,
                0.832,
                0.97,
                0.881
            ],
            "angle": 0,
            "content": "b) 证明：可以用强归纳法证明更强的断言：对 \\(n \\geqslant 4\\)，\\(Q(n)\\) 为真。其中 \\(Q(n)\\) 是命题：当不相交的对角线画于具有 \\(n\\) 条边的凸多边形内部时，至少有两个不相邻的顶点不是这些对角线的端点。从而也就证明了 \\(P(n)\\) 为真。"
        },
        {
            "type": "list",
            "bbox": [
                0.154,
                0.814,
                0.97,
                0.881
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.885,
                0.971,
                0.917
            ],
            "angle": 0,
            "content": "23. 设 \\(E(n)\\) 是命题：对具有 \\(n\\) 条边的简单多边形三角化，这些三角形中至少有一个三角形的两条边都是多边形的外部边界。"
        },
        {
            "type": "text",
            "bbox": [
                0.156,
                0.921,
                0.901,
                0.936
            ],
            "angle": 0,
            "content": "a)解释当使用强归纳法证明对所有大于等于4的整数 \\(n\\) 证明 \\(E(n)\\) 为真时，会陷入困难境地。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.68,
                0.038,
                0.792,
                0.052
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.837,
                0.038,
                0.872,
                0.052
            ],
            "angle": 0,
            "content": "305"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.093,
                0.902,
                0.126
            ],
            "angle": 0,
            "content": "b)证明可以用强归纳法证明更强的断言：对所有 \\(n\\geq 4\\) ， \\(T(n)\\) 为真。其中 \\(T(n)\\) 是命题：对简单多边形的任何三角化，这些三角形中至少有两个三角形的两条边都是多边形的外部边界。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.129,
                0.903,
                0.179
            ],
            "angle": 0,
            "content": "* 24. 在3.1节练习60的说明中定义的稳定指派称为一个最佳配对，如果不存在这样的稳定指派：一个求婚者与一个他喜欢的被追求者配成了一对。用强归纳法证明：延期接纳算法对求婚者将产生一个最佳稳定指派。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.182,
                0.77,
                0.197
            ],
            "angle": 0,
            "content": "25. 设 \\(P(n)\\) 是命题函数。确定对哪些正整数 \\(n\\)，命题 \\(P(n)\\) 必为真，验证你的答案，如果"
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.2,
                0.66,
                0.214
            ],
            "angle": 0,
            "content": "a) \\(P(1)\\) 为真；对所有的正整数 \\(n\\) ，如果 \\(P(\\overline{n})\\) 为真，那么 \\(P(n + 2)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.218,
                0.816,
                0.232
            ],
            "angle": 0,
            "content": "b) \\(P(1)\\) 和 \\(P(2)\\) 为真；对所有的正整数 \\(n\\) ，如果 \\(P(n)\\) 和 \\(P(n + 1)\\) 为真，那么 \\(P(n + 2)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.236,
                0.641,
                0.249
            ],
            "angle": 0,
            "content": "c) \\(P(1)\\) 为真；对所有的正整数 \\(n\\) ，如果 \\(P(n)\\) 为真，那么 \\(P(2n)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.254,
                0.661,
                0.268
            ],
            "angle": 0,
            "content": "d) \\(P(1)\\) 为真；对所有的正整数 \\(n\\) ，如果 \\(P(n)\\) 为真，那么 \\(P(n + 1)\\) 为真。"
        },
        {
            "type": "list",
            "bbox": [
                0.084,
                0.2,
                0.816,
                0.268
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.271,
                0.66,
                0.286
            ],
            "angle": 0,
            "content": "26. 设 \\(P(n)\\) 是命题函数。确定对哪些非负整数 \\(n\\)，命题 \\(P(n)\\) 必为真，如果"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.289,
                0.679,
                0.303
            ],
            "angle": 0,
            "content": "a) \\(P(0)\\) 为真；对所有的非负整数 \\(n\\) ，如果 \\(P(n)\\) 为真，那么 \\(P(n + 2)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.307,
                0.68,
                0.321
            ],
            "angle": 0,
            "content": "b) \\(P(0)\\) 为真；对所有的非负整数 \\(n\\) ，如果 \\(P(n)\\) 为真，那么 \\(P(n + 3)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.324,
                0.833,
                0.339
            ],
            "angle": 0,
            "content": "c) \\(P(0)\\) 和 \\(P(1)\\) 为真；对所有的非负整数 \\(n\\) ，如果 \\(P(n)\\) 和 \\(P(n + 1)\\) 为真，那么 \\(P(n + 2)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.342,
                0.772,
                0.356
            ],
            "angle": 0,
            "content": "d) \\(P(0)\\) 为真；对所有的非负整数 \\(n\\) ，如果 \\(P(n)\\) 为真，那么 \\(P(n + 2)\\) 和 \\(P(n + 3)\\) 为真。"
        },
        {
            "type": "list",
            "bbox": [
                0.085,
                0.289,
                0.833,
                0.356
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.359,
                0.903,
                0.392
            ],
            "angle": 0,
            "content": "27. 证明如果命题：对无限多的正整数 \\( nP(n) \\) 为真，且对所有正整数 \\( nP(n + 1) \\rightarrow P(n) \\) 为真，那么，对所有正整数 \\( nP(n) \\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.395,
                0.905,
                0.446
            ],
            "angle": 0,
            "content": "28. 设 \\(b\\) 是一个固定的整数，\\(j\\) 是一个固定的正整数。证明：如果对所有正整数 \\(k \\geqslant b + j\\)，都有 \\(P(b)\\)，\\(P(b + 1)\\)，…，\\(P(b + j)\\) 为真，且 \\([P(b) \\wedge P(b + 1) \\wedge \\dots \\wedge P(k)] \\rightarrow P(k + 1)\\) 为真（\\(k \\geqslant b + j\\)），则对所 \\(n \\geqslant b\\) 的整数 \\(n\\)，\\(P(n)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.449,
                0.399,
                0.463
            ],
            "angle": 0,
            "content": "29. 下面强归纳法的“证明”有什么错误？"
        },
        {
            "type": "list",
            "bbox": [
                0.055,
                0.395,
                0.905,
                0.463
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.466,
                0.443,
                0.481
            ],
            "angle": 0,
            "content": "“定理”：对所有非负整数 \\(n\\) ，都有 \\(5 \\times n = 0\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.484,
                0.258,
                0.498
            ],
            "angle": 0,
            "content": "基础步骤： \\(5\\cdot 0 = 0\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.501,
                0.905,
                0.534
            ],
            "angle": 0,
            "content": "归纳步骤：假设对所有满足 \\(0 \\leqslant j \\leqslant k\\) 的非负整数 \\(j\\)，都有 \\(5j = 0\\)。设 \\(k + 1 = i + j\\)，其中 \\(i, j\\) 都是小于 \\(k + 1\\) 的自然数。根据归纳假设有 \\(5(k + 1) = 5(i + j) = 5i + 5j = 0 + 0 = 0\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.537,
                0.721,
                0.552
            ],
            "angle": 0,
            "content": "* 30. 找出下列“证明”的错误：当 \\(a\\) 是非零实数时，对所有非负整数 \\(n\\) ，有 \\(a^n = 1\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.554,
                0.419,
                0.569
            ],
            "angle": 0,
            "content": "基础步骤：根据 \\(a^0\\) 的定义， \\(a^0 = 1\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.572,
                0.578,
                0.587
            ],
            "angle": 0,
            "content": "归纳步骤：假定对满足 \\(j \\leqslant k\\) 的所有非负整数 \\(j\\) 来说，\\(a^j = 1\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.59,
                0.132,
                0.604
            ],
            "angle": 0,
            "content": "注意"
        },
        {
            "type": "equation",
            "bbox": [
                0.371,
                0.607,
                0.593,
                0.635
            ],
            "angle": 0,
            "content": "\\[\na ^ {k + 1} = \\frac {a ^ {k} \\cdot a ^ {k}}{a ^ {k - 1}} = \\frac {1 \\cdot 1}{1} = 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.639,
                0.679,
                0.655
            ],
            "angle": 0,
            "content": "* 31. 通过证明从良序性公理得出强归纳法来证明强归纳法是有效的证明方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.657,
                0.845,
                0.672
            ],
            "angle": 0,
            "content": "32.找出下面“证明”中的瑕疵：任意大于等于3分的邮资都可以只用3分和4分的邮票来构成。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.675,
                0.884,
                0.69
            ],
            "angle": 0,
            "content": "基础步骤：可以只用一张3分的邮票来构成3分的邮资，只用一张4分的邮票来构成4分的邮资。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.693,
                0.908,
                0.743
            ],
            "angle": 0,
            "content": "归纳步骤：假设对所有满足 \\(j \\leqslant k\\) 的非负整数 \\(j\\)，只用3分和4分的邮票就能构成 \\(j\\) 分的邮资。那么就可以通过用一张4分的邮票代替一张3分的邮票，或通过用三张3分的邮票代替两张4分的邮票来构成 \\(k + 1\\) 分的邮资。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.746,
                0.816,
                0.761
            ],
            "angle": 0,
            "content": "33. 证明：如果能够证明如下命题，那么就可以证明：对所有的正整数 \\(n\\) 和 \\(k\\) ，\\(P(n, k)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.764,
                0.794,
                0.779
            ],
            "angle": 0,
            "content": "a) \\(P(1, 1)\\) 为真，且对所有的正整数 \\(n\\) 和 \\(k\\) ，\\(P(n, k) \\rightarrow [P(n + 1, k) \\wedge P(n, k + 1)]\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.782,
                0.845,
                0.796
            ],
            "angle": 0,
            "content": "b)对所有的正整数 \\(k\\) ， \\(P(1,k)\\) 为真，且对所有的正整数 \\(n\\) 和 \\(k\\) ， \\(P(n,k)\\rightarrow P(n + 1,k)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.8,
                0.844,
                0.814
            ],
            "angle": 0,
            "content": "c)对所有的正整数 \\(n\\) ， \\(P(n\\) ，1)为真，且对所有的正整数 \\(n\\) 和 \\(k\\) ， \\(P(n,k)\\rightarrow P(n,k + 1)\\) 为真。"
        },
        {
            "type": "list",
            "bbox": [
                0.089,
                0.764,
                0.845,
                0.814
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.818,
                0.34,
                0.832
            ],
            "angle": 0,
            "content": "34. 证明：对所有的正整数 \\(n\\) 和 \\(k\\)"
        },
        {
            "type": "equation",
            "bbox": [
                0.216,
                0.836,
                0.786,
                0.868
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {j = 1} ^ {n} j (j + 1) (j + 2) \\dots (j + k - 1) = n (n + 1) (n + 2) \\dots (n + k) / (k + 1)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.869,
                0.357,
                0.884
            ],
            "angle": 0,
            "content": "[提示：利用练习33中的技巧。]"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.888,
                0.911,
                0.92
            ],
            "angle": 0,
            "content": "* 35. 证明：若 \\(a_1, a_2, \\cdots, a_n\\) 是 \\(n\\) 个不同的实数，则无论在它们的乘积中插入多少对括号，计算这 \\(n\\) 个数之积都要使用 \\(n - 1\\) 次乘法。[提示：利用强归纳法并且考虑最后一次的乘法。]"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.923,
                0.912,
                0.939
            ],
            "angle": 0,
            "content": "* 36. 良序性可以用来证明：两个正整数有唯一的最大公因子。设 \\( a \\) 和 \\( b \\) 都是正整数，设 \\( S \\) 是形如 \\( as + bt \\)"
        },
        {
            "type": "list",
            "bbox": [
                0.049,
                0.888,
                0.912,
                0.939
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.134,
                0.04,
                0.172,
                0.054
            ],
            "angle": 0,
            "content": "306"
        },
        {
            "type": "header",
            "bbox": [
                0.216,
                0.039,
                0.282,
                0.054
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.095,
                0.478,
                0.11
            ],
            "angle": 0,
            "content": "的正整数的集合，其中 \\(s\\) 和 \\(t\\) 都是正整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.114,
                0.276,
                0.126
            ],
            "angle": 0,
            "content": "a)证明：S非空。"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.131,
                0.4,
                0.144
            ],
            "angle": 0,
            "content": "b)用良序性证明： \\(S\\) 有最小元 \\(c\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.149,
                0.556,
                0.162
            ],
            "angle": 0,
            "content": "c) 证明：若 \\(d\\) 是 \\(a\\) 和 \\(b\\) 的公因子，则 \\(d\\) 是 \\(c\\) 的因子。"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.167,
                0.951,
                0.2
            ],
            "angle": 0,
            "content": "d) 证明: \\(c \\mid a\\) 和 \\(c \\mid b\\). [提示: 首先假定 \\(c \\nmid a\\). 则 \\(a = qc + r\\), 其中 \\(0 < r < c\\). 证明 \\(r \\in S\\), 这与对 \\(c\\) 的选择相矛盾.]"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.205,
                0.921,
                0.218
            ],
            "angle": 0,
            "content": "e)从c)和d)得出： \\(a\\) 和 \\(b\\) 的最大公因子存在。通过证明两个正整数的最大公因子是唯一的来完成证明。"
        },
        {
            "type": "list",
            "bbox": [
                0.135,
                0.114,
                0.951,
                0.218
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.223,
                0.954,
                0.256
            ],
            "angle": 0,
            "content": "37. 设 \\(a\\) 是一个整数，\\(d\\) 是一个正整数。证明：满足 \\(a = dq + r\\) 及 \\(0 \\leqslant r < d\\) 的整数 \\(q\\) 和 \\(r\\) 是唯一的。\\(q\\) 和 \\(r\\) 的存在性已在例5中证明过了。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.259,
                0.946,
                0.272
            ],
            "angle": 0,
            "content": "38. 用数学归纳法证明：具有偶数个格子且去掉了一个黑格和一个白格的矩形棋盘可用多米诺骨牌覆盖。"
        },
        {
            "type": "text",
            "bbox": [
                0.077,
                0.277,
                0.952,
                0.327
            ],
            "angle": 0,
            "content": "**39. 你能用良序性证明下面的命题吗？“每一个正整数都可以用不超过15个英语单词来描述”。假定这些词取自某个特定的英语词典。[提示：假如存在正整数，它们不能用不超过15个英语单词来描述。那么，根据良序性公理，不能用不超过15个英语单词来描述的最小整数是存在的。]"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.331,
                0.951,
                0.38
            ],
            "angle": 0,
            "content": "40. 用良序性证明：若 \\(x\\) 和 \\(y\\) 是满足 \\(x < y\\) 的实数，则存在有理数 \\(r\\) 满足 \\(x < r < y\\)。[提示：证明存在正整数 \\(A\\) 满足 \\(A > 1 / (y - x)\\)。然后通过考虑数 \\(\\lfloor x \\rfloor + j / A\\)，其中 \\(j\\) 是正整数，来证明存在有理数 \\(r\\) 具有介于 \\(x\\) 和 \\(y\\) 之间的分母 \\(A\\)。]"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.385,
                0.687,
                0.398
            ],
            "angle": 0,
            "content": "* 41. 证明：如果把数学归纳法原理作为公理，那么良序性是可以证明的。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.402,
                0.927,
                0.417
            ],
            "angle": 0,
            "content": "* 42. 证明：数学归纳法原理与强归纳法是等价的，即每一个的有效性都可利用另一个的有效性来证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.421,
                0.951,
                0.453
            ],
            "angle": 0,
            "content": "* 43. 证明：如果我们不把良序性作为公理，而是把数学归纳法原理或强归纳法作为公理，那么良序性是可以证明的。"
        },
        {
            "type": "list",
            "bbox": [
                0.088,
                0.385,
                0.951,
                0.453
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.102,
                0.469,
                0.44,
                0.487
            ],
            "angle": 0,
            "content": "5.3 递归定义与结构归纳法"
        },
        {
            "type": "title",
            "bbox": [
                0.102,
                0.496,
                0.232,
                0.512
            ],
            "angle": 0,
            "content": "5.3.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.516,
                0.951,
                0.57
            ],
            "angle": 0,
            "content": "有时难以用明确的方式来定义一个对象。不过，用这个对象来定义它自身，这也许是容易的。这种过程称为递归。例如，图1所示的图画是递归产生的。首先，给出一幅原图。然后实现在前一幅图画的中央递归地放上更小的图画这样一个过程。"
        },
        {
            "type": "image",
            "bbox": [
                0.192,
                0.573,
                0.866,
                0.904
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.434,
                0.914,
                0.62,
                0.928
            ],
            "angle": 0,
            "content": "图1 递归定义的图画"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.679,
                0.039,
                0.789,
                0.053
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.836,
                0.04,
                0.871,
                0.053
            ],
            "angle": 0,
            "content": "307"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.095,
                0.901,
                0.187
            ],
            "angle": 0,
            "content": "可以用递归来定义序列、函数和集合。在前面的讨论里，用显式的公式来规定序列里的项。例如，用“对 \\(n = 0,1,2,\\dots\\) 来说， \\(a_{n} = 2^{n}\\) ”来给出2的幂的序列。不过，通过给出这个序列的第一项，即 \\(a_0 = 1\\) ，以及从该序列前面的项来求出当前项的公式，即对 \\(n = 0,1,2,\\dots\\) 来说 \\(a_{n + 1} = 2a_n\\) ，也可以定义这个序列。当通过规定如何从前面的各项求出序列各项来递归地定义序列时，可以用归纳法来证明关于这个序列的结果。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.189,
                0.901,
                0.244
            ],
            "angle": 0,
            "content": "当递归地定义集合时，在基础步骤里规定一些初始元素，并且在递归步骤里提供一条规则，从已有的那些元素来构造新的元素。为了证明关于递归定义的集合的结果，使用所谓的结构归纳法。"
        },
        {
            "type": "title",
            "bbox": [
                0.053,
                0.254,
                0.291,
                0.272
            ],
            "angle": 0,
            "content": "5.3.2 递归地定义函数"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.275,
                0.66,
                0.29
            ],
            "angle": 0,
            "content": "为了定义以非负整数集合作为其定义域的函数，使用两个步骤："
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.294,
                0.434,
                0.309
            ],
            "angle": 0,
            "content": "基础步骤：规定这个函数在0处的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.313,
                0.641,
                0.329
            ],
            "angle": 0,
            "content": "递归步骤：给出从较小的整数处的值来求出当前的值的规则。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.331,
                0.899,
                0.386
            ],
            "angle": 0,
            "content": "这样的定义称为递归定义或归纳定义。注意一个从非负整数集合到实数集合的函数 \\( f(n) \\) 就是一个序列 \\( a_0, a_1, \\dots \\)，其中 \\( a_i \\) 是一个实数，\\( i \\) 是非负整数。所以，2.4节中采用递推关系定义一个实数序列 \\( a_0, a_1, \\dots \\) 就是定义一个从非负整数集合到实数集合的函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.39,
                0.252,
                0.407
            ],
            "angle": 0,
            "content": "例1 假定 \\(f\\) 是用"
        },
        {
            "type": "equation",
            "bbox": [
                0.377,
                0.414,
                0.573,
                0.447
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} f (0) = 3 \\\\ f (n + 1) = 2 f (n) + 3 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.45,
                0.489,
                0.467
            ],
            "angle": 0,
            "content": "来递归定义的。求出 \\( f(1) \\) 、 \\( f(2) \\) 、 \\( f(3) \\) 和 \\( f(4) \\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.469,
                0.32,
                0.485
            ],
            "angle": 0,
            "content": "解 从这个递归定义得出"
        },
        {
            "type": "equation",
            "bbox": [
                0.313,
                0.49,
                0.636,
                0.56
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} f (1) = 2 f (0) + 3 = 2 \\cdot 3 + 3 = 9 \\\\ f (2) = 2 f (1) + 3 = 2 \\cdot 9 + 3 = 2 1 \\\\ f (3) = 2 f (2) + 3 = 2 \\cdot 2 1 + 3 = 4 5 \\\\ f (4) = 2 f (3) + 3 = 2 \\cdot 4 5 + 3 = 9 3 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.564,
                0.899,
                0.638
            ],
            "angle": 0,
            "content": "递归定义的函数是良定义的。即对于每一个正整数，函数对应取值是清楚定义的。这意味着给定任意整数，我们可以使用定义的这两个部分得到对应整数的函数值，无论怎么使用这两部分定义都会得到同样的值。这是数学归纳法原理的一个结果（见本节练习56）。在下面的例2和例3中给出递归定义的其他例子。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.643,
                0.657,
                0.66
            ],
            "angle": 0,
            "content": "例2 给出 \\(a^n\\) 的递归定义，其中 \\(a\\) 是非零实数且 \\(n\\) 是非负整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.664,
                0.899,
                0.701
            ],
            "angle": 0,
            "content": "解 这个递归定义包括两个部分。首先规定 \\(a^0\\) ，即 \\(a^0 = 1\\) 。然后给出从 \\(a^n\\) 求出 \\(a^{n + 1}\\) 的规则，即对 \\(n = 0, 1, 2, 3, \\dots, a^{n + 1} = a \\cdot a^n\\) 。这两个等式对所有非负整数唯一地定义了 \\(a^n\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.704,
                0.362,
                0.736
            ],
            "angle": 0,
            "content": "例3 给出 \\(\\sum_{k=0}^{n} a_{k}\\) 的递归定义。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.738,
                0.382,
                0.754
            ],
            "angle": 0,
            "content": "解 这个递归定义的第一部分是"
        },
        {
            "type": "equation",
            "bbox": [
                0.424,
                0.758,
                0.524,
                0.792
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {k = 0} ^ {0} a _ {k} = a _ {0}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.793,
                0.154,
                0.809
            ],
            "angle": 0,
            "content": "第二部分是"
        },
        {
            "type": "equation",
            "bbox": [
                0.364,
                0.813,
                0.583,
                0.846
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {k = 0} ^ {n + 1} a _ {k} = \\left(\\sum_ {k = 0} ^ {n} a _ {k}\\right) + a _ {n + 1}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.848,
                0.898,
                0.902
            ],
            "angle": 0,
            "content": "在函数的某些递归定义中，规定了函数在前 \\(k\\) 个正整数处的值，而且给出了从一个较大的整数之前的部分或全部 \\(k\\) 个整数处的函数值来确定在该整数处的函数值的规则。从强归纳法可以得出，这样的递归定义的函数是良定义的函数（见本节练习57）。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.904,
                0.72,
                0.922
            ],
            "angle": 0,
            "content": "回忆2.4节斐波那契数 \\( f_{0} \\)，\\( f_{1} \\)，\\( f_{2} \\)，…，是用方程组 \\( f_{0} = 0 \\)，\\( f_{1} = 1 \\) 和"
        },
        {
            "type": "equation",
            "bbox": [
                0.399,
                0.925,
                0.543,
                0.941
            ],
            "angle": 0,
            "content": "\\[\nf _ {n} = f _ {n - 1} + f _ {n - 2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.911,
                0.39,
                0.972,
                0.407
            ],
            "angle": 0,
            "content": "Extra Examples"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.139,
                0.038,
                0.175,
                0.051
            ],
            "angle": 0,
            "content": "308"
        },
        {
            "type": "header",
            "bbox": [
                0.22,
                0.036,
                0.286,
                0.052
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.093,
                0.955,
                0.128
            ],
            "angle": 0,
            "content": "来定义的，其中 \\(n = 2,3,4,\\dots\\) 。[我们认为斐波那契数 \\(f_{n}\\) 或者是序列 \\(f_0,f_1,\\dots\\) 的第 \\(_n\\) 项或者是函数 \\(f(n)\\) 在 \\(n\\) 时的取值。]"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.131,
                0.943,
                0.148
            ],
            "angle": 0,
            "content": "可以用斐波那契数的递归定义来证明这些数的许多性质。在例4里给出一个这样的性质。"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.152,
                0.682,
                0.17
            ],
            "angle": 0,
            "content": "例4 证明：当 \\(n \\geqslant 3\\) 时，有 \\(f_{n} > \\alpha^{n - 2}\\)，其中 \\(\\alpha = (1 + \\sqrt{5}) / 2\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.174,
                0.957,
                0.21
            ],
            "angle": 0,
            "content": "解可以用强归纳法来证明这个不等式。设 \\(P(n)\\) 是命题： \\(f_{n} > \\alpha^{n - 2}\\) 。想要证明的是当 \\(n\\) 是大于或等于3的整数时，有 \\(P(n)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.152,
                0.213,
                0.363,
                0.229
            ],
            "angle": 0,
            "content": "基础步骤：首先，由于"
        },
        {
            "type": "equation",
            "bbox": [
                0.348,
                0.234,
                0.721,
                0.252
            ],
            "angle": 0,
            "content": "\\[\n\\alpha <   2 = f _ {3}, \\quad \\alpha^ {2} = (3 + \\sqrt {5}) / 2 <   3 = f _ {4}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.254,
                0.349,
                0.27
            ],
            "angle": 0,
            "content": "所以 \\(P(3)\\) 和 \\(P(4)\\) 都为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.273,
                0.957,
                0.327
            ],
            "angle": 0,
            "content": "归纳步骤：现在假定 \\(P(j)\\) 为真，即对所有满足 \\(3 \\leqslant j \\leqslant k\\) 的整数 \\(j\\) 来说有 \\(f_{j} > \\alpha^{j-2}\\)，其中 \\(k \\geqslant 4\\)。必须证明 \\(P(k+1)\\) 为真，即 \\(f_{k+1} > \\alpha^{k-1}\\)。因为 \\(\\alpha\\) 是 \\(x^{2}-x-1=0\\) 的解（二次方程求根公式说明这一点），所以得出 \\(\\alpha^{2}=\\alpha+1\\)。因此，"
        },
        {
            "type": "equation",
            "bbox": [
                0.274,
                0.329,
                0.796,
                0.346
            ],
            "angle": 0,
            "content": "\\[\n\\alpha^ {k - 1} = \\alpha^ {2} \\cdot \\alpha^ {k - 3} = (\\alpha + 1) \\alpha^ {k - 3} = \\alpha \\cdot \\alpha^ {k - 3} + 1 \\cdot \\alpha^ {k - 3} = \\alpha^ {k - 2} + \\alpha^ {k - 3}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.348,
                0.451,
                0.365
            ],
            "angle": 0,
            "content": "根据归纳假设，因为 \\(k \\geqslant 4\\) ，所以得出"
        },
        {
            "type": "equation",
            "bbox": [
                0.442,
                0.367,
                0.632,
                0.385
            ],
            "angle": 0,
            "content": "\\[\nf _ {k - 1} > \\alpha^ {k - 3}, f _ {k} > \\alpha^ {k - 2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.386,
                0.199,
                0.403
            ],
            "angle": 0,
            "content": "因此就有"
        },
        {
            "type": "equation",
            "bbox": [
                0.387,
                0.405,
                0.687,
                0.422
            ],
            "angle": 0,
            "content": "\\[\nf _ {k + 1} = f _ {k} + f _ {k - 1} > \\alpha^ {k - 2} + \\alpha^ {k - 3} = \\alpha^ {k - 1}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.424,
                0.392,
                0.44
            ],
            "angle": 0,
            "content": "由此得出 \\(P(k + 1)\\) 为真，证毕。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.443,
                0.955,
                0.478
            ],
            "angle": 0,
            "content": "评注 归纳步骤证明了当 \\(k \\geqslant 4\\) 时，从对 \\(3 \\leqslant j \\leqslant k\\) 来说 \\(P(j)\\) 为真的假定就可以得出 \\(P(k + 1)\\) 。因此，归纳步骤没有证明 \\(P(3) \\rightarrow P(4)\\) 。因此，不得不单独证明 \\(P(4)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.481,
                0.957,
                0.516
            ],
            "angle": 0,
            "content": "现在可以证明：欧几里得算法用 \\(O(\\log b)\\) 次除法来求出正整数 \\(a\\) 和 \\(b\\) 的最大公因子，其中 \\(a \\geqslant b\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.525,
                0.951,
                0.561
            ],
            "angle": 0,
            "content": "定理1 拉梅定理 设 \\(a\\) 和 \\(b\\) 是满足 \\(a \\geq b\\) 的正整数。则欧几里得算法为了求出 \\(\\gcd(a, b)\\) 而使用的除法的次数小于或等于 \\(b\\) 的十进制位数的5倍。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.57,
                0.959,
                0.605
            ],
            "angle": 0,
            "content": "证明 回忆一下，当用欧几里得算法求满足 \\(a \\geqslant b\\) 的 \\(\\gcd(a, b)\\) 时，得出了下面的等式序列（其中 \\(a = r_0, b = r_1\\)）。"
        },
        {
            "type": "equation",
            "bbox": [
                0.397,
                0.611,
                0.681,
                0.624
            ],
            "angle": 0,
            "content": "\\[\nr _ {0} = r _ {1} q _ {1} + r _ {2} \\quad 0 \\leqslant r _ {2} <   r _ {1}\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.398,
                0.631,
                0.682,
                0.643
            ],
            "angle": 0,
            "content": "\\[\nr _ {1} = r _ {2} q _ {2} + r _ {3} \\quad 0 \\leqslant r _ {3} <   r _ {2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.42,
                0.651,
                0.428,
                0.661
            ],
            "angle": 0,
            "content": "中"
        },
        {
            "type": "equation",
            "bbox": [
                0.383,
                0.67,
                0.699,
                0.702
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} r _ {n - 2} \\cong r _ {n - 1} q _ {n - 1} + r _ {n} \\quad 0 \\leqslant r _ {n} <   r _ {n - 1} \\\\ r _ {n - 1} = r _ {n} q _ {n} \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.705,
                0.962,
                0.74
            ],
            "angle": 0,
            "content": "这里为了求 \\(r_n = \\gcd (a,b)\\) 而使用了 \\(n\\) 次除法。注意商 \\(q_{1}\\)，\\(q_{2}\\)，…，\\(q_{n - 1}\\) 都至少是1。另外，\\(q_{n} \\geqslant 2\\)，因为 \\(r_n < r_{n - 1}\\)。这就蕴含着"
        },
        {
            "type": "equation",
            "bbox": [
                0.387,
                0.745,
                0.489,
                0.758
            ],
            "angle": 0,
            "content": "\\[\nr _ {n} \\geqslant 1 = f _ {2}\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.373,
                0.765,
                0.566,
                0.777
            ],
            "angle": 0,
            "content": "\\[\nr _ {n - 1} \\geqslant 2 r _ {n} \\geqslant 2 f _ {2} = f _ {3}\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.373,
                0.785,
                0.648,
                0.798
            ],
            "angle": 0,
            "content": "\\[\nr _ {n - 2} \\geqslant r _ {n - 1} + r _ {n} \\geqslant f _ {3} + f _ {2} = f _ {4}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.411,
                0.804,
                0.419,
                0.816
            ],
            "angle": 0,
            "content": "中"
        },
        {
            "type": "equation",
            "bbox": [
                0.388,
                0.824,
                0.711,
                0.855
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} r _ {2} \\geqslant r _ {3} + r _ {4} \\geqslant f _ {n - 1} + f _ {n - 2} = f _ {n} \\\\ b = r _ {1} \\geqslant r _ {2} + r _ {3} \\geqslant f _ {n} + f _ {n - 1} = f _ {n + 1} \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.859,
                0.965,
                0.916
            ],
            "angle": 0,
            "content": "由此得出，若欧几里得算法为了求出满足 \\(a \\geq b\\) 的 \\(\\gcd(a, b)\\) 而使用了 \\(n\\) 次除法，则 \\(b \\geq f_{n+1}\\) 。从例4中知道，对 \\(n > 2\\) 来说 \\(f_{n+1} > \\alpha^{n-1}\\)，其中 \\(\\alpha = (1 + \\sqrt{5}) / 2\\) 。因此得出 \\(b > \\alpha^{n-1}\\) 。另外，因为 \\(\\log_{10} \\alpha \\approx 0.208 > 1 / 5\\)，所以可以看出"
        },
        {
            "type": "equation",
            "bbox": [
                0.399,
                0.92,
                0.687,
                0.936
            ],
            "angle": 0,
            "content": "\\[\n\\log_ {1 0} b > (n - 1) \\log_ {1 0} \\alpha > (n - 1) / 5\n\\]"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.663,
                0.043,
                0.772,
                0.058
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.82,
                0.045,
                0.856,
                0.057
            ],
            "angle": 0,
            "content": "309"
        },
        {
            "type": "text",
            "bbox": [
                0.037,
                0.099,
                0.888,
                0.135
            ],
            "angle": 0,
            "content": "因此，\\(n - 1 < 5 \\cdot \\log_{10} b\\)。现在假定 \\(b\\) 有 \\(k\\) 个十进制位。则 \\(b < 10^k\\) 且 \\(\\log_{10} b < k\\)。由此得出 \\(n - 1 < 5k\\)，而且因为 \\(k\\) 是整数，所以得出 \\(n \\leqslant 5k\\)。证毕。"
        },
        {
            "type": "text",
            "bbox": [
                0.037,
                0.137,
                0.888,
                0.192
            ],
            "angle": 0,
            "content": "因为 \\(b\\) 的十进制位数等于 \\(\\lfloor \\log_{10}b\\rfloor +1\\) ，它小于或等于 \\(\\log_{10}b + 1\\) ，所以定理1说求出满足 \\(a > b\\) 的 \\(\\gcd (a,b)\\) 所需要的除法次数小于或等于 \\(5(\\log_{10}b + 1)\\) 。因为 \\(5(\\log_{10}b + 1)\\) 是 \\(O(\\log b)\\) ，所以可以看出当 \\(a > b\\) 时，欧几里得算法就用 \\(O(\\log b)\\) 次除法来求出 \\(\\gcd (a,b)\\) 。"
        },
        {
            "type": "title",
            "bbox": [
                0.038,
                0.202,
                0.346,
                0.219
            ],
            "angle": 0,
            "content": "5.3.3 递归地定义集合与结构"
        },
        {
            "type": "text",
            "bbox": [
                0.038,
                0.222,
                0.89,
                0.372
            ],
            "angle": 0,
            "content": "前面探讨了如何递归地定义函数。现在把注意力转移到如何递归地定义集合。正如在函数的递归定义中那样，集合的递归定义有两个部分：基础步骤和递归步骤。在基础步骤中，规定初始的一些元素。在递归步骤中，给出用来从已知属于集合的元素来构造集合的新元素的规则。递归定义也可以包含一条排斥规则，这条规则规定，递归定义的集合仅仅包含基础步骤所规定的以及递归步骤的应用所生成的那些元素。在本书的讨论中，将总是默认排斥规则成立，因而任何元素都不属于递归定义的集合，除非这个元素属于基础步骤所规定的初始的一些元素，或者是可以一次或多次使用递归步骤来生成的。稍后将介绍如何用所谓的结构归纳法技术来证明关于递归定义的集合的结果。"
        },
        {
            "type": "text",
            "bbox": [
                0.04,
                0.374,
                0.889,
                0.411
            ],
            "angle": 0,
            "content": "例5、例6、例8和例9解释集合的递归定义。在每个例子中，都说明递归步骤的头几次应用所生成的那些元素。"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.415,
                0.453,
                0.432
            ],
            "angle": 0,
            "content": "例5 考虑如下定义的整数集合的子集 \\(S\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.438,
                0.242,
                0.453
            ],
            "angle": 0,
            "content": "基础步骤： \\(3\\in S\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.457,
                0.465,
                0.473
            ],
            "angle": 0,
            "content": "递归步骤：若 \\(x \\in S\\) 且 \\(y \\in S\\)，则 \\(x + y \\in S\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.476,
                0.89,
                0.51
            ],
            "angle": 0,
            "content": "基础步骤中求出的 \\(S\\) 中的新元素是3，递归步骤的首次应用求出的是 \\(3 + 3 = 6\\) ，递归步骤的第二次应用求出的是 \\(3 + 6 = 6 + 3 = 9\\) 以及 \\(6 + 6 = 12\\) ，等等。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.513,
                0.89,
                0.567
            ],
            "angle": 0,
            "content": "在对字符串的研究中，递归定义起着重要作用（例如，参见第13章对形式语言的介绍）。在2.4节中，字母表 \\(\\Sigma\\) 上的字符串是 \\(\\Sigma\\) 里符号的有穷序列。定义1说明可以递归地定义 \\(\\Sigma\\) 上的字符串的集合 \\(\\Sigma^{*}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.577,
                0.586,
                0.593
            ],
            "angle": 0,
            "content": "定义1 字母表 \\(\\Sigma\\) 上的字符串的集合 \\(\\Sigma^{*}\\) 递归地定义为："
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.597,
                0.571,
                0.613
            ],
            "angle": 0,
            "content": "基础步骤： \\(\\lambda \\in \\Sigma^{*}\\) （其中 \\(\\lambda\\) 是不包含任何符号的空串）。"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.617,
                0.512,
                0.633
            ],
            "angle": 0,
            "content": "递归步骤：若 \\(w \\in \\Sigma^{*}\\) 且 \\(x \\in \\Sigma\\) 时，则 \\(wx \\in \\Sigma^{*}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.642,
                0.89,
                0.696
            ],
            "angle": 0,
            "content": "字符串的递归定义的基础步骤说空串属于 \\(\\Sigma^{*}\\) 。递归步骤说把 \\(\\Sigma\\) 的符号添加到 \\(\\Sigma^{*}\\) 的字符串结尾后面就生成新的字符串。在递归步骤的每次应用中，都生成包含一个更多符号的字符串。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.701,
                0.89,
                0.759
            ],
            "angle": 0,
            "content": "例6 若 \\(\\Sigma = \\{0, 1\\}\\)，则 \\(\\Sigma^{*}\\) 中的字符串（即所有比特串的集合）是：在基础步骤中规定属于 \\(\\Sigma^{*}\\) 的 \\(\\lambda\\)，在递归步骤的首次应用中形成的0和1，在递归步骤的第二次应用中形成的00、01、10和11，等等。"
        },
        {
            "type": "title",
            "bbox": [
                0.046,
                0.765,
                0.114,
                0.787
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.049,
                0.802,
                0.185,
                0.904
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.049,
                0.91,
                0.17,
                0.929
            ],
            "angle": 0,
            "content": "\\(\\langle \\widehat{\\mathbb{C}}_i\\rangle\\) Mondadori Portfolio/Hilton Fine Text"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.05,
                0.929,
                0.17,
                0.94
            ],
            "angle": 0,
            "content": "Collection/Getty Images"
        },
        {
            "type": "text",
            "bbox": [
                0.203,
                0.801,
                0.897,
                0.906
            ],
            "angle": 0,
            "content": "斐波那契（Fibonacci，1170—1250）斐波那契出生在意大利的商业中心比萨，被称为比萨的列奥那多（Leonardo）。斐波那契是一位商人。他遍游中东各地，在那里他接触到阿拉伯数学。在他的著作《算盘书》(Liber Abaci)中，斐波那契向欧洲人介绍了阿拉伯的数字记号和算术的算法。著名的兔子问题(在8.1节描述)就出自此书。斐波那契还写过关于几何学和三角学以及关于丢番图方程的各种论著，丢番图方程是关于寻找方程整数解的。"
        },
        {
            "type": "image",
            "bbox": [
                0.903,
                0.226,
                0.974,
                0.24
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.903,
                0.414,
                0.964,
                0.432
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.14,
                0.046,
                0.177,
                0.06
            ],
            "angle": 0,
            "content": "310"
        },
        {
            "type": "header",
            "bbox": [
                0.222,
                0.044,
                0.288,
                0.06
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.101,
                0.957,
                0.137
            ],
            "angle": 0,
            "content": "递归定义可用于在递归定义的集合的元素上来定义运算或函数。定义2说明了这一点，定义2是关于两个字符串的连接的，例7是关于字符串的长度的。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.146,
                0.949,
                0.182
            ],
            "angle": 0,
            "content": "定义2 通过连接运算可以组合两个字符串。设 \\(\\Sigma\\) 是符号的集合，\\(\\Sigma^{*}\\) 是 \\(\\Sigma\\) 中符号形成的字符串的集合。可以如下定义两个字符串的连接，用·表示："
        },
        {
            "type": "text",
            "bbox": [
                0.16,
                0.186,
                0.633,
                0.201
            ],
            "angle": 0,
            "content": "基础步骤：若 \\(w \\in \\Sigma^{*}\\)，则 \\(w \\cdot \\lambda = w\\)，其中 \\(\\lambda\\) 是空串。"
        },
        {
            "type": "text",
            "bbox": [
                0.16,
                0.205,
                0.823,
                0.221
            ],
            "angle": 0,
            "content": "递归步骤：若 \\(w_{1} \\in \\Sigma^{*}\\) 且 \\(w_{2} \\in \\Sigma^{*}\\) 以及 \\(x \\in \\Sigma\\)，则 \\(w_{1} \\cdot (w_{2}x) = (w_{1} \\cdot w_{2})x\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.232,
                0.957,
                0.288
            ],
            "angle": 0,
            "content": "字符串 \\(w_{1}\\) 和 \\(w_{2}\\) 的连接通常写成 \\(w_{1}w_{2}\\)，而不是 \\(w_{1} \\cdot w_{2}\\)。通过反复应用递归定义，就可以得出两个字符串 \\(w_{1}\\) 和 \\(w_{2}\\) 的连接是 \\(w_{1}\\) 中的符号后面跟着 \\(w_{2}\\) 中的符号。例如，\\(w_{1} = abra\\) 和 \\(w_{2} = cadabra\\) 的连接是 \\(w_{1}w_{2} = abracadabra\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.149,
                0.293,
                0.682,
                0.31
            ],
            "angle": 0,
            "content": "例7字符串的长度给出字符串 \\(\\mathcal{W}\\) 的长度 \\(l(w)\\) 的递归定义。"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.316,
                0.423,
                0.332
            ],
            "angle": 0,
            "content": "解字符串的长度可以定义为"
        },
        {
            "type": "equation",
            "bbox": [
                0.387,
                0.335,
                0.724,
                0.37
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} l (\\lambda) = 0 \\\\ l (w x) = l (w) + 1, \\text {若} w \\in \\Sigma^ {*} \\text {且} x \\in \\Sigma \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.149,
                0.374,
                0.923,
                0.39
            ],
            "angle": 0,
            "content": "递归定义的另一种重要用途是定义各种类型的合式公式。在例8和例9里说明这一点。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.396,
                0.955,
                0.435
            ],
            "angle": 0,
            "content": "例8 复合命题的合式公式 可以定义关于 \\(\\mathbf{T}\\) 、F、命题变量以及集合 \\(\\{\\neg, \\land, \\lor, \\rightarrow, \\leftrightarrow\\}\\) 中运算的复合命题的合式公式的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.438,
                0.66,
                0.454
            ],
            "angle": 0,
            "content": "基础步骤：T、F和 \\(s\\) 都是合式公式，其中 \\(s\\) 是命题变量。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.456,
                0.956,
                0.492
            ],
            "angle": 0,
            "content": "递归步骤：若 \\(E\\) 和 \\(F\\) 都是合式公式，则 \\((\\neg E)\\) 、 \\((E \\land F)\\) 、 \\((E \\lor F)\\) 、 \\((E \\rightarrow F)\\) 和 \\((E \\leftrightarrow F)\\) 都是合式公式。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.495,
                0.957,
                0.588
            ],
            "angle": 0,
            "content": "例如，根据基础步骤，就可以知道T、F、 \\(p\\) 和 \\(q\\) 都是合式公式，其中 \\(p\\) 和 \\(q\\) 都是命题变量。从递归步骤的初次应用就可以知道 \\((p\\lor q)\\) 、 \\((p\\rightarrow \\mathbf{F})\\) 、 \\((\\mathbf{F}\\rightarrow q)\\) 和 \\((q\\land \\mathbf{F})\\) 都是合式公式。递归步骤的第二次应用就说明 \\(((p\\lor q)\\to (q\\land \\mathbf{F}))\\) 、 \\((q\\lor (p\\lor q))\\) 和 \\(((p\\rightarrow \\mathbf{F})\\rightarrow \\mathbf{T})\\) 都是合式公式。我们留给读者证明 \\(p\\neg \\wedge q\\) 、 \\(pq\\wedge\\) 和 \\(\\neg \\wedge pq\\) 不是合式公式，可以通过不能采用基础步骤和多次运用递归步骤来得到这些公式的方式来证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.594,
                0.955,
                0.633
            ],
            "angle": 0,
            "content": "例9 运算符与运算数的合式公式 可以递归地定义由变量、数字以及集合 \\(\\{+, -, *, /, \\uparrow\\}\\) （其中 \\(^*\\) 表示乘法， \\(\\uparrow\\) 表示指数）上的运算符所组成的合式公式的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.636,
                0.598,
                0.652
            ],
            "angle": 0,
            "content": "基础步骤：若 \\(x\\) 是数字或变量，则 \\(x\\) 是合式公式。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.654,
                0.955,
                0.69
            ],
            "angle": 0,
            "content": "递归步骤：若 \\(F\\) 和 \\(G\\) 是合式公式，则 \\((F + G)\\) 、 \\((F - G)\\) 、 \\((F * G)\\) 、 \\((F / G)\\) 和 \\((F \\uparrow G)\\) 都是合式公式。"
        },
        {
            "type": "title",
            "bbox": [
                0.109,
                0.7,
                0.156,
                0.714
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.11,
                0.732,
                0.252,
                0.838
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.108,
                0.841,
                0.248,
                0.861
            ],
            "angle": 0,
            "content": "Paul Fearn/Alamy Stock Photo"
        },
        {
            "type": "text",
            "bbox": [
                0.268,
                0.732,
                0.955,
                0.765
            ],
            "angle": 0,
            "content": "加布里尔·拉梅(Gabriel Lamé，1795—1870）他于1813年进入工业高等专科学校，1817年毕业。之后在米内兹高等专科学校继续接受教育，于1820年毕业。"
        },
        {
            "type": "text",
            "bbox": [
                0.267,
                0.767,
                0.956,
                0.853
            ],
            "angle": 0,
            "content": "1820年拉梅来到俄国，被任命为圣彼得堡公路与运输学校的校长。在俄国期间他不仅教书，而且设计道路和桥梁。他在1832年回到巴黎，帮助成立一家工程公司。不过，他很快离开这个公司，接受了工业高等专科学校的物理学教授职务，担任这个职务直到1844年。在此期间，他作为工程顾问活跃在学术之外的领域，担任过煤矿的首席工程师并且参与过铁路建设。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.856,
                0.956,
                0.907
            ],
            "angle": 0,
            "content": "拉梅对数论、应用数学以及热力学都做出了开创性工作。他最著名的工作包括引入曲线坐标。他研究数论，证明了 \\(n = 7\\) 时的费马大定理，以及本文给出的欧几里得算法所用除法次数的上界。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.909,
                0.955,
                0.943
            ],
            "angle": 0,
            "content": "有史以来最伟大的数学家之一的高斯，认为拉梅是法国当时最出色的数学家。不过，法国数学家认为他太工程化，而法国科学家认为他太理论化。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.684,
                0.035,
                0.793,
                0.049
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.84,
                0.036,
                0.874,
                0.048
            ],
            "angle": 0,
            "content": "311"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.09,
                0.907,
                0.203
            ],
            "angle": 0,
            "content": "例如，根据基础步骤就可以看出 \\(x\\)、\\(y\\)、0 和 3 都是合式公式（因为任何变量和数字都是合式公式）。应用递归步骤一次所生成的合式公式包括 \\((x + 3)\\)、\\((3 + y)\\)、\\((x - y)\\)、\\((3 - 0)\\)、\\((x * 3)\\)、\\((3 * y)\\)、\\((3 / 0)\\)、\\((x / y)\\)、\\((3 \\uparrow x)\\) 以及 \\((0 \\uparrow 3)\\) 等。应用递归步骤两次就可以说明像 \\(((x + 3) + 3)\\) 和 \\((x - (3 * y))\\) 这样的公式也是合式公式。[注意 \\((3 / 0)\\) 是合式公式，因为这里只考虑语法。]我们留给读者证明 \\(x 3+\\)、\\(y * + x\\) 和 \\(x / y\\) 不是合式公式，可以通过不能采用基础步骤和多次运用递归步骤来得到这些公式的方式来证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.204,
                0.903,
                0.241
            ],
            "angle": 0,
            "content": "第11章将深入研究树。树是特殊类型的图，图是由顶点和连接一些顶点对的边所组成的。第10章将研究图。这里将简单地介绍树和图以说明如何递归地定义树和图。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.248,
                0.895,
                0.286
            ],
            "angle": 0,
            "content": "定义3 以下这些步骤可以递归地定义根树的集合，其中根树是由一个顶点集合和连接这些顶点的边组成的，顶点集合包含的一个特殊顶点，称为树根。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.288,
                0.384,
                0.305
            ],
            "angle": 0,
            "content": "基础步骤：单个顶点 \\(r\\) 是根树。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.307,
                0.895,
                0.364
            ],
            "angle": 0,
            "content": "递归步骤：假设 \\(T_{1}\\)，\\(T_{2}\\)，…，\\(T_{n}\\) 是根树，分别带有树根 \\(r_{1}\\)，\\(r_{2}\\)，…，\\(r_{n}\\)。则如下形成的图也是根树：从树根 \\(r\\) 开始，\\(r\\) 不属于根树 \\(T_{1}\\)，\\(T_{2}\\)，…，\\(T_{n}\\) 中的任何一个，从 \\(r\\) 到顶点 \\(r_{1}\\)，\\(r_{2}\\)，…，\\(r_{n}\\) 中的每个都加入一条边。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.373,
                0.9,
                0.409
            ],
            "angle": 0,
            "content": "图2解释了从基础步骤开始并应用递归步骤一次和两次所形成的一些根树。注意，递归定义的每次应用都形成了无穷多个根树。"
        },
        {
            "type": "image",
            "bbox": [
                0.071,
                0.419,
                0.887,
                0.628
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.41,
                0.639,
                0.542,
                0.655
            ],
            "angle": 0,
            "content": "图2 建立根树"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.665,
                0.9,
                0.777
            ],
            "angle": 0,
            "content": "根树是特殊情形的二叉树。我们将给出两种类型的二叉树的定义，即满二叉树和扩展二叉树。在每种类型二叉树的定义的递归步骤中，都把两个二叉树组合起来形成一个新的二叉树，指定这两个二叉树中的一个作为左子树，另一个作为右子树。在扩展二叉树中，左子树或右子树可以为空，但是在满二叉树中，这是不允许的。在计算机科学中，二叉树是最重要的结构类型之一。第11章将看到二叉树如何用在搜索和排序算法、数据压缩算法以及许多其他应用中。首先定义扩展二叉树。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.786,
                0.625,
                0.803
            ],
            "angle": 0,
            "content": "定义4 以下这些步骤可以递归地定义扩展二叉树的集合："
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.806,
                0.383,
                0.822
            ],
            "angle": 0,
            "content": "基础步骤：空集是扩展二叉树。"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.825,
                0.891,
                0.862
            ],
            "angle": 0,
            "content": "递归步骤：如果 \\(T_{1}\\) 和 \\(T_{2}\\) 都是扩展二叉树，则存在一个表示为 \\(T_{1} \\cdot T_{2}\\) 的扩展二叉树，它包含树根 \\(r\\) 和当左子树 \\(T_{1}\\) 和右子树 \\(T_{2}\\) 都非空时，连接从 \\(r\\) 到这两个子树各自的根的边。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.871,
                0.663,
                0.887
            ],
            "angle": 0,
            "content": "图3解释如何通过应用递归步骤一次至三次来建立扩展二叉树。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.89,
                0.9,
                0.925
            ],
            "angle": 0,
            "content": "现在说明如何定义满二叉树的集合。注意，这个递归定义与扩展二叉树的递归定义之间的差别完全在于基础步骤。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.128,
                0.035,
                0.167,
                0.049
            ],
            "angle": 0,
            "content": "312"
        },
        {
            "type": "header",
            "bbox": [
                0.21,
                0.034,
                0.277,
                0.05
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "image",
            "bbox": [
                0.117,
                0.093,
                0.936,
                0.441
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.435,
                0.45,
                0.622,
                0.466
            ],
            "angle": 0,
            "content": "图3 建立扩展二叉树"
        },
        {
            "type": "text",
            "bbox": [
                0.155,
                0.482,
                0.658,
                0.499
            ],
            "angle": 0,
            "content": "定义5 以下这些步骤可以递归地定义满二叉树的集合："
        },
        {
            "type": "text",
            "bbox": [
                0.157,
                0.502,
                0.602,
                0.518
            ],
            "angle": 0,
            "content": "基础步骤：存在一个只含有单个顶点的满二叉树。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.521,
                0.942,
                0.557
            ],
            "angle": 0,
            "content": "递归步骤：如果 \\(T_{1}\\) 和 \\(T_{2}\\) 都是满二叉树，则存在一个表示为 \\(T_{1} \\cdot T_{2}\\) 的满二叉树，它包含树根 \\(r\\) 和连接从 \\(r\\) 到左子树 \\(T_{1}\\) 和右子树 \\(T_{2}\\) 各自的根的边。"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.145,
                0.567,
                0.696,
                0.584
            ],
            "angle": 0,
            "content": "图4解释如何通过应用递归步骤一次和两次来建立满二叉树。"
        },
        {
            "type": "image",
            "bbox": [
                0.123,
                0.59,
                0.941,
                0.813
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.447,
                0.821,
                0.616,
                0.837
            ],
            "angle": 0,
            "content": "图4 建立满二叉树"
        },
        {
            "type": "title",
            "bbox": [
                0.107,
                0.855,
                0.304,
                0.872
            ],
            "angle": 0,
            "content": "5.3.4 结构归纳法"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.875,
                0.954,
                0.91
            ],
            "angle": 0,
            "content": "为了证明关于递归定义的集合的结果，一般都使用某种形式的数学归纳法。例10解释了递归定义的集合与数学归纳法之间的关系。"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.915,
                0.763,
                0.933
            ],
            "angle": 0,
            "content": "例10 证明：例5所定义集合 \\(S\\) 是所有为3的倍数的正整数的集合。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.679,
                0.038,
                0.789,
                0.053
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.836,
                0.039,
                0.871,
                0.052
            ],
            "angle": 0,
            "content": "313"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.093,
                0.902,
                0.147
            ],
            "angle": 0,
            "content": "解设 \\(A\\) 是被3整除的所有正整数的集合。为了证明 \\(A = S\\) ，必须证明 \\(A\\) 是 \\(S\\) 的子集且 \\(S\\) 是 \\(A\\) 的子集。为了证明 \\(A\\) 是 \\(S\\) 的子集，必须证明被3整除的每个正整数都属于 \\(S\\) 。我们将用数学归纳法来证明它。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.15,
                0.902,
                0.205
            ],
            "angle": 0,
            "content": "设 \\(P(n)\\) 是命题：\\(3n\\) 属于 \\(S\\)。基础步骤成立，因为根据 \\(S\\) 的递归定义的第一部分，\\(3 \\cdot 1 = 3\\) 是属于 \\(S\\) 的。为了证明归纳步骤，假定 \\(P(k)\\) 为真，即 \\(3k\\) 属于 \\(S\\)。因为 \\(3k\\) 属于 \\(S\\) 而且因为 3 属于 \\(S\\)，所以从 \\(S\\) 的递归定义的第二部分得出 \\(3k + 3 = 3(k + 1)\\) 也属于 \\(S\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.207,
                0.902,
                0.303
            ],
            "angle": 0,
            "content": "为了证明 \\(S\\) 是 \\(A\\) 的子集，使用 \\(S\\) 的递归定义。首先，该定义的基础步骤规定3属于 \\(S\\) 。因为 \\(3 = 3 \\cdot 1\\) ，所以所有在这个步骤里属于 \\(S\\) 的元素都被3整除。为了完成证明，必须证明所有用该递归定义的第二部分所生成的属于 \\(S\\) 的元素都属于 \\(A\\) 。这包括证明当 \\(x\\) 和 \\(y\\) 都是 \\(S\\) 中的元素并且假定它们都属于 \\(A\\) 时，就有 \\(x + y\\) 属于 \\(A\\) 。现在若 \\(x\\) 和 \\(y\\) 都属于 \\(A\\) ，则可以得出 \\(3 \\mid x\\) 和 \\(3 \\mid y\\) 。根据4.1节的定理1，得出 \\(3 \\mid x + y\\) ，证毕。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.304,
                0.902,
                0.379
            ],
            "angle": 0,
            "content": "例10使用正整数集合上的数学归纳法和递归定义来证明关于递归定义的集合的结果。但是，除了直接使用数学归纳法来证明关于递归定义的集合的结果外，还有一种更方便的称为结构归纳法的归纳法形式，它不直接使用数学归纳法也可证明关于递归定义的集合的结果。结构归纳法证明包含如下两个部分："
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.381,
                0.902,
                0.417
            ],
            "angle": 0,
            "content": "基础步骤：证明对于递归定义的基础步骤所规定的属于该集合的所有元素来说，结果成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.419,
                0.902,
                0.455
            ],
            "angle": 0,
            "content": "递归步骤：证明如果对于定义的递归步骤中用来构造新元素的每个元素来说命题为真，则对于这些新的元素来说结果成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.457,
                0.905,
                0.609
            ],
            "angle": 0,
            "content": "结构归纳法的有效性来自非负整数的数学归纳法原理。为了看出这一点，设 \\(P(n)\\) 为：对于递归定义的递归步骤的不超过 \\(n\\) 次应用所生成的所有元素来说，断言为真。如果能够证明当 \\(n\\) 是正整数时 \\(P(n)\\) 为真，那就证明了数学归纳法原理蕴含着结构归纳法原理。在结构归纳法的基础步骤中，证明 \\(P(0)\\) 为真。换句话说，证明对于所有在定义的基础步骤中规定为属于集合的元素来说，结果为真。归纳步骤的后果是，如果假设 \\(P(k)\\) 为真，则得出 \\(P(k + 1)\\) 为真。当用结构归纳法完成一个证明时，就已经证明了 \\(P(0)\\) 为真并且 \\(P(k)\\) 蕴含 \\(P(k + 1)\\) 。根据数学归纳法就可以得出对于所有非负整数 \\(n\\) 来说，\\(P(n)\\) 为真。这也就证明了对于递归定义生成的所有元素来说结果为真，并且证明了结构归纳法是一种有效的证明技术。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.61,
                0.905,
                0.723
            ],
            "angle": 0,
            "content": "使用结构归纳法证明的例子 结构归纳法可以用于证明递归构造的集合中的所有元素具有一个特殊的性质。我们将使用结构归纳法证明关于合式公式、字符串和二叉树的结果来表明这一思想。对于每个证明，我们必须执行适当的基础步骤和递归步骤。例如，用结构归纳法证明例8中定义的合式公式集合的相关结果，其中指定T、F和每个命题变量 \\(s\\) 是合式公式，并且要求如果 \\(E\\) 和 \\(F\\) 是合式公式，那么 \\((\\neg E)\\) 、 \\((E \\land F)\\) 、 \\((E \\lor F)\\) 、 \\((E \\rightarrow F)\\) 和 \\((E \\leftrightarrow F)\\) 是合式公式，我们需要完成这个基础步骤和递归步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.724,
                0.695,
                0.742
            ],
            "angle": 0,
            "content": "基础步骤：证明当 \\(s\\) 是命题变量时，对于 \\(\\mathbf{T}\\) 、F和 \\(s\\) 来说结果为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.743,
                0.905,
                0.78
            ],
            "angle": 0,
            "content": "递归步骤：证明如果对于复合命题 \\( p \\) 和 \\( q \\) 来说，结果为真，则对于 \\( (\\neg p) \\) 、 \\( (p \\lor q) \\) 、 \\( (p \\land q) \\) 、 \\( (p \\rightarrow q) \\) 和 \\( (p \\leftrightarrow q) \\) 来说，结果都为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.782,
                0.595,
                0.8
            ],
            "angle": 0,
            "content": "例11解释如何用结构归纳法证明关于合式公式的结果。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.803,
                0.895,
                0.822
            ],
            "angle": 0,
            "content": "例11 证明：例8所定义的复合命题的每个合式公式都含有相等个数的左括号和右括号。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.826,
                0.905,
                0.861
            ],
            "angle": 0,
            "content": "解 基础步骤：公式 \\(\\mathbf{T}\\) 、F和 \\(s\\) 每个都不包含括号，所以显然它们含有相等个数的左括号和右括号。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.863,
                0.907,
                0.939
            ],
            "angle": 0,
            "content": "递归步骤：假设 \\(p\\) 和 \\(q\\) 都是各自含有相等个数的左括号和右括号的合式公式。换句话说，如果 \\(l_{p}\\) 和 \\(l_{q}\\) 分别是 \\(p\\) 和 \\(q\\) 中左括号的个数，\\(r_{p}\\) 和 \\(r_{q}\\) 分别是 \\(p\\) 和 \\(q\\) 中右括号的个数，则 \\(l_{p} = r_{p}\\) 且 \\(l_{q} = r_{q}\\) 。为了完成归纳步骤，需要证明 \\((\\neg p)\\)、\\((p \\lor q)\\)、\\((p \\land q)\\)、\\((p \\leftrightarrow q)\\) 和 \\((p \\leftrightarrow q)\\) 也各自含有相等个数的左括号和右括号。这些复合命题中第一个的左括号的个数等于 \\(l_{p} + 1\\)，其他每个复"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.138,
                0.038,
                0.174,
                0.051
            ],
            "angle": 0,
            "content": "314"
        },
        {
            "type": "header",
            "bbox": [
                0.219,
                0.037,
                0.284,
                0.052
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.093,
                0.955,
                0.147
            ],
            "angle": 0,
            "content": "合命题的左括号个数等于 \\(l_{p} + l_{q} + 1\\) 。同样，这些复合命题中第一个的右括号个数等于 \\(r_p + 1\\) 其他每个复合命题的右括号个数等于 \\(r_p + r_q + 1\\) 。因为 \\(l_{p} = r_{p}\\) 且 \\(l_{q} = r_{q}\\) ，所以这些复合表达式每个都含有相等个数的左括号和右括号。这样就完成了归纳证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.151,
                0.954,
                0.187
            ],
            "angle": 0,
            "content": "假设 \\(P(w)\\) 是 \\(\\varpi \\in \\Sigma^{*}\\) 的字符串集合上的命题函数。为了用结构归纳法来证明对于所有\\(\\varpi \\in \\Sigma^{*}\\) 的字符串来说 \\(P(w)\\) 成立，需要同时完成基础步骤和递归步骤。这些步骤是："
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.19,
                0.395,
                0.205
            ],
            "angle": 0,
            "content": "基础步骤：证明 \\(P(\\lambda)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.209,
                0.89,
                0.224
            ],
            "angle": 0,
            "content": "递归步骤：假设 \\(P(w)\\) 为真，其中 \\(w \\in \\Sigma^{*}\\)，证明如果 \\(x \\in \\Sigma\\)，则 \\(P(wx)\\) 也必定为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.229,
                0.643,
                0.244
            ],
            "angle": 0,
            "content": "例12解释如何在关于字符串的证明中使用结构归纳法。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.251,
                0.953,
                0.288
            ],
            "angle": 0,
            "content": "例12 用结构归纳法证明 \\( l(xy) = l(x) + l(y) \\)，其中 \\( x \\) 和 \\( y \\) 属于 \\( \\Sigma^{*} \\)，即字母表 \\( \\Sigma \\) 上的字符串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.293,
                0.953,
                0.327
            ],
            "angle": 0,
            "content": "解本证明将基于定义1所给出对集合 \\(\\Sigma^{*}\\) 的递归定义和例7对字符串长度的定义。设\\(P(y)\\) 是命题：当 \\(x\\in \\Sigma^{*}\\) 时就有 \\(l(xy) = l(x) + l(y)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.332,
                0.953,
                0.385
            ],
            "angle": 0,
            "content": "基础步骤：为了完成基础步骤，必须证明 \\(P(\\lambda)\\) 为真。即必须证明对所有 \\(x \\in \\Sigma^{*}\\) 来说，有 \\(l(x\\lambda) = l(x) + l(\\lambda)\\) 。因为对每个字符串 \\(x\\) 来说，\\(l(x\\lambda) = l(x) = l(x) + 0 = l(x) + l(\\lambda)\\)，所以 \\(P(\\lambda)\\) 为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.389,
                0.953,
                0.462
            ],
            "angle": 0,
            "content": "归纳步骤：为了完成归纳步骤，假定 \\(P(y)\\) 为真，而且证明这个假定蕴含着当 \\(a \\in \\Sigma\\) 时，就有 \\(P(ya)\\) 为真。需要证明的是，对每个 \\(a \\in \\Sigma\\) 来说有 \\(l(xya) = l(x) + l(ya)\\) 。为了证明这一点，注意到根据 \\(l(w)\\) 的递归定义（在例7中给出），有 \\(l(xya) = l(xy) + 1\\) 和 \\(l(ya) = l(y) + 1\\) 。而且，根据归纳假设，有 \\(l(xy) = l(x) + l(y)\\) 。故得出 \\(l(xya) = l(x) + l(y) + 1 = l(x) + l(ya)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.466,
                0.951,
                0.501
            ],
            "angle": 0,
            "content": "可以用结构归纳法证明关于树或特殊类别的树的结果。例如，为了用结构归纳法证明关于满二叉树的结果，需要证明下面的基础步骤和递归步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.504,
                0.673,
                0.519
            ],
            "angle": 0,
            "content": "基础步骤：证明对于只含有单个顶点的树来说，结果为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.523,
                0.951,
                0.558
            ],
            "angle": 0,
            "content": "递归步骤：证明如果对于树 \\(T_{1}\\) 和 \\(T_{2}\\) 来说结果为真，则对于包含树根 \\(r\\) 和以 \\(T_{1}\\) 作为左子树且以 \\(T_{2}\\) 作为右子树的树 \\(T_{1} \\cdot T_{2}\\) 来说结果为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.562,
                0.951,
                0.597
            ],
            "angle": 0,
            "content": "在给出例子说明如何用结构归纳法来证明关于满二叉树的结果之前，需要一些定义。将递归地定义满二叉树 \\(T\\) 的高度 \\(h(T)\\) 和顶点数 \\(n(T)\\) 。首先定义满二叉树的高度。"
        },
        {
            "type": "text",
            "bbox": [
                0.155,
                0.606,
                0.568,
                0.623
            ],
            "angle": 0,
            "content": "定义6 递归地定义满二叉树 \\(T\\) 的高度 \\(h(T)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.155,
                0.626,
                0.684,
                0.642
            ],
            "angle": 0,
            "content": "基础步骤：只含有树根 \\(r\\) 的满二叉树 \\(T\\) 的高度是 \\(h(T) = 0\\)。"
        },
        {
            "type": "equation",
            "bbox": [
                0.113,
                0.645,
                0.945,
                0.681
            ],
            "angle": 0,
            "content": "\\[\n\\text {递 归 步 骤 ： 如 果} T _ {1} \\text {和} T _ {2} \\text {都 是 满 二 叉 树 ， 则 满 二 叉 树} T = T _ {1} \\bullet T _ {2} \\text {有 高 度} h (T) = 1 + \\max  (h (T _ {1}), h (T _ {2})) 。\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.691,
                0.797,
                0.707
            ],
            "angle": 0,
            "content": "如果设 \\(n(T)\\) 表示满二叉树 \\(T\\) 的顶点个数，则 \\(n(T)\\) 满足下面的递归定义："
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.711,
                0.744,
                0.726
            ],
            "angle": 0,
            "content": "基础步骤：只含有树根 \\(r\\) 的满二叉树 \\(T\\) 的顶点数 \\(n(T)\\) 是 \\(n(T) = 1\\)。"
        },
        {
            "type": "equation",
            "bbox": [
                0.104,
                0.73,
                0.949,
                0.764
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{r} {\\text {递 归 步 骤 ： 如 果} T _ {1} \\text {和} T _ {2} \\text {都 是 满 二 叉 树}, \\text {则 满 二 又 树} T = T _ {1} \\bullet T _ {2} \\text {的 顶 点 数 是} n (T) = 1 + } \\\\ {n (T _ {1}) + n (T _ {2}).} \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.769,
                0.692,
                0.784
            ],
            "angle": 0,
            "content": "现在说明如何用结构归纳法来证明一个关于满二叉树的结果。"
        },
        {
            "type": "text",
            "bbox": [
                0.154,
                0.794,
                0.611,
                0.811
            ],
            "angle": 0,
            "content": "定理2 如果 \\(T\\) 是满二叉树，则 \\(n(T) \\leqslant 2^{h(T) + 1} - 1\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.821,
                0.488,
                0.836
            ],
            "angle": 0,
            "content": "证明 用结构归纳法证明这个不等式。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.841,
                0.95,
                0.874
            ],
            "angle": 0,
            "content": "基础步骤：对于只含有树根 \\(r\\) 的满二叉树来说，结果为真，因为 \\(n(T) = 1\\) 并且 \\(h(T) = 0\\) 所以 \\(n(T) = 1 \\leqslant 2^{0 + 1} - 1 = 1\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.878,
                0.951,
                0.934
            ],
            "angle": 0,
            "content": "归纳步骤：对于归纳假设，假定当 \\(T_{1}\\) 和 \\(T_{2}\\) 都是满二叉树时，\\(n(T_{1}) \\leqslant 2^{h(T_{1}) + 1} - 1\\) 并且 \\(n(T_{2}) \\leqslant 2^{h(T_{2}) + 1} - 1\\)。根据 \\(n(T)\\) 和 \\(h(T)\\) 的递归公式，就有 \\(n(T) = 1 + n(T_{1}) + n(T_{2})\\) 和 \\(h(T) = 1 + \\max(h(T_{1}), h(T_{2}))\\)。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.675,
                0.035,
                0.785,
                0.051
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.831,
                0.036,
                0.868,
                0.05
            ],
            "angle": 0,
            "content": "315"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.092,
                0.174,
                0.107
            ],
            "angle": 0,
            "content": "我们发现"
        },
        {
            "type": "equation",
            "bbox": [
                0.164,
                0.112,
                0.531,
                0.22
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} n (T) = 1 + n \\left(T _ {1}\\right) + n \\left(T _ {2}\\right) \\\\ \\leqslant 1 + (2 ^ {h \\left(T _ {1}\\right) + 1} - 1) + (2 ^ {h \\left(T _ {2}\\right) + 1} - 1) \\\\ \\leqslant 2 \\cdot \\max  \\left(2 ^ {h \\left(T _ {1}\\right) + 1}, 2 ^ {h \\left(T _ {2}\\right) + 1}\\right) - 1 \\\\ = 2 \\cdot 2 ^ {\\max  \\left(h \\left(T _ {1}\\right), h \\left(T _ {2}\\right)\\right) + 1} - 1 \\\\ = 2 \\cdot 2 ^ {h (T)} - 1 \\\\ = 2 ^ {h (T) + 1} - 1 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.577,
                0.112,
                0.777,
                0.126
            ],
            "angle": 0,
            "content": "根据 \\(n(T)\\) 的递归公式"
        },
        {
            "type": "text",
            "bbox": [
                0.577,
                0.132,
                0.701,
                0.146
            ],
            "angle": 0,
            "content": "根据归纳假设"
        },
        {
            "type": "text",
            "bbox": [
                0.577,
                0.15,
                0.885,
                0.165
            ],
            "angle": 0,
            "content": "因为两项之和至多是较大项的2倍"
        },
        {
            "type": "text",
            "bbox": [
                0.578,
                0.169,
                0.815,
                0.183
            ],
            "angle": 0,
            "content": "因为 \\(\\max (2^x, 2^y) = 2^{\\max (x,y)}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.577,
                0.188,
                0.776,
                0.202
            ],
            "angle": 0,
            "content": "根据 \\(h(T)\\) 的递归定义"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.226,
                0.264,
                0.242
            ],
            "angle": 0,
            "content": "这样就完成了归纳步骤。"
        },
        {
            "type": "title",
            "bbox": [
                0.047,
                0.253,
                0.24,
                0.269
            ],
            "angle": 0,
            "content": "5.3.5 广义归纳法"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.273,
                0.894,
                0.308
            ],
            "angle": 0,
            "content": "可以扩展数学归纳法来证明关于除整数集合以外的其他具有良序性的集合的结果。虽然9.6节将讨论这个概念，但是这里给出一个例子来说明这种方法的有用性。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.311,
                0.894,
                0.384
            ],
            "angle": 0,
            "content": "作为一个例子，注意到可以定义 \\(\\mathbf{N} \\times \\mathbf{N}\\)（非负整数的有序对）上的序，规定如果 \\(x_{1} < x_{2}\\) 或者 \\(x_{1} = x_{2}\\) 且 \\(y_{1} < y_{2}\\)，则 \\((x_{1}, y_{1})\\) 小于等于 \\((x_{2}, y_{2})\\)。这称为字典序。具有这个序的集合 \\(\\mathbf{N} \\times \\mathbf{N}\\) 具有性质：\\(\\mathbf{N} \\times \\mathbf{N}\\) 的每个子集合都有最小元（参见9.6节补充练习53）。这意味着可以递归地定义满足 \\(m \\in \\mathbb{N}\\) 和 \\(n \\in \\mathbb{N}\\) 的项 \\(a_{m,n}\\)，并且用数学归纳法的变种来证明关于这些项的结果，例13说明这一点。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.389,
                0.708,
                0.407
            ],
            "angle": 0,
            "content": "例13 假设对于 \\((m, n) \\in \\mathbf{N} \\times \\mathbf{N}\\) 来说递归地定义 \\(a_{m,n}\\)，令 \\(a_{0,0} = 0\\) 并且"
        },
        {
            "type": "equation",
            "bbox": [
                0.348,
                0.412,
                0.635,
                0.447
            ],
            "angle": 0,
            "content": "\\[\n\\left\\{ \\begin{array}{l l} a _ {m, n} = a _ {m - 1, n} + 1 & n = 0 \\text {且} m > 0 \\\\ a _ {m, n - 1} + n & n > 0 \\end{array} \\right.\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.45,
                0.894,
                0.467
            ],
            "angle": 0,
            "content": "证明对于所有 \\((m,n)\\in \\mathbf{N}\\times \\mathbf{N}\\) 来说（即对于非负整数的所有有序对来说）， \\(a_{m,n} = m + n(n + 1) / 2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.469,
                0.894,
                0.523
            ],
            "angle": 0,
            "content": "解 用广义的数学归纳法可以证明 \\(a_{m,n} = m + n(n + 1) / 2\\) 。基础步骤要求证明：当 \\((m, n) = (0, 0)\\) 时这个公式是有效的。归纳步骤要求证明：如果对于按照 \\(\\mathbf{N} \\times \\mathbf{N}\\) 上字典序小于 \\((m, n)\\) 的所有有序对来说，这个公式是有效的，则对于 \\((m, n)\\) 来说这个公式也是成立的。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.526,
                0.894,
                0.561
            ],
            "angle": 0,
            "content": "基础步骤：设 \\((m, n) = (0, 0)\\) 。于是根据 \\(a_{m,n}\\) 递归定义的基础情形就有 \\(a_{0,0} = 0\\) 。另外，当 \\(m = n = 0\\) 时，\\(m + n(n + 1)/2 = 0 + (0 \\cdot 1)/2 = 0\\) 。这样就完成了基础步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.564,
                0.894,
                0.676
            ],
            "angle": 0,
            "content": "归纳步骤：假设当按照 \\(\\mathbf{N} \\times \\mathbf{N}\\) 上字典序 \\((m', n')\\) 小于 \\((m, n)\\) 时 \\(a_{m',n'} = m' + n'(n' + 1)/2\\)。根据递归定义，如果 \\(n = 0\\)，则 \\(a_{m,n} = a_{m-1,n} + 1\\)。因为 \\((m - 1, n)\\) 小于 \\((m, n)\\)，归纳假设 \\(a_{m-1,n} = m - 1 + n(n + 1)/2\\)，所以 \\(a_{m,n} = m - 1 + n(n + 1)/2 + 1 = m + n(n + 1)/2\\)，给出了所需要的等式。现在假设 \\(n > 0\\)，所以 \\(a_{m,n} = a_{m,n-1} + n\\)。因为 \\((m, n - 1)\\) 小于 \\((m, n)\\)，归纳假设告诉我们 \\(a_{m,n-1} = m + (n - 1)n/2\\)，所以 \\(a_{m,n} = m + (n - 1)n/2 + n = m + (n^2 - n + 2n)/2 = m + n(n + 1)/2\\)。这样就完成了归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.679,
                0.42,
                0.695
            ],
            "angle": 0,
            "content": "9.6节将说明这种证明技术的合理性。"
        },
        {
            "type": "title",
            "bbox": [
                0.047,
                0.706,
                0.091,
                0.722
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.726,
                0.854,
                0.741
            ],
            "angle": 0,
            "content": "1. 求出 \\( f(1) \\) 、 \\( f(2) \\) 、 \\( f(3) \\) 和 \\( f(4) \\)，若 \\( f(n) \\) 递归地定义成： \\( f(0) = 1 \\)，而且对 \\( n = 0, 1, 2, \\dots \\) 来说，"
        },
        {
            "type": "text",
            "bbox": [
                0.068,
                0.745,
                0.24,
                0.759
            ],
            "angle": 0,
            "content": "a) \\( f(n + 1) = f(n) + 2 \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.46,
                0.745,
                0.611,
                0.759
            ],
            "angle": 0,
            "content": "b) \\(f(n + 1) = 3f(n)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.069,
                0.763,
                0.202,
                0.776
            ],
            "angle": 0,
            "content": "c) \\(f(n + 1) = 2^{f(n)}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.46,
                0.763,
                0.695,
                0.776
            ],
            "angle": 0,
            "content": "d) \\(f(n + 1) = f(n)^2 +f(n) + 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.779,
                0.891,
                0.811
            ],
            "angle": 0,
            "content": "2. 求出 \\( f(1) \\) 、 \\( f(2) \\) 、 \\( f(3) \\) 、 \\( f(4) \\) 和 \\( f(5) \\)，若 \\( f(n) \\) 递归地定义成： \\( f(0) = 3 \\)，而且对 \\( n = 0, 1, 2, \\dots \\) 来说，"
        },
        {
            "type": "text",
            "bbox": [
                0.068,
                0.816,
                0.236,
                0.829
            ],
            "angle": 0,
            "content": "a) \\(f(n + 1) = -2f(n)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.46,
                0.816,
                0.64,
                0.829
            ],
            "angle": 0,
            "content": "b) \\(f(n + 1) = 3f(n) + 7\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.068,
                0.833,
                0.312,
                0.846
            ],
            "angle": 0,
            "content": "c) \\(f(n + 1) = f(n)^2 -2f(n) - 2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.46,
                0.833,
                0.607,
                0.846
            ],
            "angle": 0,
            "content": "d) \\(f(n + 1) = 3^{f(n) / 3}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.85,
                0.891,
                0.881
            ],
            "angle": 0,
            "content": "3. 求出 \\( f(2) \\) 、 \\( f(3) \\) 、 \\( f(4) \\) 和 \\( f(5) \\)，若 \\( f \\) 递归地定义成： \\( f(0) = -1 \\)， \\( f(1) = 2 \\)，而且对 \\( n = 1, 2, \\dots \\) 来说，"
        },
        {
            "type": "text",
            "bbox": [
                0.068,
                0.886,
                0.303,
                0.899
            ],
            "angle": 0,
            "content": "a) \\(f(n + 1) = f(n) + 3f(n - 1)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.46,
                0.886,
                0.676,
                0.9
            ],
            "angle": 0,
            "content": "b) \\( f(n + 1) = f(n)^2 f(n - 1) \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.068,
                0.903,
                0.326,
                0.917
            ],
            "angle": 0,
            "content": "c) \\(f(n + 1) = 3f(n)^{2} - 4f(n - 1)^{2}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.46,
                0.904,
                0.677,
                0.917
            ],
            "angle": 0,
            "content": "d) \\(f(n + 1) = f(n - 1) / f(n)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.92,
                0.862,
                0.936
            ],
            "angle": 0,
            "content": "4. 求出 \\( f(2) \\) 、 \\( f(3) \\) 、 \\( f(4) \\) 和 \\( f(5) \\)，若 \\( f \\) 递归地定义成： \\( f(0) = f(1) = 1 \\)，而且对 \\( n = 1, 2, \\dots \\) 来说，"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.137,
                0.038,
                0.174,
                0.051
            ],
            "angle": 0,
            "content": "316"
        },
        {
            "type": "header",
            "bbox": [
                0.219,
                0.036,
                0.284,
                0.051
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.093,
                0.365,
                0.108
            ],
            "angle": 0,
            "content": "a) \\(f(n + 1) = f(n) - f(n - 1)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.526,
                0.093,
                0.738,
                0.108
            ],
            "angle": 0,
            "content": "b) \\(f(n + 1) = f(n)f(n - 1)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.134,
                0.111,
                0.377,
                0.126
            ],
            "angle": 0,
            "content": "c) \\(f(n + 1) = f(n)^2 +f(n - 1)^3\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.526,
                0.111,
                0.748,
                0.126
            ],
            "angle": 0,
            "content": "d) \\(f(n + 1) = f(n) / f(n - 1)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.129,
                0.961,
                0.161
            ],
            "angle": 0,
            "content": "5. 确定下列这些所谓的定义是否每个都是从非负整数集合到整数集合的函数 \\( f \\) 的有效递归定义。如果 \\( f \\) 是良定义，则求出当 \\( n \\) 是非负整数时 \\( f(n) \\) 的一个公式并证明这个公式是有效的。"
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.165,
                0.51,
                0.179
            ],
            "angle": 0,
            "content": "a) \\( f(0) = 0 \\)，对于 \\( n \\geqslant 1 \\) 来说 \\( f(n) = 2f(n - 2) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.183,
                0.528,
                0.198
            ],
            "angle": 0,
            "content": "b) \\( f(0) = 1 \\)，对于 \\( n \\geqslant 1 \\) 来说 \\( f(n) = f(n - 1) - 1 \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.201,
                0.611,
                0.216
            ],
            "angle": 0,
            "content": "c) \\( f(0) = 2 \\)，\\( f(1) = 3 \\)，对于 \\( n \\geqslant 2 \\) 来说 \\( f(n) = f(n - 1) - 1 \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.219,
                0.594,
                0.234
            ],
            "angle": 0,
            "content": "d) \\( f(0) = 1 \\)，\\( f(1) = 2 \\)，对于 \\( n \\geqslant 2 \\) 来说 \\( f(n) = 2f(n - 2) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.237,
                0.931,
                0.252
            ],
            "angle": 0,
            "content": "e) \\( f(0) = 1 \\)，如果 \\( n \\) 是奇数且 \\( n \\geqslant 1 \\) 则 \\( f(n) = 3f(n - 1) \\)；如果 \\( n \\) 是偶数且 \\( n \\geqslant 2 \\) 则 \\( f(n) = 9f(n - 2) \\)。"
        },
        {
            "type": "list",
            "bbox": [
                0.131,
                0.165,
                0.931,
                0.252
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.255,
                0.963,
                0.287
            ],
            "angle": 0,
            "content": "6. 确定下列这些所谓的定义是否每个都是从非负整数集合到整数集合的函数 \\( f \\) 的有效递归定义。如果 \\( f \\) 是良定义，则求出当 \\( n \\) 是非负整数时 \\( f(n) \\) 的一个公式并证明这个公式是有效的。"
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.291,
                0.518,
                0.305
            ],
            "angle": 0,
            "content": "a) \\( f(0) = 1 \\)，对于 \\( n \\geqslant 1 \\) 来说 \\( f(n) = -f(n - 1) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.308,
                0.679,
                0.323
            ],
            "angle": 0,
            "content": "b) \\( f(0) = 1 \\)，\\( f(1) = 0 \\)，\\( f(2) = 2 \\)，对于 \\( n \\geqslant 3 \\) 来说 \\( f(n) = 2f(n - 3) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.326,
                0.608,
                0.341
            ],
            "angle": 0,
            "content": "c) \\( f(0) = 0 \\)，\\( f(1) = 1 \\)，对于 \\( n \\geqslant 2 \\) 来说，\\( f(n) = 2f(n + 1) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.344,
                0.61,
                0.359
            ],
            "angle": 0,
            "content": "d) \\( f(0) = 0 \\)，\\( f(1) = 1 \\)，对于 \\( n \\geqslant 1 \\) 来说，\\( f(n) = 2f(n - 1) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.362,
                0.832,
                0.377
            ],
            "angle": 0,
            "content": "e) \\( f(0) = 2 \\)，如果 \\( n \\) 是奇数且 \\( n \\geqslant 1 \\) 则 \\( f(n) = f(n - 1) \\)；如果 \\( n \\geqslant 2 \\) 则 \\( f(n) = 2f(n - 2) \\)。"
        },
        {
            "type": "list",
            "bbox": [
                0.132,
                0.291,
                0.832,
                0.377
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.38,
                0.529,
                0.394
            ],
            "angle": 0,
            "content": "7. 给出序列 \\(\\{a_{n}\\}\\) 的递归定义， \\(n = 1\\) ，2，3，…，若"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.399,
                0.215,
                0.412
            ],
            "angle": 0,
            "content": "a) \\( a_{n} = 6n \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.529,
                0.398,
                0.634,
                0.412
            ],
            "angle": 0,
            "content": "b) \\(a_{n} = 2n + 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.137,
                0.417,
                0.219,
                0.43
            ],
            "angle": 0,
            "content": "c) \\(a_{n} = 10^{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.529,
                0.417,
                0.597,
                0.43
            ],
            "angle": 0,
            "content": "d) \\(a_{n} = 5\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.435,
                0.529,
                0.448
            ],
            "angle": 0,
            "content": "8. 给出序列 \\(\\{a_{n}\\}\\) 的递归定义， \\(n = 1\\) ，2，3，…，若"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.453,
                0.243,
                0.467
            ],
            "angle": 0,
            "content": "a) \\( a_{n} = 4n - 2 \\)"
        },
        {
            "type": "text",
            "bbox": [
                0.529,
                0.453,
                0.668,
                0.466
            ],
            "angle": 0,
            "content": "b) \\(a_{n} = 1 + (-1)^{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.137,
                0.471,
                0.258,
                0.485
            ],
            "angle": 0,
            "content": "c) \\(a_{n} = n(n + 1)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.53,
                0.47,
                0.605,
                0.484
            ],
            "angle": 0,
            "content": "d) \\(a_{n} = n^{2}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.489,
                0.763,
                0.503
            ],
            "angle": 0,
            "content": "9. 设 \\(F\\) 是这样的函数，使得 \\(F(n)\\) 是前 \\(n\\) 个正整数之和。给出 \\(F(n)\\) 的递归定义。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.507,
                0.591,
                0.521
            ],
            "angle": 0,
            "content": "10. 给出 \\( S_{m}(n) \\) 的递归定义，即整数 \\( m \\) 与非负整数 \\( n \\) 之和。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.524,
                0.592,
                0.539
            ],
            "angle": 0,
            "content": "11. 给出 \\(P_{m}(n)\\) 的递归定义，即整数 \\(m\\) 与非负整数 \\(n\\) 之积。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.543,
                0.477,
                0.557
            ],
            "angle": 0,
            "content": "在练习 \\(12\\sim 19\\) 中， \\(f_{n}\\) 是第 \\(_n\\) 个斐波那契数。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.561,
                0.591,
                0.576
            ],
            "angle": 0,
            "content": "12. 证明：当 \\(n\\) 是正整数时，有 \\(f_{1}^{2} + f_{2}^{2} + \\dots + f_{n}^{2} = f_{n} f_{n+1}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.579,
                0.584,
                0.594
            ],
            "angle": 0,
            "content": "13. 证明：当 \\(n\\) 是正整数时，有 \\(f_{1} + f_{3} + \\dots + f_{2n - 1} = f_{2n}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.597,
                0.568,
                0.612
            ],
            "angle": 0,
            "content": "* 14. 证明：当 \\( n \\) 是正整数时，有 \\( f_{n+1}f_{n-1} - f_n^2 = (-1)^n \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.616,
                0.645,
                0.631
            ],
            "angle": 0,
            "content": "* 15. 证明：当 \\( n \\) 是正整数时，有 \\( f_{0}f_{1} + f_{1}f_{2} + \\dots + f_{2n - 1}f_{2n} = f_{2n}^{2} \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.634,
                0.708,
                0.649
            ],
            "angle": 0,
            "content": "* 16. 证明：当 \\( n \\) 是正整数时，有 \\( f_{0} - f_{1} + f_{2} - \\dots - f_{2n-1} + f_{2n} = f_{2n-1} - 1 \\)。"
        },
        {
            "type": "list",
            "bbox": [
                0.101,
                0.561,
                0.708,
                0.649
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.651,
                0.965,
                0.683
            ],
            "angle": 0,
            "content": "17. 确定用欧几里得算法求出斐波那契数 \\( f_{n} \\) 和 \\( f_{n+1} \\) 的最大公因子所用的除法次数，其中 \\( n \\) 是非负整数。用数学归纳法验证你的答案。"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.687,
                0.174,
                0.701
            ],
            "angle": 0,
            "content": "18. 设"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.74,
                0.358,
                0.755
            ],
            "angle": 0,
            "content": "证明当 \\(n\\) 是正整数时，有"
        },
        {
            "type": "equation",
            "bbox": [
                0.509,
                0.705,
                0.609,
                0.737
            ],
            "angle": 0,
            "content": "\\[\n\\mathbf {A} = \\left[ \\begin{array}{l l} 1 & 1 \\\\ 1 & 0 \\end{array} \\right]\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.479,
                0.759,
                0.64,
                0.791
            ],
            "angle": 0,
            "content": "\\[\n\\mathbf {A} ^ {n} = \\left[ \\begin{array}{l l} f _ {n + 1} & f _ {n} \\\\ f _ {n} & f _ {n - 1} \\end{array} \\right]\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.795,
                0.965,
                0.827
            ],
            "angle": 0,
            "content": "19. 通过在练习18中等式的两边取行列式，证明练习14中给出的恒等式。（本题依赖于 \\(2 \\times 2\\) 矩阵的行列式概念。）"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.831,
                0.966,
                0.863
            ],
            "angle": 0,
            "content": "* 20. 给出函数 \\(\\max\\) 和 \\(\\min\\) 的递归定义，使得 \\(\\max(a_1, a_2, \\cdots, a_n)\\) 和 \\(\\min(a_1, a_2, \\cdots, a_n)\\) 分别是 \\(n\\) 个数 \\(a_1, a_2, \\cdots, a_n\\) 中的最大值和最小值。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.866,
                0.938,
                0.881
            ],
            "angle": 0,
            "content": "* 21. 设 \\( {a}_{1},{a}_{2},\\cdots ,{a}_{n} \\) 和 \\( {b}_{1},{b}_{2},\\cdots ,{b}_{n} \\) 都是实数。用练习 20 中给出的递归定义来证明下面的结果。"
        },
        {
            "type": "list",
            "bbox": [
                0.103,
                0.831,
                0.966,
                0.881
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.884,
                0.614,
                0.899
            ],
            "angle": 0,
            "content": "a) \\(\\max (-a_1, -a_2, \\dots, -a_n) = -\\min (a_1, a_2, \\dots, a_n)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.902,
                0.836,
                0.917
            ],
            "angle": 0,
            "content": "b) \\(\\max (a_{1} + b_{1}, a_{2} + b_{2}, \\dots, a_{n} + b_{n}) \\leqslant \\max (a_{1}, a_{2}, \\dots, a_{n}) + \\max (b_{1}, b_{2}, \\dots, b_{n})\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.92,
                0.825,
                0.935
            ],
            "angle": 0,
            "content": "c) \\(\\min (a_{1} + b_{1}, a_{2} + b_{2}, \\dots, a_{n} + b_{n}) \\geqslant \\min (a_{1}, a_{2}, \\dots, a_{n}) + \\min (b_{1}, b_{2}, \\dots, b_{n})\\)"
        },
        {
            "type": "list",
            "bbox": [
                0.15,
                0.884,
                0.836,
                0.935
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.673,
                0.035,
                0.783,
                0.051
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.829,
                0.037,
                0.867,
                0.05
            ],
            "angle": 0,
            "content": "317"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.091,
                0.752,
                0.107
            ],
            "angle": 0,
            "content": "22. 证明集合 \\( S \\) 是正整数集合，它定义成： \\( 1 \\in S \\)，而且当 \\( s \\in S \\) 和 \\( t \\in S \\) 时就有 \\( s + t \\in S \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.109,
                0.425,
                0.124
            ],
            "angle": 0,
            "content": "23. 给出是 5 的倍数的正整数集合的递归定义。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.127,
                0.295,
                0.142
            ],
            "angle": 0,
            "content": "24. 给出下述集合的递归定义："
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.145,
                0.193,
                0.159
            ],
            "angle": 0,
            "content": "a)正奇数集合"
        },
        {
            "type": "text",
            "bbox": [
                0.461,
                0.145,
                0.663,
                0.159
            ],
            "angle": 0,
            "content": "b)3的正整数次幂的集合"
        },
        {
            "type": "text",
            "bbox": [
                0.079,
                0.163,
                0.267,
                0.176
            ],
            "angle": 0,
            "content": "c)整系数多项式的集合"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.18,
                0.296,
                0.194
            ],
            "angle": 0,
            "content": "25. 给出下述集合的递归定义："
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.198,
                0.193,
                0.212
            ],
            "angle": 0,
            "content": "a)正偶数集合"
        },
        {
            "type": "text",
            "bbox": [
                0.461,
                0.198,
                0.724,
                0.212
            ],
            "angle": 0,
            "content": "b)模3与2同余的正整数的集合"
        },
        {
            "type": "text",
            "bbox": [
                0.079,
                0.216,
                0.341,
                0.23
            ],
            "angle": 0,
            "content": "c)不能被5整除的正整数的集合"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.234,
                0.373,
                0.248
            ],
            "angle": 0,
            "content": "26. 设 \\( S \\) 是一个正整数集合，定义如下："
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.252,
                0.223,
                0.265
            ],
            "angle": 0,
            "content": "基础步骤： \\(1\\in S\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.269,
                0.457,
                0.283
            ],
            "angle": 0,
            "content": "归纳步骤：如果 \\(n \\in S\\)，则 \\(3n + 2 \\in S\\) 且 \\(n^2 \\in S\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.287,
                0.373,
                0.301
            ],
            "angle": 0,
            "content": "a) 证明如果 \\( n \\in S \\)，则 \\( n \\equiv 1 (\\mathrm{mod} 4) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.305,
                0.443,
                0.318
            ],
            "angle": 0,
            "content": "b) 证明存在一个整数 \\(m \\equiv 1 (\\mathrm{mod} 4)\\) 不属于 \\(S\\)。"
        },
        {
            "type": "list",
            "bbox": [
                0.08,
                0.287,
                0.443,
                0.318
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.322,
                0.373,
                0.336
            ],
            "angle": 0,
            "content": "27. 设 \\(S\\) 是一个正整数集合，定义如下："
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.34,
                0.218,
                0.353
            ],
            "angle": 0,
            "content": "基础步骤： \\(5\\in S\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.357,
                0.431,
                0.371
            ],
            "angle": 0,
            "content": "归纳步骤：如果 \\(n \\in S\\)，则 \\(3n \\in S\\) 且 \\(n^2 \\in S\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.375,
                0.383,
                0.389
            ],
            "angle": 0,
            "content": "a) 证明如果 \\(n \\in S\\)，则 \\(n \\equiv 5 \\pmod{10}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.393,
                0.453,
                0.407
            ],
            "angle": 0,
            "content": "b) 证明存在一个整数 \\( m \\equiv 5 (\\mathrm{mod} 10) \\) 不属于 \\( S \\)。"
        },
        {
            "type": "list",
            "bbox": [
                0.081,
                0.375,
                0.453,
                0.407
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.411,
                0.43,
                0.425
            ],
            "angle": 0,
            "content": "28. 设 \\(S\\) 是如下递归定义的整数有序对的集合："
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.429,
                0.272,
                0.442
            ],
            "angle": 0,
            "content": "基础步骤： \\((0,0)\\in S\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.446,
                0.646,
                0.46
            ],
            "angle": 0,
            "content": "递归步骤：如果 \\((a, b) \\in S\\)，则 \\((a + 2, b + 3) \\in S\\) 且 \\((a + 3, b + 2) \\in S\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.464,
                0.485,
                0.477
            ],
            "angle": 0,
            "content": "a) 列出递归定义的前 5 次应用所产生的 \\( S \\) 的元素。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.482,
                0.741,
                0.496
            ],
            "angle": 0,
            "content": "b)对定义的递归步骤的应用次数使用强归纳法来证明：当 \\((a,b)\\in S\\) 时， \\(5\\mid a + b\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.501,
                0.479,
                0.516
            ],
            "angle": 0,
            "content": "c)用结构归纳法证明：当 \\((a,b)\\in S\\) 时， \\(5\\mid a + b\\)"
        },
        {
            "type": "list",
            "bbox": [
                0.081,
                0.464,
                0.741,
                0.516
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.521,
                0.45,
                0.535
            ],
            "angle": 0,
            "content": "29. 设 \\( S \\) 是如下递归地定义的整数有序对的集合："
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.539,
                0.272,
                0.552
            ],
            "angle": 0,
            "content": "基础步骤： \\((0,0)\\in S\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.556,
                0.777,
                0.57
            ],
            "angle": 0,
            "content": "递归步骤：如果 \\((a, b) \\in S\\)，则 \\((a, b + 1) \\in S\\)、\\((a + 1, b + 1) \\in S\\) 且 \\((a + 2, b + 1) \\in S\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.574,
                0.486,
                0.588
            ],
            "angle": 0,
            "content": "a) 列出递归定义的前 4 次应用所产生的 \\( S \\) 的元素。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.592,
                0.729,
                0.606
            ],
            "angle": 0,
            "content": "b)对定义的递归步骤的应用次数使用强归纳法来证明：当 \\((a,b)\\in S\\) 时， \\(a\\leqslant 2b\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.609,
                0.468,
                0.624
            ],
            "angle": 0,
            "content": "c)用结构归纳法证明：当 \\((a,b)\\in S\\) 时， \\(a\\leqslant 2b\\)"
        },
        {
            "type": "list",
            "bbox": [
                0.081,
                0.574,
                0.729,
                0.624
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.627,
                0.9,
                0.659
            ],
            "angle": 0,
            "content": "30. 给出下列每个正整数有序对的集合的递归定义。[提示：把集合中的点画在平面上并且寻找包含集合中的点的直线。]"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.663,
                0.46,
                0.678
            ],
            "angle": 0,
            "content": "a) \\(S = \\{(a,b)\\mid a\\in \\mathbf{Z}^{+},b\\in \\mathbf{Z}^{+}\\) 且 \\(a + b\\) 是奇数}"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.682,
                0.395,
                0.697
            ],
            "angle": 0,
            "content": "b) \\(S = \\{(a,b)\\mid a\\in \\mathbf{Z}^{+},b\\in \\mathbf{Z}^{+}\\) 且 \\(a\\mid b\\}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.702,
                0.42,
                0.717
            ],
            "angle": 0,
            "content": "c) \\(S = \\{(a,b)\\mid a\\in \\mathbf{Z}^{+},b\\in \\mathbf{Z}^{+}\\) 且 \\(3\\mid a + b\\}\\)"
        },
        {
            "type": "list",
            "bbox": [
                0.081,
                0.663,
                0.46,
                0.717
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.721,
                0.9,
                0.754
            ],
            "angle": 0,
            "content": "31. 给出下列每个正整数有序对的集合的递归定义。用结构归纳法证明所找到的递归定义是正确的。[提示：为了找出递归定义，把集合中的点画在平面上并且寻找模式。]"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.757,
                0.46,
                0.772
            ],
            "angle": 0,
            "content": "a) \\(S = \\{(a,b)\\mid a\\in \\mathbf{Z}^{+},b\\in \\mathbf{Z}^{+}\\) 且 \\(a + b\\) 是偶数}"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.777,
                0.471,
                0.792
            ],
            "angle": 0,
            "content": "b) \\(S = \\{(a,b)\\mid a\\in \\mathbf{Z}^{+},b\\in \\mathbf{Z}^{+}\\) 且 \\(a\\) 或 \\(b\\) 是奇数}"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.796,
                0.513,
                0.812
            ],
            "angle": 0,
            "content": "c) \\(S = \\{(a,b)\\mid a\\in \\mathbf{Z}^{+},b\\in \\mathbf{Z}^{+}\\) 且 \\(a + b\\) 是奇数且 \\(3\\mid b\\}\\)"
        },
        {
            "type": "list",
            "bbox": [
                0.081,
                0.757,
                0.513,
                0.812
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.816,
                0.58,
                0.83
            ],
            "angle": 0,
            "content": "32. 证明：在比特串中，字符串01至多比字符串10多出现1次。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.834,
                0.726,
                0.848
            ],
            "angle": 0,
            "content": "33. 定义由表示集合的变量和 \\(\\{\\text{一}, \\cup, \\cap, -\\}\\) 中的运算符所组成的集合的合式公式。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.852,
                0.567,
                0.865
            ],
            "angle": 0,
            "content": "34. a)给出计算比特串 \\(s\\) 中1的个数的函数ones(s)的递归定义。"
        },
        {
            "type": "list",
            "bbox": [
                0.051,
                0.816,
                0.726,
                0.865
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.869,
                0.49,
                0.883
            ],
            "angle": 0,
            "content": "b)用结构归纳法证明 \\(\\mathrm{ones}(st) = \\mathrm{ones}(s) + \\mathrm{ones}(t)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.887,
                0.679,
                0.901
            ],
            "angle": 0,
            "content": "35. a)给出等于十进制数字的非空字符串中最小数字的函数 \\( m(s) \\) 的递归定义。"
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.904,
                0.475,
                0.918
            ],
            "angle": 0,
            "content": "b)用结构归纳法证明 \\(m(st) = \\min (m(s),m(t))\\)"
        },
        {
            "type": "list",
            "bbox": [
                0.051,
                0.887,
                0.679,
                0.918
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.922,
                0.885,
                0.937
            ],
            "angle": 0,
            "content": "一个字符串的倒置(反转)，是由原字符串里的符号以相反顺序组成的字符串。把字符串 \\(w\\) 的倒置表示成 \\(\\boldsymbol{w}^{\\mathrm{R}}\\)"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.145,
                0.037,
                0.182,
                0.051
            ],
            "angle": 0,
            "content": "318"
        },
        {
            "type": "header",
            "bbox": [
                0.227,
                0.036,
                0.292,
                0.051
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.093,
                0.346,
                0.106
            ],
            "angle": 0,
            "content": "36. 求出下面比特串的倒置。"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.111,
                0.207,
                0.124
            ],
            "angle": 0,
            "content": "a)0101"
        },
        {
            "type": "text",
            "bbox": [
                0.531,
                0.111,
                0.605,
                0.123
            ],
            "angle": 0,
            "content": "b)1 1011"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.129,
                0.292,
                0.141
            ],
            "angle": 0,
            "content": "c)1000 1001 0111"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.146,
                0.964,
                0.178
            ],
            "angle": 0,
            "content": "37. 给出字符串的倒置的递归定义。[提示：首先定义空串的倒置。然后把长度为 \\( n + 1 \\) 的字符串 \\( w \\) 写成 \\( xy \\)，其中 \\( x \\) 是长度为 \\( n \\) 的字符串，并且利用 \\( x^{\\mathbb{R}} \\) 和 \\( y \\) 来表示 \\( w \\) 的倒置。]"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.182,
                0.465,
                0.195
            ],
            "angle": 0,
            "content": "* 38. 用结构归纳法证明: \\((w_{1}w_{2})^{\\mathrm{R}} = w_{2}^{\\mathrm{R}}w_{1}^{\\mathrm{R}}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.2,
                0.962,
                0.232
            ],
            "angle": 0,
            "content": "39. 给出 \\( w^{i} \\) 的递归定义，其中 \\( w \\) 是字符串而 \\( i \\) 是非负整数。（这里 \\( w^{i} \\) 表示字符串 \\( w \\) 的 \\( i \\) 份复制品的连接。）"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.237,
                0.438,
                0.249
            ],
            "angle": 0,
            "content": "* 40. 给出回文比特串的集合的递归定义。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.255,
                0.323,
                0.268
            ],
            "angle": 0,
            "content": "41. 比特串集合 \\(A\\) 定义成"
        },
        {
            "type": "equation",
            "bbox": [
                0.493,
                0.273,
                0.539,
                0.286
            ],
            "angle": 0,
            "content": "\\[\n\\lambda \\in A\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.495,
                0.291,
                0.619,
                0.304
            ],
            "angle": 0,
            "content": "\\[\n0 x _ {1} \\in A \\quad x \\in A\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.307,
                0.438,
                0.322
            ],
            "angle": 0,
            "content": "其中 \\(\\lambda\\) 是空串。哪些字符串属于 \\(A\\)？"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.326,
                0.55,
                0.339
            ],
            "angle": 0,
            "content": "* 42. 递归地定义：所包含的0比1多的比特串的集合。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.343,
                0.816,
                0.357
            ],
            "angle": 0,
            "content": "43. 用练习37和数学归纳法证明：\\(l(w^{i}) = i \\cdot l(w)\\)，其中 \\(w\\) 是比特串而 \\(i\\) 是非负整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.361,
                0.961,
                0.393
            ],
            "angle": 0,
            "content": "* 44. 证明：当 \\(w\\) 是比特串而 \\(i\\) 是非负整数时，有 \\((w^{\\mathbb{R}})^{i} = (w^{i})^{\\mathbb{R}}\\)。即证明一个字符串的倒置的 \\(i\\) 次幂是这个字符串的 \\(i\\) 次幂的倒置。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.397,
                0.962,
                0.43
            ],
            "angle": 0,
            "content": "45. 用结构归纳法证明：\\(n(T) \\geqslant 2h(T) + 1\\)，其中 \\(T\\) 是满二叉树，\\(n(T)\\) 等于 \\(T\\) 的顶点数，\\(h(T)\\) 是 \\(T\\) 的高度。"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.434,
                0.475,
                0.447
            ],
            "angle": 0,
            "content": "可以递归地定义满二叉树的树叶和内点。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.452,
                0.751,
                0.465
            ],
            "angle": 0,
            "content": "基础步骤：树根 \\(r\\) 是恰有一个顶点 \\(r\\) 的满二叉树的树叶。这个树没有内点。"
        },
        {
            "type": "text",
            "bbox": [
                0.144,
                0.469,
                0.961,
                0.501
            ],
            "angle": 0,
            "content": "递归步骤：树 \\(T = T_{1} \\cdot T_{2}\\) 的树叶集合是 \\(T_{1}\\) 的树叶集合与 \\(T_{2}\\) 的树叶集合的并。\\(T\\) 的内点集合是 \\(T\\) 的树根 \\(r\\) 与 \\(T_{1}\\) 的内点集合与 \\(T_{2}\\) 的内点集合的并。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.505,
                0.729,
                0.519
            ],
            "angle": 0,
            "content": "46. 用结构归纳法证明：满二叉树 \\(T\\) 的树叶数 \\(l(T)\\) 比 \\(T\\) 的内点数 \\(i(T)\\) 多 1。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.523,
                0.706,
                0.537
            ],
            "angle": 0,
            "content": "47. 仿照例13用广义归纳法证明：如果把 \\(a_{m,n}\\) 递归地定义成 \\(a_{0,0} = 0\\) 并且"
        },
        {
            "type": "equation",
            "bbox": [
                0.42,
                0.541,
                0.691,
                0.574
            ],
            "angle": 0,
            "content": "\\[\na _ {m, n} = \\left\\{ \\begin{array}{l l} a _ {m - 1, n} + 1 & n = 0 \\text {且} m > 0 \\\\ a _ {m, n - 1} + 1 & n > 0 \\end{array} \\right.\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.578,
                0.526,
                0.592
            ],
            "angle": 0,
            "content": "则对于所有 \\((m,n)\\in \\mathbf{N}\\times \\mathbf{N}\\) 来说， \\(a_{m,n} = m + n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.595,
                0.706,
                0.609
            ],
            "angle": 0,
            "content": "48.仿照例15用广义归纳法证明：如果把 \\(a_{m,n}\\) 递归地定义成 \\(a_{1,1} = 5\\) 并且"
        },
        {
            "type": "equation",
            "bbox": [
                0.425,
                0.613,
                0.688,
                0.645
            ],
            "angle": 0,
            "content": "\\[\n\\left\\{ \\begin{array}{l l} a _ {m, n} = a _ {m - 1, n} + 2 & n = 1 \\text {且} m > 1 \\\\ a _ {m, n - 1} + 2 & n > 1 \\end{array} \\right.\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.65,
                0.6,
                0.664
            ],
            "angle": 0,
            "content": "则对于所有 \\((m,n)\\in \\mathbf{Z}^{+}\\times \\mathbf{Z}^{+}\\) 来说， \\(a_{m,n} = 2(m + n) + 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.667,
                0.964,
                0.717
            ],
            "angle": 0,
            "content": "* 49. 正整数 \\( n \\) 的分拆是把 \\( n \\) 写成正整数之和的方式。例如，\\( 7 = 3 + 2 + 1 + 1 \\) 是 7 的分拆。设 \\( P_{m} \\) 等于 \\( m \\) 的不同分拆的数目，其中和式里项的顺序无关紧要，并设 \\( P_{m,n} \\) 是用不超过 \\( n \\) 的正整数之和来表示 \\( m \\) 的不同方式数。"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.722,
                0.312,
                0.735
            ],
            "angle": 0,
            "content": "a) 证明: \\(P_{m,m} = P_m\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.74,
                0.494,
                0.753
            ],
            "angle": 0,
            "content": "b) 证明：下面的 \\(P_{m,n}\\) 的递归定义是正确的。"
        },
        {
            "type": "equation",
            "bbox": [
                0.417,
                0.758,
                0.696,
                0.843
            ],
            "angle": 0,
            "content": "\\[\nP _ {m, n} = \\left\\{ \\begin{array}{l l} 1 & m = 1 \\\\ 1 & n = 1 \\\\ P _ {m, m} & m <   n \\\\ 1 + P _ {m, m - 1} & m = n > 1 \\\\ P _ {m, n - 1} + P _ {m - n, n} & m > n > 1 \\end{array} \\right.\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.847,
                0.473,
                0.861
            ],
            "angle": 0,
            "content": "c)用这个递归定义求出5和6的分拆数。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.867,
                0.099,
                0.88
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.864,
                0.964,
                0.934
            ],
            "angle": 0,
            "content": "考虑阿克曼函数的一个变种的下述归纳定义。这个函数是根据德国数学家威尔海姆·阿克曼的名字来命名的，他是大数学家大卫·希尔伯特的学生。在递归函数论以及涉及集合合并的某些算法的复杂性研究中，阿克曼函数起到了重要的作用。（这个函数有多种不同的变种，都称为阿克曼函数，并且都有类似的性质，尽管它们的值不一定相等。）"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.677,
                0.04,
                0.788,
                0.056
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.833,
                0.042,
                0.87,
                0.056
            ],
            "angle": 0,
            "content": "319"
        },
        {
            "type": "equation",
            "bbox": [
                0.264,
                0.097,
                0.686,
                0.165
            ],
            "angle": 0,
            "content": "\\[\nA (m, n) = \\left\\{ \\begin{array}{l l} 2 n & m = 0 \\\\ 0 & m \\geqslant 1, n = 0 \\\\ 2 & m \\geqslant 1, n = 1 \\\\ A (m - 1, A (m, n - 1)) & m \\geqslant 1, n \\geqslant 2 \\end{array} \\right.\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.168,
                0.385,
                0.182
            ],
            "angle": 0,
            "content": "练习 \\(50\\sim 57\\) 涉及这种形式的阿克曼函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.185,
                0.297,
                0.2
            ],
            "angle": 0,
            "content": "50. 求出下列阿克曼函数的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.203,
                0.171,
                0.216
            ],
            "angle": 0,
            "content": "a) \\(A(1,0)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.464,
                0.203,
                0.553,
                0.216
            ],
            "angle": 0,
            "content": "b) \\(A(0,1)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.221,
                0.169,
                0.234
            ],
            "angle": 0,
            "content": "c) \\(A(1, 1)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.464,
                0.221,
                0.553,
                0.234
            ],
            "angle": 0,
            "content": "d) \\(A(2,2)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.239,
                0.378,
                0.253
            ],
            "angle": 0,
            "content": "51. 证明：当 \\(m \\geqslant 1\\) 时，有 \\(A(m,2) = 4\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.256,
                0.378,
                0.27
            ],
            "angle": 0,
            "content": "52. 证明：当 \\(n \\geqslant 1\\) 时，有 \\(A(1, n) = 2^n\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.274,
                0.297,
                0.288
            ],
            "angle": 0,
            "content": "53. 求出下列阿克曼函数的值。"
        },
        {
            "type": "list",
            "bbox": [
                0.05,
                0.239,
                0.378,
                0.288
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.291,
                0.171,
                0.305
            ],
            "angle": 0,
            "content": "a) \\(A(2,3)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.41,
                0.292,
                0.512,
                0.304
            ],
            "angle": 0,
            "content": "\\(\\star \\mathbf{b})A(3,3)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.035,
                0.309,
                0.203,
                0.323
            ],
            "angle": 0,
            "content": "*54. 求出 \\(A(3, 4)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.027,
                0.326,
                0.592,
                0.341
            ],
            "angle": 0,
            "content": "**55. 证明：当 \\( m \\) 和 \\( n \\) 都是非负整数时，有 \\( A(m, n + 1) > A(m, n) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.027,
                0.344,
                0.592,
                0.359
            ],
            "angle": 0,
            "content": "* 56. 证明：当 \\( m \\) 和 \\( n \\) 都是非负整数时，有 \\( A(m + 1, n) \\geqslant A(m, n) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.362,
                0.481,
                0.377
            ],
            "angle": 0,
            "content": "57. 证明：当 \\(i\\) 和 \\(j\\) 都是非负整数时，有 \\(A(i, j) \\geqslant j\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.379,
                0.851,
                0.394
            ],
            "angle": 0,
            "content": "58. 用数学归纳法证明：通过规定 \\( F(0) \\) 和从 \\( F(n) \\) 获得 \\( F(n + 1) \\) 的规则所定义的函数 \\( F \\) 是良定义的。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.397,
                0.895,
                0.429
            ],
            "angle": 0,
            "content": "59. 用数学归纳法第二原理证明：通过规定 \\( F(0) \\) 以及从 \\( F(k) (k = 0, 1, 2, \\dots, n) \\) 获得 \\( F(n + 1) \\) 的规则所定义的函数是良定义的。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.432,
                0.778,
                0.447
            ],
            "angle": 0,
            "content": "60. 证明：下述每一个所谓的对正整数集合上的函数的递归定义都不能产生良定义的函数。"
        },
        {
            "type": "list",
            "bbox": [
                0.027,
                0.309,
                0.895,
                0.447
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.45,
                0.49,
                0.464
            ],
            "angle": 0,
            "content": "a)对 \\(n\\geqslant 1\\) 来说 \\(F(n) = 1 + F(\\lfloor n / 2\\rfloor)\\) ，且 \\(F(1) = 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.468,
                0.576,
                0.482
            ],
            "angle": 0,
            "content": "b)对 \\(n\\geqslant 2\\) 来说 \\(F(n) = 1 + F(n - 3)\\) ，且 \\(F(1) = 2\\) 和 \\(F(2) = 3\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.485,
                0.565,
                0.499
            ],
            "angle": 0,
            "content": "c)对 \\(n\\geqslant 2\\) 来说 \\(F(n) = 1 + F(n / 2)\\) ，且 \\(F(1) = 1\\) 和 \\(F(2) = 2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.502,
                0.861,
                0.517
            ],
            "angle": 0,
            "content": "d)若 \\(n\\) 是偶数且 \\(n\\geq 2\\) ，则 \\(F(n) = 1 + F(n / 2)\\) ；若 \\(n\\) 是奇数，则 \\(F(n) = 1 - F(n - 1)\\) ，且 \\(F(1) = 1\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.52,
                0.88,
                0.535
            ],
            "angle": 0,
            "content": "e)若 \\(n\\) 是偶数且 \\(n\\geqslant 2\\) ，则 \\(F(n) = 1 + F(n / 2)\\) ；若 \\(n\\) 是奇数且 \\(n\\geqslant 3\\) ，则 \\(F(n) = F(3n - 1)\\) ，且 \\(F(1) = 1\\) 。"
        },
        {
            "type": "list",
            "bbox": [
                0.078,
                0.45,
                0.88,
                0.535
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.538,
                0.778,
                0.553
            ],
            "angle": 0,
            "content": "61. 证明：下述每一个所谓的对正整数集合上的函数的递归定义都不能产生良定义的函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.555,
                0.531,
                0.57
            ],
            "angle": 0,
            "content": "a)对 \\(n\\geqslant 1\\) 来说 \\(F(n) = 1 + F(\\lfloor (n + 1) / 2\\rfloor)\\) ，且 \\(F(1) = 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.574,
                0.481,
                0.587
            ],
            "angle": 0,
            "content": "b)对 \\(n\\geqslant 2\\) 来说 \\(F(n) = 1 + F(n - 2)\\) ，且 \\(F(1) = 0\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.591,
                0.641,
                0.605
            ],
            "angle": 0,
            "content": "c)对 \\(n\\geqslant 3\\) 来说 \\(F(n) = 1 + F(n / 3)\\) ，且 \\(F(1) = 1\\) ， \\(F(2) = 2\\) ， \\(F(3) = 3\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.608,
                0.861,
                0.623
            ],
            "angle": 0,
            "content": "d)若 \\(n\\) 是偶数且 \\(n\\geqslant 2\\) ，则 \\(F(n) = 1 + F(n / 2)\\) ；若 \\(n\\) 是奇数，则 \\(F(n) = 1 + F(n - 2)\\) ，且 \\(F(1) = 1\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.626,
                0.504,
                0.64
            ],
            "angle": 0,
            "content": "e) 若 \\( n \\geq 2 \\)，则 \\( F(n) = 1 + F(F(n - 1)) \\)，且 \\( F(1) = 2 \\)。"
        },
        {
            "type": "list",
            "bbox": [
                0.078,
                0.555,
                0.861,
                0.64
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.644,
                0.875,
                0.659
            ],
            "angle": 0,
            "content": "练习 \\(62\\sim 64\\) 处理对数函数的迭代。像通常一样，设 \\(\\log n\\) 表示以2为底 \\(n\\) 的对数。函数 \\(\\log^{(k)}n\\) 递归地定义成"
        },
        {
            "type": "equation",
            "bbox": [
                0.261,
                0.662,
                0.678,
                0.712
            ],
            "angle": 0,
            "content": "\\[\n\\log^ {(k)} n = \\left\\{ \\begin{array}{l l} n & k = 0 \\\\ \\log (\\log^ {(k - 1)} n) & \\log^ {(k - 1)} n \\text {有 定 义 且 为 正 数} \\\\ \\text {无 定 义} & \\text {其 他 情 况} \\end{array} \\right.\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.715,
                0.674,
                0.73
            ],
            "angle": 0,
            "content": "迭代对数是函数 \\(\\log^{*}n\\) ，它在 \\(n\\) 处的值是使得 \\(\\log^{(k)}n\\leqslant 1\\) 的最小的非负整数 \\(k\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.733,
                0.258,
                0.747
            ],
            "angle": 0,
            "content": "62. 求出下述的每一个值："
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.749,
                0.161,
                0.765
            ],
            "angle": 0,
            "content": "a) \\(\\log^{(2)}16\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.269,
                0.75,
                0.359,
                0.765
            ],
            "angle": 0,
            "content": "b) \\(\\log^{(3)}256\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.468,
                0.75,
                0.569,
                0.765
            ],
            "angle": 0,
            "content": "c) \\(\\log^{(3)}2^{65536}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.679,
                0.749,
                0.776,
                0.765
            ],
            "angle": 0,
            "content": "d) \\(\\log^{(4)}2^{65536}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.768,
                0.424,
                0.783
            ],
            "angle": 0,
            "content": "63. 对下述的每一个 \\(\\log^* n\\) 的值，求出 \\(n\\) 的值："
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.786,
                0.111,
                0.798
            ],
            "angle": 0,
            "content": "a)2"
        },
        {
            "type": "text",
            "bbox": [
                0.269,
                0.787,
                0.298,
                0.799
            ],
            "angle": 0,
            "content": "b)4"
        },
        {
            "type": "text",
            "bbox": [
                0.468,
                0.787,
                0.496,
                0.799
            ],
            "angle": 0,
            "content": "c)8"
        },
        {
            "type": "text",
            "bbox": [
                0.679,
                0.787,
                0.718,
                0.799
            ],
            "angle": 0,
            "content": "d)16"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.804,
                0.127,
                0.816
            ],
            "angle": 0,
            "content": "e)256"
        },
        {
            "type": "text",
            "bbox": [
                0.269,
                0.804,
                0.337,
                0.816
            ],
            "angle": 0,
            "content": "f)65536"
        },
        {
            "type": "text",
            "bbox": [
                0.468,
                0.804,
                0.519,
                0.817
            ],
            "angle": 0,
            "content": "g)22048"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.821,
                0.577,
                0.835
            ],
            "angle": 0,
            "content": "64. 求出使得 \\(\\log^* n = 5\\) 的最小整数 \\(n\\) 。确定这个数的十进制位数。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.838,
                0.894,
                0.888
            ],
            "angle": 0,
            "content": "练习 \\(65\\sim 67\\) 处理迭代函数的值。假定 \\(f(n)\\) 是从实数集合或正实数集合或某些其他的实数集合到实数集合的函数，使得 \\(f(n)\\) 是单调递增的（即当 \\(n < m\\) 时，有 \\(f(n) < f(m)\\)，并且对 \\(f\\) 的定义域里的所有 \\(n\\) 来说，\\(f(n) < n\\)）。函数 \\(f^{(k)}(n)\\) 递归地定义成"
        },
        {
            "type": "equation",
            "bbox": [
                0.343,
                0.892,
                0.598,
                0.924
            ],
            "angle": 0,
            "content": "\\[\nf ^ {(k)} (n) = \\left\\{ \\begin{array}{l l} n & k = 0 \\\\ f (f ^ {(k - 1)} (n)) & k > 0 \\end{array} \\right.\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.927,
                0.894,
                0.942
            ],
            "angle": 0,
            "content": "另外，设 \\(c\\) 是正实数。迭代函数 \\(f_{c}^{*}\\) 是为了把 \\(f\\) 的自变量缩小到小于或等于 \\(c\\) 所需要的 \\(f\\) 的迭代次数，所"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.131,
                0.041,
                0.167,
                0.054
            ],
            "angle": 0,
            "content": "320"
        },
        {
            "type": "header",
            "bbox": [
                0.212,
                0.039,
                0.278,
                0.055
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.096,
                0.5,
                0.111
            ],
            "angle": 0,
            "content": "以 \\(f_{c}^{*}(n)\\) 是使得 \\(f^{(k)}(n)\\leqslant c\\) 的最小的非负整数 \\(k\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.114,
                0.899,
                0.128
            ],
            "angle": 0,
            "content": "65. 设 \\( f(n) = n - a \\)，其中 \\( a \\) 是正整数。求出 \\( f^{(k)}(n) \\) 的公式。当 \\( n \\) 是正整数时，\\( f_0^*(n) \\) 的值是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.131,
                0.742,
                0.146
            ],
            "angle": 0,
            "content": "66. 设 \\( f(n) = n / 2 \\) 。求出 \\( f^{(k)}(n) \\) 的公式。当 \\( n \\) 是正整数时，\\( f_{1}^{*}(n) \\) 的值是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.15,
                0.733,
                0.165
            ],
            "angle": 0,
            "content": "67. 设 \\( f(n) = \\sqrt{n} \\) 。求出 \\( f^{(k)}(n) \\) 的公式。当 \\( n \\) 是正整数时，\\( f_{2}^{*}(n) \\) 的值是什么？"
        },
        {
            "type": "list",
            "bbox": [
                0.101,
                0.114,
                0.899,
                0.165
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.102,
                0.179,
                0.281,
                0.198
            ],
            "angle": 0,
            "content": "5.4 递归算法"
        },
        {
            "type": "title",
            "bbox": [
                0.102,
                0.206,
                0.232,
                0.223
            ],
            "angle": 0,
            "content": "5.4.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.227,
                0.955,
                0.319
            ],
            "angle": 0,
            "content": "有时可以把带有具体的一组输入问题的解归约到带更小的一组输入的相同问题的解。例如，求两个正整数 \\(a\\) 和 \\(b\\) 的最大公因子的问题，其中 \\(b > a\\) ，就可以归约到求一对更小的整数（即 \\(b \\mod a\\) 和 \\(a\\) )的最大公因子的问题，因为 \\(\\gcd(b \\mod a, a) = \\gcd(a, b)\\) 。当可以实现这样的归约时，就可以用一系列归约来求出原问题的解，直到把问题归约到解是已知的某个初始情形为止。例如，对求最大公因子来说，归约持续到两个数中较小的一个为零，因为当 \\(a > 0\\) 时，\\(\\gcd(a, 0) = a\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.321,
                0.953,
                0.356
            ],
            "angle": 0,
            "content": "我们将看到，连续地把问题归约到带更小输入的相同问题，这样的算法可用来解决广泛的问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.364,
                0.945,
                0.401
            ],
            "angle": 0,
            "content": "定义1 若一个算法通过把问题归约到带更小输入的相同问题的实例来解决原来的问题，则这个算法称为递归的。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.41,
                0.449,
                0.426
            ],
            "angle": 0,
            "content": "本节将描述大量不同的递归算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.431,
                0.661,
                0.448
            ],
            "angle": 0,
            "content": "例1 给出计算 \\( n! \\) 的递归算法，其中 \\( n \\) 是一个非负整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.453,
                0.955,
                0.525
            ],
            "angle": 0,
            "content": "解 可以建立一个求 \\(n!\\) 的递归算法，其中 \\(n\\) 是一个非负整数。根据 \\(n!\\) 的递归定义，当 \\(n\\) 是一个正整数时，\\(n! = n \\cdot (n - 1)!\\)，且 \\(0! = 1\\)。为了对某个特定的整数求 \\(n!\\)，执行 \\(n\\) 次递归，每一次都用在下一个较小整数处的阶乘函数值代替阶乘函数的值。在最后一步时，代入 \\(0!\\)。所得到的递归算法由算法1所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.528,
                0.955,
                0.6
            ],
            "angle": 0,
            "content": "为了理解该算法是如何工作的，我们来追踪用算法计算4！时的每一步。首先，利用归纳步骤，有 \\( 4! = 4 \\cdot 3! \\) 。然后，重复使用归纳步骤，有 \\( 3! = 3 \\cdot 2! \\) 、 \\( 2! = 2 \\cdot 1! \\) 、 \\( 1! = 1 \\cdot 0! \\) 。代入 \\( 0! = 1 \\) 的值，并回代以上各步，即得 \\( 1! = 1 \\cdot 1 = 1 \\) 、 \\( 2! = 2 \\cdot 1! = 2 \\) 、 \\( 3! = 3 \\cdot 2! = 3 \\cdot 2 = 6 \\) 、 \\( 4! = 4 \\cdot 3! = 4 \\cdot 6 = 24 \\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.618,
                0.386,
                0.634
            ],
            "angle": 0,
            "content": "算法1 计算 \\(n!\\) 的递归算法"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.637,
                0.388,
                0.651
            ],
            "angle": 0,
            "content": "procedure factorial(n: 非负整数)"
        },
        {
            "type": "text",
            "bbox": [
                0.124,
                0.655,
                0.289,
                0.667
            ],
            "angle": 0,
            "content": "if \\( n = 0 \\) then return 1"
        },
        {
            "type": "text",
            "bbox": [
                0.124,
                0.672,
                0.358,
                0.685
            ],
            "angle": 0,
            "content": "else return \\( n \\) · factorial(n-1)"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.689,
                0.223,
                0.703
            ],
            "angle": 0,
            "content": "{输出是 \\(n!\\) 1"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.725,
                0.8,
                0.741
            ],
            "angle": 0,
            "content": "例2说明了如何构造一个递归算法，从函数的递归定义来计算函数的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.747,
                0.758,
                0.763
            ],
            "angle": 0,
            "content": "例2给出计算 \\(a^n\\) 的递归算法，其中 \\(a\\) 是非零实数而 \\(n\\) 是非负整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.768,
                0.957,
                0.821
            ],
            "angle": 0,
            "content": "解 可以让递归算法是基于 \\(a^n\\) 的递归定义。这个定义说对 \\(n > 0\\) 来说有 \\(a^{n + 1} = a\\cdot a^n\\) ，而初始条件是 \\(a^0 = 1\\) 。为了求出 \\(a^n\\) ，连续地用这个递归定义来缩小指数，直到指数是0。在算法2里给出了这个过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.124,
                0.841,
                0.356,
                0.856
            ],
            "angle": 0,
            "content": "算法2 计算 \\(a^n\\) 的递归算法"
        },
        {
            "type": "text",
            "bbox": [
                0.124,
                0.859,
                0.496,
                0.874
            ],
            "angle": 0,
            "content": "procedure power(a：非零实数， \\(n\\) ：非负整数）"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.877,
                0.291,
                0.89
            ],
            "angle": 0,
            "content": "if \\(n = 0\\) then return 1"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.895,
                0.372,
                0.909
            ],
            "angle": 0,
            "content": "else return \\(a\\cdot\\) power \\((a,n - 1)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.913,
                0.224,
                0.927
            ],
            "angle": 0,
            "content": "{输出是 \\(a^n\\) 1"
        },
        {
            "type": "image",
            "bbox": [
                0.031,
                0.413,
                0.092,
                0.446
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.671,
                0.038,
                0.78,
                0.052
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.827,
                0.039,
                0.86,
                0.052
            ],
            "angle": 0,
            "content": "321"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.094,
                0.405,
                0.11
            ],
            "angle": 0,
            "content": "下面给出求最大公因子的递归算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.116,
                0.734,
                0.134
            ],
            "angle": 0,
            "content": "例3 给出求满足 \\(a < b\\) 的两个非负整数 \\(a\\) 和 \\(b\\) 的最大公因子的递归算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.14,
                0.893,
                0.176
            ],
            "angle": 0,
            "content": "解 可以基于 \\(\\gcd(a, b) = \\gcd(b \\bmod a, a)\\) 和当 \\(b > 0\\) 时 \\(\\gcd(0, b) = b\\) 找出递归算法中的过程。这产生了欧几里得算法的递归版本——算法3。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.179,
                0.896,
                0.277
            ],
            "angle": 0,
            "content": "当输入为 \\(a = 5\\)、\\(b = 8\\) 时，跟踪算法3以说明它是如何工作的。对该输入，算法执行“else”语句，得到 \\(\\gcd(5, 8) = \\gcd(8 \\mod 5, 5) = \\gcd(3, 5)\\)。再执行此语句，得到 \\(\\gcd(3, 5) = \\gcd(5 \\mod 3, 3) = \\gcd(2, 3)\\)，然后得到 \\(\\gcd(2, 3) = \\gcd(3 \\mod 2, 2) = \\gcd(1, 2)\\)，再得到 \\(\\gcd(1, 2) = \\gcd(2 \\mod 1, 1) = \\gcd(0, 1)\\)。最后，算法执行第一步，由 \\(a = 0\\) 得到 \\(\\gcd(0, 1) = 1\\)。因此，算法的执行结果是 \\(\\gcd(5, 8) = 1\\)。"
        },
        {
            "type": "code",
            "bbox": [
                0.06,
                0.298,
                0.378,
                0.39
            ],
            "angle": 0,
            "content": "算法3 计算 \\(\\gcd(a, b)\\) 的递归算法  \nprocedure \\(\\gcd(a, b)\\) : 非负整数且 \\(a < b\\)  \nif \\(a = 0\\) then return \\(b\\)  \nelse return \\(\\gcd(b \\mod a, a)\\)  \n{输出是 \\(\\gcd(a, b)\\)}"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.415,
                0.897,
                0.455
            ],
            "angle": 0,
            "content": "例4 设计一个计算 \\( b^n \\mod m \\) 的递归算法，其中 \\( b \\)、\\( n \\) 和 \\( m \\) 是满足 \\( m \\geqslant 2 \\)、\\( n \\geqslant 0 \\) 且 \\( 1 \\leqslant b < m \\) 的整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.459,
                0.897,
                0.496
            ],
            "angle": 0,
            "content": "解 可以基于 \\(b^n \\bmod m = (b \\cdot (b^{n-1} \\bmod m)) \\bmod m\\) 这个事实来构建递归算法，这个事实来自4.1节推论2和初始条件 \\(b^0 \\bmod m = 1\\)。在本节把这个事实留给读者作为练习12。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.5,
                0.657,
                0.516
            ],
            "angle": 0,
            "content": "然而，通过观察下面的事实，可以设计出效率更高的递归算法。"
        },
        {
            "type": "equation",
            "bbox": [
                0.331,
                0.52,
                0.615,
                0.536
            ],
            "angle": 0,
            "content": "\\[\nb ^ {n} \\operatorname {m o d} m = (b ^ {n / 2} \\operatorname {m o d} m) ^ {2} \\operatorname {m o d} m\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.54,
                0.235,
                0.556
            ],
            "angle": 0,
            "content": "当 \\(n\\) 是偶数时，以及"
        },
        {
            "type": "equation",
            "bbox": [
                0.238,
                0.56,
                0.711,
                0.576
            ],
            "angle": 0,
            "content": "\\[\nb ^ {n} \\operatorname {m o d} m = ((b ^ {\\lfloor n / 2 \\rfloor} \\operatorname {m o d} m) ^ {2} \\operatorname {m o d} m \\cdot b \\operatorname {m o d} m) \\operatorname {m o d} m\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.58,
                0.405,
                0.597
            ],
            "angle": 0,
            "content": "当 \\(n\\) 是奇数时，用伪码将其写成算法4。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.6,
                0.901,
                0.739
            ],
            "angle": 0,
            "content": "下面对输入 \\(b = 2\\)、\\(n = 5\\) 及 \\(m = 3\\) 来跟踪算法4，以说明该算法是如何工作的。首先，由于 \\(n = 5\\) 是奇数，所以执行“else”语句，从而有 \\(\\mathrm{mpower}(2,5,3) = (\\mathrm{mpower}(2,2,3)^2\\bmod 3\\cdot 2\\bmod 3)\\bmod 3\\)。接下来执行“else if”语句，得到 \\(\\mathrm{mpower}(2,2,3) = \\mathrm{mpower}(2,1,3)^2\\bmod 3\\)。再执行“else”语句，得到 \\(\\mathrm{mpower}(2,1,3) = (\\mathrm{mpower}(2,0,3)^2\\bmod 3\\cdot 2\\bmod 3)\\bmod 3\\)。最后，执行“if”语句，得到 \\(\\mathrm{mpower}(2,0,3) = 1\\)。下面进行回代，得到 \\(\\mathrm{mpower}(2,1,3) = 1^2\\bmod 3\\cdot 2\\bmod 3)\\bmod 3 = 2\\)，从而 \\(\\mathrm{mpower}(2,2,3) = 2^2\\bmod 3 = 1\\)，最后，\\(\\mathrm{mpower}(2,5,3) = (1^2\\bmod 3\\cdot 2\\bmod 3)\\bmod 3 = 2\\)。"
        },
        {
            "type": "title",
            "bbox": [
                0.065,
                0.763,
                0.231,
                0.779
            ],
            "angle": 0,
            "content": "算法4 递归模指数"
        },
        {
            "type": "code",
            "bbox": [
                0.065,
                0.782,
                0.562,
                0.929
            ],
            "angle": 0,
            "content": "procedurempower \\((b,n,m\\) ：整数且 \\(b > 0\\) ， \\(m\\geqslant 2\\) ， \\(n\\geqslant 0)\\)   \nif \\(n = 0\\) then return1   \nelse if \\(n\\) 是偶数then returnmpower \\((b,n / 2,m)^{2}\\mod m\\)   \nelse return(mpower \\((b,\\lfloor n / 2\\rfloor ,m)^{2}\\mod m\\cdot b\\bmod m)\\bmod m\\)   \n{输出是 \\(b^{n}\\mathrm{mod}m\\}\\)"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.127,
                0.04,
                0.164,
                0.054
            ],
            "angle": 0,
            "content": "322"
        },
        {
            "type": "header",
            "bbox": [
                0.208,
                0.039,
                0.275,
                0.054
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.095,
                0.605,
                0.111
            ],
            "angle": 0,
            "content": "现在将要给出3.1节所介绍的搜索算法的递归形式。"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.117,
                0.494,
                0.134
            ],
            "angle": 0,
            "content": "例5 把线性搜索算法表达成递归过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.139,
                0.948,
                0.194
            ],
            "angle": 0,
            "content": "解为了在搜索序列 \\(a_1,a_2,\\dots ,a_n\\) 中搜索 \\(\\mathcal{X}\\) ，在算法的第 \\(i\\) 步比较 \\(\\mathcal{X}\\) 与 \\(a_{i}\\) 。若 \\(\\mathcal{X}\\) 等于 \\(a_{i}\\) 则 \\(i\\) 是 \\(\\mathcal{X}\\) 的位置。否则，对 \\(\\mathcal{X}\\) 的搜索就归约到在少了一个元素的序列（即序列 \\(a_{i + 1},\\dots ,a_n)\\) 中的搜索。现在给出一个递归过程，用伪码把这个过程表示成算法5。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.197,
                0.948,
                0.271
            ],
            "angle": 0,
            "content": "设 \\(\\operatorname{search}(i, j, x)\\) 是在序列 \\(a_{i}, a_{i+1}, \\cdots, a_{j}\\) 中搜索 \\(x\\) 的过程。过程的输入包括三元组 \\((1, n, x)\\) 。若剩余序列的第一项是 \\(x\\) ，或者若序列只有一项并且它不是 \\(x\\) ，则过程在这一步终止。若 \\(x\\) 不是第一项而且存在其他的项，则执行同样的过程，但是搜索序列减少一项，它是通过删除搜索序列的第一项而获得的。"
        },
        {
            "type": "title",
            "bbox": [
                0.113,
                0.292,
                0.335,
                0.307
            ],
            "angle": 0,
            "content": "算法5 递归线性搜索算法"
        },
        {
            "type": "code",
            "bbox": [
                0.111,
                0.31,
                0.616,
                0.451
            ],
            "angle": 0,
            "content": "procedure search \\((i,j,x\\) ： \\(i\\) ， \\(j\\) ， \\(x\\) 是整数， \\(1\\leqslant i\\leqslant j\\leqslant n)\\)   \nif \\(a_{i} = x\\) then  \nreturn \\(i\\)   \nelse if \\(i = j\\) then  \nreturn 0  \nelse  \nreturn search \\((i + 1,j,x)\\)   \n{输出是 \\(a_1,a_2,\\dots ,a_n\\) 中 \\(x\\) 的位置，如果有 \\(x\\) ；否则它是0}"
        },
        {
            "type": "text",
            "bbox": [
                0.134,
                0.466,
                0.463,
                0.483
            ],
            "angle": 0,
            "content": "例6构造二分搜索算法的递归形式。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.488,
                0.948,
                0.582
            ],
            "angle": 0,
            "content": "解 假定要在序列 \\(a_1, a_2, \\dots, a_n\\) 中求出 \\(x\\) 的位置。为了执行二分搜索，首先比较 \\(x\\) 与中间项 \\(a(n + 1) / 2\\) 。若 \\(x\\) 等于这一项，则算法将终止。否则，把搜索归约到更小的搜索序列，即若 \\(x\\) 小于原序列的中间项，则归约到序列的前一半，否则归约到后一半。已经把搜索问题的解归约到带长度近似为一半的序列的相同问题的解。二分搜索算法的这种递归形式表达成算法6。"
        },
        {
            "type": "title",
            "bbox": [
                0.113,
                0.604,
                0.335,
                0.619
            ],
            "angle": 0,
            "content": "算法6 递归二分搜索算法"
        },
        {
            "type": "code",
            "bbox": [
                0.111,
                0.622,
                0.682,
                0.798
            ],
            "angle": 0,
            "content": "procedure binary search \\((i,j,x\\) ： \\(i\\) ， \\(j\\) ， \\(x\\) 是整数， \\(1\\leqslant i\\leqslant n\\) ， \\(1\\leqslant j\\leqslant n)\\)   \n\\(m:=\\lfloor (i+j)/2\\rfloor\\)   \nif \\(x=a_{m}\\) then  \nreturn m  \nelse if \\((x<a_{m}\\) and \\(i<m)\\) then  \nreturn binary search \\((i,m-1,x)\\)  \nelse if \\((x>a_{m}\\) and \\(j>m)\\) then  \nreturn binary search \\((m+1,j,x)\\)  \nelse return 0  \n{输出是 \\(a_{1},a_{2},\\dots,a_{n}\\) 中 \\(x\\) 的位置，如果有 \\(x\\) ；否则为0}"
        },
        {
            "type": "title",
            "bbox": [
                0.098,
                0.819,
                0.406,
                0.836
            ],
            "angle": 0,
            "content": "5.4.2 证明递归算法的正确性"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.839,
                0.946,
                0.893
            ],
            "angle": 0,
            "content": "数学归纳法以及它的变种——强归纳法，都可以证明一个递归算法的正确性，即可以证明算法对所有可能的输入值，都能产生所需要的输出。例7和例8说明了如何用数学归纳法或强归纳法来证明算法的正确性。首先，证明算法2的正确性。"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.899,
                0.508,
                0.916
            ],
            "angle": 0,
            "content": "例7 证明算法2（求实数的幂）的正确性。"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.922,
                0.439,
                0.938
            ],
            "angle": 0,
            "content": "解 我们对指数 \\(n\\) 做数学归纳法。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.671,
                0.041,
                0.782,
                0.056
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.829,
                0.043,
                0.864,
                0.056
            ],
            "angle": 0,
            "content": "323"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.097,
                0.893,
                0.132
            ],
            "angle": 0,
            "content": "基础步骤：如果 \\( n = 0 \\)，算法的第一步告诉我们：power（a，0）=1。这是正确的，因为对任意非零实数 \\( a \\)，都有 \\( a^0 = 1 \\) 。这就完成了基础步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.135,
                0.894,
                0.228
            ],
            "angle": 0,
            "content": "归纳步骤：归纳假设是命题对所有 \\(a \\neq 0\\) 及非负整数 \\(k\\)，都有 \\(\\operatorname{power}(a, k) = a^k\\)。即归纳假设是命题：算法能正确地计算 \\(a^k\\)。为了完成归纳步骤，需要证明：如果归纳假设为真，那么算法能正确计算 \\(a^{k+1}\\)。因为 \\(k+1\\) 是正整数，所以当算法计算 \\(a^{k+1}\\) 时，它将做 \\(\\operatorname{power}(a, k+1) = a \\cdot \\operatorname{power}(a, k)\\)。根据归纳假设，有 \\(\\operatorname{power}(a, k) = a^k\\)，所以 \\(\\operatorname{power}(a, k+1) = a \\cdot \\operatorname{power}(a, k) = a \\cdot a^k = a^{k+1}\\)。这就完成了归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.231,
                0.893,
                0.267
            ],
            "angle": 0,
            "content": "我们已经完成了基础步骤和归纳步骤，因此可以得出结论：当 \\(a \\neq 0\\) 及 \\(n\\) 是一个非负整数时，算法2总能正确地计算 \\(a^n\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.269,
                0.893,
                0.305
            ],
            "angle": 0,
            "content": "一般情况下，需要用强归纳法而不是数学归纳法来证明算法的正确性。例8就说明了这一点。例8说明了如何用强归纳法来证明算法4的正确性。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.31,
                0.434,
                0.327
            ],
            "angle": 0,
            "content": "例8 证明算法4（求模指数）的正确性。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.332,
                0.324,
                0.348
            ],
            "angle": 0,
            "content": "解 对指数 \\(n\\) 用强归纳法。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.351,
                0.894,
                0.387
            ],
            "angle": 0,
            "content": "基础步骤：当 \\(n = 0\\) 时，\\(\\mathrm{mpower}(b, n, m) = 1\\)。因为当 \\(b\\) 是整数，\\(m\\) 是整数，满足 \\(m \\geqslant 2\\) 时 \\(b^0 \\mod m = 1\\)，所以基础步骤就完成了。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.39,
                0.894,
                0.463
            ],
            "angle": 0,
            "content": "归纳步骤：归纳假设是当 \\(b\\) 是正整数，\\(m\\) 是整数，满足 \\(m \\geqslant 2\\) 时，对于所有整数 \\(0 \\leqslant j < k\\) 来说，\\(\\mathrm{mpower}(b, j, m) = b^j \\mod m\\)。为了完成归纳步骤，我们证明当归纳假设正确时，\\(\\mathrm{mpower}(b, k, m) = b^k \\mod m\\)。因为递归算法对于 \\(k\\) 在奇数和偶数时处理不同，所以我们将归纳步骤分为两种情况。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.466,
                0.894,
                0.502
            ],
            "angle": 0,
            "content": "当 \\(k\\) 是偶数时，有 \\(\\mathrm{mpower}(b, k, m) = \\mathrm{mpower}(b, k/2, m)^2 \\mod m = (b^{k/2} \\mod m)^2 \\mod m = b^k \\mod m\\)，其中使用了归纳假设以便把 \\(\\mathrm{mpower}(b, k/2, m)\\) 换成 \\(b^{k/2} \\mod m\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.505,
                0.252,
                0.521
            ],
            "angle": 0,
            "content": "当 \\(k\\) 是奇数时，有"
        },
        {
            "type": "equation",
            "bbox": [
                0.176,
                0.526,
                0.893,
                0.557
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} \\operatorname {m p o w e r} (b, k, m) = \\left(\\left(\\operatorname {m p o w e r} (b, \\lfloor k / 2 \\rfloor , m)\\right) ^ {2} \\operatorname {m o d} m \\cdot b \\operatorname {m o d} m\\right) \\operatorname {m o d} m \\\\ = \\left(\\left(b ^ {\\lfloor k / 2 \\rfloor} \\bmod m\\right) ^ {2} \\bmod m \\cdot b \\bmod m\\right) \\bmod m = b ^ {\\lfloor k / 2 \\rfloor + 1} \\bmod m = b ^ {k} \\bmod m \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.561,
                0.891,
                0.598
            ],
            "angle": 0,
            "content": "利用4.1节推论2，因为当 \\(k\\) 是奇数时 \\(2\\lfloor k / 2\\rfloor +1 = 2(k - 1) / 2 + 1 = k\\) 。这里使用了归纳假设以便把 \\(\\mathrm{mpower}(b,\\lfloor k / 2\\rfloor ,m)\\) 换成 \\(b^{\\lfloor k / 2\\rfloor}\\mod m\\) 。这样就完成了归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.6,
                0.755,
                0.617
            ],
            "angle": 0,
            "content": "我们已经完成了基础步骤和归纳步骤，根据归纳假设知道算法4是正确的。"
        },
        {
            "type": "title",
            "bbox": [
                0.048,
                0.627,
                0.238,
                0.644
            ],
            "angle": 0,
            "content": "5.4.3 递归与迭代"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.647,
                0.894,
                0.779
            ],
            "angle": 0,
            "content": "函数在取某一个正整数时的值通过函数在较小整数时的值来表示，这是一个递归定义。这意味着我们可以设计递归算法来计算在取某一个正整数时该递归定义的函数值。我们不是连续地在较小的整数点处计算函数的值，而是从函数在一个或多个整数点处的函数值开始，然后连续地应用递归定义一个一个地求得函数在较大整数点处的函数值。这样的过程就称为迭代。通常，一个用递归定义的迭代算法序列要比用递归过程计算会减少很多计算量（除非使用特定用途的递归机）。这一点可以通过用计算第 \\(n\\) 个斐波那契数的迭代过程和递归过程来说明。我们先给出递归过程。"
        },
        {
            "type": "title",
            "bbox": [
                0.059,
                0.799,
                0.316,
                0.815
            ],
            "angle": 0,
            "content": "算法7 斐波那契数的递归算法"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.819,
                0.327,
                0.833
            ],
            "angle": 0,
            "content": "procedurefibonacci(n：非负整数）"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.838,
                0.223,
                0.849
            ],
            "angle": 0,
            "content": "if \\(n = 0\\) then return 0"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.855,
                0.254,
                0.866
            ],
            "angle": 0,
            "content": "else if \\( n = 1 \\) then return 1"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.873,
                0.421,
                0.884
            ],
            "angle": 0,
            "content": "else return fibonacci \\((n - 1) +\\) fibonacci \\((n - 2)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.89,
                0.231,
                0.902
            ],
            "angle": 0,
            "content": "输出是fibonacci(n)"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.925,
                0.891,
                0.943
            ],
            "angle": 0,
            "content": "当使用递归算法求 \\(f_{n}\\) 时，首先把 \\(f_{n}\\) 表示成 \\(f_{n - 1} + f_{n - 2}\\) 。然后把这两个斐波那契数都换成"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.148,
                0.04,
                0.183,
                0.054
            ],
            "angle": 0,
            "content": "324"
        },
        {
            "type": "header",
            "bbox": [
                0.229,
                0.039,
                0.294,
                0.054
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.095,
                0.746,
                0.112
            ],
            "angle": 0,
            "content": "两个前面的斐波那契数之和。当 \\( f_{0} \\) 或 \\( f_{1} \\) 出现时，就直接换成它的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.115,
                0.686,
                0.265
            ],
            "angle": 0,
            "content": "注意，在递归的每个阶段，直到获得 \\( f_{1} \\) 或 \\( f_{0} \\) 为止，需要求值的斐波那契数的个数都一直翻倍。例如，当使用这个递归算法求出 \\( f_{4} \\) 时，就必须完成图1中的树形图所说明的全部计算。这个树包括用 \\( f_{4} \\) 标记的根以及从根到用两个斐波那契数 \\( f_{3} \\) 和 \\( f_{2} \\) 标记的顶点的分支，它们出现在 \\( f_{4} \\) 的计算的归约中。每个后续的归约都产生树中的两个分支。当遇到 \\( f_{0} \\) 和 \\( f_{1} \\) 时，这种分支结束。读者可以验证一下，这个算法需要 \\( f_{n+1}-1 \\) 次加法来求出 \\( f_{n} \\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.267,
                0.686,
                0.303
            ],
            "angle": 0,
            "content": "现在考虑用算法8中的迭代过程来求出 \\( f_{n} \\) 所需要的计算量。"
        },
        {
            "type": "image",
            "bbox": [
                0.702,
                0.118,
                0.951,
                0.272
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.738,
                0.276,
                0.932,
                0.292
            ],
            "angle": 0,
            "content": "图1 递归地求 \\( f_{4} \\) 的值"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.323,
                0.432,
                0.338
            ],
            "angle": 0,
            "content": "算法8 计算斐波那契数的迭代算法"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.341,
                0.476,
                0.356
            ],
            "angle": 0,
            "content": "procedure iterative fibonacci(n:非负整数)"
        },
        {
            "type": "text",
            "bbox": [
                0.137,
                0.359,
                0.304,
                0.374
            ],
            "angle": 0,
            "content": "if \\(n = 0\\) then return 0"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.378,
                0.171,
                0.39
            ],
            "angle": 0,
            "content": "else"
        },
        {
            "type": "equation",
            "bbox": [
                0.184,
                0.396,
                0.326,
                0.497
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} x := 0 \\\\ y := 1 \\\\ \\text {f o r} i := 1 \\text {t o} n - 1 \\\\ z := x + y \\\\ x := y \\\\ y := z \\\\ \\end{array}\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.185,
                0.503,
                0.253,
                0.515
            ],
            "angle": 0,
            "content": "\\[\n\\text {r e t u r n} y\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.518,
                0.363,
                0.533
            ],
            "angle": 0,
            "content": "{输出是第 \\(n\\) 个斐波那契数}"
        },
        {
            "type": "text",
            "bbox": [
                0.122,
                0.559,
                0.972,
                0.653
            ],
            "angle": 0,
            "content": "这个过程把 \\(x\\) 初始化成 \\(f_{0} = 0\\) ，把 \\(y\\) 初始化成 \\(f_{1} = 1\\) 。当经过循环时，把 \\(x\\) 和 \\(y\\) 的和赋给辅助变量 \\(z\\) 。然后把 \\(x\\) 赋成 \\(y\\) 的值，而把 \\(y\\) 赋成辅助变量 \\(z\\) 的值。因此，在经过第一次循环之后得出 \\(x\\) 等于 \\(f_{1}\\) 而 \\(y\\) 等于 \\(f_{0} + f_{1} = f_{2}\\) 。另外，在经过 \\(n - 1\\) 次循环之后 \\(x\\) 等于 \\(f_{n - 1}\\) 而 \\(y\\) 等于 \\(f_{n}\\) （读者应当验证这个命题）。当 \\(n > 1\\) 时，用这个迭代方法求出 \\(f_{n}\\) 仅仅使用了 \\(n - 1\\) 次加法。因此，这个算法比递归算法需要的计算少得多。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.656,
                0.971,
                0.711
            ],
            "angle": 0,
            "content": "已经说明当求递归定义的函数的值时，递归算法可能比迭代算法需要更多的计算量。有时使用递归算法可能更好，即使它比迭代过程更低效，特别是当递归方法容易实现而迭代方法不容易实现时。（另外，或许可以用专门设计来处理递归的机器，它们抵消了使用迭代的好处。）"
        },
        {
            "type": "title",
            "bbox": [
                0.125,
                0.722,
                0.298,
                0.739
            ],
            "angle": 0,
            "content": "5.4.4 归并排序"
        },
        {
            "type": "text",
            "bbox": [
                0.125,
                0.742,
                0.972,
                0.778
            ],
            "angle": 0,
            "content": "现在描述称为归并排序算法的递归排序算法。在概括性地描述归并排序算法之前，将用一个例子来说明它是如何工作的。"
        },
        {
            "type": "text",
            "bbox": [
                0.165,
                0.784,
                0.741,
                0.801
            ],
            "angle": 0,
            "content": "例9 用归并排序来排序列表8，2，4，6，9，7，10，1，5，3。"
        },
        {
            "type": "text",
            "bbox": [
                0.125,
                0.807,
                0.972,
                0.842
            ],
            "angle": 0,
            "content": "解归并排序首先通过不断地把表一分为二来把表分成单个的元素。这个例子的子表的序列表示成图2上方所示的高度为4的平衡二叉树。"
        },
        {
            "type": "text",
            "bbox": [
                0.125,
                0.845,
                0.972,
                0.919
            ],
            "angle": 0,
            "content": "排序是通过不断地合并成对的表来完成的。在第一阶段里，把成对的单个元素合并成按升序排列的长度为二的表。然后对成对的表进行连续的合并，直到整个表都排成升序为止。把这些合并成按升序排列的表的序列表示成图2下方所示的高度为4的平衡二叉树（注意，这个树是“上下颠倒地”显示的）。"
        },
        {
            "type": "text",
            "bbox": [
                0.166,
                0.922,
                0.972,
                0.939
            ],
            "angle": 0,
            "content": "在一般情况下，归并排序是这样进行的：反复地把表分成长度相等的两个子表（或者其中"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.682,
                0.039,
                0.796,
                0.054
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.84,
                0.04,
                0.876,
                0.054
            ],
            "angle": 0,
            "content": "325"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.095,
                0.909,
                0.169
            ],
            "angle": 0,
            "content": "一个子表比另一个子表多一个元素), 直到每个子表包含一个元素为止。这些子表的序列可以表示成平衡二叉树。这个过程继续进行: 不断地合并成对的子表, 其中的两个表都是按升序排列的, 把它们合并成元素都是按升序排列的较大的表, 直到原来的表排成升序为止。这些合并的子表的序列可以表示成平衡二叉树。"
        },
        {
            "type": "image",
            "bbox": [
                0.214,
                0.175,
                0.755,
                0.549
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.265,
                0.553,
                0.712,
                0.569
            ],
            "angle": 0,
            "content": "图2对8，2，4，6，9，7，10，1，5，3的归并排序"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.575,
                0.912,
                0.631
            ],
            "angle": 0,
            "content": "也可以递归地描述归并排序。为了做归并排序，把表分成大小相等或近似相等的两个子表，用归并排序算法排序每个子表，然后合并这两个子表。算法9给出归并排序的递归形式。这个算法使用子过程merge，算法10描述merge。"
        },
        {
            "type": "title",
            "bbox": [
                0.08,
                0.649,
                0.264,
                0.664
            ],
            "angle": 0,
            "content": "算法9 递归归并排序"
        },
        {
            "type": "code",
            "bbox": [
                0.078,
                0.667,
                0.5,
                0.792
            ],
            "angle": 0,
            "content": "proceduremergesort \\((L = a_{1},\\dots ,a_{n})\\)   \nif \\(n > 1\\) then  \n\\(m:= \\lfloor n / 2\\rfloor\\)   \n\\(L_{1}:= a_{1}\\) ， \\(a_2\\) ，…， \\(a_{m}\\)   \n\\(L_{2}:= a_{m + 1}\\) ， \\(a_{m + 2}\\) ，…， \\(a_{n}\\)   \n\\(L:= \\mathrm{merge}(\\mathrm{mergesort}(L_1)\\) ，mergesort \\((L_{2}))\\)   \n{现在 \\(L\\) 中的元素以非降序排列}"
        },
        {
            "type": "text",
            "bbox": [
                0.066,
                0.813,
                0.916,
                0.849
            ],
            "angle": 0,
            "content": "为了实现归并排序，需要把两个有序表合并成更大有序表的有效算法。现在将描述这样的过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.854,
                0.551,
                0.871
            ],
            "angle": 0,
            "content": "例10 描述如何合并两个表2，3，5，6和1，4。"
        },
        {
            "type": "text",
            "bbox": [
                0.066,
                0.876,
                0.918,
                0.93
            ],
            "angle": 0,
            "content": "解 表1说明所使用的步骤。首先，比较两个表中的最小元素，它们分别是2和1。因为1较小，所以把它放在合并的表的开头并且从第二个表中删除它。在这个阶段，第一个表是2，3，5，6，第二个表是4，组合而成的表是1。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.127,
                0.042,
                0.164,
                0.057
            ],
            "angle": 0,
            "content": "326"
        },
        {
            "type": "header",
            "bbox": [
                0.208,
                0.041,
                0.275,
                0.057
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "table_caption",
            "bbox": [
                0.35,
                0.097,
                0.697,
                0.113
            ],
            "angle": 0,
            "content": "表 1 合并已排序的表 2,3,5,6 和 1,4"
        },
        {
            "type": "table",
            "bbox": [
                0.099,
                0.114,
                0.946,
                0.228
            ],
            "angle": 0,
            "content": "<table><tr><td>第一个表</td><td>第二个表</td><td>合并的表</td><td>比较</td></tr><tr><td>2 3 5 6</td><td>1 4</td><td></td><td>1&lt;2</td></tr><tr><td>2 3 5 6</td><td>4</td><td>1</td><td>2&lt;4</td></tr><tr><td>3 5 6</td><td>4</td><td>1 2</td><td>3&lt;4</td></tr><tr><td>5 6</td><td>4</td><td>1 2 3</td><td>4&lt;5</td></tr><tr><td>5 6</td><td></td><td>1 2 3 4</td><td></td></tr><tr><td></td><td></td><td>1 2 3 4 5 6</td><td></td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.242,
                0.945,
                0.296
            ],
            "angle": 0,
            "content": "其次，比较2和4，它们是两个表中的最小元素。因为2较小，所以将它添加到组合的表并且从第一个表中删除它。在这个阶段，第一个表是3，5，6，第二个表是4，组合而成的表是1，2。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.299,
                0.945,
                0.354
            ],
            "angle": 0,
            "content": "继续比较3和4，它们是各自表中的最小元素。因为3是这两个元素中较小的，所以将它添加到组合的表并且从第一个表中删除它。在这个阶段，第一个表是5，6，第二个表是4，组合而成的表是1，2，3。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.356,
                0.945,
                0.411
            ],
            "angle": 0,
            "content": "然后比较5和4，它们是两个表里的最小元素。因为4是这两个元素中较小的，所以将它添加到组合的表并且从第二个表中删除它。在这个阶段，第一个表是5，6，第二个表是空的，组合而成的表是1，2，3，4。"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.413,
                0.945,
                0.449
            ],
            "angle": 0,
            "content": "最后，因为第二个表是空的，所以第一个表中的所有元素可以附加到组合表的后面，保持它们在第一个表中的出现顺序。这样就产生出有序表1，2，3，4，5，6。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.45,
                0.945,
                0.525
            ],
            "angle": 0,
            "content": "现在考虑将两个有序表 \\(L_{1}\\) 和 \\(L_{2}\\) 合并成一个有序表 \\(L\\) 的一般问题。可以使用下面的过程。从空表 \\(L\\) 开始。比较两个表的最小元素。把这两个元素中较小的放到 \\(L\\) 后面，并且从它所在的表中删除它。下一步，若 \\(L_{1}\\) 和 \\(L_{2}\\) 有一个是空的，则附加另一个(非空)表到 \\(L\\) ，这样就完成了合并。若 \\(L_{1}\\) 和 \\(L_{2}\\) 都非空，则重复这个过程。算法10给出这个过程的伪代码描述。"
        },
        {
            "type": "title",
            "bbox": [
                0.109,
                0.541,
                0.286,
                0.557
            ],
            "angle": 0,
            "content": "算法10 归并两个表"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.56,
                0.427,
                0.576
            ],
            "angle": 0,
            "content": "procedure merge \\((L_{1}, L_{2}\\) ：已排序的表）"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.579,
                0.195,
                0.593
            ],
            "angle": 0,
            "content": "\\(L\\coloneqq\\) 空表"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.596,
                0.286,
                0.611
            ],
            "angle": 0,
            "content": "while \\(L_{1}\\) 和 \\(L_{2}\\) 都非空"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.613,
                0.88,
                0.629
            ],
            "angle": 0,
            "content": "从 \\(L_{1}\\) 和 \\(L_{2}\\) 的第一元素中较小的元素所在的表中删除这个元素并且把这个元素放到 \\(L\\) 的左端"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.631,
                0.916,
                0.666
            ],
            "angle": 0,
            "content": "if 删除这个元素导致一个表为空 then 从另一个表中删除所有元素并且把这些元素附加到 \\(L\\) 的后面 return \\(L\\{L\\) 是元素按照递增顺序排列的已归并的表"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.683,
                0.945,
                0.796
            ],
            "angle": 0,
            "content": "在对归并排序的分析中，将需要估计合并两个有序表 \\(L_{1}\\) 和 \\(L_{2}\\) 所用的比较次数。对于算法10来说，可以容易地得出这样的估计。每次比较 \\(L_{1}\\) 的一个元素与 \\(L_{2}\\) 的一个元素，把一个附加元素添加到合并的表 \\(L\\) 中。不过，当 \\(L_{1}\\) 或 \\(L_{2}\\) 为空时，就不需要更多的比较了。因此，当执行\\(m + n - 2\\) 次比较时，其中 \\(m\\) 和 \\(n\\) 分别是 \\(L_{1}\\) 和 \\(L_{2}\\) 中的元素个数，算法10效率最低， \\(L_{1}\\) 和 \\(L_{2}\\) 每个只剩下一个元素。下一次比较将是最后一次，因为这次比较使得这两个表之一为空。因此，算法10使用不超过 \\(m + n - 1\\) 次比较。下面的引理总结了这个估计。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.802,
                0.935,
                0.841
            ],
            "angle": 0,
            "content": "引理1 使用不超过 \\(m + n - 1\\) 次比较，可以把 \\(m\\) 个元素和 \\(n\\) 个元素的两个有序表合并成一个有序表。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.847,
                0.945,
                0.941
            ],
            "angle": 0,
            "content": "有时使用远远少于 \\(m + n - 1\\) 次比较就可以合并两个长度为 \\(m\\) 和 \\(n\\) 的有序表。例如，当 \\(m = 1\\) 时，可以用二叉搜索过程来把第一个表里的这一个元素放到第二个表中。这只需要 \\(\\lceil \\log n \\rceil\\) 次比较，对 \\(m = 1\\) 来说，\\(\\lceil \\log n \\rceil\\) 比 \\(m + n - 1 = n\\) 小得多。在另一方面，对 \\(m\\) 和 \\(n\\) 的某些值来说，引理1给出了最好可能的界限。即存在着带有 \\(m\\) 个和 \\(n\\) 个元素的表，比较次数少于 \\(m + n - 1\\) 次是无法合并它们的。（见本节练习47。）"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.68,
                0.038,
                0.792,
                0.053
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.837,
                0.038,
                0.874,
                0.052
            ],
            "angle": 0,
            "content": "327"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.094,
                0.902,
                0.149
            ],
            "angle": 0,
            "content": "现在可以分析归并排序的复杂性了。与研究一般性问题不一样的是，将假定表中的元素个数 \\( n \\) 是 2 的幂，比方说 \\( 2^{m} \\) 。这样将使分析不太复杂，但是当实际情况不是这样时，还可以做各种修改，这些修改将产生同样的估计。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.151,
                0.902,
                0.246
            ],
            "angle": 0,
            "content": "在分解过程的第一阶段，把表分解成两个子表，每个子表都有 \\(2^{m-1}\\) 个元素，位于分解所生成的树的1层上。这个过程继续下去，把两个带 \\(2^{m-1}\\) 个元素的子表分解成4个在2层上各有 \\(2^{m-2}\\) 个元素的子表，以此类推。在一般情况下，在 \\(k-1\\) 层上有 \\(2^{k-1}\\) 个表，每个表有 \\(2^{m-k+1}\\) 个元素。在 \\(k-1\\) 层上的这些表分解成在 \\(k\\) 层上的 \\(2^k\\) 个表，每个表有 \\(2^{m-k}\\) 个元素。在这个过程的最后，有 \\(2^m\\) 个表，每个表有一个元素，在 \\(m\\) 层上。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.248,
                0.902,
                0.305
            ],
            "angle": 0,
            "content": "可以这样来开始合并：把 \\(2^{m}\\) 个含有一个元素的表成对地组合成 \\(2^{m-1}\\) 个表，都在 \\(m-1\\) 层上，各有两个元素。为了这样做，把 \\(2^{m-1}\\) 对含一个元素的表合并。每一对表的合并恰好需要一次比较。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.307,
                0.902,
                0.402
            ],
            "angle": 0,
            "content": "这个过程继续下去，使得在 \\(k\\) 层上 \\((k = m, m - 1, m - 2, \\dots, 3, 2, 1)\\)，\\(2^k\\) 个各有 \\(2^{m - k}\\) 个元素的表合并成 \\(2^{k - 1}\\) 个表，各有 \\(2^{m - k} + 1\\) 个元素，都在 \\(k - 1\\) 层上。为了这样做，需要总共 \\(2^{k - 1}\\) 次合并两个表，每个表有 \\(2^{m - k}\\) 个元素。但是，根据引理1，这些合并每个都可以用至多 \\(2^{m - k} + 2^{m - k} - 1 = 2^{m - k + 1} - 1\\) 次比较来完成。因此，从 \\(k\\) 层进行到 \\(k - 1\\) 层，可以用至多 \\(2^{k - 1}(2^{m - k + 1} - 1)\\) 次比较来完成。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.404,
                0.673,
                0.421
            ],
            "angle": 0,
            "content": "对所有这些估计求和就证明了归并排序所需要的比较次数至多是"
        },
        {
            "type": "equation",
            "bbox": [
                0.137,
                0.426,
                0.816,
                0.459
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {k = 1} ^ {m} 2 ^ {k - 1} (2 ^ {m - k + 1} - 1) = \\sum_ {k = 1} ^ {m} 2 ^ {m} - \\sum_ {k = 1} ^ {m} 2 ^ {k - 1} = m 2 ^ {m} - (2 ^ {m} - 1) = n \\log n - n + 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.464,
                0.899,
                0.53
            ],
            "angle": 0,
            "content": "因为 \\(m = \\log n\\) 和 \\(n = 2^{m}\\)。（这样求 \\(\\sum_{k=1}^{m} 2^{m}\\) 的值，注意它是 \\(m\\) 个相同项的和，每个都等于 \\(2m\\)。这样求 \\(\\sum_{k=1}^{m} 2^{k-1}\\) 的值，用2.4节定理1几何级数各项求和的公式。）"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.531,
                0.889,
                0.548
            ],
            "angle": 0,
            "content": "定理1总结了我们发现的归并排序达到了排序算法所需比较次数的最好可能的大 \\(O\\) 估计。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.558,
                0.734,
                0.575
            ],
            "angle": 0,
            "content": "定理1 对 \\(n\\) 个元素的表进行归并排序所需要的比较次数是 \\(O(n\\log n)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.584,
                0.902,
                0.64
            ],
            "angle": 0,
            "content": "在第11章，我们将证明最快的比较排序算法具有 \\(O(n\\log n)\\) 时间复杂度。（比较排序算法是以两个数比较为基础的。）定理1告诉我们归并排序算法针对排序算法取得了最好可能的大 \\(O\\) 估计时间复杂度。练习50将描述另一个有效的算法——快速排序。"
        },
        {
            "type": "title",
            "bbox": [
                0.055,
                0.65,
                0.099,
                0.666
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.669,
                0.896,
                0.702
            ],
            "angle": 0,
            "content": "1. 当给定 \\( n = 5 \\) 作为输入时，跟踪算法 1。即，像例 4 中求 4！那样，证明算法 1 中的所有步骤都是为了求 5！。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.706,
                0.896,
                0.738
            ],
            "angle": 0,
            "content": "2. 当给定 \\( n = 6 \\) 作为输入时，跟踪算法1。即，像例4中求4！那样，证明算法1中的所有步骤都是为了求6！。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.742,
                0.757,
                0.757
            ],
            "angle": 0,
            "content": "3. 跟踪算法 4 计算 gcd(8, 13)。即，证明算法 4 中的所有步骤都是为了求 gcd(8, 13)。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.761,
                0.757,
                0.775
            ],
            "angle": 0,
            "content": "4. 跟踪算法 4 计算 gcd(12, 7)。即，证明算法 4 中的所有步骤都是为了求 gcd(12, 7)。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.778,
                0.896,
                0.81
            ],
            "angle": 0,
            "content": "5. 当给定 \\( m = 5 \\)，\\( n = 11 \\) 和 \\( b = 3 \\) 作为输入时，跟踪算法3。即，证明算法3中的所有步骤都是为了求 \\( 3^{11} \\mod 5 \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.815,
                0.896,
                0.847
            ],
            "angle": 0,
            "content": "6. 当给定 \\( m = 7 \\)，\\( n = 10 \\) 和 \\( b = 2 \\) 作为输入时，跟踪算法3。即，证明算法3中的所有步骤都是为了求 \\( 2^{10} \\mod 7 \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.851,
                0.598,
                0.865
            ],
            "angle": 0,
            "content": "7. 给出当 \\( n \\) 是正整数而 \\( x \\) 是整数时，只用加法计算 \\( nx \\) 的递归算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.869,
                0.381,
                0.883
            ],
            "angle": 0,
            "content": "8. 给出求前 \\( n \\) 个正整数之和的递归算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.888,
                0.381,
                0.901
            ],
            "angle": 0,
            "content": "9. 给出求前 \\( n \\) 个正奇数之和的递归算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.905,
                0.896,
                0.938
            ],
            "angle": 0,
            "content": "10. 给出求有限整数集合中的最大值的递归算法，利用事实：\\(n\\) 个整数中的最大值是列表中最后一个整数与 \\(n - 1\\) 个整数列表中最大值之间的较大者。"
        },
        {
            "type": "list",
            "bbox": [
                0.055,
                0.669,
                0.896,
                0.938
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.132,
                0.04,
                0.167,
                0.052
            ],
            "angle": 0,
            "content": "328"
        },
        {
            "type": "header",
            "bbox": [
                0.212,
                0.039,
                0.278,
                0.053
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.095,
                0.951,
                0.127
            ],
            "angle": 0,
            "content": "11. 给出求有限整数集合中的最小值的递归算法，利用事实：\\(n\\) 个整数中的最小值是列表中最后一个整数与 \\(n - 1\\) 个整数列表中最小值之间的较小者。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.131,
                0.953,
                0.162
            ],
            "angle": 0,
            "content": "12. 设计一个递归算法，当 \\( n \\) 、 \\( x \\) 和 \\( m \\) 都是正整数时，基于事实 \\( x^n \\mod m = (x^{n-1} \\mod m \\cdot x \\mod m) \\mod m \\)，求出 \\( x^n \\mod m \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.166,
                0.592,
                0.18
            ],
            "angle": 0,
            "content": "13. 给出当 \\(n\\) 和 \\(m\\) 都是正整数时，求 \\(n! \\mod m\\) 的递归算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.184,
                0.951,
                0.216
            ],
            "angle": 0,
            "content": "14. 给出求整数列表中的众数的递归算法。（众数是列表中出现的频繁程度至少与其他每个元素一样的元素。）"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.22,
                0.951,
                0.252
            ],
            "angle": 0,
            "content": "15. 设计一个递归算法，它计算假如 \\(\\gcd(a, b) = \\gcd(a, b - a)\\) 时，满足 \\(a < b\\) 的两个非负整数 \\(a\\) 和 \\(b\\) 的最大公因子。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.256,
                0.651,
                0.269
            ],
            "angle": 0,
            "content": "16. 证明：练习8找到的求前 \\(n\\) 个正整数之和的递归算法是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.273,
                0.951,
                0.306
            ],
            "angle": 0,
            "content": "17. 设计把两个非负整数 \\(x\\) 和 \\(y\\) 相乘的递归算法，基于这样的事实：当 \\(y\\) 是偶数时 \\(xy = 2(x \\cdot (y / 2))\\) 当 \\(y\\) 是奇数时 \\(xy = 2(x \\cdot \\lfloor y / 2 \\rfloor) + x\\) ，以及初始条件：当 \\(y = 0\\) 时 \\(xy = 0\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.309,
                0.592,
                0.323
            ],
            "angle": 0,
            "content": "18. 证明：当 \\(n\\) 是非负整数时，算法1关于求 \\(n!\\) 是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.327,
                0.734,
                0.341
            ],
            "angle": 0,
            "content": "19. 证明：当 \\(a, b\\) 是非负整数且 \\(a < b\\) 时，算法3关于求 \\(\\gcd(a, b)\\) 是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.345,
                0.458,
                0.358
            ],
            "angle": 0,
            "content": "20. 证明：练习17中设计的算法是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.362,
                0.486,
                0.376
            ],
            "angle": 0,
            "content": "21. 证明：练习7中找到的递归算法是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.38,
                0.496,
                0.394
            ],
            "angle": 0,
            "content": "22. 证明：练习10中找到的递归算法是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.398,
                0.953,
                0.43
            ],
            "angle": 0,
            "content": "23. 利用事实 \\((n + 1)^{2} = n^{2} + 2n + 1\\) ，设计一个求 \\(n^2\\) 的递归算法，其中 \\(n\\) 是一个非负整数。然后证明该算法的正确性。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.435,
                0.853,
                0.451
            ],
            "angle": 0,
            "content": "24. 设计求 \\(a^{2^n}\\) 的递归算法，其中 \\(a\\) 是实数而 \\(n\\) 是正整数。[提示：利用等式 \\(a^{2^{n+1}} = (a^{2^n})^2\\)]"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.457,
                0.898,
                0.472
            ],
            "angle": 0,
            "content": "25. 对于求 \\( a^{2^n} \\) 的值，练习 24 的算法所用的乘法次数与算法 2 所用的乘法次数相比较的结果如何？"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.476,
                0.912,
                0.49
            ],
            "angle": 0,
            "content": "* 26. 用练习24的算法，设计当 \\( n \\) 是非负整数时求 \\( a^n \\) 的值的算法。[提示：利用 \\( n \\) 的二进制展开式。]"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.494,
                0.896,
                0.508
            ],
            "angle": 0,
            "content": "* 27. 对于求 \\(a^n\\) 的值，练习26的算法所用的乘法次数与算法2所用的乘法次数相比较的结果如何？"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.512,
                0.955,
                0.543
            ],
            "angle": 0,
            "content": "28. 为了求出斐波那契数 \\( f_{7} \\)，在算法 7 和算法 8 里给出的递归算法和迭代算法，各自分别使用多少次加法？"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.548,
                0.955,
                0.58
            ],
            "angle": 0,
            "content": "29. 设计求一个序列的第 \\( n \\) 项的递归算法，该序列定义成： \\( a_0 = 1 \\)， \\( a_1 = 2 \\)，而且对 \\( n = 2, 3, 4, \\cdots \\) 来说有 \\( a_n = a_{n-1} \\cdot a_{n-2} \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.584,
                0.536,
                0.597
            ],
            "angle": 0,
            "content": "30. 设计求练习29定义的序列的第 \\(n\\) 项的迭代算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.602,
                0.631,
                0.616
            ],
            "angle": 0,
            "content": "31. 求练习29的序列的递归算法与迭代算法，哪个算法更有效？"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.62,
                0.957,
                0.651
            ],
            "angle": 0,
            "content": "32. 设计求一个序列的第 \\( n \\) 项的递归算法，该序列定义成： \\( a_0 = 1 \\)， \\( a_1 = 2 \\)， \\( a_2 = 3 \\)，而且对 \\( n = 3, 4, 5, \\cdots \\) 来说有 \\( a_n = a_{n-1} + a_{n-2} + a_{n-3} \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.655,
                0.537,
                0.669
            ],
            "angle": 0,
            "content": "33. 设计求练习 32 定义的序列的第 \\( n \\) 项的迭代算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.673,
                0.631,
                0.687
            ],
            "angle": 0,
            "content": "34. 求练习 32 的序列的递归算法与迭代算法，哪个算法更有效？"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.691,
                0.957,
                0.722
            ],
            "angle": 0,
            "content": "35. 给出求一个序列的第 \\(n\\) 项的递归算法和迭代算法，该序列定义成：\\(a_0 = 1\\)，\\(a_1 = 3\\)，\\(a_2 = 5\\)，而且 \\(a_n = a_{n-1} \\cdot a_{n-2}^2 \\cdot a_{n-3}^3\\)。哪个算法更有效？"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.726,
                0.741,
                0.74
            ],
            "angle": 0,
            "content": "36. 根据5.3节练习47给出的递归定义，给出求正整数的划分数的递归算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.744,
                0.87,
                0.758
            ],
            "angle": 0,
            "content": "37. 给出求字符串的倒置的递归算法。（见5.3节练习34前面的说明对比特串的倒置的定义。）"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.762,
                0.763,
                0.776
            ],
            "angle": 0,
            "content": "38. 给出当 \\( w \\) 是比特串时，求字符串 \\( w^i \\) （即 \\( w \\) 的 \\( i \\) 个复制品的连接）的递归算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.781,
                0.649,
                0.794
            ],
            "angle": 0,
            "content": "39. 证明：练习37所给出的关于字符串倒置的递归算法是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.798,
                0.65,
                0.812
            ],
            "angle": 0,
            "content": "40. 证明：练习38所给出的关于字符串连接的递归算法是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.816,
                0.685,
                0.83
            ],
            "angle": 0,
            "content": "* 41. 给出用右三联骨牌覆盖一个去掉了一格的 \\(2^{n} \\times 2^{n}\\) 棋盘的递归算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.834,
                0.765,
                0.848
            ],
            "angle": 0,
            "content": "42. 利用5.2节中的引理1，给出对具有 \\(n\\) 条边的简单多边形三角化的递归算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.851,
                0.78,
                0.865
            ],
            "angle": 0,
            "content": "43. 给出递归算法来计算阿克曼函数的值。[提示：见5.3节练习48前面的说明。]"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.869,
                0.737,
                0.883
            ],
            "angle": 0,
            "content": "44. 用归并排序来排序 4, 3, 2, 5, 1, 8, 7, 6, 说明算法所用的所有步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.887,
                0.796,
                0.901
            ],
            "angle": 0,
            "content": "45. 用归并排序来排序 \\(b, d, a, f, g, h, z, p, o, k\\) ，说明算法所用的所有步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.905,
                0.616,
                0.919
            ],
            "angle": 0,
            "content": "46. 为了用算法10来合并下面的成对的表，需要多少次比较？"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.923,
                0.436,
                0.936
            ],
            "angle": 0,
            "content": "a)1，3，5，7，9；2，4，6，8，10"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.682,
                0.038,
                0.792,
                0.052
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.838,
                0.038,
                0.874,
                0.052
            ],
            "angle": 0,
            "content": "329"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.094,
                0.376,
                0.106
            ],
            "angle": 0,
            "content": "b)1，2，3，4，5；6，7，8，9，10"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.111,
                0.376,
                0.123
            ],
            "angle": 0,
            "content": "c)1，5，6，7，8；2，3，4，9，10"
        },
        {
            "type": "list",
            "bbox": [
                0.087,
                0.094,
                0.376,
                0.123
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.127,
                0.903,
                0.157
            ],
            "angle": 0,
            "content": "47. 证明：存在着带有 \\( m \\) 个和 \\( n \\) 个元素的表，使得它们不能用算法10以少于 \\( m + n - 1 \\) 次的比较来合并成一个有序表。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.16,
                0.9,
                0.174
            ],
            "angle": 0,
            "content": "* 48. 当两个升序的表里的元素个数如下时，把它们合并成一个升序的表，所需要的最少比较次数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.176,
                0.148,
                0.19
            ],
            "angle": 0,
            "content": "a)1，4"
        },
        {
            "type": "text",
            "bbox": [
                0.272,
                0.176,
                0.332,
                0.19
            ],
            "angle": 0,
            "content": "b)2，4"
        },
        {
            "type": "text",
            "bbox": [
                0.458,
                0.177,
                0.516,
                0.19
            ],
            "angle": 0,
            "content": "c)3，4"
        },
        {
            "type": "text",
            "bbox": [
                0.641,
                0.177,
                0.701,
                0.19
            ],
            "angle": 0,
            "content": "d)4，4"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.193,
                0.343,
                0.207
            ],
            "angle": 0,
            "content": "* 49. 证明：归并排序算法是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.209,
                0.905,
                0.29
            ],
            "angle": 0,
            "content": "快速排序是一个有效算法。为了排序 \\(a_1, a_2, \\cdots, a_n\\)，这个算法首先挑出第一个元素 \\(a_1\\) 并构造两个子表，第一个子表包含小于 \\(a_1\\) 的元素，是按照元素出现的顺序排列的。第二个子表包含大于 \\(a_1\\) 的元素，是按照元素出现的顺序排列的。然后把 \\(a_1\\) 放在第一个子表的后面。对每个子表递归地重复这个过程，直到所有子表都只包含一个项为止。\\(n\\) 个项的有序表是这样获得的：按照只含有一个项的子表出现的顺序来组合它们。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.292,
                0.485,
                0.306
            ],
            "angle": 0,
            "content": "50. 用快速排序来排序3，5，7，8，1，9，2，4，6。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.309,
                0.903,
                0.34
            ],
            "angle": 0,
            "content": "51. 设 \\(a_1, a_2, \\dots, a_n\\) 是 \\(n\\) 个不同实数的表。从这个表构造两个子表，第一个子表包含小于 \\(a_1\\) 的元素而第二个子表包含大于 \\(a_1\\) 的元素，那么需要多少次比较？"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.342,
                0.325,
                0.356
            ],
            "angle": 0,
            "content": "52. 用伪代码描述快速排序算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.358,
                0.641,
                0.373
            ],
            "angle": 0,
            "content": "53. 用快速排序算法来排序四个元素的表，需要的最大比较次数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.375,
                0.641,
                0.39
            ],
            "angle": 0,
            "content": "54. 用快速排序算法来排序四个元素的表，需要的最小比较次数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.392,
                0.602,
                0.406
            ],
            "angle": 0,
            "content": "55. 就所用的比较次数而言，确定快速排序算法的最坏情形复杂性。"
        },
        {
            "type": "list",
            "bbox": [
                0.055,
                0.209,
                0.905,
                0.406
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.059,
                0.42,
                0.262,
                0.438
            ],
            "angle": 0,
            "content": "5.5 程序正确性"
        },
        {
            "type": "title",
            "bbox": [
                0.06,
                0.447,
                0.187,
                0.464
            ],
            "angle": 0,
            "content": "5.5.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.467,
                0.907,
                0.559
            ],
            "angle": 0,
            "content": "假定设计了一个解决问题的算法，而且编写了实现它的程序。如何才能保证这个程序总是产生正确的答案？在消除了所有的错误使得语法正确之后，可以用简单的输入来测试这个程序。若对任何简单输入来说产生了不正确的结果，则它是不正确的。但是即使对所有的简单输入来说这个程序都给出了正确的答案，它也不一定总是产生正确的答案（除非已经测试了所有可能的输入）。需要一个说明这个程序总是给出正确答案的证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.561,
                0.907,
                0.653
            ],
            "angle": 0,
            "content": "程序验证（即程序正确性的证明）使用在本章里描述的推理规则和证明技术，包括数学归纳法。因为不正确的程序可能导致灾难性的后果，所以已经构造了大量的方法来对程序进行验证。在使程序验证自动化以便可以用计算机来完成方面已经做出了大量努力，但取得的进展是非常有限的。事实上，一些数学家和计算机理论家争论的使复杂程序的正确性证明机械化永远是不现实的。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.655,
                0.907,
                0.728
            ],
            "angle": 0,
            "content": "本节将介绍用来证明程序正确的一些概念和方法。有许多不同方法用来证明程序的正确性。在本节中我们将讨论广泛使用的由Tony Hoare提出的程序验证方法。还有一些其他方法也同样常用。不过，在本书中将不展开讨论程序验证的完整方法。本节将把逻辑规则、证明技术以及算法的概念联系在一起，对程序验证领域给予粗略的介绍。"
        },
        {
            "type": "title",
            "bbox": [
                0.064,
                0.738,
                0.235,
                0.755
            ],
            "angle": 0,
            "content": "5.5.2 程序验证"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.758,
                0.909,
                0.812
            ],
            "angle": 0,
            "content": "若对每个可能的输入来说程序都产生正确的输出，则说这个程序是正确的。一个程序的正确性证明包括两个部分。第一部分证明：若程序终止，则获得正确的答案。证明的这一部分证明了程序的部分正确性。证明的第二部分证明：程序总是终止。"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.814,
                0.909,
                0.869
            ],
            "angle": 0,
            "content": "为了规定程序产生正确的输出是什么意思，使用两个命题。第一个是初始断言，它给出输入值必须具有的性质。第二个是终结断言，它给出假如程序做了要求它做的事情，则程序的输出应当具有的性质。当验证一个程序时，必须提供适当的初始断言和终结断言。"
        },
        {
            "type": "text",
            "bbox": [
                0.071,
                0.876,
                0.904,
                0.933
            ],
            "angle": 0,
            "content": "定义1 若当对一个程序或程序段 \\(S\\) 的输入值来说初始断言 \\(p\\) 为真时，就有对 \\(S\\) 的输出值来说终结断言 \\(q\\) 为真，则说 \\(S\\) 是相对于 \\(p\\) 和 \\(q\\) 部分正确的。记号 \\(p\\{S\\} q\\) 说明程序或程序段 \\(S\\) 是相对于初始断言 \\(p\\) 和终结断言 \\(q\\) 部分正确的。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.136,
                0.036,
                0.172,
                0.049
            ],
            "angle": 0,
            "content": "330"
        },
        {
            "type": "header",
            "bbox": [
                0.217,
                0.034,
                0.282,
                0.05
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.091,
                0.861,
                0.107
            ],
            "angle": 0,
            "content": "注意 记号 \\( p\\{S\\} q \\) 称为霍尔三元组，因为托尼·霍尔引入了部分正确性的概念。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.11,
                0.953,
                0.145
            ],
            "angle": 0,
            "content": "注意，部分正确性的概念与程序是否终止是无关的，它仅仅关注若程序终止，则程序是否做了期待它做的事情。"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.148,
                0.655,
                0.165
            ],
            "angle": 0,
            "content": "可以用一个简单的例子说明初始断言和终结断言的概念。"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.169,
                0.307,
                0.187
            ],
            "angle": 0,
            "content": "例1 证明程序段"
        },
        {
            "type": "equation",
            "bbox": [
                0.481,
                0.195,
                0.546,
                0.209
            ],
            "angle": 0,
            "content": "\\[\ny := 2\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.482,
                0.215,
                0.582,
                0.228
            ],
            "angle": 0,
            "content": "\\[\nz := x + y\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.232,
                0.655,
                0.248
            ],
            "angle": 0,
            "content": "是相对于初始断言 \\( p: x = 1 \\) 和终结断言 \\( q: z = 3 \\) 部分正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.252,
                0.953,
                0.29
            ],
            "angle": 0,
            "content": "解假定 \\(p\\) 为真，所以在程序开始时 \\(x = 1\\) 。则把 \\(y\\) 赋值成2，而把 \\(z\\) 赋值成 \\(x\\) 和 \\(y\\) 值之和，即3。因此， \\(S\\) 是相对于初始断言 \\(p\\) 和终结断言 \\(q\\) 部分正确的。因此， \\(p\\{S\\} q\\) 为真。"
        },
        {
            "type": "title",
            "bbox": [
                0.105,
                0.302,
                0.279,
                0.319
            ],
            "angle": 0,
            "content": "5.5.3 推理规则"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.324,
                0.953,
                0.361
            ],
            "angle": 0,
            "content": "一条有用的推理规则是通过把一个程序分成一系列子程序，然后证明每个子程序为正确的来证明这个程序为正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.365,
                0.954,
                0.467
            ],
            "angle": 0,
            "content": "假定把程序 \\(S\\) 分成子程序 \\(S_{1}\\) 和 \\(S_{2}\\) 。写 \\(S = S_{1}\\) ； \\(S_{2}\\) 来表示 \\(S\\) 是由 \\(S_{1}\\) 后接 \\(S_{2}\\) 来组成的。假定已经证明了 \\(S_{1}\\) 相对于初始断言 \\(p\\) 和终结断言 \\(q\\) 的正确性，以及 \\(S_{2}\\) 相对于初始断言 \\(q\\) 和终结断言 \\(r\\) 的正确性。由此得出了若 \\(p\\) 为真且 \\(S_{1}\\) 执行并终止则 \\(q\\) 为真；若 \\(q\\) 为真且 \\(S_{2}\\) 执行并终止则 \\(r\\) 为真。因此，若 \\(p\\) 为真且 \\(S = S_{1}\\) ； \\(S_{2}\\) 执行并终止则 \\(r\\) 为真。这条推理规则称为合成规则，它可以叙述成"
        },
        {
            "type": "equation",
            "bbox": [
                0.187,
                0.478,
                0.251,
                0.493
            ],
            "angle": 0,
            "content": "\\[\np \\left\\{S _ {1} \\right\\} q\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.191,
                0.499,
                0.247,
                0.512
            ],
            "angle": 0,
            "content": "\\[\nq \\left\\{S _ {2} \\right\\} r\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.158,
                0.536,
                0.284,
                0.551
            ],
            "angle": 0,
            "content": "\\[\n\\therefore \\quad p \\left\\{S _ {1}; S _ {2} \\right\\} r\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.561,
                0.406,
                0.577
            ],
            "angle": 0,
            "content": "在本节后面将使用这条推理规则。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.58,
                0.951,
                0.616
            ],
            "angle": 0,
            "content": "下一步，将给出含有条件语句和循环的程序段的推理规则。因为可以把程序分成程序段，以便进行正确性证明，所以这样就能够验证许多不同的程序。"
        },
        {
            "type": "title",
            "bbox": [
                0.105,
                0.627,
                0.279,
                0.643
            ],
            "angle": 0,
            "content": "5.5.4 条件语句"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.647,
                0.643,
                0.663
            ],
            "angle": 0,
            "content": "首先将给出条件语句的推理规则。假定一个程序段形如"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.684,
                0.282,
                0.714
            ],
            "angle": 0,
            "content": "If condition then S"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.736,
                0.953,
                0.811
            ],
            "angle": 0,
            "content": "其中 \\(S\\) 是一个语句块。若 condition(条件)为真，则 \\(S\\) 执行，而当 condition 为假时，则 \\(S\\) 不执行。为了验证这个程序段相对于初始断言 \\(p\\) 和终结断言 \\(q\\) 来说是正确的，必须做两件事情。首先，必须证明当 \\(p\\) 为真且 condition 也为真时，在 \\(S\\) 终止之后 \\(q\\) 为真。其次，必须证明当 \\(p\\) 为真且 condition 为假时，\\(q\\) 为真（因为在这种情形中 \\(S\\) 不执行）。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.814,
                0.365,
                0.83
            ],
            "angle": 0,
            "content": "这导致下面的推理规则："
        },
        {
            "type": "equation",
            "bbox": [
                0.175,
                0.84,
                0.324,
                0.854
            ],
            "angle": 0,
            "content": "\\[\n(p \\wedge \\text {c o n d i t i o n}) \\{S \\} q\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.175,
                0.859,
                0.324,
                0.871
            ],
            "angle": 0,
            "content": "\\[\n(p \\wedge \\neg \\text {c o n d i t i o n}) \\rightarrow q\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.158,
                0.892,
                0.348,
                0.906
            ],
            "angle": 0,
            "content": "\\[\n\\therefore p \\{\\text {i f c o n d i t i o n t h e n} S \\} q\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.916,
                0.446,
                0.933
            ],
            "angle": 0,
            "content": "例2说明如何使用这条推理规则。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.684,
                0.039,
                0.793,
                0.053
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.841,
                0.04,
                0.874,
                0.052
            ],
            "angle": 0,
            "content": "331"
        },
        {
            "type": "title",
            "bbox": [
                0.097,
                0.097,
                0.256,
                0.115
            ],
            "angle": 0,
            "content": "例2 验证程序段"
        },
        {
            "type": "code",
            "bbox": [
                0.097,
                0.133,
                0.201,
                0.166
            ],
            "angle": 0,
            "content": "if \\(x > y\\) then \\(y\\coloneqq x\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.184,
                0.472,
                0.2
            ],
            "angle": 0,
            "content": "相对于初始断言 \\(\\mathbf{T}\\) 和终结断言 \\(y\\geq x\\) 是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.203,
                0.906,
                0.256
            ],
            "angle": 0,
            "content": "解 当初始断言为真且 \\(x > y\\) 时，则执行赋值语句 \\(y := x\\)。因此，在这种情形里，断言 \\(y \\geqslant x\\) 的终结断言为真。另外，当初始断言为真且 \\(x > y\\) 为假因而 \\(x \\leqslant y\\) 时，终结断言再次为真。因此，使用这种类型的程序段的推理规则，这个程序相对于给定的初始断言和终结断言是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.258,
                0.396,
                0.275
            ],
            "angle": 0,
            "content": "同理，考虑含有如下命题的程序。"
        },
        {
            "type": "code",
            "bbox": [
                0.096,
                0.292,
                0.229,
                0.359
            ],
            "angle": 0,
            "content": "if condition then \\(S_{1}\\)   \nelse \\(S_{2}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.376,
                0.906,
                0.448
            ],
            "angle": 0,
            "content": "若 condition(条件)为真，则执行 \\( S_{1} \\)；若 condition 为假，则执行 \\( S_{2} \\)。为了验证这个程序段相对于初始断言 \\( p \\) 和终结断言 \\( q \\) 是正确的，必须做两件事情。首先，必须证明当 \\( p \\) 为真且 condition 为真时，在 \\( S_{1} \\) 终止之后 \\( q \\) 为真。其次，必须证明当 \\( p \\) 为真且 condition 为假时，在 \\( S_{2} \\) 终止之后 \\( q \\) 为真。这导致下面的推理规则："
        },
        {
            "type": "code",
            "bbox": [
                0.121,
                0.455,
                0.294,
                0.491
            ],
            "angle": 0,
            "content": "\\((p \\wedge \\text{condition}) \\{S_1\\} q\\)  \n\\((p \\wedge \\neg \\text{condition}) \\{S_2\\} q\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.502,
                0.356,
                0.517
            ],
            "angle": 0,
            "content": "\\(\\therefore p\\{\\) if condition then \\(S_{1}\\) else \\(S_{2}\\} q\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.524,
                0.396,
                0.541
            ],
            "angle": 0,
            "content": "例3说明如何使用这条推理规则。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.545,
                0.254,
                0.562
            ],
            "angle": 0,
            "content": "例3 验证程序段"
        },
        {
            "type": "code",
            "bbox": [
                0.095,
                0.582,
                0.233,
                0.648
            ],
            "angle": 0,
            "content": "if \\(x <   0\\) then abs \\(\\coloneqq -x\\) else abs \\(\\coloneqq x\\)"
        },
        {
            "type": "image",
            "bbox": [
                0.055,
                0.667,
                0.123,
                0.69
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.064,
                0.703,
                0.203,
                0.818
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.064,
                0.823,
                0.178,
                0.833
            ],
            "angle": 0,
            "content": "Courtesy of Tony Hoare"
        },
        {
            "type": "text",
            "bbox": [
                0.214,
                0.702,
                0.902,
                0.786
            ],
            "angle": 0,
            "content": "C.安东尼·R.霍尔(C.Annony R.Hoare，1934—）霍尔出生在锡兰（现在称为斯里兰卡)的科伦坡，他的父亲是大英帝国在锡兰的公务员，他的外祖父在锡兰拥有一个种植园。他在那里度过了少年时光，并于1945年移居英格兰。霍尔在牛津大学学习哲学和古典学，同时，对数理逻辑的力量和数学真值的确定性的痴迷使得他开始对计算技术感兴趣。他于1956年从牛津大学获得学士学位。"
        },
        {
            "type": "text",
            "bbox": [
                0.214,
                0.788,
                0.902,
                0.837
            ],
            "angle": 0,
            "content": "霍尔在英国皇家海军服务期间学习了俄语，后来，他在莫斯科国立大学研究计算机自然语言翻译。他于1960年回到了英格兰，在一家小型计算机制造厂工作，在那里他写出了Algol编程语言的编译器。1968年，他成为贝尔法斯特女王大学的计"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.84,
                0.901,
                0.872
            ],
            "angle": 0,
            "content": "计算机科学教授；1977年，他移居到英国牛津大学，成为一名计算技术教授，他现在还是一名名誉教授。他是英国皇家学会的院士，并在微软剑桥研究中心拥有一个职位。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.875,
                0.902,
                0.942
            ],
            "angle": 0,
            "content": "霍尔在编程语言和编程方法论方面做出了许多贡献。他首次定义了一种基于如何证明程序正确符合其需求规格的编程语言。霍尔还发明了一种最常用的排序算法：快速排序算法（见5.4节练习50的前导文）。1980年他获得ACM图灵奖，2000年他因在教育和计算机科学的贡献被封为爵士。霍尔还是一位计算机科学在技术和社会方面的著名作家。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.134,
                0.04,
                0.172,
                0.054
            ],
            "angle": 0,
            "content": "332"
        },
        {
            "type": "header",
            "bbox": [
                0.216,
                0.039,
                0.282,
                0.054
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.096,
                0.565,
                0.112
            ],
            "angle": 0,
            "content": "相对于初始断言 \\(\\mathbf{T}\\) 和终结断言 \\(\\mathrm{abs} = |x|\\) 是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.117,
                0.959,
                0.237
            ],
            "angle": 0,
            "content": "解 必须证明两件事情。首先必须证明：若初始断言为真且 \\(x < 0\\)，则 \\(\\mathrm{abs} = |x|\\)。这是正确的，因为当 \\(x < 0\\) 时赋值语句 \\(\\mathrm{abs} := -x\\) 让 \\(\\mathrm{abs} = -x\\) 成立，根据定义当 \\(x < 0\\) 时它是 \\(|x|\\)。其次必须证明：若初始断言为真且 \\(x < 0\\) 为假时，（所以 \\(x \\geqslant 0\\)）则 \\(\\mathrm{abs} = |x|\\)。这是正确的，因为在这种情形中，程序使用赋值语句 \\(\\mathrm{abs} := x\\)，而根据定义，当 \\(x \\geqslant 0\\) 时 \\(x\\) 是 \\(|x|\\)，所以 \\(\\mathrm{abs} = x\\)。因此，利用对于这种类型的程序段的推理规则，这个程序相对于给定的初始断言和终结断言是正确的。"
        },
        {
            "type": "title",
            "bbox": [
                0.107,
                0.248,
                0.307,
                0.265
            ],
            "angle": 0,
            "content": "5.5.5 循环不变量"
        },
        {
            "type": "text",
            "bbox": [
                0.149,
                0.268,
                0.837,
                0.285
            ],
            "angle": 0,
            "content": "下面将描述while循环的正确性证明。为了逐步如下类型程序段的推理规则："
        },
        {
            "type": "code",
            "bbox": [
                0.152,
                0.307,
                0.275,
                0.34
            ],
            "angle": 0,
            "content": "while condition S"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.361,
                0.962,
                0.397
            ],
            "angle": 0,
            "content": "注意，S反复执行直到condition变假为止。必须选择一个每次执行S时都保持为真的断言。这样的断言称为循环不变量。换句话说，若 \\((p\\wedge\\) condition） \\(\\{S\\} p\\) 为真，则 \\(p\\) 是循环不变量。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.4,
                0.962,
                0.437
            ],
            "angle": 0,
            "content": "假定 \\(p\\) 是循环不变量。可以得出若在执行这个程序段之前 \\(p\\) 为真，则在程序终止后 \\(p\\) 和 \\(\\neg\\) condition都为真，假如程序真的终止。这个推理规则是"
        },
        {
            "type": "code",
            "bbox": [
                0.164,
                0.448,
                0.46,
                0.5
            ],
            "angle": 0,
            "content": "\\((p\\wedge\\) condition) \\(\\{S\\} p\\) \\(\\therefore p\\{\\mathrm{while~condition~}S\\} (\\neg \\mathrm{condition}\\land p)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.153,
                0.51,
                0.438,
                0.526
            ],
            "angle": 0,
            "content": "例4说明如何使用循环不变量。"
        },
        {
            "type": "text",
            "bbox": [
                0.152,
                0.532,
                0.926,
                0.55
            ],
            "angle": 0,
            "content": "例4需要一个循环不变量来验证当 \\(n\\) 是正整数时，如下程序段以factorial \\(\\equiv n!\\) 终止。"
        },
        {
            "type": "code",
            "bbox": [
                0.154,
                0.574,
                0.391,
                0.678
            ],
            "angle": 0,
            "content": "\\(\\mathrm{i}\\coloneqq 1\\)   \nfactorial \\(:=1\\)   \nwhile \\(i <   n\\)   \nbegin  \n\\(i\\coloneqq i + 1\\)   \nfactorial \\(\\coloneqq\\) factorial·i"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.699,
                0.967,
                0.776
            ],
            "angle": 0,
            "content": "设 \\(p\\) 是命题：“factorial \\(= i!\\) 并且 \\(i \\leqslant n\\)”。首先证明 \\(p\\) 是循环不变量。假设在执行一遍 while 循环的开头时，\\(p\\) 为真而且 while 循环的条件成立。换句话说，factorial \\(= i!\\) 且 \\(i < n\\)。\\(i\\) 和 factorial 的新值 \\(i_{\\text{new}}\\) 和 factorial现在是 \\(i_{\\text{new}} = i + 1\\) 和 factorial \\(= \\text{factorial} \\cdot (i + 1) = (i + 1)! = i_{\\text{new}}!\\)。由于 \\(i < n\\)，所以也有 \\(i_{\\text{new}} = i + 1 \\leqslant n\\)。因此在循环执行的结尾 \\(p\\) 为真。这就证明了 \\(p\\) 是循环不变量。"
        },
        {
            "type": "text",
            "bbox": [
                0.115,
                0.779,
                0.967,
                0.854
            ],
            "angle": 0,
            "content": "现在考虑上述程序段。在正好要进入循环之前，\\(i = 1 \\leqslant n\\) 和 factorial \\(= 1 = 1! = i!\\) 都为真，所以 \\(p\\) 为真。由于 \\(p\\) 是循环不变量，所以刚刚介绍过的推理规则就蕴含着如果 while 循环终止，那么循环终止时 \\(p\\) 为真且 \\(i < n\\) 为假。在这样的情况下，最终 factorial \\(= i!\\) 和 \\(i \\leqslant n\\) 都为真，但 \\(i < n\\) 为假。换句话说，\\(i = n\\) 且 factorial \\(= i! = n!\\)，这正是想要的结果。"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.856,
                0.966,
                0.892
            ],
            "angle": 0,
            "content": "最后还需要验证 while 循环确实终止。在程序开头把 \\(i\\) 赋值成 1，所以在 \\(n - 1\\) 次执行循环后，\\(i\\) 的新的值是 \\(n\\)，循环在这时就终止了。"
        },
        {
            "type": "text",
            "bbox": [
                0.158,
                0.895,
                0.893,
                0.911
            ],
            "angle": 0,
            "content": "下面将给出最后一个例子来说明如何用各种推理规则来验证较长的程序的正确性。"
        },
        {
            "type": "text",
            "bbox": [
                0.158,
                0.918,
                0.682,
                0.936
            ],
            "angle": 0,
            "content": "例5 简述如何验证计算两个整数之积的程序 \\(S\\) 的正确性。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.677,
                0.04,
                0.788,
                0.055
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.834,
                0.042,
                0.87,
                0.055
            ],
            "angle": 0,
            "content": "333"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.106,
                0.352,
                0.122
            ],
            "angle": 0,
            "content": "procedure multiply \\((m, n\\) ：整数）"
        },
        {
            "type": "algorithm",
            "bbox": [
                0.092,
                0.125,
                0.345,
                0.318
            ],
            "angle": 0,
            "content": "\\(\\begin{array}{l}S_{1}\\left\\{ \\begin{array}{ll}\\text{if} n <   0\\text{then} a:= -n\\\\ \\text{else} a:= n \\end{array} \\right.\\\\ S_{2}\\left\\{ \\begin{array}{ll}k:= 0\\\\ x:= 0 \\end{array} \\right.\\\\ S_{3}\\left\\{ \\begin{array}{ll}\\text{while} k <   a\\\\ x:= x + m\\\\ k:= k + 1 \\end{array} \\right.\\\\ S_{4}\\left\\{ \\begin{array}{ll}\\text{if} n <   0\\text{then product}:= -x\\\\ \\text{else product}:= x \\end{array} \\right.\\\\ \\text{return product}\\\\ \\{\\text{product等于} mn\\} \\end{array}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.336,
                0.905,
                0.391
            ],
            "angle": 0,
            "content": "目标是证明在执行 \\(S\\) 之后 product 有值 \\(mn\\)。通过把 \\(S\\) 分成 \\(S = S_{1}\\)；\\(S_{2}\\)；\\(S_{3}\\)；\\(S_{4}\\)，如 \\(S\\) 的程序清单所示那样，就可以完成正确性证明。可以用合成规则来建立正确性证明。细节将留给读者作为练习。"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.394,
                0.906,
                0.507
            ],
            "angle": 0,
            "content": "设 \\(p\\) 是初始断言：\\(m\\) 和 \\(n\\) 都是整数。则可以证明当 \\(q\\) 是命题 \\(p \\wedge (a = |n|)\\) 时，\\(p\\{S_1\\} q\\) 为真。下一步，设 \\(r\\) 是命题 \\(q \\wedge (k = 0) \\wedge (x = 0)\\) 。容易验证 \\(q\\{S_2\\} r\\) 为真。可以证明“\\(x = mk\\) 且 \\(k \\leqslant a\\)”是 \\(S_3\\) 中的循环不变量。另外，容易看出，在 \\(a\\) 次循环之后循环终止且 \\(k = a\\)，所以这时 \\(x = ma\\)。因为 \\(r\\) 蕴含着 \\(x = m \\cdot 0\\) 和 \\(0 \\leqslant a\\)，所以在进入循环之前循环不变量为真。因为循环终止且 \\(k = a\\)，所以得出 \\(r\\{S_3\\} s\\) 为真，其中 \\(s\\) 是命题“\\(x = ma\\) 且 \\(a = |n|\\)”。最后，可以证明 \\(S_4\\) 相对于初始断言 \\(s\\) 和终结断言 \\(t\\) 是正确的，其中 \\(t\\) 是命题“product = mn”。"
        },
        {
            "type": "text",
            "bbox": [
                0.054,
                0.509,
                0.906,
                0.564
            ],
            "angle": 0,
            "content": "把所有这些结果放到一起来考虑，因为 \\( p\\{S_1\\} q \\) 、 \\( q\\{S_2\\} r \\) 、 \\( r\\{S_3\\} s \\) 和 \\( s\\{S_4\\} t \\) 都为真，所以从合成规则得出 \\( p\\{S\\} t \\) 为真。另外，因为所有4个程序段都终止，所以 \\( S \\) 终止。这样就验证了这个程序的正确性。"
        },
        {
            "type": "title",
            "bbox": [
                0.056,
                0.575,
                0.102,
                0.59
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.595,
                0.175,
                0.61
            ],
            "angle": 0,
            "content": "1. 证明程序段"
        },
        {
            "type": "equation",
            "bbox": [
                0.078,
                0.619,
                0.159,
                0.649
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} y := 1 \\\\ z := x + y \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.658,
                0.482,
                0.673
            ],
            "angle": 0,
            "content": "相对于初始断言 \\(x = 0\\) 和终结断言 \\(z = 1\\) 是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.676,
                0.176,
                0.69
            ],
            "angle": 0,
            "content": "2. 验证程序段"
        },
        {
            "type": "equation",
            "bbox": [
                0.078,
                0.699,
                0.225,
                0.712
            ],
            "angle": 0,
            "content": "\\[\ni f x <   0 \\text {t h e n} x := 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.722,
                0.456,
                0.736
            ],
            "angle": 0,
            "content": "相对于初始断言 \\(\\mathbf{T}\\) 和终结断言 \\(x\\geq 0\\) 是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.74,
                0.176,
                0.754
            ],
            "angle": 0,
            "content": "3. 验证程序段"
        },
        {
            "type": "equation",
            "bbox": [
                0.08,
                0.763,
                0.19,
                0.826
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} x := 2 \\\\ z := x + y \\\\ i f y > 0 \\text {t h e n} \\\\ z := z + 1 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.832,
                0.111,
                0.842
            ],
            "angle": 0,
            "content": "else"
        },
        {
            "type": "equation",
            "bbox": [
                0.116,
                0.848,
                0.166,
                0.859
            ],
            "angle": 0,
            "content": "\\[\nz := 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.869,
                0.482,
                0.884
            ],
            "angle": 0,
            "content": "相对于初始断言 \\(y = 3\\) 和终结断言 \\(z = 6\\) 是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.888,
                0.178,
                0.901
            ],
            "angle": 0,
            "content": "4. 验证程序段"
        },
        {
            "type": "equation",
            "bbox": [
                0.08,
                0.911,
                0.187,
                0.94
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} i f x <   y \\text {t h e n} \\\\ \\min  := x \\\\ \\end{array}\n\\]"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.14,
                0.039,
                0.176,
                0.053
            ],
            "angle": 0,
            "content": "334"
        },
        {
            "type": "header",
            "bbox": [
                0.222,
                0.038,
                0.288,
                0.054
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "code",
            "bbox": [
                0.135,
                0.097,
                0.241,
                0.125
            ],
            "angle": 0,
            "content": "else min \\(\\coloneqq y\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.135,
                0.751,
                0.15
            ],
            "angle": 0,
            "content": "相对于初始断言 \\(\\mathbf{T}\\) 和终结断言 \\((x\\leqslant y\\land \\min = x)\\lor (x > y\\land \\min = y)\\) 是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.153,
                0.38,
                0.167
            ],
            "angle": 0,
            "content": "*5. 设计一条推理规则来验证形如"
        },
        {
            "type": "code",
            "bbox": [
                0.134,
                0.178,
                0.303,
                0.293
            ],
            "angle": 0,
            "content": "if condition 1 then \\(S_{1}\\)   \nelse if condition 2 then \\(S_{2}\\) （204   \nelse \\(S_{n}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.134,
                0.303,
                0.601,
                0.317
            ],
            "angle": 0,
            "content": "的语句的部分正确性，其中 \\(S_{1}\\) ， \\(S_{2}\\) ，…， \\(S_{n}\\) 都是语句块。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.321,
                0.472,
                0.335
            ],
            "angle": 0,
            "content": "6. 使用在练习5讨论的推理规则来验证程序"
        },
        {
            "type": "code",
            "bbox": [
                0.134,
                0.345,
                0.293,
                0.443
            ],
            "angle": 0,
            "content": "if \\(x <   0\\) then \\(y:= -2\\mid x\\mid /x\\)   \nelse if \\(x > 0\\) then \\(y:= 2\\mid x\\mid /x\\)   \nelse if \\(x = 0\\) then \\(y:= 2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.133,
                0.453,
                0.511,
                0.468
            ],
            "angle": 0,
            "content": "相对于初始断言 \\(\\mathbf{T}\\) 和终结断言 \\(y = 2\\) 是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.47,
                0.798,
                0.485
            ],
            "angle": 0,
            "content": "7. 用循环不变量证明下述计算实数 \\(x\\) 的 \\(n\\) 次方幂的程序是正确的，其中 \\(n\\) 是正整数。"
        },
        {
            "type": "code",
            "bbox": [
                0.134,
                0.496,
                0.301,
                0.575
            ],
            "angle": 0,
            "content": "power \\(: = 1\\)   \ni:=1   \nwhile \\(i\\leqslant n\\) power \\(\\coloneqq\\) power \\(\\ast x\\) （204 \\(i\\coloneqq i + 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.587,
                0.526,
                0.601
            ],
            "angle": 0,
            "content": "* 8. 证明在 5.4 节给出的求 \\( f_{n} \\) 的迭代程序是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.605,
                0.48,
                0.618
            ],
            "angle": 0,
            "content": "9. 给出在例5给出的正确性证明的所有细节。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.622,
                0.742,
                0.637
            ],
            "angle": 0,
            "content": "10. 假定蕴含式 \\(p_0 \\rightarrow p_1\\) 和程序断言 \\(p_1\\{S\\} q\\) 都为真。证明 \\(p_0\\{S\\} q\\) 也必然为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.64,
                0.737,
                0.655
            ],
            "angle": 0,
            "content": "11. 假定程序断言 \\( p\\{S\\} q_0 \\) 和蕴含式 \\( q_0 \\rightarrow q_1 \\) 都为真。证明 \\( p\\{S\\} q_1 \\) 也必然为真。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.658,
                0.378,
                0.672
            ],
            "angle": 0,
            "content": "12. 下面的程序计算商数和余数。"
        },
        {
            "type": "code",
            "bbox": [
                0.143,
                0.684,
                0.236,
                0.764
            ],
            "angle": 0,
            "content": "\\(r\\coloneqq a\\)   \n\\(q\\coloneqq 0\\)   \nwhile \\(r\\geqslant d\\) （20 \\(r\\coloneqq r - d\\)   \n\\(q\\coloneqq q + 1\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.773,
                0.957,
                0.806
            ],
            "angle": 0,
            "content": "验证它相对于初始断言“ \\(a\\) 和 \\(d\\) 都是正整数”和终结断言“ \\(q\\) 和 \\(r\\) 是使得 \\(a = dq + r\\) 和 \\(0 \\leqslant r < d\\) 的整数”是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.808,
                0.956,
                0.841
            ],
            "angle": 0,
            "content": "13. 用循环不变量验证欧几里得算法(4.3节算法1)相对于初始断言“ \\(a\\) 和 \\(b\\) 都是正整数”和终结断言“ \\(x = \\gcd(a, b)\\)”是部分正确的。"
        },
        {
            "type": "title",
            "bbox": [
                0.11,
                0.856,
                0.301,
                0.874
            ],
            "angle": 0,
            "content": "关键术语和结论"
        },
        {
            "type": "title",
            "bbox": [
                0.11,
                0.884,
                0.16,
                0.898
            ],
            "angle": 0,
            "content": "术语"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.903,
                0.581,
                0.918
            ],
            "angle": 0,
            "content": "序列（sequence）：以整数集合的子集合作为定义域的函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.921,
                0.811,
                0.936
            ],
            "angle": 0,
            "content": "几何序列（geometricprogression）：形如 \\(a\\) ， \\(ar\\) ， \\(ar^2\\) ，…的序列，其中 \\(a\\) 和 \\(r\\) 都是实数。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.669,
                0.038,
                0.78,
                0.052
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.826,
                0.039,
                0.862,
                0.052
            ],
            "angle": 0,
            "content": "335"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.094,
                0.792,
                0.108
            ],
            "angle": 0,
            "content": "等差序列(arithmetic progression)：形如 \\(a\\) ， \\(a + d\\) ， \\(a + 2d\\) ，…的序列，其中 \\(a\\) 和 \\(d\\) 都是实数。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.112,
                0.89,
                0.144
            ],
            "angle": 0,
            "content": "数学归纳法原理（the principle of mathematical induction）：命题“若 \\(P(1)\\) 为真且 \\(\\forall k[P(k) \\rightarrow P(k + 1)]\\) 为真，则 \\(\\forall nP(n)\\) 为真”。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.147,
                0.613,
                0.162
            ],
            "angle": 0,
            "content": "基础步骤（basis step）：在 \\(\\forall nP(n)\\) 的数学归纳法证明中对 \\(P(1)\\) 的证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.165,
                0.731,
                0.18
            ],
            "angle": 0,
            "content": "归纳步骤(inductive step)：在 \\(\\forall nP(n)\\) 的数学归纳法证明中对 \\(P(k)\\rightarrow P(k + 1)\\) 的证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.183,
                0.888,
                0.216
            ],
            "angle": 0,
            "content": "强归纳法(strong induction)：命题“若 \\(P(1)\\) 为真且 \\(\\forall k[(P(1) \\land \\dots \\land P(k)) \\rightarrow P(k + 1)]\\) 为真，则 \\(\\forall nP(n)\\) 为真”。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.219,
                0.638,
                0.234
            ],
            "angle": 0,
            "content": "良序性（well-ordering property）：非负整数的每个非空集合都有最小元素。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.238,
                0.888,
                0.27
            ],
            "angle": 0,
            "content": "函数的递归定义（recursive definition of a function）：规定一组初始的函数值以及从较小整数处的函数值获得较大整数处的函数值的规则。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.273,
                0.888,
                0.305
            ],
            "angle": 0,
            "content": "集合的递归定义(recursive definition of a set)：规定集合里的一组初始元素以及从已知属于集合的元素获得其他元素的规则。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.309,
                0.649,
                0.324
            ],
            "angle": 0,
            "content": "结构归纳法（structural induction）：证明关于递归定义的集合的结果的技术。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.327,
                0.776,
                0.342
            ],
            "angle": 0,
            "content": "递归算法（recursive algorithm）：通过把问题归约到带有较小输入的同样问题而进行的算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.345,
                0.888,
                0.377
            ],
            "angle": 0,
            "content": "归并排序（merge sort）：排序一个表的排序算法，它把一个表分成两个表，对得出的两个表各自进行排序，并且把结果归并成一个有序表。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.381,
                0.468,
                0.395
            ],
            "angle": 0,
            "content": "迭代（iteration）：基于反复利用循环中的操作的过程。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.399,
                0.598,
                0.413
            ],
            "angle": 0,
            "content": "程序正确性(program correctness)：对过程总是产生正确结果的验证。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.417,
                0.621,
                0.431
            ],
            "angle": 0,
            "content": "循环不变量（loop invariant）：在循环的每次执行期间都保持为真的性质。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.435,
                0.597,
                0.449
            ],
            "angle": 0,
            "content": "初始断言(initial assertion)：规定程序的输入值所具有的性质的命题。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.453,
                0.734,
                0.467
            ],
            "angle": 0,
            "content": "终结断言（final assertion）：规定若程序正确地工作则输出值所应当具有的性质的命题。"
        },
        {
            "type": "title",
            "bbox": [
                0.043,
                0.482,
                0.122,
                0.501
            ],
            "angle": 0,
            "content": "复习题"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.509,
                0.558,
                0.523
            ],
            "angle": 0,
            "content": "1. a)能否用数学归纳法原理求出一个序列的前 \\(n\\) 项之和的公式？"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.526,
                0.687,
                0.541
            ],
            "angle": 0,
            "content": "b)能否用数学归纳法原理来判定一个序列的前 \\(n\\) 项之和的给定公式是正确的？"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.545,
                0.553,
                0.559
            ],
            "angle": 0,
            "content": "c)求出前 \\(n\\) 个正偶数之和的公式，并且用数学归纳法证明它。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.563,
                0.406,
                0.577
            ],
            "angle": 0,
            "content": "2. a) 对哪些正整数 \\( n \\) 来说 \\( 11n + 17 \\leqslant 2^n \\) 为真？"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.581,
                0.387,
                0.595
            ],
            "angle": 0,
            "content": "b)用数学归纳法来证明a中所做的猜想。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.599,
                0.5,
                0.613
            ],
            "angle": 0,
            "content": "3. a) 仅用 5 分和 9 分的邮票，可以组成哪些数量的邮资？"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.617,
                0.333,
                0.631
            ],
            "angle": 0,
            "content": "b)用数学归纳法证明所做的猜想。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.635,
                0.404,
                0.649
            ],
            "angle": 0,
            "content": "c)用数学归纳法第二原理证明所做的猜想。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.653,
                0.404,
                0.666
            ],
            "angle": 0,
            "content": "d)找出与b和c中所给出的证明不同之处。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.67,
                0.406,
                0.684
            ],
            "angle": 0,
            "content": "4. 给出使用强归纳法的三个不同的证明例子。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.688,
                0.293,
                0.702
            ],
            "angle": 0,
            "content": "5. a)叙述正整数集合的良序性。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.706,
                0.516,
                0.72
            ],
            "angle": 0,
            "content": "b)利用这个性质证明：每个正整数都可以写成素数之积。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.724,
                0.885,
                0.756
            ],
            "angle": 0,
            "content": "6. a) 解释为什么若通过规定 \\( f(1) \\) 以及从 \\( f(n - 1) \\) 求出 \\( f(n) \\) 的规则来递归地定义一个函数，则这个函数是良定义的。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.76,
                0.393,
                0.774
            ],
            "angle": 0,
            "content": "b)给出函数 \\(f(n) = (n + 1)\\) 的递归定义。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.778,
                0.312,
                0.792
            ],
            "angle": 0,
            "content": "7. a)给出斐波那契数的递归定义。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.798,
                0.761,
                0.813
            ],
            "angle": 0,
            "content": "b)证明：当 \\(n\\geq 3\\) 时，有 \\(f_{n} > \\alpha^{n - 2}\\) ，其中 \\(f_{n}\\) 是斐波那契序列的第 \\(n\\) 项而 \\(\\alpha = (1 + \\sqrt{5}) / 2\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.817,
                0.885,
                0.849
            ],
            "angle": 0,
            "content": "8. a) 解释为什么若通过规定 \\(a_1\\) 和 \\(a_2\\) 以及从 \\(a_1, a_2, \\cdots, a_{n-1} (n = 3, 4, 5, \\cdots)\\) 来求 \\(a_n\\) 的规则来递归地定义一个序列，则这个序列是良定义的。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.852,
                0.718,
                0.867
            ],
            "angle": 0,
            "content": "b)若 \\(a_1 = 1\\) ， \\(a_2 = 2\\) ， \\(a_{n} = a_{n - 1} + a_{n - 2} + \\dots +a_{1}\\) ， \\(n = 3\\) ，4，5，…，试求出 \\(a_{n}\\) 的值。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.87,
                0.739,
                0.884
            ],
            "angle": 0,
            "content": "9. 给出两个例子说明对由元素和运算组成的不同集合来说，如何递归地定义合式公式。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.888,
                0.321,
                0.902
            ],
            "angle": 0,
            "content": "10. a)给出字符串长度的递归定义。"
        },
        {
            "type": "text",
            "bbox": [
                0.071,
                0.906,
                0.441,
                0.92
            ],
            "angle": 0,
            "content": "b)用a的递归定义来证明 \\(l(xy) = l(x) + l(y)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.924,
                0.229,
                0.938
            ],
            "angle": 0,
            "content": "11. a) 什么是递归算法？"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.144,
                0.038,
                0.18,
                0.051
            ],
            "angle": 0,
            "content": "336"
        },
        {
            "type": "header",
            "bbox": [
                0.226,
                0.037,
                0.291,
                0.052
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.093,
                0.496,
                0.108
            ],
            "angle": 0,
            "content": "b)描述计算序列里 \\(n\\) 个数之和的递归算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.111,
                0.533,
                0.126
            ],
            "angle": 0,
            "content": "12. 描述计算两个正整数的最大公因子的递归算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.129,
                0.328,
                0.143
            ],
            "angle": 0,
            "content": "13. a)描述归并排序算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.146,
                0.697,
                0.16
            ],
            "angle": 0,
            "content": "b)用归并排序算法把表4，10，1，5，3，8，7，2，6，9排成升序。"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.164,
                0.517,
                0.178
            ],
            "angle": 0,
            "content": "c)给出归并排序使用的比较次数的大 \\(O\\) 估计。"
        },
        {
            "type": "list",
            "bbox": [
                0.147,
                0.146,
                0.697,
                0.178
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.181,
                0.965,
                0.214
            ],
            "angle": 0,
            "content": "14. a) 测试一个计算机程序，看看对某些输入值来说它是否产生了正确的输出，是否这样就验证了这个程序总是产生正确的输出？"
        },
        {
            "type": "text",
            "bbox": [
                0.147,
                0.217,
                0.965,
                0.25
            ],
            "angle": 0,
            "content": "b)证明了一个计算机程序是相对于初始断言和终结断言为部分正确的，是否这样就验证了这个程序总是产生正确的输出？若不是，则还需要证明什么其他东西？"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.253,
                0.814,
                0.269
            ],
            "angle": 0,
            "content": "15. 可以用什么技术来证明长的计算机程序相对于初始断言和终结断言是部分正确的？"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.271,
                0.5,
                0.286
            ],
            "angle": 0,
            "content": "16. 什么是循环不变量？如何使用循环不变量？"
        },
        {
            "type": "title",
            "bbox": [
                0.119,
                0.302,
                0.229,
                0.32
            ],
            "angle": 0,
            "content": "补充练习"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.328,
                0.7,
                0.354
            ],
            "angle": 0,
            "content": "1. 用数学归纳法证明 \\(\\frac{2}{3} + \\frac{2}{9} + \\frac{2}{27} + \\dots + \\frac{2}{3^n} = 1 - \\frac{1}{3^n}\\)，其中 \\(n\\) 是正整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.358,
                0.792,
                0.373
            ],
            "angle": 0,
            "content": "2. 证明：当 \\(n\\) 是正整数时，有 \\(1^{3} + 3^{3} + 5^{3} + \\dots + (2n + 1)^{3} = (n + 1)^{2}(2n2 + 4n + 1)\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.377,
                0.807,
                0.391
            ],
            "angle": 0,
            "content": "3. 证明：当 \\(n\\) 是正整数时，有 \\(1 \\cdot 2^{0} + 2 \\cdot 2^{1} + 3 \\cdot 2^{2} + \\dots + n \\cdot 2^{n - 1} = (n - 1) \\cdot 2^{n} + 1\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.396,
                0.37,
                0.41
            ],
            "angle": 0,
            "content": "4. 证明：当 \\(n\\) 是正整数时，有"
        },
        {
            "type": "list",
            "bbox": [
                0.119,
                0.328,
                0.807,
                0.41
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "equation",
            "bbox": [
                0.37,
                0.414,
                0.724,
                0.441
            ],
            "angle": 0,
            "content": "\\[\n\\frac {1}{1 \\cdot 3} + \\frac {1}{3 \\cdot 5} + \\dots + \\frac {1}{(2 n - 1) (2 n + 1)} = \\frac {n}{2 n + 1}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.444,
                0.371,
                0.459
            ],
            "angle": 0,
            "content": "5. 证明：当 \\(n\\) 是正整数时，有"
        },
        {
            "type": "equation",
            "bbox": [
                0.37,
                0.463,
                0.724,
                0.489
            ],
            "angle": 0,
            "content": "\\[\n\\frac {1}{1 \\cdot 4} + \\frac {1}{4 \\cdot 7} + \\dots + \\frac {1}{(3 n - 2) (3 n + 1)} = \\frac {n}{3 n + 1}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.493,
                0.54,
                0.508
            ],
            "angle": 0,
            "content": "6. 证明：当 \\(n\\) 是大于4的正整数时，有 \\(2^{n} > n^{2} + n\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.511,
                0.642,
                0.525
            ],
            "angle": 0,
            "content": "7. 用数学归纳法证明：当 \\(n\\) 是大于9的正整数时，就有 \\(2^{n} > n^{3}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.529,
                0.834,
                0.543
            ],
            "angle": 0,
            "content": "8. 求出整数 \\(N\\) ，使得当 \\(n\\) 大于 \\(N\\) 时，有 \\(2^{n} > n^{4}\\) 。用数学归纳法证明你的结果是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.547,
                0.65,
                0.561
            ],
            "angle": 0,
            "content": "9. 用数学归纳法证明：当 \\(n\\) 是正整数时，\\(a - b\\) 是 \\(a^n - b^n\\) 的因子。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.564,
                0.78,
                0.579
            ],
            "angle": 0,
            "content": "10. 用数学归纳法证明：当 \\(n\\) 是非负整数时，\\(n^3 + (n + 1)^3 + (n + 2)^3\\) 能被9整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.583,
                0.676,
                0.597
            ],
            "angle": 0,
            "content": "11. 用数学归纳法证明：当 \\(n\\) 是正整数时，\\(6^{n+1} + 7^{2n-1}\\) 能被43整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.601,
                0.712,
                0.615
            ],
            "angle": 0,
            "content": "12. 用数学归纳法证明：当 \\(n\\) 是正整数时，\\(3^{2n+2} + 56n + 55\\) 能被 64 整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.619,
                0.523,
                0.633
            ],
            "angle": 0,
            "content": "13. 用数学归纳法证明等差序列各项之和的公式："
        },
        {
            "type": "list",
            "bbox": [
                0.12,
                0.493,
                0.834,
                0.633
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "equation",
            "bbox": [
                0.374,
                0.636,
                0.756,
                0.651
            ],
            "angle": 0,
            "content": "\\[\na + (a + d) + \\dots + (a + n d) = (n + 1) (2 a + n d) / 2\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.654,
                0.706,
                0.668
            ],
            "angle": 0,
            "content": "14. 假定对 \\(j = 1,2,\\dots ,n\\) 来说， \\(a_{j}\\equiv b_{j}(\\mathrm{mod}m)\\) 。用数学归纳法证明："
        },
        {
            "type": "text",
            "bbox": [
                0.156,
                0.673,
                0.375,
                0.707
            ],
            "angle": 0,
            "content": "a) \\(\\sum_{j = 1}^{n}a_{j}\\equiv \\sum_{j = 1}^{n}b_{j}(\\mathrm{mod} m)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.156,
                0.709,
                0.375,
                0.741
            ],
            "angle": 0,
            "content": "b) \\(\\prod_{j = 1}^{n}a_{j}\\equiv \\prod_{j = 1}^{n}b_{j}(\\mathrm{mod} m)\\)"
        },
        {
            "type": "list",
            "bbox": [
                0.156,
                0.673,
                0.375,
                0.741
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.742,
                0.367,
                0.757
            ],
            "angle": 0,
            "content": "15. 证明：若 \\(n\\) 是正整数，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.387,
                0.762,
                0.712,
                0.793
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {k = 1} ^ {n} \\frac {k + 4}{k (k + 1) (k + 2)} = \\frac {n (3 n + 7)}{2 (n + 1) (n + 2)}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.795,
                0.731,
                0.81
            ],
            "angle": 0,
            "content": "16. 对于哪些正整数 \\(n\\) ， \\(n + 6 < (n^2 - 8n) / 16?\\) 用数学归纳法证明你的答案。"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.812,
                0.974,
                0.845
            ],
            "angle": 0,
            "content": "17.（需要微积分知识）假设 \\(f(x) = \\mathrm{e}^{x}\\) 并且 \\(g(x) = x\\mathrm{e}^{x}\\) 。用数学归纳法以及乘积求导规则和 \\(f^{\\prime}(x) = \\mathrm{e}^{x}\\) 的事实来证明：当 \\(n\\) 是正整数时， \\(g(n)(x) = (x + n)\\mathrm{e}^{x}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.127,
                0.848,
                0.974,
                0.881
            ],
            "angle": 0,
            "content": "18. (需要微积分知识) 假设 \\( f(x) = \\mathrm{e}^{x} \\) 并且 \\( g(x) = \\mathrm{e}^{cx} \\)，其中 \\( c \\) 是常数。用数学归纳法以及复合求导规则和 \\( f'(x) = \\mathrm{e}^{x} \\) 的事实来证明：当 \\( n \\) 是正整数时，\\( g(n) = c^{n}\\mathrm{e}^{cx} \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.884,
                0.748,
                0.898
            ],
            "angle": 0,
            "content": "* 19. 确定哪些斐波那契数是偶数，用数学归纳法的一种形式来证明你的猜想。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.902,
                0.786,
                0.916
            ],
            "angle": 0,
            "content": "* 20. 确定哪些斐波那契数能被3整除，用数学归纳法的一种形式来证明你的猜想。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.92,
                0.975,
                0.934
            ],
            "angle": 0,
            "content": "* 21. 证明：对所有非负整数 \\( n \\) 来说，\\( f_{k}f_{n} + f_{k+1}f_{n+1} = f_{n+k+1} \\)，其中 \\( k \\) 是非负整数且 \\( f_{i} \\) 表示第 \\( i \\) 个斐波那"
        },
        {
            "type": "list",
            "bbox": [
                0.113,
                0.884,
                0.975,
                0.934
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.685,
                0.038,
                0.796,
                0.053
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.842,
                0.039,
                0.878,
                0.052
            ],
            "angle": 0,
            "content": "337"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.094,
                0.139,
                0.109
            ],
            "angle": 0,
            "content": "契数。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.112,
                0.804,
                0.127
            ],
            "angle": 0,
            "content": "卢卡斯(Lucas)数的序列定义成： \\(l_0 = 2\\) ， \\(l_{1} = 1\\) 以及对 \\(n = 2\\) ，3，4，…来说， \\(l_{n} = l_{n - 1} + l_{n - 2}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.129,
                0.907,
                0.163
            ],
            "angle": 0,
            "content": "22. 证明：当 \\( n \\) 是正整数时，有 \\( f_{n} + f_{n+2} = l_{n+1} \\)，其中 \\( f_{i} \\) 和 \\( l_{i} \\) 分别是第 \\( i \\) 个斐波那契数和第 \\( i \\) 个卢卡斯数。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.165,
                0.743,
                0.18
            ],
            "angle": 0,
            "content": "23. 证明：当 \\(n\\) 是非负整数且 \\(l_{i}\\) 是第 \\(i\\) 个卢卡斯数时，有 \\(l_0^2 + l_1^2 + \\dots + l_n^2 = l_n l_{n+1} + 2\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.183,
                0.907,
                0.217
            ],
            "angle": 0,
            "content": "* 24. 用数学归纳法证明：任意 \\( n \\) 个连续正整数之积能被 \\( n! \\) 整除。[提示：利用恒等式 \\( m(m + 1)\\dots (m + n - 1) / n! = (m - 1)m(m + 1)\\dots (m + n - 2) / n! + m(m + 1)\\dots (m + n - 2) / (n - 1)! \\)。]"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.22,
                0.909,
                0.254
            ],
            "angle": 0,
            "content": "25. 用数学归纳法证明：当 \\(n\\) 是正整数时，有 \\((\\cos x + i \\sin x)^n = \\cos nx + i \\sin nx\\)。[提示：利用恒等式 \\(\\cos (a + b) = \\cos a \\cos b - \\sin a \\sin b\\) 和 \\(\\sin (a + b) = \\sin a \\cos b + \\cos a \\sin b\\)。]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.256,
                0.556,
                0.272
            ],
            "angle": 0,
            "content": "* 26. 用数学归纳法证明：当 \\( n \\) 是正整数且 \\( \\sin (x / 2) \\neq 0 \\) 时，有"
        },
        {
            "type": "equation",
            "bbox": [
                0.288,
                0.277,
                0.68,
                0.308
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {j = 1} ^ {n} \\cos j x = \\cos [ (n + 1) x / 2 ] \\sin (n x / 2) \\sin (x / 2)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.31,
                0.411,
                0.325
            ],
            "angle": 0,
            "content": "27. 用数学归纳法证明：对于每个正整数 \\( n \\)"
        },
        {
            "type": "equation",
            "bbox": [
                0.327,
                0.33,
                0.648,
                0.362
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {j = 1} ^ {n} j ^ {2} 2 ^ {j} = n ^ {2} 2 ^ {n + 1} - n 2 ^ {n + 2} + 3 \\cdot 2 ^ {n + 1} - 6\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.365,
                0.809,
                0.381
            ],
            "angle": 0,
            "content": "28.（需要微积分知识）假设序列 \\(x_{1}, x_{2}, \\dots, x_{n}, \\dots\\) 递归地定义成 \\(x_{1} = 0\\) 和 \\(x_{n + 1} = \\sqrt{x_n + 6}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.384,
                0.68,
                0.399
            ],
            "angle": 0,
            "content": "a)用数学归纳法证明： \\(x_{1} <   x_{2} <   \\dots <  x_{n} <   \\dots\\) ，即序列 \\(\\{x_{n}\\}\\) 是单调递增的。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.402,
                0.499,
                0.417
            ],
            "angle": 0,
            "content": "b)用数学归纳法证明：对于 \\(n = 1\\) ，2，…， \\(x_{n} <   3\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.42,
                0.253,
                0.436
            ],
            "angle": 0,
            "content": "c) 证明：\\(\\lim x_n = 3\\)。"
        },
        {
            "type": "list",
            "bbox": [
                0.091,
                0.384,
                0.68,
                0.436
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.445,
                0.399,
                0.46
            ],
            "angle": 0,
            "content": "29. 证明：如果 \\(n\\) 是正整数，且 \\(n \\geqslant 2\\) ，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.364,
                0.465,
                0.611,
                0.497
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {j = 2} ^ {n} \\frac {1}{j ^ {2} - 1} = \\frac {(n - 1) (3 n + 2)}{4 n (n + 1)}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.498,
                0.911,
                0.532
            ],
            "angle": 0,
            "content": "30. 用数学归纳法证明 3.6 节中的定理 1，即证明如果 \\( b \\) 是一个正整数，\\( b > 1 \\)，\\( n \\) 也是一个正整数，那么 \\( n \\) 可以唯一表示为 \\( n = a_{k}b^{k} + a_{k - 1}b^{k - 1} + \\dots + a_{1}b + a_{0} \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.534,
                0.912,
                0.569
            ],
            "angle": 0,
            "content": "*31. 如果平面上的点 \\((x, y)\\) 中 \\(x\\) 和 \\(y\\) 都是整数，则称点 \\((x, y)\\) 为格点。用数学归纳法证明：至少需要 \\(n + 1\\) 条直线才能确保满足 \\(x \\geqslant 0\\)、\\(y \\geqslant 0\\) 及 \\(x + y \\leqslant n\\) 的格点 \\((x, y)\\) 位于其中的一条直线上。"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.57,
                0.912,
                0.604
            ],
            "angle": 0,
            "content": "32. (需要微积分知识) 利用数学归纳法和乘积规则证明: 如果 \\(n\\) 是一个正整数, 且 \\(f_{1}(x), f_{2}(x), \\dots, f_{n}(x)\\) 都是可导函数, 那么"
        },
        {
            "type": "list",
            "bbox": [
                0.05,
                0.534,
                0.912,
                0.604
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "equation",
            "bbox": [
                0.258,
                0.606,
                0.718,
                0.637
            ],
            "angle": 0,
            "content": "\\[\n\\frac {\\left(f _ {1} (x) f _ {2} (x) \\cdots f _ {n} (x)\\right) ^ {\\prime}}{f _ {1} (x) f _ {2} (x) \\cdots f _ {n} (x)} = \\frac {f _ {1} ^ {\\prime} (x)}{f _ {1} (x)} + \\frac {f _ {2} ^ {\\prime} (x)}{f _ {2} (x)} + \\dots + \\frac {f _ {n} ^ {\\prime} (x)}{f _ {n} (x)}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.639,
                0.914,
                0.672
            ],
            "angle": 0,
            "content": "33.（需要2.6节中的知识）设 \\(B = MAM^{-1}\\) ，其中 \\(\\mathbf{A}\\) 和 \\(\\pmb{B}\\) 都是 \\(n\\times n\\) 矩阵， \\(M\\) 可逆。证明：对所有的正整数\\(k\\) 都有 \\(B^{k} = MA^{k}M^{-1}\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.675,
                0.914,
                0.708
            ],
            "angle": 0,
            "content": "34. 用数学归纳法证明：如果在平面上画线时，只需要用两种颜色来对所形成的区域着色，使得具有共同边界的区域都有不同的颜色。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.711,
                0.914,
                0.745
            ],
            "angle": 0,
            "content": "35. 证明：当 \\(n \\geqslant 3\\) 时，\\(n!\\) 总可以表示成 \\(n\\) 的不同正因子之和。[提示：利用归纳载入。首先试着用数学归纳法证明该结论。当你发现证明失败时，找出一个用数学归纳法容易证明的更强的断言。]"
        },
        {
            "type": "list",
            "bbox": [
                0.062,
                0.639,
                0.914,
                0.745
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.748,
                0.672,
                0.763
            ],
            "angle": 0,
            "content": "*36. 用数学归纳法证明：如果 \\(x_{1}, x_{2}, \\cdots, x_{n}\\) 都是正实数，且 \\(n \\geqslant 2\\) ，则有"
        },
        {
            "type": "equation",
            "bbox": [
                0.143,
                0.766,
                0.838,
                0.795
            ],
            "angle": 0,
            "content": "\\[\n\\left(x _ {1} + \\frac {1}{x _ {1}}\\right) \\left(x _ {2} + \\frac {1}{x _ {2}}\\right) \\dots \\left(x _ {n} + \\frac {1}{x _ {n}}\\right) \\geqslant \\left(x _ {1} + \\frac {1}{x _ {2}}\\right) \\left(x _ {2} + \\frac {1}{x _ {3}}\\right) \\dots \\left(x _ {n - 1} + \\frac {1}{x _ {n}}\\right) \\left(x _ {n} + \\frac {1}{x _ {1}}\\right)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.797,
                0.915,
                0.831
            ],
            "angle": 0,
            "content": "37. 用数学归纳法证明：若 \\( n \\) 个人站成一队，其中 \\( n \\) 是正整数，并且若该队中第一个人是女人，最后一个人是男人，则队中某处有一个女人直接站在一个男人的前面。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.834,
                0.915,
                0.867
            ],
            "angle": 0,
            "content": "* 38. 假设在一个国家中有直达的单行道路连接每一对城市。用数学归纳法证明：存在一个城市，从其他每个城市都可以直达这个城市，或者恰好经由一个其他城市而到达这个城市。"
        },
        {
            "type": "text",
            "bbox": [
                0.065,
                0.869,
                0.915,
                0.903
            ],
            "angle": 0,
            "content": "39. 用数学归纳法证明：当 \\(n\\) 个圆周把平面分成区域时，这些区域可以用两种颜色着色，使得具有共同边界的区域都染成不同的颜色。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.905,
                0.915,
                0.939
            ],
            "angle": 0,
            "content": "* 40. 假设有足够的燃料让环行赛道上一组汽车中的一辆跑完一圈。用数学归纳法证明：在这组汽车中存在一辆汽车，当它沿着赛道前进时，可以通过从其他汽车获得加油来跑完一圈。"
        },
        {
            "type": "list",
            "bbox": [
                0.053,
                0.797,
                0.915,
                0.939
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.138,
                0.04,
                0.174,
                0.053
            ],
            "angle": 0,
            "content": "338"
        },
        {
            "type": "header",
            "bbox": [
                0.219,
                0.038,
                0.284,
                0.053
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.095,
                0.386,
                0.11
            ],
            "angle": 0,
            "content": "41. 证明：如果 \\(n\\) 是正整数，则有"
        },
        {
            "type": "equation",
            "bbox": [
                0.382,
                0.113,
                0.689,
                0.145
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {j = 1} ^ {n} (2 j - 1) \\left(\\sum_ {k = j} ^ {n} 1 / k\\right) = n (n + 1) / 2\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.146,
                0.957,
                0.179
            ],
            "angle": 0,
            "content": "42. 用数学归纳法证明：如果 \\(a\\)、\\(b\\) 和 \\(c\\) 是一个直角三角形的三条边长，\\(c\\) 是斜边的边长，则对于所有整数 \\(n \\geqslant 3\\)，有 \\(a^n + b^n < c^n\\) 成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.186,
                0.957,
                0.22
            ],
            "angle": 0,
            "content": "43. 用数学归纳法证明：如果 \\( n \\) 为整数，序列 \\( 2 \\bmod n \\)，\\( 2^2 \\bmod n \\)，\\( 2^{2^2} \\bmod n \\)，\\( 2^{2^{2^2}} \\bmod n \\)，…，最后是一个常数。（即在有限个项以后的所有项都一样。）"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.223,
                0.957,
                0.327
            ],
            "angle": 0,
            "content": "44. 单位分数或埃及分数是形如 \\(1 / n\\) 的分数，其中 \\(n\\) 是正整数。在本题中，将用强归纳法证明：可以用贪心算法把每个满足 \\(0 < p / q < 1\\) 的有理数 \\(p / q\\) 表达成不同的单位分数之和。在算法的每一步，求出最小的正整数 \\(n\\) 使得这个和可以加上 \\(1 / n\\) 而不超过 \\(p / q\\) 。例如，为了表达 \\(5 / 7\\) ，从 \\(1 / 2\\) 这个和开始。由于 \\(5 / 7 - 1 / 2 = 3 / 14\\) ，所以把 \\(1 / 5\\) 加上这个和，因为 \\(5\\) 是最小的正整数 \\(k\\) 使得 \\(1 / k < 3 / 14\\) 。由于 \\(3 / 14 - 1 / 5 = 1 / 70\\) ，所以算法终止，证明 \\(5 / 7 = 1 / 2 + 1 / 5 + 1 / 70\\) 。设 \\(T(p)\\) 是命题：对于所有满足 \\(0 < p / q < 1\\) 的有理数 \\(p / q\\) 来说这个算法终止。通过证明对于所有正整数 \\(p\\) 来说 \\(T(p)\\) 为真，将证明这个算法总是终止。"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.329,
                0.364,
                0.343
            ],
            "angle": 0,
            "content": "a) 证明基础步骤 \\(T(1)\\) 成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.137,
                0.346,
                0.957,
                0.414
            ],
            "angle": 0,
            "content": "b)假设对于满足 \\(k < p\\) 的正整数 \\(k\\) 来说 \\(T(k)\\) 成立。换句话说，假设对于所有有理数 \\(k / r\\) 来说算法终止，其中 \\(1 \\leqslant k < p\\) 。证明：如果从 \\(p / q\\) 开始并且算法第一步选择分数 \\(1 / n\\) ，则 \\(p / q = p' / q' + 1 / n\\) 其中 \\(p' = np - q\\) 且 \\(q' = nq\\) 。在考虑 \\(p / q = 1 / n\\) 的情形之后，用归纳假设证明：当贪心算法从 \\(p' / q'\\) 开始时，这个算法总会终止，从而完成归纳步骤。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.417,
                0.948,
                0.432
            ],
            "angle": 0,
            "content": "麦卡锡91函数(人工智能的奠基人之一——John McCarthy所定义)定义成：对所有正整数 \\(n\\) 来说应用规则"
        },
        {
            "type": "equation",
            "bbox": [
                0.384,
                0.435,
                0.68,
                0.468
            ],
            "angle": 0,
            "content": "\\[\nM (n) = \\left\\{ \\begin{array}{l l} n - 1 0 & n > 1 0 0 \\\\ M (M (n + 1 1)) & n \\leqslant 1 0 0 \\end{array} \\right.\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.47,
                0.435,
                0.485
            ],
            "angle": 0,
            "content": "45. 通过连续地使用 \\(M(n)\\) 的定义规则求"
        },
        {
            "type": "text",
            "bbox": [
                0.137,
                0.487,
                0.223,
                0.501
            ],
            "angle": 0,
            "content": "a) \\(M(102)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.387,
                0.488,
                0.47,
                0.501
            ],
            "angle": 0,
            "content": "b) \\(M(101)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.636,
                0.488,
                0.707,
                0.501
            ],
            "angle": 0,
            "content": "c) \\(M(99)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.139,
                0.505,
                0.213,
                0.518
            ],
            "angle": 0,
            "content": "d) \\(M(97)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.387,
                0.506,
                0.458,
                0.518
            ],
            "angle": 0,
            "content": "e) \\(M(87)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.636,
                0.506,
                0.705,
                0.518
            ],
            "angle": 0,
            "content": "f) \\(M(76)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.523,
                0.955,
                0.556
            ],
            "angle": 0,
            "content": "** 46. 证明：函数 \\( M(n) \\) 是从正整数集合到正整数集合的良定义函数。[提示：证明对所有满足 \\( n \\leqslant 101 \\) 的正整数 \\( n \\) 来说都有 \\( M(n) = 91 \\)。]"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.558,
                0.383,
                0.573
            ],
            "angle": 0,
            "content": "47. 下述的证明当 \\(n\\) 是正整数时有"
        },
        {
            "type": "equation",
            "bbox": [
                0.395,
                0.576,
                0.7,
                0.604
            ],
            "angle": 0,
            "content": "\\[\n\\frac {1}{1 \\cdot 2} + \\frac {1}{2 \\cdot 3} + \\dots + \\frac {1}{(n - 1) n} = \\frac {3}{2} - \\frac {1}{n}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.137,
                0.607,
                0.411,
                0.622
            ],
            "angle": 0,
            "content": "是否正确？为你的答案给出理由。"
        },
        {
            "type": "text",
            "bbox": [
                0.137,
                0.625,
                0.448,
                0.639
            ],
            "angle": 0,
            "content": "基础步骤：当 \\(n = 1\\) 时结果为真，因为"
        },
        {
            "type": "equation",
            "bbox": [
                0.485,
                0.643,
                0.608,
                0.67
            ],
            "angle": 0,
            "content": "\\[\n\\frac {1}{1 \\cdot 2} = \\frac {3}{2} - \\frac {1}{1}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.137,
                0.673,
                0.458,
                0.688
            ],
            "angle": 0,
            "content": "归纳步骤：假定对 \\(n\\) 来说结果为真。则"
        },
        {
            "type": "equation",
            "bbox": [
                0.24,
                0.691,
                0.851,
                0.719
            ],
            "angle": 0,
            "content": "\\[\n\\frac {1}{1 \\cdot 2} + \\frac {1}{2 \\cdot 3} + \\dots + \\frac {1}{(n - 1) n} + \\frac {1}{n (n + 1)} = \\frac {3}{2} - \\frac {1}{n} + \\left(\\frac {1}{n} - \\frac {1}{n + 1}\\right) = \\frac {3}{2} - \\frac {1}{n + 1}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.136,
                0.722,
                0.643,
                0.737
            ],
            "angle": 0,
            "content": "因此，若对 \\(n\\) 来说结果为真，则对 \\(n + 1\\) 来说结果为真。证毕。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.74,
                0.955,
                0.79
            ],
            "angle": 0,
            "content": "48. 设 \\(A_{1}, A_{2}, \\cdots, A_{n}\\) 是一组集合，且对 \\(k = 3, 4, \\cdots, n\\) 都有 \\(R_{2} = A_{1} \\oplus A_{2}\\) 及 \\(R_{k} = R_{k-1} \\oplus A_{k}\\) 。利用数学归纳法证明：当且仅当 \\(x\\) 属于 \\(A_{1}, A_{2}, \\cdots, A_{n}\\) 中一个奇数下标的集合时，有 \\(x \\in R_{n}\\)。（回忆2.2节中的定义：\\(S \\oplus T\\) 是集合 \\(S\\) 和 \\(T\\) 的对称差。）"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.793,
                0.954,
                0.825
            ],
            "angle": 0,
            "content": "* 49. 证明：若在 \\( n \\) 个圆中每两个都恰好相交于两点，而任意三个都没有公共点，则这些圆把平面划分成 \\( n^2 - n + 2 \\) 个区域。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.828,
                0.954,
                0.861
            ],
            "angle": 0,
            "content": "* 50. 证明：若在 \\( n \\) 个平面中任意三个都有公共点，而任意四个都没有公共点，则这些平面把三维空间划分成 \\( (n^3 + 5n + 6) / 6 \\) 个区域。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.866,
                0.954,
                0.902
            ],
            "angle": 0,
            "content": "*51. 用良序性证明：\\(\\sqrt{2}\\) 是无理数。[提示：假定 \\(\\sqrt{2}\\) 是有理数。证明形如 \\(b\\sqrt{2}\\) 的正整数组成的集合有最小元素 \\(a\\) 。然后证明 \\(a\\sqrt{2} - a\\) 是具有这种形式的更小的正整数。]"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.905,
                0.951,
                0.937
            ],
            "angle": 0,
            "content": "52. 若一个集合的每个非空子集合都有最小元素，则这个集合是良序性的。判断下面的每个集合是否良序性的。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.672,
                0.038,
                0.781,
                0.052
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.828,
                0.039,
                0.864,
                0.052
            ],
            "angle": 0,
            "content": "339"
        },
        {
            "type": "text",
            "bbox": [
                0.077,
                0.094,
                0.173,
                0.109
            ],
            "angle": 0,
            "content": "a)整数集合"
        },
        {
            "type": "text",
            "bbox": [
                0.409,
                0.094,
                0.631,
                0.109
            ],
            "angle": 0,
            "content": "b)大于一100的整数的集合"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.113,
                0.208,
                0.127
            ],
            "angle": 0,
            "content": "c)正有理数集合"
        },
        {
            "type": "text",
            "bbox": [
                0.409,
                0.113,
                0.691,
                0.127
            ],
            "angle": 0,
            "content": "d)分母小于100的正有理数的集合"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.13,
                0.893,
                0.163
            ],
            "angle": 0,
            "content": "53. a) 证明：若 \\(a_1, a_2, \\dots, a_n\\) 都是正整数，则 \\(\\gcd(a_1, a_2, \\dots, a_{n-1}, a_n) = \\gcd(a_1, a_2, \\dots, a_{n-2}, \\gcd(a_{n-1}, a_n))\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.166,
                0.7,
                0.181
            ],
            "angle": 0,
            "content": "b)利用a和欧几里得算法得出一个计算 \\(n\\) 个正整数的最大公因子的递归算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.035,
                0.185,
                0.701,
                0.2
            ],
            "angle": 0,
            "content": "* 54. 描述一个递归算法，把 \\( n \\) 个正整数的最大公因子表示成这些整数的线性组合。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.203,
                0.893,
                0.236
            ],
            "angle": 0,
            "content": "55. 求出 \\( f(n) \\) 的显式公式，其中 \\( f(1) = 1 \\) 而且若 \\( n \\geqslant 2 \\) 则 \\( f(n) = f(n - 1) + 2n - 1 \\) 。用数学归纳法证明你的结果。"
        },
        {
            "type": "text",
            "bbox": [
                0.023,
                0.24,
                0.61,
                0.254
            ],
            "angle": 0,
            "content": "**56. 给出由所含有的 0 是 1 的两倍的比特串所组成的集合的递归定义。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.258,
                0.867,
                0.273
            ],
            "angle": 0,
            "content": "57. 设 \\(S\\) 是比特串的集合，它递归地定义成： \\(\\lambda \\in S\\) ，并且若 \\(x\\in S\\) ，则 \\(0x\\in S\\) ， \\(x_{1}\\in S\\) ，其中 \\(\\lambda\\) 是空串。"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.276,
                0.369,
                0.29
            ],
            "angle": 0,
            "content": "a)求出 \\(S\\) 中所有长度不超过5的串。"
        },
        {
            "type": "text",
            "bbox": [
                0.409,
                0.276,
                0.665,
                0.29
            ],
            "angle": 0,
            "content": "b)给出对 \\(S\\) 中元素的显式描述。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.294,
                0.893,
                0.326
            ],
            "angle": 0,
            "content": "58. 设 \\(S\\) 是字符串的集合，它递归地定义成： \\(abc \\in S\\) ， \\(bac \\in S\\) ， \\(acb \\in S\\) ，并且若 \\(x \\in S\\) 则 \\(abc x \\in S\\) ， \\(abxc \\in S\\) ， \\(axbc \\in S\\) 和 \\(xabc \\in S\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.33,
                0.386,
                0.344
            ],
            "angle": 0,
            "content": "a)求出 \\(S\\) 中长度为8或更短的所有串。"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.348,
                0.474,
                0.362
            ],
            "angle": 0,
            "content": "b) 证明：\\(S\\) 中的每个元素都有能被3整除的长度。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.366,
                0.89,
                0.382
            ],
            "angle": 0,
            "content": "由所有平衡的括号串组成的集合递归地定义成： \\(\\lambda \\in B\\) ，其中 \\(\\lambda\\) 是空串。若 \\(x,y\\in B\\) ，则 \\((x)\\in B\\) ， \\(xy\\in B\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.385,
                0.543,
                0.399
            ],
            "angle": 0,
            "content": "59. 证明：（（）（）是平衡的括号串而（（））不是平衡的括号串。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.403,
                0.423,
                0.417
            ],
            "angle": 0,
            "content": "60. 求出所有恰好带 6 个符号的平衡的括号串。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.421,
                0.441,
                0.435
            ],
            "angle": 0,
            "content": "61. 求出所有带 4 个或更少符号的平衡的括号串。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.439,
                0.72,
                0.453
            ],
            "angle": 0,
            "content": "62. 用归纳法证明：若 \\( x \\) 是平衡的括号串，则在 \\( x \\) 左括号的个数等于右括号的个数。"
        },
        {
            "type": "list",
            "bbox": [
                0.045,
                0.385,
                0.72,
                0.453
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.457,
                0.354,
                0.472
            ],
            "angle": 0,
            "content": "在括号串的集合上定义函数 \\(N\\) 为："
        },
        {
            "type": "equation",
            "bbox": [
                0.354,
                0.475,
                0.623,
                0.489
            ],
            "angle": 0,
            "content": "\\[\nN (\\lambda) = 0, N (() = 1, N ()) = - 1\n\\]"
        },
        {
            "type": "equation",
            "bbox": [
                0.344,
                0.493,
                0.532,
                0.507
            ],
            "angle": 0,
            "content": "\\[\nN (u v) = N (u) + N (v)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.075,
                0.511,
                0.534,
                0.526
            ],
            "angle": 0,
            "content": "其中 \\(\\lambda\\) 是空串， \\(u\\) 和 \\(v\\) 都是串。可以证明 \\(N\\) 是良定义的。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.53,
                0.099,
                0.544
            ],
            "angle": 0,
            "content": "63. 求"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.548,
                0.15,
                0.562
            ],
            "angle": 0,
            "content": "a) \\(N((\\cdot))\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.408,
                0.548,
                0.537,
                0.562
            ],
            "angle": 0,
            "content": "b) \\(N(\\cdot)(\\cdot)(\\cdot)(\\cdot)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.566,
                0.185,
                0.58
            ],
            "angle": 0,
            "content": "c) \\(N((\\cdot)(\\cdot))\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.408,
                0.566,
                0.573,
                0.58
            ],
            "angle": 0,
            "content": "d) \\(N((\\langle \\rangle (\\langle \\rangle))(\\langle \\rangle))\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.025,
                0.584,
                0.864,
                0.599
            ],
            "angle": 0,
            "content": "**64. 证明：括号串 \\( w \\) 是平衡的当且仅当 \\( N(w) = 0 \\)，而且当 \\( u \\) 是 \\( w \\) 的前缀（即 \\( w = uv \\)）时，有 \\( N(u) \\geqslant 0 \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.035,
                0.603,
                0.609,
                0.617
            ],
            "angle": 0,
            "content": "* 65. 给出一个求所有包含 \\( n \\) 个或更少符号的平衡的括号串的递归算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.62,
                0.893,
                0.636
            ],
            "angle": 0,
            "content": "66. 根据下述的事实：若 \\(a > b\\) 则 \\(\\gcd(a, b) = \\gcd(b, a)\\)；若 \\(a\\) 和 \\(b\\) 都是偶数则 \\(\\gcd(a, b) = 2\\gcd(a/2, b)\\)."
        },
        {
            "type": "list",
            "bbox": [
                0.025,
                0.584,
                0.893,
                0.636
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.646,
                0.092,
                0.659
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.055,
                0.675,
                0.189,
                0.778
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.047,
                0.782,
                0.177,
                0.813
            ],
            "angle": 0,
            "content": "Matthew Naythons/The LIFE Images Collection/ Getty Images"
        },
        {
            "type": "text",
            "bbox": [
                0.202,
                0.674,
                0.894,
                0.778
            ],
            "angle": 0,
            "content": "约翰·麦卡锡（John McCarthy，1927—2011）他出生在波士顿，在波士顿和洛杉矶长大。他在本科和研究生阶段学习的都是数学。1948年他从加州理工学院获得学士学位并在1951年从普林斯顿获得博士学位。从普林斯顿毕业后，麦卡锡在普林斯顿大学、斯坦福大学、达特茅斯和麻省理工学院任职。\\(1962\\sim 1994\\) 年他一直在斯坦福大学任职，是那里的荣誉教授。在斯坦福大学，他是人工智能实验室的主任，担任工程学院的名誉院长，并且是胡佛学院的资深院士。"
        },
        {
            "type": "text",
            "bbox": [
                0.202,
                0.781,
                0.894,
                0.831
            ],
            "angle": 0,
            "content": "麦卡锡是人工智能研究的开拓者，“人工智能”就是他在1955年发明的术语。他致力于关于智能的计算机行为所需要的推理和信息需求的问题。麦卡锡是设计分时计算机系统的首批计算机科学家之一。他开发了LISP，这是用符号表达式来计算的"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.834,
                0.894,
                0.903
            ],
            "angle": 0,
            "content": "一种程序设计语言。他在用逻辑来验证计算机程序的正确性方面起到了重要作用。麦卡锡还致力于研究计算机技术的社会影响问题。他还致力于研究在情况不是错综复杂的假设下人和计算机如何形成猜想的问题。麦卡锡是人类可持续性发展的倡导者并且是关于人类未来的乐观者。他还编写科幻故事。他最近的一些著作探索了我们的世界是由更高的力量所编写的计算机程序的可能性。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.905,
                0.893,
                0.938
            ],
            "angle": 0,
            "content": "麦卡锡所获得过的国际奖励有：美国计算机学会的图灵奖、国际人工智能会议的杰出研究工作奖、京都奖和美国国家科学奖章。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.139,
                0.037,
                0.175,
                0.05
            ],
            "angle": 0,
            "content": "340"
        },
        {
            "type": "header",
            "bbox": [
                0.22,
                0.035,
                0.286,
                0.051
            ],
            "angle": 0,
            "content": "第5章"
        },
        {
            "type": "text",
            "bbox": [
                0.14,
                0.092,
                0.956,
                0.125
            ],
            "angle": 0,
            "content": "2)， \\(\\gcd (0,b) = b\\) ；若 \\(a\\) 是偶数而 \\(b\\) 是奇数， \\(\\gcd (a,b) = \\gcd (a,b - a)\\) 则 \\(\\gcd (a,b) = \\gcd (a / 2,b)\\) ，给出一个求满足两个非负整数 \\(a\\) 和 \\(b\\) 的最大公因子的递归算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.128,
                0.242,
                0.142
            ],
            "angle": 0,
            "content": "67. 验证程序段"
        },
        {
            "type": "equation",
            "bbox": [
                0.156,
                0.152,
                0.276,
                0.182
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} \\text {i f} \\quad x > y \\quad \\text {t h e n} \\\\ x := y \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.192,
                0.528,
                0.206
            ],
            "angle": 0,
            "content": "相对于初始断言 \\(\\mathbf{T}\\) 和终结断言 \\(x\\leqslant y\\) 是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.21,
                0.826,
                0.225
            ],
            "angle": 0,
            "content": "* 68. 提出一条验证递归程序的推理规则，并用它验证5.4节给出的计算阶乘的递归程序。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.228,
                0.511,
                0.243
            ],
            "angle": 0,
            "content": "69. 设计求整数表中整数 0 出现次数的递归算法。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.246,
                0.962,
                0.314
            ],
            "angle": 0,
            "content": "练习 \\(70\\sim 77\\) 处理某些不寻常的序列，这些序列非正式地称为自生成序列，它们是用简单的递归关系或规则产生的。尤其是，练习 \\(70\\sim 75\\) 处理序列 \\(\\{a(n)\\}\\) ，它定义成：对 \\(n\\geqslant 1\\) 来说， \\(a(n) = n - a(a(n - 1))\\) ，且\\(a(0) = 0\\) 。（这个序列以及在练习74和练习75里的序列，都是在道格拉斯·霍夫斯塔德的奇妙的书《歌德尔、埃舍尔、巴赫》(Godel，Escher，Bach)[Ho99]中定义的）。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.318,
                0.594,
                0.332
            ],
            "angle": 0,
            "content": "70. 求出在本题前面的说明中定义的序列 \\(\\{a(n)\\}\\) 的前10项。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.335,
                0.806,
                0.35
            ],
            "angle": 0,
            "content": "*71. 证明：这个序列是良定义的。即证明对所有非负整数 \\( n \\) 来说，\\( a(n) \\) 是唯一定义的。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.356,
                0.961,
                0.407
            ],
            "angle": 0,
            "content": "**72. 证明：\\(a(n) = \\lfloor (n + 1) / \\mu \\rfloor \\mu\\)，其中 \\(\\mu = (-1 + \\sqrt{5}) / 2\\)。[提示：首先证明对所有 \\(n > 0\\) 来说，\\((\\mu n - \\lfloor \\mu n \\rfloor) + (\\mu^2 n - \\lfloor \\mu^2 n \\rfloor) = 1\\)。然后，证明对满足 \\(0 \\leqslant \\alpha < 1\\) 和 \\(\\alpha \\neq 1 - \\mu\\) 的所有实数 \\(\\alpha\\) 来说，\\(\\lfloor (1 + \\mu)(1 - \\alpha) \\rfloor + \\lfloor \\alpha + \\mu \\rfloor = 1\\)，分别考虑 \\(0 \\leqslant \\alpha < 1 - \\mu\\) 和 \\(1 - \\mu < \\alpha < 1\\) 的情形。]"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.41,
                0.896,
                0.426
            ],
            "angle": 0,
            "content": "*73. 利用练习 72 的公式证明：若 \\(\\mu n - \\lfloor \\mu n\\rfloor < 1 - \\mu\\) ，则 \\(a(n) = a(n - 1)\\) ，否则 \\(a(n) = a(n - 1) + 1\\) 。"
        },
        {
            "type": "list",
            "bbox": [
                0.087,
                0.335,
                0.961,
                0.426
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.429,
                0.446,
                0.443
            ],
            "angle": 0,
            "content": "74. 求出下面每个自生成序列的前 10 项："
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.446,
                0.608,
                0.46
            ],
            "angle": 0,
            "content": "a)对 \\(n\\geqslant 1\\) 来说， \\(a(n) = n - a(a(a(n - 1)))\\) ，且 \\(a(0) = 0\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.464,
                0.636,
                0.479
            ],
            "angle": 0,
            "content": "b)对 \\(n\\geqslant 1\\) 来说， \\(a(n) = n - a(a(a(n - 1))))\\) ，且 \\(a(0) = 0\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.482,
                0.809,
                0.497
            ],
            "angle": 0,
            "content": "c)对 \\(n\\geqslant 3\\) 来说， \\(a(n) = a(n - a(n - 1)) + a(n - a(n - 2))\\) ，且 \\(a(1) = 1\\) 和 \\(a(2) = 1\\)"
        },
        {
            "type": "list",
            "bbox": [
                0.145,
                0.446,
                0.809,
                0.497
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.499,
                0.961,
                0.533
            ],
            "angle": 0,
            "content": "75. 求出序列 \\(m(n)\\) 和 \\(f(n)\\) 的前10项，它们是用下面的嵌套的递归关系来定义的：对 \\(n \\geqslant 1\\) 来说，\\(m(n) = n - f(m(n - 1))\\)，\\(f(n) = n - m(f(n - 1))\\)，且 \\(f(0) = 1\\) 和 \\(m(0) = 0\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.535,
                0.964,
                0.569
            ],
            "angle": 0,
            "content": "哥伦布的自生成序列是具有下述性质的、唯一的、非减的正整数序列 \\(a_1, a_2, a_3, \\cdots\\)，对每个正整数 \\(k\\) 来说，这个序列恰好包含 \\(k\\) 的 \\(a_k\\) 次出现。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.571,
                0.448,
                0.586
            ],
            "angle": 0,
            "content": "76. 求出哥伦布的自生成序列的前20项。"
        },
        {
            "type": "text",
            "bbox": [
                0.101,
                0.589,
                0.961,
                0.641
            ],
            "angle": 0,
            "content": "*77. 证明：若 \\( f(n) \\) 是使得 \\( a_{m} = n \\) 的最大整数 \\( m \\)，其中 \\( a_{m} \\) 是哥伦布的自生成序列的第 \\( m \\) 项，则 \\( f(n) = \\sum_{k=1}^{n} a_{k} \\) 且 \\( f(f(n)) = \\sum_{k=1}^{n} k a_{k} \\)。"
        },
        {
            "type": "title",
            "bbox": [
                0.116,
                0.654,
                0.254,
                0.672
            ],
            "angle": 0,
            "content": "计算机课题"
        },
        {
            "type": "title",
            "bbox": [
                0.116,
                0.68,
                0.353,
                0.694
            ],
            "angle": 0,
            "content": "按给定的输入和输出写程序。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.698,
                0.699,
                0.712
            ],
            "angle": 0,
            "content": "**1. 给定去掉一个格子的 \\(2^{n} \\times 2^{n}\\) 棋盘，用 \\(L\\) 形状的拼片构造出这个棋盘。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.716,
                0.962,
                0.747
            ],
            "angle": 0,
            "content": "**2. 对含有变量 \\(x\\)、\\(y\\) 和 \\(z\\) 以及运算符 \\(\\{+\\), \\(*\\), \\(/, -\\}\\) 的表达式来说，生成所有的带有 \\(n\\) 个或更少符号的合式公式。"
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.752,
                0.962,
                0.783
            ],
            "angle": 0,
            "content": "**3. 生成所有带有 \\( n \\) 个或更少符号的命题的合式公式，其中每个符号是 T、F、命题变量 \\( p \\) 和 \\( q \\) 之一或 \\(\\{\\neg, \\vee, \\wedge, \\rightarrow, \\leftrightarrow\\}\\) 中的一个运算符。"
        },
        {
            "type": "list",
            "bbox": [
                0.09,
                0.698,
                0.962,
                0.783
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.788,
                0.413,
                0.802
            ],
            "angle": 0,
            "content": "4. 给定一个字符串，求出它的倒置。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.806,
                0.468,
                0.82
            ],
            "angle": 0,
            "content": "5. 给定实数 \\(a\\) 和非负整数 \\(n\\)，用递归求 \\(a^n\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.826,
                0.474,
                0.842
            ],
            "angle": 0,
            "content": "6. 给定实数 \\(a\\) 和非负整数 \\(n\\)，用递归求 \\(a^{2^n}\\)。"
        },
        {
            "type": "list",
            "bbox": [
                0.117,
                0.788,
                0.474,
                0.842
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.847,
                0.793,
                0.863
            ],
            "angle": 0,
            "content": "*7. 给定实数 \\(a\\) 和非负整数 \\(n\\)，利用 \\(n\\) 的二进制展开式和计算 \\(a^{2^k}\\) 的递归算法来求 \\(a^n\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.866,
                0.6,
                0.88
            ],
            "angle": 0,
            "content": "8. 给定两个不全为零的整数，用递归求它们的最大公因子。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.884,
                0.764,
                0.899
            ],
            "angle": 0,
            "content": "9. 给定整数的列表和元素 \\( x \\)，用线性搜索的递归实现求 \\( x \\) 在这个列表中的位置。"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.902,
                0.773,
                0.917
            ],
            "angle": 0,
            "content": "10. 给定整数的列表和元素 \\( x \\)，用二叉搜索的递归实现求 \\( x \\) 在这个列表中的位置。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.92,
                0.548,
                0.935
            ],
            "angle": 0,
            "content": "11. 给定非负整数 \\(n\\)，用迭代来求第 \\(n\\) 个斐波那契数。"
        },
        {
            "type": "list",
            "bbox": [
                0.117,
                0.866,
                0.773,
                0.935
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.673,
                0.037,
                0.783,
                0.052
            ],
            "angle": 0,
            "content": "归纳与递归"
        },
        {
            "type": "page_number",
            "bbox": [
                0.829,
                0.038,
                0.864,
                0.051
            ],
            "angle": 0,
            "content": "341"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.093,
                0.476,
                0.108
            ],
            "angle": 0,
            "content": "12. 给定非负整数 \\( n \\)，用递归来求第 \\( n \\) 个斐波那契数。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.111,
                0.651,
                0.126
            ],
            "angle": 0,
            "content": "13. 给定一个正整数，求出这个整数的划分的数目。（参见5.3节练习47。）"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.128,
                0.886,
                0.144
            ],
            "angle": 0,
            "content": "14. 给定正整数 \\(m\\) 和 \\(n\\) ，求出阿克曼函数在 \\((m,n)\\) 处的值 \\(A(m,n)\\) 。（参见5.3节练习48前面的说明。）"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.146,
                0.5,
                0.162
            ],
            "angle": 0,
            "content": "15. 给定 \\( n \\) 个整数的列表，用归并排序给这些整数排序。"
        },
        {
            "type": "list",
            "bbox": [
                0.048,
                0.093,
                0.886,
                0.162
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.051,
                0.176,
                0.184,
                0.195
            ],
            "angle": 0,
            "content": "计算和探索"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.202,
                0.47,
                0.217
            ],
            "angle": 0,
            "content": "用一个计算程序或你自己编写的程序做下面的练习。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.22,
                0.775,
                0.235
            ],
            "angle": 0,
            "content": "1. 让 \\( n! \\) 具有不超过 100 位十进制数字和不超过 1000 位十进制数字的 \\( n \\) 的最大值是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.238,
                0.851,
                0.253
            ],
            "angle": 0,
            "content": "2. 确定哪些斐波那契数能被5整除、哪些能被7整除、哪些能被11整除。证明你的猜想是正确的。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.256,
                0.658,
                0.271
            ],
            "angle": 0,
            "content": "3. 用右三联骨牌构造出去掉一个格子的 \\(16 \\times 16\\)、\\(32 \\times 32\\) 和 \\(64 \\times 64\\) 的棋盘。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.274,
                0.749,
                0.289
            ],
            "angle": 0,
            "content": "4.探索用右三联骨牌可以完全地覆盖哪些 \\(m\\times n\\) 棋盘。能否形成关于这个问题的猜想？"
        },
        {
            "type": "list",
            "bbox": [
                0.048,
                0.22,
                0.851,
                0.289
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.027,
                0.292,
                0.586,
                0.307
            ],
            "angle": 0,
            "content": "**5. 设计一个算法：确定一点是否为一个简单多边形的内点或外点。"
        },
        {
            "type": "text",
            "bbox": [
                0.027,
                0.31,
                0.42,
                0.324
            ],
            "angle": 0,
            "content": "**6. 设计一个算法：将一个简单多边形三角化。"
        },
        {
            "type": "list",
            "bbox": [
                0.027,
                0.292,
                0.586,
                0.324
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.327,
                0.514,
                0.342
            ],
            "angle": 0,
            "content": "7. 阿克曼函数的哪些值是足够小的使得能够计算出它们？"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.344,
                0.697,
                0.36
            ],
            "angle": 0,
            "content": "8. 比较一下递归地计算斐波那契数与迭代地计算它们所需要的运算次数或时间。"
        },
        {
            "type": "list",
            "bbox": [
                0.05,
                0.327,
                0.697,
                0.36
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.053,
                0.375,
                0.16,
                0.394
            ],
            "angle": 0,
            "content": "写作课题"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.401,
                0.417,
                0.416
            ],
            "angle": 0,
            "content": "用本教材以外的资料，按下列要求写成论文。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.419,
                0.719,
                0.434
            ],
            "angle": 0,
            "content": "1. 描述数学归纳法的起源。谁是第一批使用它的人？他们在哪个问题上用到了它？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.436,
                0.899,
                0.469
            ],
            "angle": 0,
            "content": "2. 解释如何证明关于简单多边形的若尔当曲线定理，并给出一个算法：确定一点是否为一个简单多边形的内点或外点。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.472,
                0.718,
                0.487
            ],
            "angle": 0,
            "content": "3. 描述在计算几何学中，简单多边形的三角化是如何应用于某些关键的算法中的。"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.49,
                0.478,
                0.505
            ],
            "angle": 0,
            "content": "4. 描述斐波那契数在生物物理学中大量不同的应用。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.507,
                0.793,
                0.522
            ],
            "angle": 0,
            "content": "5. 描述在递归定义的理论里以及在集合合并算法的复杂性分析里对阿克曼函数的使用情况。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.525,
                0.9,
                0.558
            ],
            "angle": 0,
            "content": "6. 给出高德纳箭号表示法的递归定义，并说明它在不同例子中的应用，包括如何表示阿克曼函数的值（在5.3节练习50的前导文中有定义）。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.56,
                0.793,
                0.576
            ],
            "angle": 0,
            "content": "7. 讨论一些用来证明程序正确性的方法，并且将它们与5.5节所描述的霍尔方法进行比较。"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.579,
                0.609,
                0.594
            ],
            "angle": 0,
            "content": "8. 解释如何扩充程序正确性的思想和概念来证明操作系统是安全的。"
        },
        {
            "type": "list",
            "bbox": [
                0.051,
                0.419,
                0.9,
                0.594
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.12,
                0.094,
                0.198,
                0.113
            ],
            "angle": 0,
            "content": "第6章"
        },
        {
            "type": "header",
            "bbox": [
                0.12,
                0.117,
                0.41,
                0.129
            ],
            "angle": 0,
            "content": "Discrete Mathematics and Its Applications, 8E"
        },
        {
            "type": "title",
            "bbox": [
                0.111,
                0.138,
                0.262,
                0.165
            ],
            "angle": 0,
            "content": "计数"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.236,
                0.957,
                0.349
            ],
            "angle": 0,
            "content": "组合数学这一研究个体安排的学科，是离散数学的重要部分。早在17世纪就开始了这类课题的研究，当时在赌博游戏的研究中出现了组合问题。枚举——具有确定性质的个体的计数，是组合数学的一个重要部分。我们必须对个体计数以求解许多不同类型的问题。例如，用计数确定算法的复杂性。计数也用于确定是否存在着能够充分满足需求的电话号码或因特网地址。近年来，它在数学生物学，特别是DNA测序研究中发挥着重要作用。此外，计数技术也广泛用于计算事件的概率。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.351,
                0.956,
                0.445
            ],
            "angle": 0,
            "content": "6.1节将要研究的基本计数规则可以求解各种各样的问题。例如，可以用这些规则来计数美国各种可能的电话号码，计算机系统中允许使用的密码，以及比赛结束时赛跑运动员的名次。另一个重要的组合工具是鸽巢原理，将在6.2节研究。这个原理指出，当把物体放在盒子里时，若物体比盒子多，那么有一个盒子至少包含两个物体。例如，我们可以用这个原理证明在15个或者更多的学生中至少有3人出生在相同的星期几。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.447,
                0.956,
                0.522
            ],
            "angle": 0,
            "content": "我们可以用集合中个体可重复或者不可重复的有序或无序安排来描述许多计数问题。这些安排称为排列和组合，在许多计数问题中都会用到它们。例如，在2000个学生参加的考试竞赛中最终将有100个获胜者被邀请赴宴。我们可以枚举将被邀请的100个学生的可能的组合，以及最终10名获奖者的产生方式。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.524,
                0.954,
                0.56
            ],
            "angle": 0,
            "content": "组合数学的另一个问题涉及生成某个特定类型的所有排列。这在计算机模拟中通常是很重要的。我们将设计算法来生成各种类型的排列。"
        },
        {
            "type": "title",
            "bbox": [
                0.104,
                0.574,
                0.309,
                0.594
            ],
            "angle": 0,
            "content": "6.1 计数的基础"
        },
        {
            "type": "title",
            "bbox": [
                0.104,
                0.602,
                0.234,
                0.618
            ],
            "angle": 0,
            "content": "6.1.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.622,
                0.955,
                0.676
            ],
            "angle": 0,
            "content": "假设计算机系统的密码由6、7或8个字符组成，每个字符必须是数字或字母表中的字母，每个密码必须至少包含一位数字。问有多少个这样的密码？本节将介绍回答这个问题及各种其他计数问题所需要的技术。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.679,
                0.955,
                0.735
            ],
            "angle": 0,
            "content": "数学和计算机科学中存在着计数问题。例如，我们必须为成功的实验结果和所有可能的实验结果计数，以确定离散事件的概率。我们需要对某个算法用到的操作数计数，以便研究它的时间复杂性。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.737,
                0.755,
                0.755
            ],
            "angle": 0,
            "content": "本节将介绍基本的计数方法。这些方法是几乎所有计数技术的基础。"
        },
        {
            "type": "title",
            "bbox": [
                0.103,
                0.764,
                0.345,
                0.782
            ],
            "angle": 0,
            "content": "6.1.2 基本的计数原则"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.785,
                0.951,
                0.82
            ],
            "angle": 0,
            "content": "我们将提出两个基本的计数原则：乘积法则和求和法则。然后将说明怎样用它们来求解许多不同的计数问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.144,
                0.823,
                0.571,
                0.84
            ],
            "angle": 0,
            "content": "当一个过程由独立的任务组成时使用乘积法则。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.848,
                0.943,
                0.886
            ],
            "angle": 0,
            "content": "乘积法则 假定一个过程可以被分解成两个任务。如果完成第一个任务有 \\( n_1 \\) 种方式，在第一个任务完成之后有 \\( n_2 \\) 种方式完成第二个任务，那么完成这个过程有 \\( n_1n_2 \\) 种方式。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.895,
                0.444,
                0.912
            ],
            "angle": 0,
            "content": "例 \\(1\\sim 10\\) 讨论怎样使用乘积法则。"
        },
        {
            "type": "text",
            "bbox": [
                0.142,
                0.918,
                0.951,
                0.935
            ],
            "angle": 0,
            "content": "例1一个新建公司中只有两个雇员Sanchez和Patel，公司租用了一个大楼的底层，共12"
        },
        {
            "type": "footer",
            "bbox": [
                0.026,
                0.895,
                0.058,
                0.904
            ],
            "angle": 0,
            "content": "Extra"
        },
        {
            "type": "footer",
            "bbox": [
                0.028,
                0.904,
                0.087,
                0.911
            ],
            "angle": 0,
            "content": "Examples"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.695,
                0.039,
                0.787,
                0.054
            ],
            "angle": 0,
            "content": "计数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.831,
                0.041,
                0.868,
                0.054
            ],
            "angle": 0,
            "content": "343"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.096,
                0.514,
                0.111
            ],
            "angle": 0,
            "content": "个办公室。有多少种方法为这两个雇员分配办公室？"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.115,
                0.897,
                0.169
            ],
            "angle": 0,
            "content": "解对这两个雇员分配办公室的过程是这样的：为Sanchez分配办公室，有12种方法，然后为Patel分配一个不同的办公室，有11种方法。根据乘积法则，为这两个雇员分配办公室共有 \\(12\\cdot 11 = 132\\) 种方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.174,
                0.895,
                0.212
            ],
            "angle": 0,
            "content": "例2 用一个大写英文字母和一个不超过100的正整数给礼堂的座位编号。那么不同编号的座位最多有多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.215,
                0.895,
                0.269
            ],
            "angle": 0,
            "content": "解 给一个座位编号的过程由两个任务组成，即从26个字母中先选择一个字母分配给这个座位，然后再从100个正整数中选择一个整数分配给它。乘积法则表明一个座位可以有 \\(26 \\cdot 100 = 2600\\) 种不同的编号方式。因此，不同编号的座位数至多是2600。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.274,
                0.895,
                0.312
            ],
            "angle": 0,
            "content": "例3 某云数据中心有32台计算机，每台计算机有24个端口。问在这个中心有多少个不同的计算机端口？"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.315,
                0.895,
                0.368
            ],
            "angle": 0,
            "content": "解 选择一个端口的过程由两个任务组成。首先挑一台计算机，然后在这台计算机上挑一个端口。因为有32种方式选择计算机，而不管选择了哪台计算机，又有24种方式选择端口，所以由乘积法则存在 \\(32 \\cdot 24 = 768\\) 个端口。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.371,
                0.895,
                0.426
            ],
            "angle": 0,
            "content": "经常会用到推广的乘积法则。假定一个过程由执行任务 \\(T_{1}\\)，\\(T_{2}\\)，…，\\(T_{m}\\) 来完成。如果在完成任务之后用 \\(n_{i}\\) 种方式来完成 \\(T_{i} (i = 1, 2, \\dots, m)\\)，那么完成这个过程有 \\(n_{1} \\cdot n_{2} \\cdot \\dots \\cdot n_{m}\\) 种方式。可以由两个任务的乘积法则通过数学归纳法证明推广的乘积法则（见本节练习76）。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.431,
                0.401,
                0.448
            ],
            "angle": 0,
            "content": "例4 有多少个不同的7位比特串？"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.453,
                0.895,
                0.488
            ],
            "angle": 0,
            "content": "解 每位有两种选择方式，可以是0或1。因此，乘积法则表明总共有 \\(2^{7} = 128\\) 个不同的7位比特串。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.493,
                0.895,
                0.532
            ],
            "angle": 0,
            "content": "例5如果每个车牌由3个大写英文字母后跟3个数字的序列构成（任何字母的序列都允许，即使是不良词汇），那么有多少个不同的有效车牌？"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.535,
                0.895,
                0.57
            ],
            "angle": 0,
            "content": "解 对3个字母中的每个字母有26种选择，对3个数字中的每个数字有10种选择。因此，由乘积法则总共有 \\(26 \\cdot 26 \\cdot 26 \\cdot 10 \\cdot 10 \\cdot 10 = 17576000\\) 个可能的车牌。"
        },
        {
            "type": "image",
            "bbox": [
                0.302,
                0.594,
                0.638,
                0.634
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.64,
                0.651,
                0.657
            ],
            "angle": 0,
            "content": "例6 计数函数 从一个 \\(n\\) 元集到一个 \\(m\\) 元集存在多少个函数？"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.662,
                0.895,
                0.717
            ],
            "angle": 0,
            "content": "解 函数对于定义域中 \\(m\\) 个元素中的每个元素都要选择陪域中 \\(n\\) 个元素中的一个元素来对应。因此，由乘积法则存在 \\(n \\cdot n \\cdot \\dots \\cdot n = n^m\\) 个从 \\(m\\) 元集到 \\(n\\) 元集的函数。例如，从一个3元集到一个5元集存在 \\(5^3\\) 个不同的函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.722,
                0.773,
                0.739
            ],
            "angle": 0,
            "content": "例7计数一对一函数 从一个 \\(m\\) 元集到一个 \\(n\\) 元集存在多少个一对一函数？"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.744,
                0.895,
                0.838
            ],
            "angle": 0,
            "content": "解首先注意，当 \\(m > n\\) 时没有从 \\(m\\) 元集到 \\(n\\) 元集的一对一函数。现在令 \\(m \\leqslant n\\) 。假设定义域中的元素是 \\(a_1, a_2, \\dots, a_m\\) 。有 \\(n\\) 种方式选择函数在 \\(a_1\\) 的值。因为函数是一对一的，所以可以有 \\(n - 1\\) 种方式选择函数在 \\(a_2\\) 的值（因为 \\(a_1\\) 用过的值不能再用）。一般地，有 \\(n - k + 1\\) 种方式选择函数在 \\(a_k\\) 的值。由乘积法则，从一个 \\(m\\) 元集到一个 \\(n\\) 元集存在着 \\(n(n - 1)(n - 2) \\dots (n - m + 1)\\) 个一对一函数。例如，从一个3元集到一个5元集存在 \\(5 \\cdot 4 \\cdot 3 = 60\\) 个一对一函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.843,
                0.895,
                0.941
            ],
            "angle": 0,
            "content": "例8 电话编号计划“北美洲编号计划”(NANP)规定美国、加拿大以及北美洲许多其他地区的电话号码的格式。在这个编号计划中，一个电话号码由10个数字组成，这些数字由一个3位的地区代码、一个3位的局代码以及一个4位的话机代码组成。出于信号的考虑，在一些数字上有某种限制。为了规定允许的格式，令X表示可以在0到9之间任意选取的数字，N表示可以在2到9之间选取的数字，而Y表示必须取0或1的数字。下面讨论两个编号计划，"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.132,
                0.041,
                0.169,
                0.055
            ],
            "angle": 0,
            "content": "344"
        },
        {
            "type": "header",
            "bbox": [
                0.214,
                0.04,
                0.28,
                0.055
            ],
            "angle": 0,
            "content": "第6章"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.096,
                0.951,
                0.15
            ],
            "angle": 0,
            "content": "分别称为老计划和新计划（老计划是20世纪60年代使用的，已经被新计划代替了，但目前对新号码需求的迅速增长使得这个新计划也将显得落伍了。在这个例题中，用于表示数字的字母遵循“北美洲编号计划”）。正如将要证明的，新计划允许使用更多的号码。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.153,
                0.954,
                0.227
            ],
            "angle": 0,
            "content": "在老计划中，地区代码、局代码和话机代码的格式分别为NYX、NNX和XXXX，因而电话号码的形式为NYX-NNX-XXXX。在新计划中，这些代码的格式分别为NXX、NXX和XXXX，因而电话号码的形式为NXX-NXX-XXXX。在老计划和新计划下分别可能有多少个不同的北美洲电话号码？"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.229,
                0.955,
                0.284
            ],
            "angle": 0,
            "content": "解 由乘积法则，格式为NYX的地区代码有 \\(8 \\cdot 2 \\cdot 10 = 160\\) 个，格式为NXX的地区代码有 \\(8 \\cdot 10 \\cdot 10 = 800\\) 个。类似地，由乘积法则，存在 \\(8 \\cdot 8 \\cdot 10 = 640\\) 个格式为NNX的局代码。乘积法则也表明存在着 \\(10 \\cdot 10 \\cdot 10 \\cdot 10 = 10000\\) 个格式为XXXX的话机代码。"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.287,
                0.545,
                0.302
            ],
            "angle": 0,
            "content": "因此，再次使用乘积法则，在老计划下存在"
        },
        {
            "type": "equation",
            "bbox": [
                0.381,
                0.306,
                0.682,
                0.32
            ],
            "angle": 0,
            "content": "\\[\n1 6 0 \\cdot 6 4 0 \\cdot 1 0 0 0 0 = 1 0 2 4 0 0 0 0 0 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.324,
                0.566,
                0.34
            ],
            "angle": 0,
            "content": "个不同的北美洲有效的电话号码。在新计划下存在"
        },
        {
            "type": "equation",
            "bbox": [
                0.381,
                0.344,
                0.682,
                0.358
            ],
            "angle": 0,
            "content": "\\[\n8 0 0 \\cdot 8 0 0 \\cdot 1 0 0 0 0 = 6 4 0 0 0 0 0 0 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.362,
                0.287,
                0.378
            ],
            "angle": 0,
            "content": "个不同的电话号码。"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.384,
                0.541,
                0.401
            ],
            "angle": 0,
            "content": "例9 执行下面的代码以后，\\(k\\) 的值是什么？"
        },
        {
            "type": "equation",
            "bbox": [
                0.154,
                0.416,
                0.346,
                0.53
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{r l} k := 0 \\\\ \\text {f o r} i _ {1} := 1 \\text {t o} n _ {1} \\\\ \\text {f o r} i _ {2} := 1 \\text {t o} n _ {2} \\\\ \\vdots \\\\ \\text {f o r} i _ {m} := 1 \\text {t o} n _ {m} \\\\ k := k + 1 \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.539,
                0.957,
                0.612
            ],
            "angle": 0,
            "content": "解 \\(k\\) 的初值是0。这个嵌套的循环每执行一次，\\(k\\) 就加1。令 \\(T_{i}\\) 表示执行第 \\(i\\) 个循环的任务，那么循环执行的次数就是完成任务 \\(T_{1}\\)，\\(T_{2}\\)，…，\\(T_{m}\\) 的方法数。因为对每个整数 \\(i_{j}\\)，\\(1 \\leqslant i_{j} \\leqslant n_{j}\\)，第 \\(j\\) 个循环都执行一次，所以执行任务 \\(T_{j} (j = 1, 2, \\dots, m)\\) 的方法数就是 \\(n_{j}\\)。由乘积法则，这个嵌套的循环执行了 \\(n_{1}n_{2}\\dots n_{m}\\) 次。因此 \\(k\\) 最后的值是 \\(n_{1}n_{2}\\dots n_{m}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.614,
                0.891,
                0.633
            ],
            "angle": 0,
            "content": "例10 计数有穷集的子集 用乘积法则证明一个有穷集 \\(S\\) 的不同的子集数是 \\(2^{|S|}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.637,
                0.96,
                0.711
            ],
            "angle": 0,
            "content": "解设 \\(S\\) 是有穷集。按任意的顺序将 \\(S\\) 的元素列成一个表。考虑到在 \\(S\\) 的子集和长度为 \\(|S|\\) 的比特串之间存在着一对一的对应，即如果表的第 \\(i\\) 个元素在这个子集中，则该子集对应的比特串的第 \\(i\\) 位为1，否则该位为0。由乘积法则，存在着 \\(2^{|S|}\\) 个长度为 \\(|S|\\) 的比特串。因此 \\(\\left|P(S)\\right| = 2^{|S|}\\)。（5.1节中例10用数学归纳法证明了这个事实。）"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.713,
                0.96,
                0.785
            ],
            "angle": 0,
            "content": "乘积法则也常用集合的语言表述如下：如果 \\(A_{1}\\)，\\(A_{2}\\)，…，\\(A_{m}\\) 是有穷集，那么在这些集合的笛卡儿积中的元素数是每个集合的元素数之积。为了把这种表述与乘积法则联系起来，注意到在笛卡儿积 \\(A_{1} \\times A_{2} \\times \\dots \\times A_{m}\\) 中选一个元素的任务是通过在 \\(A_{1}\\) 中选一个元素，\\(A_{2}\\) 中选一个元素，…，\\(A_{m}\\) 中选一个元素来完成的。由乘积法则得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.324,
                0.787,
                0.752,
                0.805
            ],
            "angle": 0,
            "content": "\\[\n\\left| A _ {1} \\times A _ {2} \\times \\dots \\times A _ {m} \\right| = \\left| A _ {1} \\right| \\cdot \\left| A _ {2} \\right| \\cdot \\dots \\cdot \\left| A _ {m} \\right|\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.808,
                0.962,
                0.883
            ],
            "angle": 0,
            "content": "例11 DNA和基因组生物体的遗传信息是使用脱氧核糖核酸(DNA)编码的，或对于某些病毒，采用核糖核酸(RNA)。DNA和RNA是非常复杂的分子，采用非常多的分子相互作用的方式支持生命中的不同过程。对于我们而言，我们只对DNA和RNA如何进行遗传信息编码给出简短的描述。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.886,
                0.964,
                0.94
            ],
            "angle": 0,
            "content": "DNA分子由2条脱氧核糖核苷酸链组成，每个核苷酸的子部分称为碱基，其中有腺嘌呤(A)、胞嘧啶(C)、鸟嘌呤(G)或胸腺嘧啶(T)。DNA包括不同碱基的两条链通过氢键结合在一起，而且A仅与T配对，C只与G配对。与DNA不同，RNA分子由1条核糖核苷酸链组"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.685,
                0.042,
                0.772,
                0.056
            ],
            "angle": 0,
            "content": "计数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.82,
                0.043,
                0.856,
                0.056
            ],
            "angle": 0,
            "content": "345"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.097,
                0.887,
                0.152
            ],
            "angle": 0,
            "content": "成，其中尿嘧啶(U)代替了胸腺嘧啶。因此，在DNA中可能碱基对是A-T和C-G，而在RNA中碱基对是A-U和C-G。生物的DNA包括多段DNA，它们形成不同的染色体，一个基因是一个DNA分子的片段，编码一种特定蛋白质。一个生物体的全部基因信息称为基因组。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.153,
                0.887,
                0.244
            ],
            "angle": 0,
            "content": "DNA和RNA碱基序列编码的蛋白质长链称为氨基酸。人类必需的氨基酸有22种。我们很快能看到至少三个碱基的序列就可以编码出这22种不同的氨基酸。首先，因为在DNA中有四种可能的碱基A、C、G和T，所以由乘积法则， \\(4^{2} = 16 < 22\\) 种不同的两碱基序列。但 \\(4^{3} = 64\\) 种不同的三碱基序列，这样可以足够编码22种不同的氨基酸。（甚至可以出现不同的三碱基序列对应相同的氨基酸的情况。）"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.246,
                0.887,
                0.435
            ],
            "angle": 0,
            "content": "像藻类和细菌这样的简单生物的DNA具有 \\(10^{5}\\) 和 \\(10^{7}\\) 个链接。每个链接都是这四种可能碱基的一种。更复杂的生物，如昆虫、鸟类和哺乳动物，它们的DNA具有 \\(10^{8}\\) 和 \\(10^{10}\\) 个链接。因此，由乘积法则，在简单生物中具有至少 \\(4^{10^{5}}\\) 种不同的碱基序列，而复杂生物中具有至少\\(4^{10^{8}}\\) 种不同的碱基序列。这些都是不可想象的大数字，这也帮助我们解释了为什么生物有这么多种类。在过去的数十年中，确定不同生物体的基因组的技术一直在发展。第一步就是确定第一个基因在生物体DNA中的位置。接着的任务称为基因测序，确定每个基因的链接序列。（当然，这些基因上链接的特定序列取决于一个物种特定的个体表达，必须对它的DNA进行分析。）例如，人类基因组包含大约23000个基因，每一个基因有1000或者更多个链接。基因测序技术运用了许多新开发的算法，也运用了组合学中大量的新思路。许多数学家和计算机科学家在解决涉及基因组的问题时，参与了对分子信息学和计算生物学这一快速发展领域的研究。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.437,
                0.26,
                0.454
            ],
            "angle": 0,
            "content": "现在引入求和法则。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.462,
                0.884,
                0.499
            ],
            "angle": 0,
            "content": "求和法则 如果完成第一项任务有 \\(n_1\\) 种方式，完成第二项任务有 \\(n_2\\) 种方式，并且这些任务不能同时执行，那么完成第一或第二项任务有 \\(n_1 + n_2\\) 种方式。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.508,
                0.352,
                0.526
            ],
            "angle": 0,
            "content": "例12说明怎样使用求和法则。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.529,
                0.89,
                0.568
            ],
            "angle": 0,
            "content": "例12 假定要选一位数学学院的教师或数学专业的学生作为校委会的代表。如果有37位数学学院的教师和83位数学专业的学生，那么这个代表有多少种不同的选择？"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.57,
                0.89,
                0.626
            ],
            "angle": 0,
            "content": "解 完成第一项任务，选一位数学学院的教师，可以有37种方式。完成第二项任务，选一位数学专业的学生，有83种方式。根据求和法则，结果有 \\(37 + 83 = 120\\) 种可能的方式来挑选这个代表。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.627,
                0.89,
                0.7
            ],
            "angle": 0,
            "content": "可以把求和法则推广到多于两项任务的情况。假定任务 \\(T_{1}\\)，\\(T_{2}\\)，…，\\(T_{m}\\) 分别有 \\(n_{1}\\)，\\(n_{2}\\)，…，\\(n_{m}\\) 种完成方式，并且任何两项任务都不能同时执行，那么完成其中一项任务的方式数是 \\(n_{1} + n_{2} + \\dots + n_{m}\\)。如例 13 和例 14 所示，这个推广的求和法则在计数问题中常常用到。这个求和法则可以使用数学归纳法从两个集合的求和法则加以证明（见本节练习 75）。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.704,
                0.89,
                0.743
            ],
            "angle": 0,
            "content": "例13一个学生可以从三个表中的一个表选择一个计算机课题。这三个表分别包含23、15和19个可能的课题。那么课题的选择可能有多少种？"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.745,
                0.89,
                0.781
            ],
            "angle": 0,
            "content": "解这个学生有23种方式从第一个表中选择课题，有15种方式从第二个表中选择课题，有19种方式从第三个表中选择课题。因此，共有 \\(23 + 15 + 19 = 57\\) 种选择课题的方式。"
        },
        {
            "type": "text",
            "bbox": [
                0.087,
                0.785,
                0.733,
                0.803
            ],
            "angle": 0,
            "content": "例14 在执行下面的代码后， \\(k\\) 的值是什么 \\((n_{1}, n_{2}, \\dots, n_{m}\\) 是正整数）？"
        },
        {
            "type": "code",
            "bbox": [
                0.092,
                0.824,
                0.236,
                0.936
            ],
            "angle": 0,
            "content": "\\(k:=0\\)  \nfor \\(i_1:=1\\) to \\(n_1\\),  \n\\(k:=k+1\\)  \nfor \\(i_2:=1\\) to \\(n_2\\),  \n\\(k:=k+1\\)  \n\\(\\vdots\\)"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.139,
                0.038,
                0.177,
                0.052
            ],
            "angle": 0,
            "content": "346"
        },
        {
            "type": "header",
            "bbox": [
                0.221,
                0.037,
                0.288,
                0.053
            ],
            "angle": 0,
            "content": "第6章"
        },
        {
            "type": "equation",
            "bbox": [
                0.157,
                0.105,
                0.305,
                0.139
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} \\text {f o r} i _ {m} := 1 \\text {t o} n _ {m} \\\\ k := k + 1 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.16,
                0.957,
                0.234
            ],
            "angle": 0,
            "content": "解 \\(k\\) 的初值是0。这个代码块由 \\(m\\) 个不同的循环构成。循环中的每次执行 \\(k\\) 都要加1。为了确定这段代码执行后 \\(k\\) 的值，我们需要知道循环执行了多少次。注意，执行第 \\(i\\) 次循环共有 \\(n_i\\) 种方式。由于一次只能执行一个循环，因此由求和法则可以算出 \\(k\\) 的最终值，即执行 \\(m\\) 个循环中的一个共有 \\(n_1 + n_2 + \\dots + n_m\\) 种方式。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.237,
                0.957,
                0.329
            ],
            "angle": 0,
            "content": "求和法则可以用集合的语言表述：如果 \\(A_{1}\\)，\\(A_{2}\\)，…，\\(A_{m}\\) 是不交的集合，那么在其并集中的元素数是每个集合的元素数之和。为了把这种表述与求和法则联系起来，令 \\(T_{i}\\) 是从 \\(A_{i} (i = 1, 2, \\dots, m)\\) 中选择一个元素的任务。有 \\(|A_{i}|\\) 种方式执行 \\(T_{i}\\)。由于任何两个任务不可能同时执行，所以根据求和法则，从其中某个集合中选择一个元素的方式数，即在并集中的元素数，是"
        },
        {
            "type": "equation",
            "bbox": [
                0.175,
                0.332,
                0.895,
                0.35
            ],
            "angle": 0,
            "content": "\\[\n\\left| A _ {1} \\cup A _ {2} \\cup \\dots \\cup A _ {m} \\right| = \\left| A _ {1} \\right| + \\left| A _ {2} \\right| + \\dots + \\left| A _ {m} \\right| \\quad A _ {i} \\cap A _ {j} = \\varnothing , \\text {对 于 所 有 的} i, j\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.352,
                0.956,
                0.388
            ],
            "angle": 0,
            "content": "这个等式仅适用于问题中的集合是不相交的情况。当这些集合含有公共元素时，情况要复杂得多。本节的后面将对这种情况进行简要的讨论，更深入的讨论放在第8章。"
        },
        {
            "type": "title",
            "bbox": [
                0.109,
                0.398,
                0.396,
                0.416
            ],
            "angle": 0,
            "content": "6.1.3 比较复杂的计数问题"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.419,
                0.956,
                0.473
            ],
            "angle": 0,
            "content": "许多计数问题不能仅仅使用求和法则或者乘积法则来求解。但是，许多复杂的计数问题可以结合使用这两个法则来求解。我们从编程语言BASIC中变量名个数的计数开始。（在练习中，我们将考虑Java中变量名的个数。）然后针对一组特别限制，计算有效密码的个数。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.477,
                0.957,
                0.554
            ],
            "angle": 0,
            "content": "例15 在计算机语言BASIC的某个版本中，变量的名字是含有一个或两个字符的符号串，其中的大写和小写字母是不加区分的（一个字母数字字符或者取自26个英文字母，或者取自10个数字）。此外，变量名必须以字母开始，并且必须与由两个字符构成的用于程序设计的5个保留字相区别。在BASIC的这个版本中有多少个不同的变量名？"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.557,
                0.957,
                0.65
            ],
            "angle": 0,
            "content": "解 令 \\(V\\) 等于在这个BASIC版本中的不同变量名的个数，\\(V_{1}\\) 是单字符的变量名的个数，\\(V_{2}\\) 是两个字符的变量名的个数。那么由求和法则，\\(V = V_{1} + V_{2}\\) 。由于单字符变量名必须是字母，所以 \\(V_{1} = 26\\) 。又根据乘积法则存在 \\(26 \\cdot 36\\) 个以字母打头且以字母数字结尾的2位字符串。但是其中5个不包含在内，因此 \\(V_{2} = 26 \\cdot 36 - 5 = 931\\) 。所以，在这个BASIC版本中存在 \\(V = V_{1} + V_{2} = 26 + 931 = 957\\) 个不同的变量名。"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.654,
                0.956,
                0.693
            ],
            "angle": 0,
            "content": "例16 计算机系统的每个用户有一个由 \\(6\\sim 8\\) 个字符构成的密码，其中每个字符是大写字母或者数字，且每个密码必须至少包含一个数字。有多少可能的密码？"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.696,
                0.957,
                0.789
            ],
            "angle": 0,
            "content": "解设 \\(P\\) 是可能的密码总数，且 \\(P_{6}, P_{7}, P_{8}\\) 分别表示6、7或8位的可能的密码数。由求和法则，\\(P = P_{6} + P_{7} + P_{8}\\) 。我们现在求 \\(P_{6}, P_{7}\\) 和 \\(P_{8}\\) 。直接求 \\(P_{6}\\) 是困难的。而求由6个大写字母和数字构成的字符串的个数是容易的，其中包含那些没有数字的串，然后从中减去没有数字的串数就得到 \\(P_{6}\\) 。由乘积法则，6个字符的串的个数是 \\(36^{6}\\)，而没有数字的字符串的个数是 \\(26^{6}\\) 。因此，"
        },
        {
            "type": "equation",
            "bbox": [
                0.271,
                0.792,
                0.795,
                0.807
            ],
            "angle": 0,
            "content": "\\[\nP _ {6} = 3 6 ^ {6} - 2 6 ^ {6} = 2 1 7 6 7 8 2 3 3 6 - 3 0 8 9 1 5 7 7 6 = 1 8 6 7 8 6 6 5 6 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.811,
                0.236,
                0.826
            ],
            "angle": 0,
            "content": "类似地，得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.255,
                0.829,
                0.812,
                0.845
            ],
            "angle": 0,
            "content": "\\[\nP _ {7} = 3 6 ^ {7} - 2 6 ^ {7} = 7 8 3 6 4 1 6 4 0 9 6 - 8 0 3 1 8 1 0 1 7 6 = 7 0 3 3 2 3 5 3 9 2 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.849,
                0.136,
                0.863
            ],
            "angle": 0,
            "content": "和"
        },
        {
            "type": "equation",
            "bbox": [
                0.219,
                0.867,
                0.848,
                0.883
            ],
            "angle": 0,
            "content": "\\[\nP _ {8} = 3 6 ^ {8} - 2 6 ^ {8} = 2 8 2 1 1 0 9 9 0 7 4 5 6 - 2 0 8 \\bar {8} 2 7 0 6 4 5 7 6 = 2 6 1 2 2 8 2 8 4 2 8 8 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.886,
                0.154,
                0.901
            ],
            "angle": 0,
            "content": "因此"
        },
        {
            "type": "equation",
            "bbox": [
                0.357,
                0.905,
                0.71,
                0.921
            ],
            "angle": 0,
            "content": "\\[\nP = P _ {6} + P _ {7} + P _ {8} = 2 6 8 4 4 8 3 0 6 3 3 6 0\n\\]"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.694,
                0.038,
                0.785,
                0.053
            ],
            "angle": 0,
            "content": "计数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.829,
                0.039,
                0.866,
                0.052
            ],
            "angle": 0,
            "content": "347"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.097,
                0.894,
                0.174
            ],
            "angle": 0,
            "content": "例17 计数因特网网址在由计算机的物理网络互连而成的因特网中，每台计算机（或者更精确地说是计算机的每个网络连接）被分配一个因特网地址(IP地址)。在因特网协议版本4(IPv4)中，一个地址是一个32位的比特串。它以网络号(netid)开始，后面跟随着主机号(hostid)，把一个计算机认定为某个指定网络的成员。"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.176,
                0.896,
                0.346
            ],
            "angle": 0,
            "content": "根据网络号和主机号位数的不同，使用3种地址形式。用于最大网络的A类地址，由0后跟7位的网络号和24位的主机号构成。用于中等网络的B类地址，由10后跟14位的网络号和16位的主机号构成。用于最小网络的C类地址，由110后跟21位的网络号和8位的主机号构成。由于特定用途，对地址有着某些限制：111111在A类网络的网络号中是无效的，全0和全1组成的主机号对任何网络都是无效的。因特网上的一台计算机有一个A类、B类或C类地址。（除了A类、B类和C类地址外，还有D类地址和E类地址。D类地址在多台计算机同时编址时用于组播，它由1110后跟28位组成。E类地址保留为将来应用，由1110后跟27位组成。D和E类地址不会分配给因特网中的计算机作为IP地址。）图1显示了IPv4的编址。（A类和B类网络号的数量限制已经使得IPv4编址不够用了。用于代替IPv4的IPv6使用128位地址来解决这个问题。）"
        },
        {
            "type": "image",
            "bbox": [
                0.117,
                0.35,
                0.821,
                0.448
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.365,
                0.453,
                0.569,
                0.468
            ],
            "angle": 0,
            "content": "图1 因特网地址（IPv4）"
        },
        {
            "type": "text",
            "bbox": [
                0.083,
                0.478,
                0.54,
                0.495
            ],
            "angle": 0,
            "content": "对因特网上的计算机有多少不同的有效IPv4地址？"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.497,
                0.892,
                0.572
            ],
            "angle": 0,
            "content": "解 令 \\(x\\) 是因特网上计算机的有效地址数，\\(x_{\\mathrm{A}}\\)、\\(x_{\\mathrm{B}}\\) 和 \\(x_{\\mathrm{C}}\\) 分别表示 A 类、B 类和 C 类的有效地址数。由求和法则，\\(x = x_{\\mathrm{A}} + x_{\\mathrm{B}} + x_{\\mathrm{C}}\\)。为了找到 \\(x_{\\mathrm{A}}\\)，由于 1111111 是无效的，所以存在 \\(2^{7} - 1 = 127\\) 个 A 类的网络号。对于每个网络号，存在 \\(2^{24} - 2 = 16777214\\) 个主机号，这是由于全 0 和全 1 组成的主机号是无效的。因此，"
        },
        {
            "type": "equation",
            "bbox": [
                0.3,
                0.574,
                0.632,
                0.59
            ],
            "angle": 0,
            "content": "\\[\nx _ {\\mathrm {A}} = 1 2 7 \\cdot 1 6 7 7 7 2 1 4 = 2 1 3 0 7 0 6 1 7 8\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.593,
                0.891,
                0.648
            ],
            "angle": 0,
            "content": "为了找到 \\(x_{\\mathrm{B}}\\) 和 \\(x_{\\mathrm{C}}\\) ，首先注意存在 \\(2^{14} = 16384\\) 个B类网络号和 \\(2^{21} = 2097152\\) 个C类网络号。对每个B类网络号存在 \\(2^{16} - 2 = 65534\\) 个主机号，而对每个C类网络号存在 \\(2^{8} - 2 = 254\\) 个主机号，这也考虑到全0和全1组成的主机号是无效的。因此，"
        },
        {
            "type": "equation",
            "bbox": [
                0.301,
                0.651,
                0.631,
                0.667
            ],
            "angle": 0,
            "content": "\\[\nx _ {\\mathrm {B}} = 1 0 7 3 7 0 9 0 5 6, x _ {\\mathrm {C}} = 5 3 2 6 7 6 6 0 8\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.669,
                0.424,
                0.686
            ],
            "angle": 0,
            "content": "我们可以得出IPv4有效地址的总数是"
        },
        {
            "type": "equation",
            "bbox": [
                0.126,
                0.688,
                0.807,
                0.705
            ],
            "angle": 0,
            "content": "\\[\nx = x _ {\\mathrm {A}} + x _ {\\mathrm {B}} + x _ {\\mathrm {C}} = 2 1 3 0 7 0 6 1 7 8 + 1 0 7 3 7 0 9 0 5 6 + 5 3 2 6 7 6 6 0 8 = 3 7 3 7 0 9 1 8 4 2\n\\]"
        },
        {
            "type": "title",
            "bbox": [
                0.041,
                0.715,
                0.439,
                0.733
            ],
            "angle": 0,
            "content": "6.1.4 减法法则（两个集合的容斥原理）"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.735,
                0.891,
                0.79
            ],
            "angle": 0,
            "content": "假设一项任务可以通过两种方法之一来完成，但在这两种方法中，有一些方法是相同的。在这种情况下，我们不能通过求和法则来计算完成任务的方法数。如果我们将两种方法的数量相加，总数会超过正确结果，因为我们将两种方法中相同的部分算了两次。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.793,
                0.891,
                0.829
            ],
            "angle": 0,
            "content": "为了正确计算完成任务的方法数，我们必须减去算了两次的部分。这就产生了一个重要的计数法则。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.836,
                0.886,
                0.874
            ],
            "angle": 0,
            "content": "减法法则 如果一个任务或者可以通过 \\( n_1 \\) 种方法执行，或者可以通过 \\( n_2 \\) 种另一类方法执行，那么执行这个任务的方法数是 \\( n_1 + n_2 \\) 减去两类方法中相同的方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.883,
                0.891,
                0.939
            ],
            "angle": 0,
            "content": "减法法则也称为容斥原理，特别是在计算两个集合并集的元素个数时。令 \\(A_{1}\\) 和 \\(A_{2}\\) 是集合，\\(|A_{1}|\\) 是从 \\(A_{1}\\) 选择一个元素的方法数，\\(|A_{2}|\\) 是从 \\(A_{2}\\) 选择一个元素的方法数。从 \\(A_{1}\\) 或 \\(A_{2}\\) 中选择一个元素的方法数是从它们的并集中选择元素的方法数，这等于从 \\(A_{1}\\) 选择一个元素的"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.137,
                0.038,
                0.172,
                0.051
            ],
            "angle": 0,
            "content": "348"
        },
        {
            "type": "header",
            "bbox": [
                0.218,
                0.037,
                0.284,
                0.052
            ],
            "angle": 0,
            "content": "第6章"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.093,
                0.957,
                0.147
            ],
            "angle": 0,
            "content": "方法数与从 \\(A_{2}\\) 选择一个元素的方法数的和减去从 \\(A_{1}\\) 和 \\(A_{2}\\) 中都选择一个元素的方法数。因为 \\(\\left|A_{1} \\cup A_{2}\\right|\\) 表示从 \\(A_{1}\\) 或者 \\(A_{2}\\) 中选择一个元素的方法数，\\(\\left|A_{1} \\cap A_{2}\\right|\\) 表示从 \\(A_{1}\\) 和 \\(A_{2}\\) 中同时选择一个元素的方法数，所以我们有"
        },
        {
            "type": "equation",
            "bbox": [
                0.365,
                0.15,
                0.705,
                0.168
            ],
            "angle": 0,
            "content": "\\[\n\\left| A _ {1} \\cup A _ {2} \\right| = \\left| A _ {1} \\right| + \\left| A _ {2} \\right| - \\left| A _ {1} \\cap A _ {2} \\right|\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.171,
                0.597,
                0.187
            ],
            "angle": 0,
            "content": "这就是2.2节给出的计数两个集合并集中元素的公式。"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.19,
                0.565,
                0.206
            ],
            "angle": 0,
            "content": "例18显示了怎样用减法法则来求解计数问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.211,
                0.651,
                0.228
            ],
            "angle": 0,
            "content": "例18 以1开始或者以00结束的8位比特串有多少个？"
        },
        {
            "type": "text",
            "bbox": [
                0.109,
                0.234,
                0.701,
                0.364
            ],
            "angle": 0,
            "content": "解 在应用容斥原理之前，我们需要解决三个计数问题，如图2所示。首先，我们构造以1开始的8位比特串，共有 \\( 2^{7} = 128 \\) 种方式，这是由乘积法则得到的。因为第一位只有一种选择方式，而其他7位中的每位有两种选择方式。类似地，构造以00结束的8位比特串，共有 \\( 2^{6} = 64 \\) 种方式，这也是由乘积法则得到的。因为前6位的每位有两种选择方式，而最后两位只有一种选择方式。"
        },
        {
            "type": "image",
            "bbox": [
                0.735,
                0.172,
                0.948,
                0.325
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.734,
                0.327,
                0.944,
                0.36
            ],
            "angle": 0,
            "content": "图2 以1开始或者以00结束的8位比特串"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.367,
                0.962,
                0.459
            ],
            "angle": 0,
            "content": "接下来同时完成这两个任务，构造以1开始以00结束的8位比特串，共有 \\(2^{5} = 32\\) 种方式。即在完成上述两个任务的方式中，有32种是相同的。这里也使用了乘积法则，因为第一位只有一种选择方式，从第二位到第六位每位可以有两种选择方式，最后两位也只有一种选择方式。因而，以1开始或者以00结束的8位比特串的个数，即完成第一或第二个任务的方式数，等于 \\(128 + 64 - 32 = 160\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.153,
                0.462,
                0.704,
                0.478
            ],
            "angle": 0,
            "content": "我们将给出一个例题来说明容斥原理如何用于解决计数问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.483,
                0.964,
                0.56
            ],
            "angle": 0,
            "content": "例19 某计算机公司收到了350份大学毕业生求职一组新网络服务器工作的申请书。假如这些申请人中有220人主修的是计算机科学专业，有147人主修的是商务专业，有51人既主修了计算机科学专业又主修了商务专业。那么，有多少个申请人既没有主修计算机科学专业又没有主修商务专业？"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.563,
                0.964,
                0.674
            ],
            "angle": 0,
            "content": "解为了求出既没有主修计算机科学专业又没有主修商务专业的申请人的个数，可以从总的申请人数中减去主修计算机科学专业的人数，或减去主修商务专业的人数（或减去二者人数之和）。设 \\(A_{1}\\) 是主修计算机科学专业的学生的集合， \\(A_{2}\\) 是主修商务专业的学生的集合，那么\\(A_{1}\\bigcup A_{2}\\) 是主修计算机科学专业或主修商务专业学生的集合， \\(A_{1}\\cap A_{2}\\) 是既主修计算机科学专业又主修商务专业学生的集合。根据减法法则，主修计算机科学专业或主修商务专业（或二者都主修）的学生的人数为"
        },
        {
            "type": "equation",
            "bbox": [
                0.271,
                0.677,
                0.812,
                0.694
            ],
            "angle": 0,
            "content": "\\[\n\\left| A _ {1} \\cup A _ {2} \\right| = \\left| A _ {1} \\right| + \\left| A _ {2} \\right| - \\left| A _ {1} \\cap A _ {2} \\right| = 2 2 0 + 1 4 7 - 5 1 = 3 1 6\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.697,
                0.964,
                0.732
            ],
            "angle": 0,
            "content": "因此得到结论：有 \\(350 - 316 = 34\\) 个申请人既没有主修计算机科学专业又没有主修商务专业。本例题的文氏图见图3。"
        },
        {
            "type": "image",
            "bbox": [
                0.281,
                0.742,
                0.805,
                0.876
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.281,
                0.883,
                0.803,
                0.899
            ],
            "angle": 0,
            "content": "图3既没有主修计算机科学专业又没有主修商务专业的申请人"
        },
        {
            "type": "text",
            "bbox": [
                0.157,
                0.909,
                0.965,
                0.927
            ],
            "angle": 0,
            "content": "减法法则或者容斥原理可以推广来求完成 \\(n\\) 个不同任务中的一个任务的方式数，换句话"
        },
        {
            "type": "image",
            "bbox": [
                0.034,
                0.209,
                0.097,
                0.226
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.694,
                0.039,
                0.785,
                0.055
            ],
            "angle": 0,
            "content": "计数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.828,
                0.041,
                0.866,
                0.055
            ],
            "angle": 0,
            "content": "349"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.095,
                0.893,
                0.131
            ],
            "angle": 0,
            "content": "说，就是寻找 \\(n\\) 个集合的并集中的元素数，其中 \\(n\\) 是正整数。我们将在第8章研究容斥原理和它的某些应用。"
        },
        {
            "type": "title",
            "bbox": [
                0.048,
                0.141,
                0.218,
                0.159
            ],
            "angle": 0,
            "content": "6.1.5 除法法则"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.162,
                0.895,
                0.198
            ],
            "angle": 0,
            "content": "我们介绍了计数中的乘积法则、求和法则和减法法则。是否有除法法则呢？实际上，在解决某些计数问题时，也存在这样的法则。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.206,
                0.886,
                0.243
            ],
            "angle": 0,
            "content": "除法法则 如果一个任务能由一个可以用 \\(n\\) 种方式完成的过程实现，而对于每种完成任务的方式 \\(\\omega\\) ，在 \\(n\\) 种方式中正好有 \\(d\\) 种与之对应，那么完成这个任务的方法数为 \\(n / d\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.252,
                0.895,
                0.288
            ],
            "angle": 0,
            "content": "我们可用集合的方式再描述一遍除法法则：“如果一个有限集 \\(A\\) 是 \\(n\\) 个有 \\(d\\) 个元素的互斥集合的并集，那么 \\(n = |A| / d\\)。”"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.291,
                0.897,
                0.346
            ],
            "angle": 0,
            "content": "我们也可用函数的方式定义除法法则：“如果 \\(f\\) 是一个 \\(A\\) 到 \\(B\\) 的函数，\\(A\\) 和 \\(B\\) 都是有限集合，那么对于每一个取值 \\(y \\in B\\)，正好有 \\(d\\) 个值 \\(x \\in A\\) 使得 \\(f(x) = y\\)（在这种情况下，\\(f\\) 是 \\(d\\) 对1的），那么 \\(|B| = |A| / d\\)。”"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.349,
                0.895,
                0.385
            ],
            "angle": 0,
            "content": "评注 在一个任务能以 \\( n \\) 种不同方式实现，但对于每一种实现任务的方法有 \\( d \\) 种等价的方法的情况下，就要用到除法法则。在这种情况下，我们就说完成任务有 \\( n / d \\) 种不等价的方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.387,
                0.536,
                0.404
            ],
            "angle": 0,
            "content": "我们将用两个例题说明除法法则在计数中的使用。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.409,
                0.895,
                0.448
            ],
            "angle": 0,
            "content": "例20 假设在牧场中有一个计数奶牛腿数的系统。假设这个系统统计出该牧场的奶牛共有572条腿，则牧场中有多少只奶牛？假设每只奶牛有4条腿，而且没有其他动物。"
        },
        {
            "type": "text",
            "bbox": [
                0.049,
                0.45,
                0.897,
                0.486
            ],
            "angle": 0,
            "content": "解设 \\(n\\) 为牧场统计的奶牛腿数。因为每头奶牛有4条腿，由除法法则可知牧场有 \\(n / 4\\) 头奶牛。所以，572条腿的牧场有 \\(572 / 4 = 143\\) 头奶牛。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.491,
                0.897,
                0.53
            ],
            "angle": 0,
            "content": "例214个人坐在一个圆桌旁边，有多少种坐法？如果每个人左右相邻的人都相同就认为是同一种坐法。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.532,
                0.899,
                0.644
            ],
            "angle": 0,
            "content": "解我们任意选择一个桌子旁边的椅子，标记为座位1，依圆桌顺时针依次标记其他椅子。座位1有4种选择坐人的方法，座位2有3种选择坐人的方法，座位3有2种选择坐人的方法，座位4有1种选择坐人的方法，这样有 \\( 4! = 24 \\) 种方法将4个人安排在圆桌旁边。然而，每一个座位1可选的4种坐法中都会产生相同的安排，因为我们仅将一个人左边或者右边相邻的人不一样才视为两种不同的安排。因为有4种选择人坐座位1的方法，所以由除法法则将4个人安排到一个圆桌旁的不同的方法数是 \\( 24 / 4 = 6 \\) 种。"
        },
        {
            "type": "title",
            "bbox": [
                0.052,
                0.655,
                0.178,
                0.672
            ],
            "angle": 0,
            "content": "6.1.6 树图"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.675,
                0.9,
                0.749
            ],
            "angle": 0,
            "content": "可以使用树图求解计数问题。一棵树由根、从根出发的许多分支以及可能从其他分支端点出发的新的分支构成（我们将在第11章详细地研究树）。为了在计数中使用树，我们用一个分支表示每个可能的选择，用树叶表示可能的结果。这些树叶是某些分支的端点，从这些端点不再进一步分支。"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.751,
                0.686,
                0.787
            ],
            "angle": 0,
            "content": "注意，当用树图求解计数问题时，为到达一片树叶所做的选择个数可能是不同的（作为例子，见例22）。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.792,
                0.5,
                0.809
            ],
            "angle": 0,
            "content": "例22 有多少不含连续两个1的4位比特串？"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.814,
                0.686,
                0.85
            ],
            "angle": 0,
            "content": "解图4的树图给出了所有不含连续两个1的4位比特串。我们看出存在8个不含连续两个1的4位比特串。"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.855,
                0.686,
                0.893
            ],
            "angle": 0,
            "content": "例23 在两个队（队1和队2）之间的决赛至多由5次比赛构成。先胜3次的队赢得决赛。决赛可能出现多少种不同的方式？"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.896,
                0.686,
                0.932
            ],
            "angle": 0,
            "content": "解 在图5的树图中，以每次比赛的得胜者给出了决赛可能进行的所有方式。我们看到有20种不同的决赛方式。"
        },
        {
            "type": "image",
            "bbox": [
                0.699,
                0.735,
                0.886,
                0.867
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.694,
                0.868,
                0.89,
                0.899
            ],
            "angle": 0,
            "content": "图4 不含连续两个1的4位比特串"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.131,
                0.038,
                0.167,
                0.052
            ],
            "angle": 0,
            "content": "350"
        },
        {
            "type": "header",
            "bbox": [
                0.212,
                0.037,
                0.278,
                0.053
            ],
            "angle": 0,
            "content": "第6章"
        },
        {
            "type": "image",
            "bbox": [
                0.101,
                0.097,
                0.954,
                0.376
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.435,
                0.38,
                0.616,
                0.395
            ],
            "angle": 0,
            "content": "图5 5次决赛胜3次"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.404,
                0.95,
                0.481
            ],
            "angle": 0,
            "content": "例24 假设“我爱新泽西”T恤衫有5种不同的规格：S、M、L、XL和XXL。又知道XL规格只有红色、绿色和黑色三种颜色，XXL规格只有绿色和黑色。除此之外，其他规格有四种颜色：白色、红色、绿色和黑色。如果每种规格和颜色的T恤衫至少一件，那么一个纪念品商店必须库存多少件不同的T恤衫？"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.483,
                0.95,
                0.519
            ],
            "angle": 0,
            "content": "解图6的树图给出了所有规格和颜色的配对。从图6中可知这个纪念品商店老板必须库存17件不同的T恤衫。"
        },
        {
            "type": "image",
            "bbox": [
                0.285,
                0.524,
                0.769,
                0.652
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.42,
                0.658,
                0.63,
                0.674
            ],
            "angle": 0,
            "content": "图6 计数不同的T恤衫"
        },
        {
            "type": "title",
            "bbox": [
                0.102,
                0.693,
                0.149,
                0.708
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.713,
                0.61,
                0.727
            ],
            "angle": 0,
            "content": "1. 一个学院有18个数学专业和325个计算机科学专业的学生。"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.73,
                0.823,
                0.744
            ],
            "angle": 0,
            "content": "a) 选两个代表，使得一个是数学专业的而另一个是计算机科学专业的，有多少种方式？"
        },
        {
            "type": "text",
            "bbox": [
                0.122,
                0.747,
                0.621,
                0.761
            ],
            "angle": 0,
            "content": "b) 选一个数学专业或计算机科学专业的代表又有多少种方式？"
        },
        {
            "type": "list",
            "bbox": [
                0.121,
                0.73,
                0.823,
                0.761
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.765,
                0.788,
                0.78
            ],
            "angle": 0,
            "content": "2. 一个办公大楼有27层，每层有37个办公室，那么在这个大楼里有多少个办公室？"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.783,
                0.646,
                0.796
            ],
            "angle": 0,
            "content": "3. 一次多项选择考试包含10个问题。每个问题有4个可能的答案。"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.8,
                0.805,
                0.813
            ],
            "angle": 0,
            "content": "a)在这次考试中如果每个问题都要回答，一个学生回答这些问题可能有多少种方式？"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.817,
                0.805,
                0.83
            ],
            "angle": 0,
            "content": "b)在这次考试中如果允许某些答案空缺，一个学生回答这些问题可能有多少种方式？"
        },
        {
            "type": "list",
            "bbox": [
                0.121,
                0.8,
                0.805,
                0.83
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.834,
                0.948,
                0.866
            ],
            "angle": 0,
            "content": "4. 某种商标的衬衫有 12 种颜色，有男式和女式 2 种样式，每种样式有 3 种大小型号。这些衬衫有多少种不同的类型？"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.868,
                0.948,
                0.9
            ],
            "angle": 0,
            "content": "5. 从纽约到丹佛有6条不同的航线，而从丹佛到旧金山有7条。如果选一个到丹佛的航班，接着选一个到旧金山的航班，那么从纽约经丹佛到旧金山的旅行有多少种不同的可能性？"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.903,
                0.948,
                0.935
            ],
            "angle": 0,
            "content": "6. 从波士顿到底特律有4条汽车主干线，而从底特律到洛杉矶有6条。那么从波士顿经底特律到洛杉矶的汽车主干线有多少条？"
        },
        {
            "type": "list",
            "bbox": [
                0.099,
                0.834,
                0.948,
                0.935
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.698,
                0.038,
                0.787,
                0.052
            ],
            "angle": 0,
            "content": "计数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.833,
                0.039,
                0.867,
                0.052
            ],
            "angle": 0,
            "content": "351"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.094,
                0.606,
                0.108
            ],
            "angle": 0,
            "content": "7. 如果用3个字母作为姓名的缩写，人们可以有多少种不同的选择？"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.112,
                0.568,
                0.126
            ],
            "angle": 0,
            "content": "8. 如果这3个字母不允许重复，人们可以有多少种不同的选择？"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.129,
                0.57,
                0.143
            ],
            "angle": 0,
            "content": "9. 如果这3个字母以A开始，人们又可以有多少种不同的选择？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.147,
                0.258,
                0.161
            ],
            "angle": 0,
            "content": "10.8位比特串有多少个？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.164,
                0.382,
                0.179
            ],
            "angle": 0,
            "content": "11. 首尾都是 1 的 10 位比特串有多少个？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.182,
                0.354,
                0.196
            ],
            "angle": 0,
            "content": "12. 位数不超过6的比特串有多少个？"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.2,
                0.63,
                0.214
            ],
            "angle": 0,
            "content": "13. 位数不超过 \\( n \\) 且全由 1 组成的比特串有多少个？这里的 \\( n \\) 是正整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.218,
                0.538,
                0.232
            ],
            "angle": 0,
            "content": "14. 首尾都是 1 的 \\( n \\) 位比特串有多少个？这里的 \\( n \\) 是正整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.235,
                0.558,
                0.25
            ],
            "angle": 0,
            "content": "15. 位数不超过4且由小写字母构成的串有多少个（不计空串）？"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.253,
                0.487,
                0.267
            ],
            "angle": 0,
            "content": "16. 由4个小写字母构成且含有字母 \\(x\\) 的串有多少个？"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.271,
                0.857,
                0.285
            ],
            "angle": 0,
            "content": "17. 由5个ASCII码构成且至少包含一个@字符的串有多少个？[注意：有128个不同的ASCII码。]"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.288,
                0.422,
                0.303
            ],
            "angle": 0,
            "content": "18. 有多少满足以下条件的5元素DNA序列？"
        },
        {
            "type": "list",
            "bbox": [
                0.05,
                0.094,
                0.857,
                0.303
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.08,
                0.306,
                0.182,
                0.321
            ],
            "angle": 0,
            "content": "a)由A结束"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.307,
                0.666,
                0.32
            ],
            "angle": 0,
            "content": "b)开始于T并结束于G"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.324,
                0.217,
                0.337
            ],
            "angle": 0,
            "content": "c)只包含A和T"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.324,
                0.568,
                0.337
            ],
            "angle": 0,
            "content": "d)不包含C"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.341,
                0.421,
                0.355
            ],
            "angle": 0,
            "content": "19. 有多少满足以下条件的6元素RNA序列？"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.359,
                0.177,
                0.373
            ],
            "angle": 0,
            "content": "a)不包含U"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.359,
                0.584,
                0.373
            ],
            "angle": 0,
            "content": "b)结束于GU"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.377,
                0.174,
                0.391
            ],
            "angle": 0,
            "content": "c)开始于C"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.377,
                0.631,
                0.391
            ],
            "angle": 0,
            "content": "d)只包含A或者U"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.394,
                0.622,
                0.409
            ],
            "angle": 0,
            "content": "20. 在5到31之间有多少个满足以下条件的正整数，这些整数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.412,
                0.193,
                0.427
            ],
            "angle": 0,
            "content": "a) 能被 3 整除"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.413,
                0.587,
                0.427
            ],
            "angle": 0,
            "content": "b) 能被 4 整除"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.43,
                0.266,
                0.444
            ],
            "angle": 0,
            "content": "c) 能被 3 和 4 同时整除"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.447,
                0.64,
                0.462
            ],
            "angle": 0,
            "content": "21. 在50到100之间有多少个满足以下条件的正整数，这些整数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.465,
                0.193,
                0.479
            ],
            "angle": 0,
            "content": "a) 能被 7 整除"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.465,
                0.596,
                0.479
            ],
            "angle": 0,
            "content": "b)能被11整除"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.483,
                0.275,
                0.497
            ],
            "angle": 0,
            "content": "c) 能被 7 和 11 同时整除"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.5,
                0.454,
                0.515
            ],
            "angle": 0,
            "content": "22. 有多少个小于 1000 的满足以下条件的正整数？"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.518,
                0.175,
                0.533
            ],
            "angle": 0,
            "content": "a)被7整除"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.519,
                0.688,
                0.533
            ],
            "angle": 0,
            "content": "b)被7整除但不被11整除"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.536,
                0.256,
                0.55
            ],
            "angle": 0,
            "content": "c)同时被7和11整除"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.536,
                0.614,
                0.55
            ],
            "angle": 0,
            "content": "d)被7或11整除"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.554,
                0.349,
                0.568
            ],
            "angle": 0,
            "content": "e)恰好被7或11中的一个数整除"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.554,
                0.74,
                0.568
            ],
            "angle": 0,
            "content": "f)既不被7整除，也不被11整除"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.572,
                0.23,
                0.586
            ],
            "angle": 0,
            "content": "g)含有不同的数字"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.572,
                0.698,
                0.586
            ],
            "angle": 0,
            "content": "h)含有不同的数字且是偶数"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.589,
                0.519,
                0.603
            ],
            "angle": 0,
            "content": "23. 在 100 到 999 之间包含多少个满足以下条件的正整数？"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.607,
                0.174,
                0.621
            ],
            "angle": 0,
            "content": "a)被7整除"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.608,
                0.549,
                0.621
            ],
            "angle": 0,
            "content": "b)是奇数"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.625,
                0.302,
                0.639
            ],
            "angle": 0,
            "content": "c)有相同的3个十进制数字"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.625,
                0.586,
                0.639
            ],
            "angle": 0,
            "content": "d)不被4整除"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.643,
                0.21,
                0.656
            ],
            "angle": 0,
            "content": "e)被3或4整除"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.643,
                0.657,
                0.656
            ],
            "angle": 0,
            "content": "f)不被3也不被4整除"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.66,
                0.284,
                0.674
            ],
            "angle": 0,
            "content": "g)被3整除但不被4整除"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.66,
                0.605,
                0.674
            ],
            "angle": 0,
            "content": "h)被3和4整除"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.677,
                0.538,
                0.691
            ],
            "angle": 0,
            "content": "24. 在 1000 到 9999 之间包含多少个满足以下条件的正整数？"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.695,
                0.174,
                0.709
            ],
            "angle": 0,
            "content": "a)被9整除"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.695,
                0.549,
                0.709
            ],
            "angle": 0,
            "content": "b)是偶数"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.713,
                0.265,
                0.727
            ],
            "angle": 0,
            "content": "c)有不同的十进制数字"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.713,
                0.585,
                0.727
            ],
            "angle": 0,
            "content": "d)不被3整除"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.731,
                0.209,
                0.744
            ],
            "angle": 0,
            "content": "e)被5或7整除"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.731,
                0.657,
                0.744
            ],
            "angle": 0,
            "content": "f)不被5也不被7整除"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.748,
                0.284,
                0.762
            ],
            "angle": 0,
            "content": "g)被5整除但不被7整除"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.748,
                0.605,
                0.762
            ],
            "angle": 0,
            "content": "h)被5和7整除"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.765,
                0.482,
                0.78
            ],
            "angle": 0,
            "content": "25. 有多少个串含有3个十进制数字且满足以下条件？"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.783,
                0.284,
                0.797
            ],
            "angle": 0,
            "content": "a)同一数字不能出现3次"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.783,
                0.622,
                0.797
            ],
            "angle": 0,
            "content": "b) 以奇数数字开始"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.801,
                0.242,
                0.815
            ],
            "angle": 0,
            "content": "c) 恰有 2 个数字是 4"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.818,
                0.482,
                0.833
            ],
            "angle": 0,
            "content": "26. 有多少个串含有 4 个十进制数字且满足以下条件？"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.836,
                0.266,
                0.85
            ],
            "angle": 0,
            "content": "a)同一数字不出现两次"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.836,
                0.622,
                0.85
            ],
            "angle": 0,
            "content": "b) 以偶数数字结束"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.854,
                0.242,
                0.867
            ],
            "angle": 0,
            "content": "c) 恰有 3 个数字是 9"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.871,
                0.893,
                0.903
            ],
            "angle": 0,
            "content": "27. 一个委员会由50个州的代表构成，每个州可从州长或两个参议员中选一个人参加，有多少种不同的方式？"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.906,
                0.666,
                0.921
            ],
            "angle": 0,
            "content": "28. 用3个数字后跟3个字母或者3个字母后跟3个数字可构成多少种车牌？"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.924,
                0.666,
                0.939
            ],
            "angle": 0,
            "content": "29. 用2个字母后跟4个数字或者2个数字后跟4个字母可构成多少种车牌？"
        },
        {
            "type": "list",
            "bbox": [
                0.05,
                0.871,
                0.893,
                0.939
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.145,
                0.037,
                0.182,
                0.051
            ],
            "angle": 0,
            "content": "352"
        },
        {
            "type": "header",
            "bbox": [
                0.227,
                0.036,
                0.292,
                0.051
            ],
            "angle": 0,
            "content": "第6章"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.092,
                0.738,
                0.107
            ],
            "angle": 0,
            "content": "30. 用3个字母后跟3个数字或者4个字母后跟2个数字可构成多少种车牌？"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.11,
                0.628,
                0.125
            ],
            "angle": 0,
            "content": "31. 用2个或3个字母后跟2个或3个数字可构成多少种车牌？"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.128,
                0.424,
                0.142
            ],
            "angle": 0,
            "content": "32. 由8个英语字母可构成多少个串？"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.145,
                0.321,
                0.159
            ],
            "angle": 0,
            "content": "a)如果字母可以重复"
        },
        {
            "type": "text",
            "bbox": [
                0.543,
                0.146,
                0.713,
                0.159
            ],
            "angle": 0,
            "content": "b)如果字母不能重复"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.163,
                0.415,
                0.177
            ],
            "angle": 0,
            "content": "c)如果字母可以重复且以X开始"
        },
        {
            "type": "text",
            "bbox": [
                0.544,
                0.163,
                0.81,
                0.177
            ],
            "angle": 0,
            "content": "d)如果字母不能重复且以X开始"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.181,
                0.471,
                0.194
            ],
            "angle": 0,
            "content": "e)如果字母可以重复且以X开始和结束"
        },
        {
            "type": "text",
            "bbox": [
                0.544,
                0.181,
                0.906,
                0.195
            ],
            "angle": 0,
            "content": "f)如果字母可以重复且以BO（按此次序）开始"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.198,
                0.571,
                0.212
            ],
            "angle": 0,
            "content": "g)如果字母可以重复且以BO(按此次序)开始和结束"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.216,
                0.573,
                0.23
            ],
            "angle": 0,
            "content": "h)如果字母可以重复且以BO(按此次序)开始或结束"
        },
        {
            "type": "list",
            "bbox": [
                0.148,
                0.145,
                0.906,
                0.23
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.234,
                0.424,
                0.248
            ],
            "angle": 0,
            "content": "33. 由8个英语字母可构成多少个串？"
        },
        {
            "type": "text",
            "bbox": [
                0.149,
                0.251,
                0.468,
                0.265
            ],
            "angle": 0,
            "content": "a)如果字母可以重复且不包含元音字母"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.269,
                0.469,
                0.283
            ],
            "angle": 0,
            "content": "b)如果字母不能重复且不包含元音字母"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.287,
                0.469,
                0.3
            ],
            "angle": 0,
            "content": "c)如果字母可以重复且以元音字母开始"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.304,
                0.47,
                0.318
            ],
            "angle": 0,
            "content": "d)如果字母不能重复且以元音字母开始"
        },
        {
            "type": "text",
            "bbox": [
                0.149,
                0.322,
                0.524,
                0.336
            ],
            "angle": 0,
            "content": "e)如果字母可以重复且包含至少一个元音字母"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.34,
                0.523,
                0.353
            ],
            "angle": 0,
            "content": "f)如果字母可以重复且包含恰好一个元音字母"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.357,
                0.622,
                0.371
            ],
            "angle": 0,
            "content": "g)如果字母可以重复且以X开始并至少包含一个元音字母"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.374,
                0.679,
                0.389
            ],
            "angle": 0,
            "content": "h)如果字母可以重复且以X开始和结束并至少包含一个元音字母"
        },
        {
            "type": "list",
            "bbox": [
                0.149,
                0.251,
                0.679,
                0.389
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.392,
                0.658,
                0.407
            ],
            "angle": 0,
            "content": "34. 从10元素集合到含有下述元素数的集合有多少个不同的函数？"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.41,
                0.185,
                0.423
            ],
            "angle": 0,
            "content": "a)2"
        },
        {
            "type": "text",
            "bbox": [
                0.346,
                0.41,
                0.378,
                0.423
            ],
            "angle": 0,
            "content": "b)3"
        },
        {
            "type": "text",
            "bbox": [
                0.541,
                0.411,
                0.571,
                0.423
            ],
            "angle": 0,
            "content": "c)4"
        },
        {
            "type": "text",
            "bbox": [
                0.734,
                0.411,
                0.765,
                0.423
            ],
            "angle": 0,
            "content": "d)5"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.427,
                0.648,
                0.442
            ],
            "angle": 0,
            "content": "35. 从 5 元素集合到含有下述元素数的集合有多少一对一的函数？"
        },
        {
            "type": "text",
            "bbox": [
                0.152,
                0.445,
                0.185,
                0.458
            ],
            "angle": 0,
            "content": "a)4"
        },
        {
            "type": "text",
            "bbox": [
                0.347,
                0.445,
                0.378,
                0.458
            ],
            "angle": 0,
            "content": "b)5"
        },
        {
            "type": "text",
            "bbox": [
                0.541,
                0.446,
                0.571,
                0.458
            ],
            "angle": 0,
            "content": "c)6"
        },
        {
            "type": "text",
            "bbox": [
                0.735,
                0.446,
                0.765,
                0.458
            ],
            "angle": 0,
            "content": "d)7"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.462,
                0.731,
                0.477
            ],
            "angle": 0,
            "content": "36. 从集合 \\(\\{1,2,\\dots ,n\\}\\) 到集合 \\(\\{0,1\\}\\) 有多少个函数？这里的 \\(n\\) 是正整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.48,
                0.859,
                0.495
            ],
            "angle": 0,
            "content": "37. 从集合 \\(\\{1,2,\\dots ,n\\}\\) 到集合 \\(\\{0,1\\}\\) 有多少个满足下列条件的函数？这里的 \\(n\\) 是正整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.498,
                0.248,
                0.511
            ],
            "angle": 0,
            "content": "a)一对一的"
        },
        {
            "type": "text",
            "bbox": [
                0.347,
                0.498,
                0.513,
                0.511
            ],
            "angle": 0,
            "content": "b)对1和 \\(n\\) 赋值为0"
        },
        {
            "type": "text",
            "bbox": [
                0.542,
                0.498,
                0.853,
                0.512
            ],
            "angle": 0,
            "content": "c)对恰好一个小于 \\(n\\) 的正整数赋值为1"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.515,
                0.724,
                0.53
            ],
            "angle": 0,
            "content": "38. 从5元素集合到含有下述元素数的集合有多少个部分函数（见2.3节）？"
        },
        {
            "type": "text",
            "bbox": [
                0.153,
                0.534,
                0.184,
                0.546
            ],
            "angle": 0,
            "content": "a)1"
        },
        {
            "type": "text",
            "bbox": [
                0.347,
                0.534,
                0.378,
                0.546
            ],
            "angle": 0,
            "content": "b)2"
        },
        {
            "type": "text",
            "bbox": [
                0.542,
                0.535,
                0.571,
                0.546
            ],
            "angle": 0,
            "content": "c)5"
        },
        {
            "type": "text",
            "bbox": [
                0.735,
                0.535,
                0.765,
                0.546
            ],
            "angle": 0,
            "content": "d)9"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.55,
                0.92,
                0.565
            ],
            "angle": 0,
            "content": "39. 从 \\( m \\) 元素集合到 \\( n \\) 元素集合有多少个部分函数（见2.3节的定义13）？这里的 \\( m \\) 和 \\( n \\) 是正整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.568,
                0.543,
                0.582
            ],
            "angle": 0,
            "content": "40.100 个元素的集合有多少个子集的元素数多于 1?"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.586,
                0.969,
                0.617
            ],
            "angle": 0,
            "content": "41. 如果一个字符串反转后所得结果与原来的字符串一样，就称它是一个回文。有多少个长为 \\( n \\) 的比特串是回文？"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.621,
                0.496,
                0.635
            ],
            "angle": 0,
            "content": "42. 有多少满足以下条件的 4 元素 DNA 序列？"
        },
        {
            "type": "text",
            "bbox": [
                0.153,
                0.639,
                0.288,
                0.652
            ],
            "angle": 0,
            "content": "a)不包含碱基T"
        },
        {
            "type": "text",
            "bbox": [
                0.544,
                0.639,
                0.683,
                0.652
            ],
            "angle": 0,
            "content": "b)包含序列ACG"
        },
        {
            "type": "text",
            "bbox": [
                0.153,
                0.656,
                0.446,
                0.669
            ],
            "angle": 0,
            "content": "c)包含所有4种碱基A、T、C和G"
        },
        {
            "type": "text",
            "bbox": [
                0.544,
                0.657,
                0.93,
                0.67
            ],
            "angle": 0,
            "content": "d)只包含4种碱基A、T、C和G中的3种碱基"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.673,
                0.496,
                0.687
            ],
            "angle": 0,
            "content": "43. 有多少满足以下条件的 4 元素 RNA 序列？"
        },
        {
            "type": "text",
            "bbox": [
                0.153,
                0.691,
                0.271,
                0.705
            ],
            "angle": 0,
            "content": "a)碱基包含U"
        },
        {
            "type": "text",
            "bbox": [
                0.544,
                0.692,
                0.703,
                0.705
            ],
            "angle": 0,
            "content": "b)不包含序列CUG"
        },
        {
            "type": "text",
            "bbox": [
                0.153,
                0.709,
                0.466,
                0.722
            ],
            "angle": 0,
            "content": "c)不包含所有4种碱基A、U、C和G"
        },
        {
            "type": "text",
            "bbox": [
                0.544,
                0.709,
                0.914,
                0.723
            ],
            "angle": 0,
            "content": "d)只包含4种碱基A、U、C和G中两种碱基"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.726,
                0.969,
                0.759
            ],
            "angle": 0,
            "content": "44. 某月有22个工作日，一家初创公司每个工作日都给每名员工发送一份公司通讯。如果一共发送了4642份公司通讯，则这家公司有多少员工？假设这个月没有人员变动。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.762,
                0.969,
                0.794
            ],
            "angle": 0,
            "content": "45. 某大学有 434 名大一学生、883 名大二学生和 43 名大三学生注册了算法导论课程。如果一个班只能安排 34 名学生，那么这门课需要安排多少个班才能保障所有注册的学生都能上这门课？"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.797,
                0.969,
                0.828
            ],
            "angle": 0,
            "content": "46. 一组10个人选取4人坐在4人的圆桌旁边，一共有多少种坐法？当每个人左右邻座都相同时算为同一种坐法。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.832,
                0.969,
                0.864
            ],
            "angle": 0,
            "content": "47.6个人坐在一个圆桌旁边，一共有多少种坐法？当每一个人有相同邻座而不考虑左右算为同一种会坐法。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.867,
                0.969,
                0.899
            ],
            "angle": 0,
            "content": "48.在一个婚礼上摄影师从10个人中安排6个人在一排拍照，其中新娘和新郎也在这10个人中，如果满足下述条件，有多少种安排方式？"
        },
        {
            "type": "text",
            "bbox": [
                0.153,
                0.902,
                0.326,
                0.916
            ],
            "angle": 0,
            "content": "a)新娘必须在照片中"
        },
        {
            "type": "text",
            "bbox": [
                0.546,
                0.903,
                0.789,
                0.917
            ],
            "angle": 0,
            "content": "b)新娘和新郎必须都在照片中"
        },
        {
            "type": "text",
            "bbox": [
                0.155,
                0.92,
                0.437,
                0.934
            ],
            "angle": 0,
            "content": "c)新娘和新郎恰好有一人在照片中"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.694,
                0.037,
                0.782,
                0.051
            ],
            "angle": 0,
            "content": "计数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.828,
                0.038,
                0.864,
                0.05
            ],
            "angle": 0,
            "content": "353"
        },
        {
            "type": "text",
            "bbox": [
                0.044,
                0.092,
                0.893,
                0.125
            ],
            "angle": 0,
            "content": "49.在一个婚礼上摄影师安排6个人在一排拍照，包含新娘和新郎在内，如果满足下述条件，有多少种安排方式？"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.128,
                0.264,
                0.142
            ],
            "angle": 0,
            "content": "a)新娘必须在新郎旁边"
        },
        {
            "type": "text",
            "bbox": [
                0.465,
                0.128,
                0.635,
                0.142
            ],
            "angle": 0,
            "content": "b)新娘不在新郎旁边"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.146,
                0.321,
                0.159
            ],
            "angle": 0,
            "content": "c)新娘在新郎左边的某个位置"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.163,
                0.5,
                0.177
            ],
            "angle": 0,
            "content": "50. 有多少个7位比特串以2个0开始或以3个1结束？"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.181,
                0.509,
                0.195
            ],
            "angle": 0,
            "content": "51. 有多少个 10 位比特串以 3 个 0 开始或以 2 个 0 结束？"
        },
        {
            "type": "text",
            "bbox": [
                0.031,
                0.199,
                0.56,
                0.213
            ],
            "angle": 0,
            "content": "* 52. 有多少个 10 位比特串包含 5 个连续的 0 或者 5 个连续的 1?"
        },
        {
            "type": "text",
            "bbox": [
                0.023,
                0.217,
                0.552,
                0.231
            ],
            "angle": 0,
            "content": "** 53. 有多少个8位比特串包含3个连续的0或者4个连续的1？"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.234,
                0.896,
                0.284
            ],
            "angle": 0,
            "content": "54. 离散数学班的每个学生都是计算机科学或数学专业的，或者是同时修这两个专业的。如果有38个人是计算机科学专业的（包含同时修两个专业的），23个人是数学专业的（包含同时修两个专业的），7个人是同时修两个专业的，那么这个班有多少个学生？"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.287,
                0.464,
                0.302
            ],
            "angle": 0,
            "content": "55. 有多少个不超过100的正整数能被4或6整除？"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.305,
                0.896,
                0.337
            ],
            "angle": 0,
            "content": "56.如果一个人最少有2个、最多有5个不同的姓名首字母，那么他能有多少个不同的姓名首字母呢？假定每个姓名首字母都取自26个英文字母。"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.34,
                0.896,
                0.372
            ],
            "angle": 0,
            "content": "57. 假定一个计算机系统的口令最少有 8 个、最多有 12 个字符，其中口令中的每个字符可以是小写英文字母、大写英文字母、数字或 6 个特殊字符（*、>、<、!、+、=）中的一个。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.376,
                0.427,
                0.39
            ],
            "angle": 0,
            "content": "a)该计算机系统可以有多少个不同的口令？"
        },
        {
            "type": "text",
            "bbox": [
                0.469,
                0.376,
                0.835,
                0.39
            ],
            "angle": 0,
            "content": "b)有多少个口令含有6个特殊字符中的一个？"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.393,
                0.872,
                0.407
            ],
            "angle": 0,
            "content": "c)如果一个黑客核对每个可能的口令需要1纳秒时间，他要核对完所有可能的口令需要多少时间？"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.411,
                0.898,
                0.461
            ],
            "angle": 0,
            "content": "58. 在 C 程序设计语言中的变量名是一个字符串，可以包含大写字母、小写字母、数字或下划线。此外，字符串的第一个字符必须是字母（大写或小写字母）或下划线。如果一个变量名由它的前 8 个字符确定，那么在 C 语言中可以命名多少个不同的变量？（注意：变量名包含的字符数可以少于 8 个）。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.464,
                0.898,
                0.496
            ],
            "angle": 0,
            "content": "59. Java 程序设计语言中的变量名是一个长度从 1 到 65535 的字符串，可包含大、小写字母、美元符号、下划线或者数字，第一个字符不能是数字。那么在 Java 语言中可以命名多少个不同的变量？"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.499,
                0.898,
                0.531
            ],
            "angle": 0,
            "content": "60. 国际电信联盟(ITU)规定一个电话号码包含国家编码为1到3的数字，0不能为国家编码，接着是最多15位数字的号码，满足这种规定的电话号码一共有多少个？"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.535,
                0.898,
                0.584
            ],
            "angle": 0,
            "content": "61. 假定在将来的某个时间世界上的每部电话将被分配一个号码，这个号码包含一个 1 到 3 位数字的形如 \\( X \\)、\\( XX \\) 或 \\( XXX \\) 的国家代码，后面跟随着一个 10 位数字的形如 \\( NXX-NXX-XXXX \\) 的电话号码（如例 8 所描述的）。在这个编码计划中，全世界将有多少个不同的有效电话号码？"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.587,
                0.898,
                0.62
            ],
            "angle": 0,
            "content": "62. 维吉尼亚密码系统中密码是一个英文字母串，大小写无关。在这个密码系统中有多少长度为3、4、5，或者6个字母的不同密码？"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.623,
                0.898,
                0.655
            ],
            "angle": 0,
            "content": "63. 用于Wi-Fi(无线保真)网络的有线等效保密(WEP)协议的密码是一个或者10、26，或者58位的十六进制数字串，一共能有多少种这样的密码？"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.658,
                0.774,
                0.673
            ],
            "angle": 0,
            "content": "64. 设 \\( p \\) 和 \\( q \\) 都是素数，\\( n = pq \\)。使用容斥原理计算不超过 \\( n \\) 并与 \\( n \\) 互素的正整数的个数。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.676,
                0.68,
                0.69
            ],
            "angle": 0,
            "content": "65. 使用容斥原理计算小于 1000000 且不能被 4 或者 6 整除的正整数的个数。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.693,
                0.504,
                0.707
            ],
            "angle": 0,
            "content": "66. 使用树图找出不含3个连续0的4位比特串的个数。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.711,
                0.664,
                0.725
            ],
            "angle": 0,
            "content": "67. 有多少种不同的方式排列字母 a、b、c 和 d，使得 b 不紧跟在 a 的后边？"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.728,
                0.838,
                0.743
            ],
            "angle": 0,
            "content": "68. 使用树图找出世界职业棒球大赛可能出现的方式数，其中7场中先胜4场的队赢得这个比赛。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.746,
                0.703,
                0.761
            ],
            "angle": 0,
            "content": "69. 使用树图确定 \\(\\{3, 7, 9, 11, 24\\}\\) 的子集数，使得子集中的元素之和小于 28。"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.764,
                0.902,
                0.832
            ],
            "angle": 0,
            "content": "70. a) 假设一个商店出售 6 种不同的软饮料：可乐、姜汁茶、橙汁、乐啤露、柠檬茶和奶油苏打。所有品种的瓶装饮料都有 12 盎司规格的。除了柠檬茶外，其他品种都有 20 盎司规格的。只有可乐和姜汁茶有 32 盎司规格的。除了柠檬茶和奶油苏打以外，其他品种都有 64 盎司规格的。如果这个商店要具有所有品种和规格的饮料，使用树图确定它必须库存多少瓶不同的饮料？"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.835,
                0.356,
                0.849
            ],
            "angle": 0,
            "content": "b)使用计数原理回答a中的问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.852,
                0.902,
                0.902
            ],
            "angle": 0,
            "content": "71. a)假设运动鞋的流行式样对男女都适用。女鞋的大小号码是6、7、8、9，男鞋的大小号码是8、9、10、11和12。男鞋有白色和黑色，而女鞋是白色、红色和黑色。如果一个商店各种大小和颜色的男、女运动鞋必须至少存一双，用树图确定所需要的鞋的数目。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.905,
                0.356,
                0.919
            ],
            "angle": 0,
            "content": "b)使用计数原理回答a中的问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.923,
                0.902,
                0.937
            ],
            "angle": 0,
            "content": "72. 确定有 \\( n \\) 个选手参加的淘汰赛的比赛场次数。淘汰赛的规则是每一场比赛有两名选手参加，胜者晋"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.136,
                0.038,
                0.172,
                0.052
            ],
            "angle": 0,
            "content": "354"
        },
        {
            "type": "header",
            "bbox": [
                0.218,
                0.037,
                0.284,
                0.052
            ],
            "angle": 0,
            "content": "第6章"
        },
        {
            "type": "text",
            "bbox": [
                0.138,
                0.094,
                0.264,
                0.108
            ],
            "angle": 0,
            "content": "级，败者淘汰。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.111,
                0.956,
                0.144
            ],
            "angle": 0,
            "content": "73. 确定有 \\( n \\) 个选手参加的双败淘汰赛的比赛场次数的最小值和最大值。双败淘汰赛规则是每一场比赛有两名选手参加，胜者晋级，仅失败一场的选手晋级。"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.15,
                0.664,
                0.165
            ],
            "angle": 0,
            "content": "* 74. 使用乘积法则证明对于 \\( n \\) 个变量的命题存在 \\( 2^{2^n} \\) 个不同的真值表。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.168,
                0.714,
                0.183
            ],
            "angle": 0,
            "content": "75. 使用数学归纳法从两个任务的求和法则证明关于 \\(m\\) 个任务的求和法则。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.186,
                0.714,
                0.2
            ],
            "angle": 0,
            "content": "76. 使用数学归纳法从两个任务的乘积法则证明关于 \\(m\\) 个任务的乘积法则。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.203,
                0.955,
                0.236
            ],
            "angle": 0,
            "content": "77. 具有 \\(n\\) 条边的凸多边形有多少条对角线？（如果在多边形内或边界的每两个顶点的连线完全在这个集合内，则称为凸多边形）。"
        },
        {
            "type": "text",
            "bbox": [
                0.105,
                0.239,
                0.956,
                0.36
            ],
            "angle": 0,
            "content": "78. 因特网中的数据以数据报传输，数据报是由比特数据块构成的。每个数据报包含有头信息和数据区。头信息最多分成14个不同的字段（详细说明许多事项，包括发送和接收地址），数据区包含被传输的实际数据。14个头信息字段中有一个头长度字段（表示为HLEN），根据协议规定是4比特，它说明了以32比特为一个数据块的头信息的长度。例如，如果 \\(\\mathrm{HLEN} = 0110\\) ，那么头信息由6个32比特的数据块构成。14个头信息字段中的另一个字段是16比特的总长度字段（表示为TOTAL LENGTH），它说明了以比特为单位的整个数据报（包含头信息和数据区在内）的总长度。数据区的长度是数据报的总长度减去头的长度。"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.363,
                0.954,
                0.395
            ],
            "angle": 0,
            "content": "a)TOTAL LENGTH的最大值(16比特长)确定了因特网数据报以字节(8比特的数据块)为单位的最大总长度。这个值是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.398,
                0.955,
                0.431
            ],
            "angle": 0,
            "content": "b) HLEN 的最大值 (4 比特长) 确定了头信息以 32 比特数据块为单位的最大总长度, 这个值是多少? 以字节为单位的最大的头信息的总长度是多少?"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.434,
                0.939,
                0.448
            ],
            "angle": 0,
            "content": "c)最小的(最常见的)头长度是20字节。因特网数据报的数据区以字节为单位的最大总长度是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.135,
                0.452,
                0.903,
                0.466
            ],
            "angle": 0,
            "content": "d)如果头长度是20字节并且总长度尽可能地长，那么在数据区可以传输多少个不同的字节串？"
        },
        {
            "type": "list",
            "bbox": [
                0.105,
                0.111,
                0.956,
                0.466
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.105,
                0.481,
                0.281,
                0.5
            ],
            "angle": 0,
            "content": "6.2 鸽巢原理"
        },
        {
            "type": "title",
            "bbox": [
                0.105,
                0.508,
                0.234,
                0.525
            ],
            "angle": 0,
            "content": "6.2.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.528,
                0.956,
                0.622
            ],
            "angle": 0,
            "content": "有20只鸽子要飞往19个鸽巢栖息。由于有20只鸽子，而只有19个鸽巢，所以这19个鸽巢中至少有1个鸽巢里最少栖息着2只鸽子。为了说明这个结论是真的，注意如果每个鸽巢中最多栖息1只鸽子，那么最多只有19只鸽子有住处，其中每只鸽子一个巢。这个例子阐述了一个一般原理，叫作鸽巢原理。该原理断言：如果鸽子数比鸽巢数多，那么一定有一个鸽巢里至少有2只鸽子（见图1）。当然，这个原理除了鸽子和鸽巢外也可以用于其他对象。"
        },
        {
            "type": "image",
            "bbox": [
                0.164,
                0.63,
                0.393,
                0.774
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.271,
                0.784,
                0.291,
                0.795
            ],
            "angle": 0,
            "content": "a)"
        },
        {
            "type": "image",
            "bbox": [
                0.418,
                0.63,
                0.645,
                0.774
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.527,
                0.783,
                0.547,
                0.795
            ],
            "angle": 0,
            "content": "b）"
        },
        {
            "type": "image",
            "bbox": [
                0.671,
                0.63,
                0.898,
                0.774
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.777,
                0.783,
                0.797,
                0.795
            ],
            "angle": 0,
            "content": "c）"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.446,
                0.805,
                0.614,
                0.821
            ],
            "angle": 0,
            "content": "图1鸽子比鸽巢多"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.849,
                0.943,
                0.886
            ],
            "angle": 0,
            "content": "定理1鸽巢原理如果 \\(k + 1\\) 个或更多的物体放入 \\(k\\) 个盒子，那么至少有一个盒子包含了2个或更多的物体。"
        },
        {
            "type": "text",
            "bbox": [
                0.104,
                0.895,
                0.951,
                0.93
            ],
            "angle": 0,
            "content": "证明 假定 \\(k\\) 个盒子中没有一个盒子包含的物体多于1个，那么物体总数至多是 \\(k\\) ，这与至少有 \\(k + 1\\) 个物体矛盾。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.71,
                0.039,
                0.796,
                0.053
            ],
            "angle": 0,
            "content": "计数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.845,
                0.04,
                0.879,
                0.053
            ],
            "angle": 0,
            "content": "355"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.095,
                0.909,
                0.169
            ],
            "angle": 0,
            "content": "鸽巢原理也叫作狄利克雷抽屉原理，以19世纪的德国数学家狄利克雷的名字命名，他经常在工作中使用这个原理。（狄利克雷不是第一个使用这个原理的人。至少有两个巴黎人用有相同数量的头发的事例说明这个原理的可追溯到17世纪，见练习35。）这是对我们前几章中证明方法的一个重要补充。我们在这一章介绍它，因为它在组合学中有许多重要应用。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.172,
                0.71,
                0.189
            ],
            "angle": 0,
            "content": "我们将说明鸽巢原理的有用性。我们首先证明关于函数的一个推论。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.198,
                0.9,
                0.235
            ],
            "angle": 0,
            "content": "推论1 一个从有 \\(k + 1\\) 甚至更多个元素的集合到 \\(k\\) 个元素的集合的函数 \\(f\\) 不是一对一函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.244,
                0.908,
                0.3
            ],
            "angle": 0,
            "content": "证明 设函数 \\(f\\) 陪域中的每一个元素 \\(y\\) 都有一个盒子，包含了定义域中满足 \\(f(x) = y\\) 的 \\(x\\)。因为定义域有 \\(k + 1\\) 或者更多个元素，而陪域只有 \\(k\\) 个元素，所以由鸽巢原理可知这些盒子中有一个包含了定义域中2个或者更多的 \\(x\\) 元素。这说明 \\(f\\) 不是一对一函数。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.303,
                0.411,
                0.319
            ],
            "angle": 0,
            "content": "例 \\(1\\sim 3\\) 说明了怎样使用鸽巢原理。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.325,
                0.863,
                0.342
            ],
            "angle": 0,
            "content": "例1 在一组367个人中一定至少有2个人有相同的生日，这是由于只有366个可能的生日。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.35,
                0.906,
                0.39
            ],
            "angle": 0,
            "content": "例2 在27个英文单词中一定至少有2个单词以同一个字母开始，因为英文字母表中只有26个字母。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.396,
                0.906,
                0.435
            ],
            "angle": 0,
            "content": "例3如果考试的分数是从0到100，班上必须有多少个学生才能保证在这次期末考试中至少有2个学生得到相同的分数？"
        },
        {
            "type": "list",
            "bbox": [
                0.062,
                0.325,
                0.906,
                0.435
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.438,
                0.906,
                0.474
            ],
            "angle": 0,
            "content": "解 期末考试有101个分数。鸽巢原理证明在102个学生中一定至少有2个学生具有相同的分数。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.476,
                0.906,
                0.512
            ],
            "angle": 0,
            "content": "鸽巢原理在许多证明中都是有用的工具，有些证明结果是令人意外的，正如例4所给出的。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.518,
                0.893,
                0.535
            ],
            "angle": 0,
            "content": "例4 证明：对每个整数 \\(n\\) ，存在一个数是 \\(n\\) 的倍数且在它的十进制表示中只出现0和1。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.541,
                0.908,
                0.616
            ],
            "angle": 0,
            "content": "解 令 \\(n\\) 是正整数。考虑 \\(n\\) 个整数1，11，111，…，11…1（在这个表中，最后一个整数的十进制表示中具有 \\(n + 1\\) 个1）。注意当一个整数被 \\(n\\) 整除时存在 \\(n\\) 个可能的余数。因为这个表中有 \\(n + 1\\) 个整数，由鸽巢原理，必有两个整数在除以 \\(n\\) 时有相同的余数。这两个整数之差的十进制表示中只含有0和1，且它能被 \\(n\\) 整除。"
        },
        {
            "type": "title",
            "bbox": [
                0.064,
                0.627,
                0.277,
                0.644
            ],
            "angle": 0,
            "content": "6.2.2 广义鸽巢原理"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.647,
                0.908,
                0.703
            ],
            "angle": 0,
            "content": "鸽巢原理指出当物体比盒子多时一定至少有2个物体在同一个盒子里。但是当物体数超过盒子数的倍数时可以得出更多的结果。例如，在任意21个十进制数字中一定有3个是相同的。这是由于21个物体被分配到10个盒子里，那么某个盒子的物体一定多于2个。"
        },
        {
            "type": "title",
            "bbox": [
                0.064,
                0.712,
                0.105,
                0.727
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.064,
                0.745,
                0.201,
                0.856
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.064,
                0.86,
                0.205,
                0.879
            ],
            "angle": 0,
            "content": "©INTERFOTO/Alamy Stock Photo"
        },
        {
            "type": "text",
            "bbox": [
                0.218,
                0.745,
                0.908,
                0.902
            ],
            "angle": 0,
            "content": "G.L.狄利克雷(G.LejenueDirichlet，1805—1859）狄利克雷出生在德国科隆附近的一个比利时家庭。他的父亲是一位邮政局长。狄利克雷在年轻时对数学感兴趣。他12岁在波恩读中学时，就将所有零用钱用在买数学书上。14岁时，他进入科隆耶稣会学院，16岁时，他开始在巴黎大学学习。1825年，他回到德国，在布雷斯劳大学获得一个职位。1828年他转到柏林大学。1855年，在哥廷根大学他当选为高斯的接替者。据说狄利克雷是第一个掌握高斯《算术研究》（DisquisitionesArithmeticae）一书的人，是提前20年出现的人。据说他总是将这本书带在身边，甚至在他旅行的时候。狄利克雷在数论方面有许多重要发现，包括定理“当 \\(a\\) 、 \\(b\\) 互素条件下，在 \\(an + b\\) 算术级数中有无限多的素数”。他证明了 \\(n = 5\\) 时的费马大定理，即方程 \\(x^{5} + y^{5} = z^{5}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.905,
                0.906,
                0.937
            ],
            "angle": 0,
            "content": "没有非平凡整数解。狄利克雷在数学分析方面也做出了许多贡献。狄利克雷被认为是一位能非常清晰地解释想法的优秀教师。他娶了作曲家菲利克斯·门德尔松的姐妹之一——丽贝卡·门德尔松。"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.922,
                0.517,
                0.984,
                0.533
            ],
            "angle": 0,
            "content": "Extra Examples"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.134,
                0.037,
                0.171,
                0.052
            ],
            "angle": 0,
            "content": "356"
        },
        {
            "type": "header",
            "bbox": [
                0.215,
                0.036,
                0.28,
                0.052
            ],
            "angle": 0,
            "content": "第6章"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.099,
                0.941,
                0.136
            ],
            "angle": 0,
            "content": "定理2广义鸽巢原理 如果 \\(N\\) 个物体放入 \\(k\\) 个盒子，那么至少有一个盒子包含了至少 \\([N / k]\\) 个物体。"
        },
        {
            "type": "text",
            "bbox": [
                0.148,
                0.144,
                0.799,
                0.161
            ],
            "angle": 0,
            "content": "证明 假定没有盒子包含了比 \\(\\lceil N / k\\rceil -1\\) 多的物体，那么物体总数至多是"
        },
        {
            "type": "equation",
            "bbox": [
                0.368,
                0.165,
                0.697,
                0.198
            ],
            "angle": 0,
            "content": "\\[\nk \\left(\\left\\lceil \\frac {N}{k} \\right\\rceil - 1\\right) <   k \\left(\\left(\\frac {N}{k} + 1\\right) - 1\\right) = N\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.108,
                0.203,
                0.704,
                0.219
            ],
            "angle": 0,
            "content": "这里用到不等式 \\(\\lceil N / k\\rceil <  (N / k) + 1\\) 。这与存在总数 \\(N\\) 个物体矛盾。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.222,
                0.955,
                0.315
            ],
            "angle": 0,
            "content": "一类普遍的问题是，把一些物体分到 \\(k\\) 个盒子中，使得某个盒子至少含有 \\(r\\) 个物体，求这些物体的最少个数。当有 \\(N\\) 个物体时，广义鸽巢原理告诉我们，只要 \\(\\lceil N / k\\rceil \\geqslant r\\) ，一定有 \\(r\\) 个物体在同一个盒子里。满足 \\(N / k > r - 1\\) 的最小正整数，即 \\(N = k(r - 1) + 1\\) ，是满足不等式 \\(\\lceil N / k\\rceil \\geqslant r\\) 的最小正整数。还可能有更小的 \\(N\\) 值吗？答案是没有，因为如果我们有 \\(k(r - 1)\\) 个物体，我们就可以在 \\(k\\) 个盒子的每个盒子中放 \\(r - 1\\) 个物体，因此没有一个盒子至少有 \\(r\\) 个物体。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.318,
                0.955,
                0.373
            ],
            "angle": 0,
            "content": "当思考这种问题时，下面的想法是有用的，就是在不断地放物体时怎样避免一个盒子至少有 \\(r\\) 个物体出现。为避免把第 \\(r\\) 个物体放到任何一个盒子里，每个盒子最终将以具有 \\(r - 1\\) 个物体结束。如果不允许将第 \\(r\\) 个物体放到盒子里，就没有办法增加下一个物体。"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.375,
                0.502,
                0.392
            ],
            "angle": 0,
            "content": "例 \\(5\\sim 8\\) 说明了怎样使用广义鸽巢原理。"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.397,
                0.682,
                0.414
            ],
            "angle": 0,
            "content": "例5 在100个人中至少有 \\(\\lceil 100 / 12\\rceil = 9\\) 个人生在同一个月。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.422,
                0.955,
                0.46
            ],
            "angle": 0,
            "content": "例6如果有5个可能的成绩A、B、C、D和F，那么在一个离散数学班里最少有多少个学生才能保证至少6个学生得到相同的分数？"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.463,
                0.957,
                0.537
            ],
            "angle": 0,
            "content": "解 为保证至少6个学生得到相同的分数，需要的最少学生数是使得 \\(\\lceil N / 5\\rceil = 6\\) 的最小整数 \\(N\\) 。这样的最小整数是 \\(N = 5\\cdot 5 + 1 = 26\\) 。如果只有25个学生，可能是5个学生得到同样的分数，而没有6个学生得到同样的分数。于是，26是保证至少6个学生得到相同分数所需的最少学生数。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.542,
                0.955,
                0.581
            ],
            "angle": 0,
            "content": "例7 a)从一副标准的52张牌中必须选多少张牌才能保证选出的牌中至少有3张是同样的花色？"
        },
        {
            "type": "text",
            "bbox": [
                0.15,
                0.584,
                0.68,
                0.599
            ],
            "angle": 0,
            "content": "b) 必须选多少张牌才能保证选出的牌中至少有 3 张是红心？"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.602,
                0.959,
                0.714
            ],
            "angle": 0,
            "content": "解 a)假设存在4个盒子保存4种花色的牌，选中的牌放在同种花色的盒子里。使用广义鸽巢原理，如果选了 \\(N\\) 张牌，那么至少有一个盒子含有至少 \\(\\lceil N / 4\\rceil\\) 张牌。因此如果 \\(\\lceil N / 4\\rceil \\geqslant 3\\) ，我们知道至少选了3张同种花色的牌。使得 \\(\\lceil N / 4\\rceil \\geqslant 3\\) 的最小的整数 \\(N\\) 是 \\(N = 2\\cdot 4 + 1 = 9\\) ，所以9张牌就足够了。注意如果选8张牌，可能每种花色2张牌，因此必须选9张牌才能保证选出的牌中至少3张是同样的花色。想到这一点的一个好方法就是，注意到在选了8张牌以后没有办法避免出现3张同样花色的牌。"
        },
        {
            "type": "text",
            "bbox": [
                0.11,
                0.717,
                0.959,
                0.772
            ],
            "angle": 0,
            "content": "b)我们不用广义鸽巢原理回答这个问题，因为我们要保证存在3张红心而不仅仅是3张同样花色的牌。在最坏情况下，在选一张红心以前可能已经选了所有的黑桃、方块、梅花，总共39张牌，下面选的3张牌将都是红心。因此为得到3张红心，可能需要选42张牌。"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.777,
                0.96,
                0.835
            ],
            "angle": 0,
            "content": "例8 为保证一个州的2500万个电话有不同的10位电话号码，所需的地区代码的最小数是多少？（假定电话号码是NXX-NXX-XXXX形式，其中前3位是地区代码，N表示从2到9的十进制数字，X表示任何十进制数字。）"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.837,
                0.959,
                0.892
            ],
            "angle": 0,
            "content": "解有800万个形如NXX-XXXX的不同的电话号码（如6.1节的例8所示）。因此，由广义鸽巢原理，在2500万个电话号码中，一定至少有[2500000/8000000]个同样的电话号码。因此至少需要4个地区代码来保证所有的10位号码是不同的。"
        },
        {
            "type": "text",
            "bbox": [
                0.154,
                0.894,
                0.682,
                0.911
            ],
            "angle": 0,
            "content": "尽管例9没有用到广义鸽巢原理，但也用到了类似的原理。"
        },
        {
            "type": "text",
            "bbox": [
                0.154,
                0.916,
                0.96,
                0.934
            ],
            "angle": 0,
            "content": "例9 假设计算机科学实验室有15台工作站和10台服务器。可以用一条电缆直接把工作"
        },
        {
            "type": "image",
            "bbox": [
                0.034,
                0.419,
                0.097,
                0.437
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.701,
                0.042,
                0.79,
                0.056
            ],
            "angle": 0,
            "content": "计数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.836,
                0.043,
                0.871,
                0.056
            ],
            "angle": 0,
            "content": "357"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.097,
                0.904,
                0.171
            ],
            "angle": 0,
            "content": "站连接到服务器。同一时刻只有一条到服务器的直接连接是有效的。我们想保证在任何时刻任何一组不超过10台工作站可以通过直接连接同时访问不同的服务器。尽管我们可以通过将每台工作站直接连接到每台服务器(使用150条连线)来做到这一点，但达到这个目标所需要的最少直接连线的数目是多少？"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.174,
                0.905,
                0.309
            ],
            "angle": 0,
            "content": "解 将工作站标记为 \\(W_{1}\\), \\(W_{2}\\), \\(\\cdots\\), \\(W_{15}\\), 服务器标记为 \\(S_{1}\\), \\(S_{2}\\), \\(\\cdots\\), \\(S_{10}\\) 。假设对于 \\(k = 1, 2, \\cdots, 10\\) ，我们连接 \\(W_{k}\\) 到 \\(S_{k}\\)，并且 \\(W_{11} 、 W_{12} 、 W_{13} 、 W_{14}\\) 和 \\(W_{15}\\) 中的每个工作站都连接到所有的10台服务器。总共 \\(10 + 5 \\cdot 10 = 60\\) 条直接连线。显然，在任何时刻，任何一组不超过10台工作站可以通过直接连接同时访问不同的服务器。为看到这一点只要注意下述事实：如果这个组包含工作站 \\(W_{j}(1 \\leqslant j \\leqslant 10)\\)，那么 \\(W_{j}\\) 可以访问服务器 \\(S_{j}\\) 。对于组里的每台工作站 \\(W_{k}(k \\geqslant 11)\\)，一定存在不在组里的工作站 \\(W_{j}(1 \\leqslant j \\leqslant 10)\\) 与之对应，因此 \\(W_{k}\\) 可以访问服务器 \\(S_{j}\\) （这是由于存在多少台不在组里的工作站 \\(W_{j}\\)，\\(1 \\leqslant j \\leqslant 10\\)，至少存在同样多台的服务器 \\(S_{j}\\) 可以被其他工作站访问）。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.31,
                0.904,
                0.386
            ],
            "angle": 0,
            "content": "现在假设在工作站和服务器之间直接连线少于60条。那么某台服务器将至多连接 \\(\\lfloor 59 / 10\\rfloor =\\) 5台工作站。（如果所有的服务器连接到至少6台工作站，那么将存在至少 \\(6\\cdot 10 = 60\\) 条直接连线。）这意味着剩下的9台服务器对于其他10台工作站同时访问不同的服务器就不够用了。因此，至少需要60条直接连线，从而得到答案是60。"
        },
        {
            "type": "title",
            "bbox": [
                0.059,
                0.395,
                0.387,
                0.413
            ],
            "angle": 0,
            "content": "6.2.3 鸽巢原理的几个简单应用"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.416,
                0.904,
                0.451
            ],
            "angle": 0,
            "content": "在鸽巢原理的许多有趣应用中，必须用某种巧妙的方式选择放入盒子中的物体。下面将描述这样的一些应用。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.457,
                0.904,
                0.496
            ],
            "angle": 0,
            "content": "例10 在30天的一个月里，某棒球队一天至少打一场比赛，但至多打45场。证明一定有连续的若干天内这个队恰好打了14场。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.498,
                0.905,
                0.554
            ],
            "angle": 0,
            "content": "解 令 \\(a_{j}\\) 是在这个月的第 \\(j\\) 天或第 \\(j\\) 天之前所打的场数。则 \\(a_{1}, a_{2}, \\cdots, a_{30}\\) 是不同正整数的一个递增序列，其中 \\(1 \\leqslant a_{j} \\leqslant 45\\) 。而且 \\(a_{1} + 14, a_{2} + 14, \\cdots, a_{30} + 14\\) 也是不同正整数的一个递增序列，其中 \\(15 \\leqslant a_{j} + 14 \\leqslant 59\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.557,
                0.907,
                0.632
            ],
            "angle": 0,
            "content": "60个正整数 \\(a_1\\) ， \\(a_2\\) ，…， \\(a_{30}\\) ， \\(a_1 + 14\\) ， \\(a_2 + 14\\) ，…， \\(a_{30} + 14\\) 全都小于等于59。因此，由鸽巢原理，有两个正整数相等。因为整数 \\(a_{j}(j = 1\\) ，2，…，30)都不相同，并且 \\(a_{j} + 14(j = 1\\) 2，…，30)也不相同，所以一定存在下标 \\(i\\) 和 \\(j\\) 满足 \\(a_{i} = a_{j} + 14\\) 。这意味着从第 \\(j + 1\\) 天到第 \\(i\\) 天恰好打了14场比赛。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.637,
                0.907,
                0.676
            ],
            "angle": 0,
            "content": "例11 证明在不超过 \\(2n\\) 的任意 \\(n + 1\\) 个正整数中一定存在一个正整数被另一个正整数整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.678,
                0.909,
                0.775
            ],
            "angle": 0,
            "content": "解 把 \\(n + 1\\) 个整数 \\(a_1, a_2, \\dots, a_{n + 1}\\) 中的每一个都写成 2 的幂与一个奇数的乘积。换句话说，令 \\(a_j = 2^{k_j} q_j (j = 1, 2, \\dots, n + 1)\\)，其中 \\(k_j\\) 是非负整数，\\(q_j\\) 是奇数。整数 \\(q_1, q_2, \\dots, q_{n + 1}\\) 都是小于 \\(2n\\) 的正奇数。因为只存在 \\(n\\) 个小于 \\(2n\\) 的正奇数，所以由鸽巢原理，\\(q_1, q_2, \\dots, q_{n + 1}\\) 中必有两个相等。于是，存在整数 \\(i\\) 和 \\(j\\) 使得 \\(q_i = q_j\\)。令 \\(q_i\\) 与 \\(q_j\\) 的公共值是 \\(q\\)，那么 \\(a_i = 2^{k_i} q, a_j = 2^{k_j} q\\)。因而，若 \\(k_i < k_j\\)，则 \\(a_i\\) 整除 \\(a_j\\)；若 \\(k_i > k_j\\)，则 \\(a_j\\) 整除 \\(a_i\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.061,
                0.777,
                0.91,
                0.872
            ],
            "angle": 0,
            "content": "巧妙地应用鸽巢原理证明了在不同整数的序列中存在着确定长度的递增或递减子序列。在给出这个应用之前先回顾某些定义。假定 \\(a_1, a_2, \\cdots, a_N\\) 是实数序列。它的一个子序列是形如 \\(a_{i_1}, a_{i_2}, \\cdots, a_{i_m}\\) 的序列，其中 \\(1 \\leqslant i_1 < i_2 < \\cdots < i_m \\leqslant N\\) 。因此一个子序列是从初始序列得到的序列，按照原来的顺序选取初始序列的某些项，也许要排除其他的项。如果这个序列的每一项都大于它前面的项，就称为严格递增的，如果每一项都小于它前面的项，就称为严格递减的。"
        },
        {
            "type": "text",
            "bbox": [
                0.073,
                0.88,
                0.9,
                0.917
            ],
            "angle": 0,
            "content": "定理3 每个由 \\(n^2 + 1\\) 个不同实数构成的序列都包含一个长为 \\(n + 1\\) 的严格递增子序列或严格递减子序列。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.926,
                0.424,
                0.943
            ],
            "angle": 0,
            "content": "在证明定理3之前先给出一个例子。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.142,
                0.044,
                0.177,
                0.057
            ],
            "angle": 0,
            "content": "358"
        },
        {
            "type": "header",
            "bbox": [
                0.223,
                0.043,
                0.288,
                0.057
            ],
            "angle": 0,
            "content": "第6章"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.102,
                0.962,
                0.16
            ],
            "angle": 0,
            "content": "例12 序列8，11，9，1，4，6，12，10，5，7包含10项。由于 \\(10 = 3^{2} + 1\\) ，存在四个长为4的严格递增子序列，即1，4，6，12；1，4，6，7；1，4，6，10和1，4，5，7。还存在一个长为4的严格递减子序列，即11，9，6，5。"
        },
        {
            "type": "text",
            "bbox": [
                0.153,
                0.163,
                0.352,
                0.179
            ],
            "angle": 0,
            "content": "现在给出定理的证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.182,
                0.962,
                0.236
            ],
            "angle": 0,
            "content": "证明 令 \\(a_1, a_2, \\dots, a_{n^2 + 1}\\) 是 \\(n^2 + 1\\) 个不同实数的序列。与序列中的每一项 \\(a_k\\) 相关联着一个有序对，即 \\((i_k, d_k)\\)，其中 \\(i_k\\) 是从 \\(a_k\\) 开始的最长的递增子序列的长度，\\(d_k\\) 是从 \\(a_k\\) 开始的最长的递减子序列的长度。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.239,
                0.962,
                0.353
            ],
            "angle": 0,
            "content": "假定没有长为 \\(n + 1\\) 的递增或递减子序列。那么 \\(i_k\\) 和 \\(d_k\\) 都是小于或等于 \\(n\\) 的正整数，\\(k = 1, 2, \\dots, n^2 + 1\\)。因此，由乘积法则，关于 \\((i_k, d_k)\\) 存在 \\(n^2\\) 个可能的有序对。根据鸽巢原理，\\(n^2 + 1\\) 个有序对中必有两个相等。换句话说，存在项 \\(a_s\\) 和 \\(a_t\\)，\\(s < t\\)，使得 \\(i_s = i_t\\) 和 \\(d_s = d_t\\)。我们将证明这是不可能的。由于序列的项是不同的，所以不是 \\(a_s < a_t\\) 就是 \\(a_s > a_t\\)。如果 \\(a_s < a_t\\)，那么由于 \\(i_s = i_t\\)，所以把 \\(a_s\\) 加到从 \\(a_t\\) 开始的长度为 \\(i_t\\) 的递增子序列前面就构造出一个从 \\(a_s\\) 开始的长度为 \\(i_t + 1\\) 的递增子序列。从而产生矛盾。类似地，如果 \\(a_s > a_t\\)，可以证明 \\(d_s\\) 一定大于 \\(d_t\\)，从而也产生矛盾。\\(\\triangleleft\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.355,
                0.962,
                0.411
            ],
            "angle": 0,
            "content": "最后的例子说明了怎样把广义鸽巢原理用于组合学的重要部分，即拉姆齐理论（Ramsey theory），它是以英国数学家拉姆齐的名字命名的。拉姆齐理论通常可用于处理集合元素的子集分配问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.416,
                0.962,
                0.454
            ],
            "angle": 0,
            "content": "例13 假定一组有6个人，任意两个人或者是朋友或者是敌人。证明在这组人中或存在3个人彼此都是朋友，或存在3个人彼此都是敌人。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.457,
                0.962,
                0.55
            ],
            "angle": 0,
            "content": "解 令 \\(A\\) 是6个人中的一人，组里其他5个人中至少有3个是 \\(A\\) 的朋友，或至少有3个是\\(A\\) 的敌人。这可从广义鸽巢原理得出，因为当5个物体分成两个集合时，其中的一个集合至少有 \\(\\lceil 5 / 2\\rceil = 3\\) 个元素。若是前一种情况，假定 \\(B\\) 、 \\(C\\) 和 \\(D\\) 是 \\(A\\) 的朋友。如果这3个人中有2个也是朋友，那么这2个人和 \\(A\\) 构成彼此是朋友的3人组。否则， \\(B\\) 、 \\(C\\) 和 \\(D\\) 构成彼此为敌人的3人组。对于后一种情况的证明，当 \\(A\\) 存在3个或更多的敌人时可以用类似的方法处理。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.552,
                0.962,
                0.645
            ],
            "angle": 0,
            "content": "拉姆齐数 \\(R(m, n)\\) （其中 \\(m\\) 和 \\(n\\) 是大于或等于2的正整数）表示：假设晚会上每两个人是朋友或者是敌人，那么在一个晚会上使得或者有 \\(m\\) 个人两两都是朋友，或者有 \\(n\\) 个人两两都是敌人所需要的最少人数。例13显示 \\(R(3, 3) \\leqslant 6\\) 。在一组5个人中，其中每两个人是朋友或者是敌人，可能没有3个人两两是朋友，也没有3个人两两是敌人，因此我们断言 \\(R(3, 3) = 6\\) （见练习28）。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.648,
                0.962,
                0.741
            ],
            "angle": 0,
            "content": "可以证明某些关于拉姆齐数的有用的性质，但是对于大多数拉姆齐数，找到精确的值是困难的。根据对称性可以证明 \\( R(m, n) = R(n, m) \\) （见练习32）。对于每个正整数 \\( n \\geqslant 2 \\)，我们也有 \\( R(2, n) = n \\) （见练习31）。只知道9个拉姆齐数 \\( R(m, n) (3 \\leqslant m \\leqslant n) \\) 的精确值，其中包括 \\( R(4, 4) = 18 \\) 。对许多其他的拉姆齐数只知道界，包括 \\( R(5, 5) \\) 在内，已知它满足 \\( 43 \\leqslant R(5, 5) \\leqslant 49 \\) 。有兴趣更多地了解有关拉姆齐数知识的读者可以参考[MiRo91]或[GrRoSp90]。"
        },
        {
            "type": "title",
            "bbox": [
                0.109,
                0.751,
                0.156,
                0.765
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.114,
                0.783,
                0.252,
                0.894
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.108,
                0.898,
                0.241,
                0.917
            ],
            "angle": 0,
            "content": "Courtesy of Stephen Frank Burch"
        },
        {
            "type": "text",
            "bbox": [
                0.267,
                0.783,
                0.957,
                0.94
            ],
            "angle": 0,
            "content": "富兰克·波拉姆顿·拉姆齐(Frank Plumpton Ramsey，1903—1930) 拉姆齐是剑桥马格达林学院校长的儿子，在温彻斯特和特里尼特学院受过教育。1923年毕业以后，他应聘在剑桥皇家学院工作，并在那里度过余生。拉姆齐对数理逻辑做出了重要的贡献。我们现在所称的拉姆齐理论是由他在“一个形式逻辑问题”（On a Problem of Formal Logic）的论文中所发表的聪明的组合论辩引起的。拉姆齐也对经济学理论做出了贡献。他作为在数学基础方面的优秀讲师而受到注意。据他的一位兄长说，从英国文学到政治学，他几乎对任何事都感兴趣。拉姆齐结过婚，并有两个女儿。他因慢性肝病死于26岁，他的死使得数学界和剑桥大学失去了一个才华横溢的年轻学者。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.705,
                0.036,
                0.793,
                0.051
            ],
            "angle": 0,
            "content": "计数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.84,
                0.037,
                0.875,
                0.05
            ],
            "angle": 0,
            "content": "359"
        },
        {
            "type": "title",
            "bbox": [
                0.06,
                0.1,
                0.105,
                0.116
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.12,
                0.702,
                0.134
            ],
            "angle": 0,
            "content": "1. 假定周末不排课，证明：在任一组6门课中一定有2门课安排在同一天上课。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.138,
                0.657,
                0.151
            ],
            "angle": 0,
            "content": "2. 如果一个班有 30 个学生，证明：至少 2 个学生的姓以同一个字母开头。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.156,
                0.886,
                0.169
            ],
            "angle": 0,
            "content": "3.抽屉里有一打棕色的短袜和一打黑色的短袜，全都没有配好对。一个人在黑暗中随机取出一些袜子。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.173,
                0.537,
                0.187
            ],
            "angle": 0,
            "content": "a)必须取多少只袜子才能保证至少有2只袜子是同色的？"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.191,
                0.537,
                0.205
            ],
            "angle": 0,
            "content": "b)必须取多少只袜子才能保证至少有2只袜子是黑色的？"
        },
        {
            "type": "list",
            "bbox": [
                0.078,
                0.173,
                0.537,
                0.205
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.209,
                0.646,
                0.224
            ],
            "angle": 0,
            "content": "4. 一个碗里有10个红球和10个蓝球。一个女士不看着球而随机地选取。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.227,
                0.518,
                0.241
            ],
            "angle": 0,
            "content": "a)她必须选多少个球才能保证至少有3个球是同色的？"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.245,
                0.518,
                0.259
            ],
            "angle": 0,
            "content": "b)她必须选多少个球才能保证至少有3个球是蓝色的？"
        },
        {
            "type": "list",
            "bbox": [
                0.078,
                0.227,
                0.518,
                0.259
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.262,
                0.901,
                0.295
            ],
            "angle": 0,
            "content": "5. 某学院的学生属于四个年级，这是依据他们的毕业年份来划分的。每一个学生必须选择21个专业中的一个专业。需要多少学生才能保证在同一年同一个专业有两名学生将要毕业？"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.298,
                0.902,
                0.33
            ],
            "angle": 0,
            "content": "6. 一所大学有 6 名教授讲授离散数学导论这门课。6 名教授采用相同的期末试卷。如果最低分为 0 , 最高分为 100 , 需要多少学生才能保证同一名教授所教的学生中有两名学生得到相同的分数?"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.334,
                0.682,
                0.348
            ],
            "angle": 0,
            "content": "7. 证明：在任意5个整数中（不一定是连续的）有2个整数被4除的余数相等。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.351,
                0.88,
                0.365
            ],
            "angle": 0,
            "content": "8. 设 \\(d\\) 是正整数。证明：在任意一组 \\(d + 1\\) 个整数中（不一定是连续的）有2个整数被 \\(d\\) 除的余数相等。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.369,
                0.7,
                0.383
            ],
            "angle": 0,
            "content": "9. 设 \\( n \\) 是正整数。证明：在任意一组 \\( n \\) 个连续的正整数中恰好有 1 个被 \\( n \\) 整除。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.388,
                0.899,
                0.421
            ],
            "angle": 0,
            "content": "10. 证明：如果 \\( f \\) 是从 \\( S \\) 到 \\( T \\) 的函数，其中 \\( S \\) 和 \\( T \\) 是有穷集，满足 \\( |S| > |T| \\)，那么在 \\( S \\) 中存在元素 \\( s_1 \\) 和 \\( s_2 \\) 使得 \\( f(s_1) = f(s_2) \\)，或者换句话说，\\( f \\) 不是一对一的。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.424,
                0.899,
                0.456
            ],
            "angle": 0,
            "content": "11.在一个大学里每个学生来自50个州中的一个州，那么必须有多少个学生注册才能保证至少有100个学生来自同一个州？"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.46,
                0.901,
                0.492
            ],
            "angle": 0,
            "content": "* 12. 设 \\((x_{i}, y_{i}) (i = 1, 2, 3, 4, 5)\\) 是 \\(xy\\) 平面上一组具有整数坐标的 5 个不同的点。证明：至少有一对点的连线中点的坐标是整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.496,
                0.899,
                0.528
            ],
            "angle": 0,
            "content": "* 13. 设 \\((x_{i}, y_{i}, z_{i})(i = 1, 2, 3, 4, 5, 6, 7, 8, 9)\\) 是 \\(xyz\\) 空间中一组具有整数坐标的9个不同的点。证明：至少有一对点的连线中点的坐标是整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.531,
                0.901,
                0.563
            ],
            "angle": 0,
            "content": "14. 至少需要多少个有序对 \\((a, b)\\) 才能保证存在两个有序对 \\((a_{1}, b_{1})\\) 和 \\((a_{2}, b_{2})\\)，使得 \\(a_{1} \\bmod 5 = a_{2} \\bmod 5\\) 并且 \\(b_{1} \\bmod 5 = b_{2} \\bmod 5\\)?"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.567,
                0.702,
                0.581
            ],
            "angle": 0,
            "content": "15. a) 证明：如果从前 8 个正整数中选 5 个整数，一定存在一对整数其和等于 9。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.585,
                0.537,
                0.599
            ],
            "angle": 0,
            "content": "b) 如果不是选 5 个而是选 4 个整数，a 的结论还为真吗？"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.602,
                0.757,
                0.617
            ],
            "angle": 0,
            "content": "16. a) 证明：如果从前 10 个正整数中选 7 个整数，一定至少存在 2 对整数其和等于 11。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.62,
                0.537,
                0.634
            ],
            "angle": 0,
            "content": "b) 如果不是选 7 个而是选 6 个整数，a 的结论还为真吗？"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.638,
                0.778,
                0.652
            ],
            "angle": 0,
            "content": "17. 从集合 \\(\\{1,2,3,4,5,6\\}\\) 中必须选多少个数才能保证其中至少有一对数之和等于7？"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.655,
                0.868,
                0.67
            ],
            "angle": 0,
            "content": "18. 从集合 \\(\\{1,3,5,7,9,11,13,15\\}\\) 中必须选多少个数才能保证其中至少有一对数之和等于16？"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.673,
                0.901,
                0.723
            ],
            "angle": 0,
            "content": "19. 一个公司在仓库中存储产品。仓库中的存储柜由通道、它们在通道中的位置和货架来指定。整个仓库有50个通道，每个通道有85个水平位置，每个位置有5个货架。公司产品数至少是多少才能使得在同一个存储柜中至少有2个产品？"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.726,
                0.429,
                0.74
            ],
            "angle": 0,
            "content": "20. 设一个小学院的离散数学班中有9个学生。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.744,
                0.577,
                0.759
            ],
            "angle": 0,
            "content": "a) 证明：这个班一定至少有 5 个男生，或者至少有 5 个女生。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.762,
                0.577,
                0.776
            ],
            "angle": 0,
            "content": "b)证明：这个班一定至少有3个男生，或者至少有7个女生。"
        },
        {
            "type": "list",
            "bbox": [
                0.086,
                0.744,
                0.577,
                0.776
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.78,
                0.698,
                0.794
            ],
            "angle": 0,
            "content": "21. 在25个学生的离散数学班中，设学生有一年级的、二年级的或者三年级的。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.797,
                0.854,
                0.812
            ],
            "angle": 0,
            "content": "a) 证明：这个班至少有 9 个是一年级的，或至少有 9 个是二年级的，或至少有 9 个是三年级的。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.815,
                0.863,
                0.829
            ],
            "angle": 0,
            "content": "b) 证明：这个班至少有 3 个是一年级的，或至少有 19 个是二年级的，或至少有 5 个是三年级的。"
        },
        {
            "type": "list",
            "bbox": [
                0.086,
                0.797,
                0.863,
                0.829
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.833,
                0.865,
                0.847
            ],
            "angle": 0,
            "content": "22. 在序列 22, 5, 7, 2, 23, 10, 15, 21, 3, 17 中找出一个最长的递增子序列和一个最长的递减子序列。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.851,
                0.605,
                0.864
            ],
            "angle": 0,
            "content": "23. 构造 16 个正整数的序列，使得它没有 5 项的递增或递减子序列。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.868,
                0.899,
                0.9
            ],
            "angle": 0,
            "content": "24. 如果101个不同高度的人站在一条线上，证明可能找到11个人使得他们在线上的高度是按递增或者递减顺序排列的。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.904,
                0.722,
                0.918
            ],
            "angle": 0,
            "content": "* 25. 25个女孩和25个男孩围坐一个圆桌旁边，证明总会有一个人的邻座都是男孩。"
        },
        {
            "type": "text",
            "bbox": [
                0.045,
                0.922,
                0.899,
                0.936
            ],
            "angle": 0,
            "content": "* 26. 假设有 21 个女生和 21 个男生参加数学竞赛。设每一个参赛者解出了至少 6 个题目, 对于每一个男生-女生"
        },
        {
            "type": "list",
            "bbox": [
                0.045,
                0.833,
                0.899,
                0.936
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.147,
                0.038,
                0.183,
                0.051
            ],
            "angle": 0,
            "content": "360"
        },
        {
            "type": "header",
            "bbox": [
                0.229,
                0.036,
                0.294,
                0.052
            ],
            "angle": 0,
            "content": "第6章"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.092,
                0.917,
                0.107
            ],
            "angle": 0,
            "content": "对，他们至少解出了一个相同的题目。证明有一个题目至少被3个女生和至少被3个男生解答出来。"
        },
        {
            "type": "text",
            "bbox": [
                0.106,
                0.111,
                0.722,
                0.125
            ],
            "angle": 0,
            "content": "* 27. 用伪码描述一个算法产生一个不同整数序列的最大递增或递减子序列。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.128,
                0.965,
                0.161
            ],
            "angle": 0,
            "content": "28. 证明：在任一组5个人中（其中任两个人或者是朋友或者是敌人），不一定有3个人彼此都是朋友或者3个人彼此都是敌人。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.164,
                0.966,
                0.197
            ],
            "angle": 0,
            "content": "29. 证明：在任一组10个人中（其中任两个人或者是朋友或者是敌人），或存在3个人彼此都是朋友，或存在4个人彼此都是敌人，并且存在3个人彼此是敌人，或存在4个人彼此是朋友。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.2,
                0.967,
                0.233
            ],
            "angle": 0,
            "content": "30. 使用练习29证明：在任一组20个人中（其中任两个人或者是朋友或者是敌人），或存在4个人彼此都是朋友，或存在4个人彼此都是敌人。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.236,
                0.95,
                0.251
            ],
            "angle": 0,
            "content": "31. 证明：如果 \\( n \\) 是正整数，\\( n \\geqslant 2 \\)，那么拉姆齐数 \\( R(2, n) \\) 等于 \\( n \\)。（回忆6.2节例13后对拉姆齐数的讨论。）"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.254,
                0.847,
                0.269
            ],
            "angle": 0,
            "content": "32. 证明：如果 \\(m\\) 和 \\(n\\) 是正整数，\\(m \\geqslant 2\\)，\\(n \\geqslant 2\\)，那么拉姆齐数 \\(R(m, n)\\) 和 \\(R(n, m)\\) 相等。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.271,
                0.967,
                0.304
            ],
            "angle": 0,
            "content": "33. 证明：在加利福尼亚州（人口3900万）至少有6个人姓名的3个缩写字母相同并且他们生在一年的同一天（但不一定是同一年）。假设每个人的姓名都有3个缩写字母。"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.307,
                0.967,
                0.34
            ],
            "angle": 0,
            "content": "34. 证明：如果美国工薪阶层有10000000人的工资低于1000000美元，那么去年有2个人挣的钱恰好相同（精确到美分）。"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.343,
                0.97,
                0.412
            ],
            "angle": 0,
            "content": "35. 在17世纪，巴黎人口超过800000。那时，认为人的头发不会超过200000根。设这些数据都是正确的，而且每一个人头上至少有一根头发（没有人完全没有头发）。使用鸽巢原理证明，如法国作家皮尔尼科尔所做的，有两个巴黎人有相同数量的头发。使用广义鸽巢原理证明至少有5个巴黎人有相同数量的头发。"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.415,
                0.969,
                0.448
            ],
            "angle": 0,
            "content": "36. 设没有人有超过 1000000 根头发，纽约 2016 年人口为 8537673。证明 2016 年至少 9 个人有相同数量的头发。"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.451,
                0.931,
                0.465
            ],
            "angle": 0,
            "content": "37. 一个大学有 38 个不同的时间段来安排课程，如果有 677 门不同的课程，那么需要多少个不同的教室？"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.468,
                0.97,
                0.501
            ],
            "angle": 0,
            "content": "38. 一个计算机网络由6台计算机组成。每台计算机至少直接连接到一台其他的计算机。证明：网络中至少有两台计算机直接连接相同数目的其他计算机。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.504,
                0.972,
                0.555
            ],
            "angle": 0,
            "content": "39. 一个计算机网络由6台计算机组成。每台计算机直接连接到零台或者更多台其他计算机。证明：网络中至少有两台计算机直接连接相同数目的其他计算机。（提示：不可能一台计算机不与任何计算机相连或连接到所有其他计算机。）"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.558,
                0.972,
                0.591
            ],
            "angle": 0,
            "content": "40. 把8台计算机连接到4台打印机上，为保证4台计算机可以直接访问4台不同的打印机，找出至少需要多少条缆线。证明你的答案。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.594,
                0.972,
                0.627
            ],
            "angle": 0,
            "content": "41. 把 100 台计算机连接到 20 台打印机上，为保证 20 台计算机可以直接访问 20 台不同的打印机，找出至少需要多少条缆线。证明你的答案。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.63,
                0.708,
                0.644
            ],
            "angle": 0,
            "content": "* 42. 证明：在至少 2 个人的聚会中，存在 2 个人认识人数相同的其他人。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.647,
                0.972,
                0.68
            ],
            "angle": 0,
            "content": "43. 一个摔跤选手是75小时之内的冠军。该选手一小时至少赛一场，但总共不超过125场。证明：存在着连续的若干个小时使得该选手恰好进行了24场比赛。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.683,
                0.562,
                0.697
            ],
            "angle": 0,
            "content": "* 44. 如果在练习 43 中的 24 替换如下，命题是否为真？"
        },
        {
            "type": "text",
            "bbox": [
                0.159,
                0.701,
                0.192,
                0.714
            ],
            "angle": 0,
            "content": "a)2"
        },
        {
            "type": "text",
            "bbox": [
                0.353,
                0.702,
                0.394,
                0.714
            ],
            "angle": 0,
            "content": "b)23"
        },
        {
            "type": "text",
            "bbox": [
                0.558,
                0.702,
                0.596,
                0.714
            ],
            "angle": 0,
            "content": "c)25"
        },
        {
            "type": "text",
            "bbox": [
                0.759,
                0.702,
                0.799,
                0.714
            ],
            "angle": 0,
            "content": "d)30"
        },
        {
            "type": "text",
            "bbox": [
                0.125,
                0.719,
                0.974,
                0.754
            ],
            "angle": 0,
            "content": "45. 如果 \\( f \\) 是从 \\( S \\) 到 \\( T \\) 的函数，其中 \\( S \\) 和 \\( T \\) 是有穷集，并且 \\( m = \\left\\lceil |S| / |T|\\right\\rceil \\)，那么证明至少存在 \\( S \\) 的 \\( m \\) 个元素映射到 \\( T \\) 的同一个值。即存在 \\( S \\) 中的元素 \\( s_1, s_2, \\dots, s_m \\) 使得 \\( f(s_1) = f(s_2) = \\dots = f(s_m) \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.757,
                0.975,
                0.79
            ],
            "angle": 0,
            "content": "46. 一条街道上有51所房子，每所房子的地址在1000到1099之间（包括1000与1099）。证明：至少有2所房子的地址是连续的。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.793,
                0.969,
                0.808
            ],
            "angle": 0,
            "content": "* 47. 设 \\( x \\) 是无理数。证明：对于某个不超过 \\( n \\) 的正整数 \\( j \\)，在 \\( jx \\) 与到 \\( jx \\) 最近的整数之间的差的绝对值小于 \\( 1/n \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.811,
                0.974,
                0.843
            ],
            "angle": 0,
            "content": "48. 设 \\(n_1, n_2, \\dots, n_t\\) 是正整数。证明：如果将 \\(n_1 + n_2 + \\dots + n_t - t + 1\\) 个物体放到 \\(t\\) 个盒子里，则对某个 \\(i (i = 1, 2, \\dots, t)\\)，第 \\(i\\) 个盒子包含了至少 \\(n_i\\) 个物体。"
        },
        {
            "type": "text",
            "bbox": [
                0.113,
                0.846,
                0.916,
                0.861
            ],
            "angle": 0,
            "content": "* 49. 在这个练习中概述了基于广义鸽巢原理的定理3的证明，使用的记号与教科书中的证明一样。"
        },
        {
            "type": "text",
            "bbox": [
                0.158,
                0.864,
                0.975,
                0.899
            ],
            "angle": 0,
            "content": "a)假定 \\(i_k\\leqslant n\\) ， \\(k = 1\\) ，2，…， \\(n^2 +1\\) 。使用广义鸽巢原理证明：存在 \\(n + 1\\) 个项 \\(a_{k_1}\\) 、 \\(a_{k_2}\\) ，…， \\(a_{k_{n + 1}}\\) 满足 \\(i_{k_1} = i_{k_2} = \\dots = i_{k_{n + 1}}\\) ，其中 \\(1\\leqslant k_{1} <   k_{2} <   \\dots <  k_{n + 1}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.158,
                0.901,
                0.953,
                0.919
            ],
            "angle": 0,
            "content": "b) 证明: \\(a_{k_j} > a_{k_{j+1}}\\), \\(j = 1, 2, \\dots, n\\)。[提示: 假定 \\(a_{k_j} < a_{k_{j+1}}\\), 证明这将推出 \\(i_{k_j} > i_{k_{j+1}}\\) 的矛盾。]"
        },
        {
            "type": "text",
            "bbox": [
                0.158,
                0.92,
                0.921,
                0.935
            ],
            "angle": 0,
            "content": "c)使用a和b证明：如果没有长度为 \\(n + 1\\) 的递增子序列，那么一定有同样长度的递减子序列。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.705,
                0.038,
                0.793,
                0.053
            ],
            "angle": 0,
            "content": "计数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.84,
                0.039,
                0.874,
                0.053
            ],
            "angle": 0,
            "content": "361"
        },
        {
            "type": "title",
            "bbox": [
                0.059,
                0.106,
                0.259,
                0.126
            ],
            "angle": 0,
            "content": "6.3 排列与组合"
        },
        {
            "type": "title",
            "bbox": [
                0.059,
                0.133,
                0.185,
                0.151
            ],
            "angle": 0,
            "content": "6.3.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.153,
                0.907,
                0.248
            ],
            "angle": 0,
            "content": "许多计数问题都可以通过找到特定大小的集合中不同元素排列的不同方法数来得以解决，其中这些元素的次序是有限制的。许多其他计数问题也可以通过从特定大小的集合元素中选择特定数量元素的方法数来得以解决，其中这些元素的次序是不受限制的。例如，从5个学生中选出3个学生站成一行照相，有多少种选择方法？从4个学生中选出3个学生组成一个委员会，有多少种选择方法？本节将介绍一些方法来解决此类问题。"
        },
        {
            "type": "title",
            "bbox": [
                0.06,
                0.257,
                0.187,
                0.275
            ],
            "angle": 0,
            "content": "6.3.2 排列"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.277,
                0.854,
                0.295
            ],
            "angle": 0,
            "content": "我们先通过解决引言中提出的第一个问题以及一些其他相关问题来开始本节的内容。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.299,
                0.907,
                0.338
            ],
            "angle": 0,
            "content": "例1从5个学生中选出3个学生站成一行照相，有多少种选择方法？让5个学生站成一行照相，有多少种排列方法？"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.34,
                0.907,
                0.434
            ],
            "angle": 0,
            "content": "解首先，注意选择学生时次序是有限制的。从5个学生中选择第一个学生站在一行的第一个位置有5种方法。一旦这个学生被选定之后，则有4种方法选择第二个学生站在一行的第二个位置。当第一和第二个学生都被选定之后，则有3种方法选择第三个学生站在一行的第三个位置。根据乘积法则，共有 \\(5 \\cdot 4 \\cdot 3 = 60\\) 种方法从5个学生中选出3个学生站成一行来照相。"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.436,
                0.907,
                0.492
            ],
            "angle": 0,
            "content": "为了排列所有5个学生站成一行来照相，选择第一个学生时有5种方法，选择第二个学生时有4种方法，第三个学生时有3种方法，第四个学生时有2种方法，第五个学生时有1种方法。因此，共有 \\(5 \\cdot 4 \\cdot 3 \\cdot 2 \\cdot 1 = 120\\) 种方法让所有5个学生站成一行来照相。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.493,
                0.752,
                0.51
            ],
            "angle": 0,
            "content": "例1阐述了不同个体有次序的排列是如何计数的。这也引出了几个术语。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.513,
                0.907,
                0.549
            ],
            "angle": 0,
            "content": "集合中不同元素的排列，是对这些元素的一种有序安排。我们也对集合中某些元素的有序安排感兴趣。对一个集合中 \\( r \\) 个元素的有序安排称为 \\( r \\) 排列。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.553,
                0.792,
                0.571
            ],
            "angle": 0,
            "content": "例2设 \\(S = \\{1,2,3\\}\\) 。3，1，2是 \\(S\\) 的一个排列，3，2是 \\(S\\) 的一个2排列。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.576,
                0.785,
                0.593
            ],
            "angle": 0,
            "content": "一个 \\(n\\) 元集的 \\(r\\) 排列数记为 \\(P(n, r)\\) 。我们可以使用乘积法则求出 \\(P(n, r)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.598,
                0.909,
                0.674
            ],
            "angle": 0,
            "content": "例3设 \\(S = \\{1,2,3\\}\\) 。 \\(S\\) 的2排列有如下有序安排： \\(a,b;a,c;b,a;b,c;c,a;c,\\) （20\\(b\\) 。因此，具有3个元素的这个集合共有6个2排列。所有具有3个元素的集合都有6个2排列。有3种方法选择排列中的第一个元素。有2种方法选择排列中的第二个元素，因为第二个元素必须不同于第一个元素。因此，根据乘积法则，有 \\(P(3,2) = 3\\cdot 2 = 6\\) □"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.677,
                0.904,
                0.694
            ],
            "angle": 0,
            "content": "下面利用乘积法则找出求 \\(P(n, r)\\) 的一个公式，其中 \\(n\\) 和 \\(r\\) 都是任意正整数，且 \\(1 \\leqslant r \\leqslant n\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.702,
                0.541,
                0.719
            ],
            "angle": 0,
            "content": "定理1 具有 \\(n\\) 个不同元素的集合的 \\(r\\) 排列数是"
        },
        {
            "type": "equation",
            "bbox": [
                0.316,
                0.722,
                0.658,
                0.739
            ],
            "angle": 0,
            "content": "\\[\nP (n, r) = n (n - 1) (n - 2) \\dots (n - r + 1)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.748,
                0.91,
                0.822
            ],
            "angle": 0,
            "content": "证明 选择这个排列的第一个元素可以有 \\(n\\) 种方法，因为集合中有 \\(n\\) 个元素。选择排列的第二个元素有 \\(n - 1\\) 种方法，由于在使用了为第一个位置挑出的元素之后集合里还留下了 \\(n - 1\\) 个元素。类似地，选择第三个元素有 \\(n - 2\\) 种方法，以此类推，直到选择第 \\(r\\) 个元素恰好有 \\(n - (r - 1) = n - r + 1\\) 种方法。因此，由乘积法则，存在"
        },
        {
            "type": "equation",
            "bbox": [
                0.363,
                0.825,
                0.61,
                0.841
            ],
            "angle": 0,
            "content": "\\[\nn (n - 1) (n - 2) \\dots (n - r + 1)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.066,
                0.843,
                0.219,
                0.86
            ],
            "angle": 0,
            "content": "个集合的 \\(r\\) 排列。"
        },
        {
            "type": "text",
            "bbox": [
                0.066,
                0.862,
                0.91,
                0.898
            ],
            "angle": 0,
            "content": "注意，只要 \\(n\\) 是一个非负整数，就有 \\(P(n,0) = 1\\) ，因为恰好有一种方法来排列0个元素。也就是说，恰好有一个排列中没有元素，即空排列。"
        },
        {
            "type": "text",
            "bbox": [
                0.107,
                0.901,
                0.424,
                0.918
            ],
            "angle": 0,
            "content": "下面给出定理1的一个有用的推论。"
        },
        {
            "type": "text",
            "bbox": [
                0.921,
                0.298,
                0.98,
                0.315
            ],
            "angle": 0,
            "content": "Extra Examples"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.133,
                0.038,
                0.169,
                0.051
            ],
            "angle": 0,
            "content": "362"
        },
        {
            "type": "header",
            "bbox": [
                0.214,
                0.036,
                0.28,
                0.052
            ],
            "angle": 0,
            "content": "第6章"
        },
        {
            "type": "text",
            "bbox": [
                0.154,
                0.099,
                0.576,
                0.116
            ],
            "angle": 0,
            "content": "推论1 如果 \\(n\\) 和 \\(r\\) 都是整数，且 \\(0 \\leqslant r \\leqslant n\\) ，则"
        },
        {
            "type": "equation",
            "bbox": [
                0.443,
                0.12,
                0.614,
                0.149
            ],
            "angle": 0,
            "content": "\\[\nP (n, r) = \\frac {n !}{(n - r) !}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.159,
                0.616,
                0.176
            ],
            "angle": 0,
            "content": "证明 当 \\(n\\) 和 \\(r\\) 是整数，且 \\(1 \\leqslant r \\leqslant n\\) 时，由定理1有"
        },
        {
            "type": "equation",
            "bbox": [
                0.292,
                0.181,
                0.763,
                0.211
            ],
            "angle": 0,
            "content": "\\[\nP (n, r) = n (n - 1) (n - 2) \\dots (n - r + 1) = \\frac {n !}{(n - r) !}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.216,
                0.949,
                0.264
            ],
            "angle": 0,
            "content": "因为只要 \\(n\\) 是非负整数，就有 \\(\\frac{n!}{(n - 0)!} = \\frac{n!}{n!} = 1\\) ，所以我们知道公式 \\(P(n, r) = \\frac{n!}{(n - r)!}\\)，当 \\(r = 0\\) 时也成立。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.267,
                0.914,
                0.285
            ],
            "angle": 0,
            "content": "由定理1知道，如果 \\(n\\) 是一个正整数，则 \\(P(n,n) = n!\\) 。用一些例子来说明这个结论。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.289,
                0.949,
                0.328
            ],
            "angle": 0,
            "content": "例4 在进入竞赛的100个不同的人中有多少种方法选出一个一等奖得主、一个二等奖得主和一个三等奖得主？"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.331,
                0.95,
                0.367
            ],
            "angle": 0,
            "content": "解不管哪个人得哪个奖，选取3个得奖人的方法数是从100个元素的集合中有序选择3个元素的方法数，即100个元素的集合的3排列数。因此，答案是"
        },
        {
            "type": "equation",
            "bbox": [
                0.362,
                0.37,
                0.692,
                0.385
            ],
            "angle": 0,
            "content": "\\[\nP (1 0 0, 3) = 1 0 0 \\cdot 9 9 \\cdot 9 8 = 9 7 0 2 0 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.391,
                0.949,
                0.43
            ],
            "angle": 0,
            "content": "例5 假定有8个赛跑运动员。第一名得到一枚金牌，第二名得到一枚银牌，第三名得到一枚铜牌。如果比赛可能出现所有可能的结果，有多少种不同的颁奖方式？"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.433,
                0.949,
                0.469
            ],
            "angle": 0,
            "content": "解 颁奖方式就是8元素的集合的3排列数。因此存在 \\(P(8, 3) = 8 \\cdot 7 \\cdot 6 = 336\\) 种可能的颁奖方式。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.473,
                0.949,
                0.532
            ],
            "angle": 0,
            "content": "例6 假定一个女推销员要访问8个不同的城市。她的访问必须从某个指定的城市开始，但对其他7个城市的访问可以按照任何次序进行。当访问这些城市时，这个女推销员可以有多少种可能的次序？"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.534,
                0.949,
                0.609
            ],
            "angle": 0,
            "content": "解 由于第一个城市是确定的，而其他7个城市可以是任意的顺序，所以城市之间可能的路径数是7个元素的排列数。因此，这个女推销员有 \\(7! = 7 \\cdot 6 \\cdot 5 \\cdot 4 \\cdot 3 \\cdot 2 \\cdot 1 = 5040\\) 种方式选择她的旅行。比如说，如果这个女推销员想要在城市中找出具有最短距离的路径，并且她对每一条可能的路径计算总距离，那么她必须考虑5040条路径。"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.613,
                0.606,
                0.631
            ],
            "angle": 0,
            "content": "例7 字母ABCDEFGH有多少种排列包含串ABC？"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.636,
                0.949,
                0.691
            ],
            "angle": 0,
            "content": "解 由于字母ABC必须成组出现，我们可以通过找6个对象，即组ABC和单个字母D、E、F、G和H的排列数得到答案。由于这6个对象可以按任何次序出现，因此，存在 \\(6! = 720\\) 种ABCDEFGH字母的排列，其中ABC成组出现。"
        },
        {
            "type": "title",
            "bbox": [
                0.102,
                0.701,
                0.229,
                0.718
            ],
            "angle": 0,
            "content": "6.3.3 组合"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.721,
                0.949,
                0.757
            ],
            "angle": 0,
            "content": "现在把注意力转到无序选择个体的计数上来。我们先通过解决本章引言中提出的第二个问题来开始本节的内容。"
        },
        {
            "type": "text",
            "bbox": [
                0.141,
                0.762,
                0.786,
                0.78
            ],
            "angle": 0,
            "content": "例8 从4个学生中选出3个学生组成一个委员会，有多少种选择方法？"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.785,
                0.949,
                0.858
            ],
            "angle": 0,
            "content": "解为了回答这个问题，只需从含有4个学生的集合中找到具有3个元素的子集的个数。我们知道，一共有4个这样的子集，每个子集中都有一个不同的学生，因为选择4个学生等价于从4个学生中选出一个人离开这个集合。这就意味着有4种方法选择3个学生组成一个委员会，这与学生的次序是无关的。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.861,
                0.949,
                0.896
            ],
            "angle": 0,
            "content": "例8阐明了这样一个事实：许多计数问题都可以通过从具有 \\(n\\) 个元素的集合中求得特定大小的子集的个数来得以解决，其中 \\(n\\) 是一个正整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.102,
                0.899,
                0.949,
                0.935
            ],
            "angle": 0,
            "content": "集合元素的一个 \\( r \\) 组合是从这个集合无序选取的 \\( r \\) 个元素。于是，简单地说，一个 \\( r \\) 组合是这个集合的一个 \\( r \\) 个元素的子集。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.691,
                0.035,
                0.78,
                0.049
            ],
            "angle": 0,
            "content": "计数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.826,
                0.036,
                0.862,
                0.049
            ],
            "angle": 0,
            "content": "363"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.092,
                0.892,
                0.133
            ],
            "angle": 0,
            "content": "例9 设 \\(S\\) 是集合 \\(\\{1, 2, 3, 4\\}\\)，那么 \\(\\{1, 3, 4\\}\\) 是 \\(S\\) 的一个3组合。（注意，\\(\\{4, 1, 3\\}\\) 与组合 \\(\\{1, 3, 4\\}\\) 是一样的，因为集合中元素顺序是没有关系的。）"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.14,
                0.892,
                0.189
            ],
            "angle": 0,
            "content": "具有 \\(n\\) 个不同元素的集合的 \\(r\\) 组合数记为 \\(C(n, r)\\) 。注意 \\(C(n, r)\\) 也记作 \\(\\binom{n}{r}\\)，并且称为二项式系数。在6.4节我们将学习这个记号。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.193,
                0.892,
                0.233
            ],
            "angle": 0,
            "content": "例10因为 \\(\\{a,b,c,d\\}\\) 的2组合是 \\(\\{a,b\\} ,\\{a,c\\} ,\\{a,d\\} ,\\{b,c\\} ,\\{b,d\\}\\) 和 \\(\\{c,d\\}\\) 共6个子集，所以 \\(C(4,2) = 6\\) △"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.235,
                0.892,
                0.29
            ],
            "angle": 0,
            "content": "可以用关于集合的 \\(r\\) 排列数的公式确定 \\(n\\) 元素的集合的 \\(r\\) 组合数。为此只需注意集合的 \\(r\\) 排列可以按下述方法得到：首先构成集合的 \\(r\\) 组合，接着排列这些组合中的元素。下面的定理给出了 \\(C(n, r)\\) 的值，它的证明就是基于这个观察。"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.298,
                0.816,
                0.316
            ],
            "angle": 0,
            "content": "定理2设 \\(n\\) 是正整数， \\(r\\) 是满足 \\(0\\leqslant r\\leqslant n\\) 的整数， \\(n\\) 元素的集合的 \\(r\\) 组合数等于"
        },
        {
            "type": "equation",
            "bbox": [
                0.368,
                0.321,
                0.56,
                0.35
            ],
            "angle": 0,
            "content": "\\[\nC (n, r) = \\frac {n !}{r ! (n - r) !}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.359,
                0.891,
                0.395
            ],
            "angle": 0,
            "content": "证明 可以如下得到这个集合的 \\(r\\) 排列。先构成集合的 \\(C(n, r)\\) 个 \\(r\\) 组合，然后以 \\(P(n, r)\\) 种方式排序每个 \\(r\\) 组合中的元素，这可以用 \\(P(r, r)\\) 种方式来做。因此，"
        },
        {
            "type": "equation",
            "bbox": [
                0.335,
                0.398,
                0.595,
                0.414
            ],
            "angle": 0,
            "content": "\\[\nP (n, r) = C (n, r) \\cdot P (r, r)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.417,
                0.125,
                0.433
            ],
            "angle": 0,
            "content": "这就推出"
        },
        {
            "type": "equation",
            "bbox": [
                0.251,
                0.436,
                0.679,
                0.468
            ],
            "angle": 0,
            "content": "\\[\nC (n, r) = \\frac {P (n , r)}{P (r , r)} = \\frac {n ! / (n - r) !}{r ! / (r - r) !} = \\frac {n !}{r ! (n - r) !}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.47,
                0.891,
                0.539
            ],
            "angle": 0,
            "content": "我们可以用计数的除法法则证明这个定理。因为在组合中不考虑元素的顺序，并且有 \\(P(r, r)\\) 种方式排序 \\(n\\) 元素的 \\(r\\) 组合中的这 \\(r\\) 个元素，所以 \\(n\\) 个元素的每个 \\(C(n, r)r\\) 组合对应一个 \\(P(r, r)r\\) 排列。因此，由除法法则 \\(C(n, r) = \\frac{P(n, r)}{P(r, r)}\\)，也就是前面的 \\(C(n, r) = \\frac{n!}{r!(n - r)}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.542,
                0.891,
                0.617
            ],
            "angle": 0,
            "content": "尽管定理2中的公式很清楚，但对很大的 \\(n\\) 和 \\(r\\) 而言，这个公式并没有什么用处。其原因是，在实际计算中，只能对较小的整数求阶乘的准确值，而且当用浮点数来计算时，从定理2的公式中得到的结果可能并不是一个整数值。因此，当计算 \\(C(n, r)\\) 时，首先注意，如果从定理2的 \\(C(n, r)\\) 计算公式的分子和分母中都消去 \\((n - r)\\)！后，可以得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.254,
                0.62,
                0.676,
                0.65
            ],
            "angle": 0,
            "content": "\\[\nC (n, r) = \\frac {n !}{r ! (n - r) !} = \\frac {n (n - 1) \\cdots (n - r + 1)}{r !}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.042,
                0.653,
                0.891,
                0.746
            ],
            "angle": 0,
            "content": "因此，为了计算 \\(C(n, r)\\)，可以从分子和分母中消去分母中所有较大的因子，再把分子中所有没有消去的项相乘，然后再除以分母中较小的因子。[如果是用手而不是用机器计算，有必要再在 \\(n(n - 1) \\cdots (n - r + 1)\\) 和 \\(r!\\) 中消去公因数。]注意许多计算器中都有一个关于计算 \\(C(n, r)\\) 内置函数，这些函数可以对相对较小的 \\(n\\) 和 \\(r\\) 求结果，许多计算机程序也可以用来求 \\(C(n, r)\\) 的值。[这些函数可能称为 \\(\\operatorname{chose}(n, k)\\) 或 \\(\\operatorname{binom}(n, k)\\)。]"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.748,
                0.889,
                0.785
            ],
            "angle": 0,
            "content": "例11说明了当 \\(k\\) 相对于 \\(n\\) 较小时，以及当 \\(k\\) 接近于 \\(n\\) 时，如何计算 \\(C(n, r)\\) 。该例子也给出了组合数 \\(C(n, r)\\) 的一个关键的恒等式。"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.788,
                0.889,
                0.828
            ],
            "angle": 0,
            "content": "例11从一副52张标准扑克牌中选出5张，共有多少种不同方法？从一副52张标准扑克牌中选出47张，又有多少种不同方法？"
        },
        {
            "type": "text",
            "bbox": [
                0.079,
                0.83,
                0.873,
                0.847
            ],
            "angle": 0,
            "content": "解因为从52张牌中选出5张，这5张牌的次序不受限制，所以不同的选择方法数共有"
        },
        {
            "type": "equation",
            "bbox": [
                0.382,
                0.85,
                0.543,
                0.881
            ],
            "angle": 0,
            "content": "\\[\nC (5 2, 5) = \\frac {5 2 !}{5 ! 4 7 !}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.883,
                0.56,
                0.9
            ],
            "angle": 0,
            "content": "为了计算 \\(C(52, 5)\\)，首先在分子和分母中都消去47！，得"
        },
        {
            "type": "equation",
            "bbox": [
                0.318,
                0.903,
                0.612,
                0.934
            ],
            "angle": 0,
            "content": "\\[\nC (5 2, 5) = \\frac {5 2 \\cdot 5 1 \\cdot 5 0 \\cdot 4 9 \\cdot 4 8}{5 \\cdot 4 \\cdot 3 \\cdot 2 \\cdot 1}\n\\]"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.148,
                0.037,
                0.186,
                0.052
            ],
            "angle": 0,
            "content": "364"
        },
        {
            "type": "header",
            "bbox": [
                0.23,
                0.036,
                0.297,
                0.051
            ],
            "angle": 0,
            "content": "第6章"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.092,
                0.972,
                0.165
            ],
            "angle": 0,
            "content": "上述表达式还可以化简。首先将分子中的50除以分母中的因子5，则在分子中得到因子10；然后将分子中的48除以分母中的因子4，则在分子中得到因子12；再将分子中的51除以分母中的因子3，则在分子中得到因子17；最后将分子中的52除以分母中的因子2，在分子中得到因子26。于是得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.346,
                0.168,
                0.747,
                0.184
            ],
            "angle": 0,
            "content": "\\[\nC (5 2, 5) = 2 6 \\cdot 1 7 \\cdot 1 0 \\cdot 4 9 \\cdot 1 2 = 2 5 9 8 9 6 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.187,
                0.971,
                0.223
            ],
            "angle": 0,
            "content": "因此，从一副52张标准扑克牌中选出5张，共有2598960种不同方法。注意从一副52张标准扑克牌中选出47张，不同的选择方法数为"
        },
        {
            "type": "equation",
            "bbox": [
                0.459,
                0.227,
                0.635,
                0.256
            ],
            "angle": 0,
            "content": "\\[\nC (5 2, 4 7) = \\frac {5 2 !}{4 7 ! 5 !}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.26,
                0.975,
                0.296
            ],
            "angle": 0,
            "content": "不用再计算这个值了，因为 \\(C(52, 57) = C(52, 5)\\)。（因为在计算它们的公式中，只有分母中5！和47！的次序是不同的。）因此，从一副52张标准扑克牌中选出47张，共有2598960种不同方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.122,
                0.298,
                0.975,
                0.335
            ],
            "angle": 0,
            "content": "在例11中，我们看到 \\(C(52, 5) = C(52, 47)\\) 。这很容易理解，因为52张牌中取5张牌也就等同于选取余下的47张牌。这个等式是引理2中关于 \\(r\\) 组合数的有用的恒等式的一个特例。"
        },
        {
            "type": "text",
            "bbox": [
                0.171,
                0.343,
                0.825,
                0.361
            ],
            "angle": 0,
            "content": "推论2设 \\(n\\) 和 \\(r\\) 是满足 \\(r\\leqslant n\\) 的非负整数，那么 \\(C(n,r) = C(n,n - r)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.164,
                0.37,
                0.356,
                0.386
            ],
            "angle": 0,
            "content": "证明 由定理2得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.318,
                0.39,
                0.781,
                0.455
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} C (n, r) = \\frac {n !}{r ! (n - r) !} \\\\ C (n, n - r) = \\frac {n !}{(n - r) ! [ n - (n - r) ] !} = \\frac {n !}{(n - r) ! r !} \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.125,
                0.458,
                0.399,
                0.474
            ],
            "angle": 0,
            "content": "因此， \\(C(n,r) = C(n,n - r)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.125,
                0.476,
                0.975,
                0.512
            ],
            "angle": 0,
            "content": "我们也可以不用代数运算证明推论2。而是使用组合证明。我们在定义1描述了这种重要的证明类型。"
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.521,
                0.968,
                0.577
            ],
            "angle": 0,
            "content": "定义1 恒等式的组合证明是一种证明，在这个证明中使用计数的论述而不使用某些其他的方法（如代数技巧）来证明一个定理或者基于等式两边的对象集合存在一个双射函数来证明。这两种证明分别称为双计数证明和双射证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.125,
                0.586,
                0.976,
                0.64
            ],
            "angle": 0,
            "content": "可以使用组合证明来证明许多涉及二项式系数的恒等式。如果可以说明一个恒等式两边通过不同的方法计数了同样的元素，那么对这个恒等式就可以使用组合证明。现在提供一个推论2的组合证明。我们同时提供双计数证明和双射证明，两者基于相同的基本原理。"
        },
        {
            "type": "text",
            "bbox": [
                0.125,
                0.643,
                0.977,
                0.716
            ],
            "angle": 0,
            "content": "证明 我们将使用双射证明方法证明 \\(C(n, r) = c(n, n - r)\\)，对于所有整数 \\(n, r, 0 \\leqslant r \\leqslant n\\)。设 \\(S\\) 是有 \\(n\\) 个元素的集合。从 \\(S\\) 的子集 \\(A\\) 到 \\(\\overline{A}\\) 的一个函数是一个从 \\(r\\) 个元素的子集 \\(S\\) 到 \\(n - r\\) 个元素子集的双射函数（读者可证明）。因为这两个有限集合有双射函数，所以这两个集合必定有相同的元素个数，恒等式 \\(C(n, r) = c(n, n - r)\\) 可得。"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.719,
                0.977,
                0.774
            ],
            "angle": 0,
            "content": "另一种方法，我们可以通过双计数证明来解释。由定义，\\(C(n, r)\\) 是 \\(r\\) 元素的 \\(S\\) 子集的个数。但 \\(S\\) 的子集 \\(A\\) 也确定了不在 \\(A\\) 中的元素，即 \\(\\overline{A}\\) 。因为 \\(r\\) 个元素的 \\(S\\) 子集的补集有 \\(n - r\\) 个元素，具有 \\(r\\) 个元素的 \\(S\\) 子集的个数是 \\(C(n, n - r)\\) 。因此 \\(C(n, r) = C(n, n - r)\\) 。"
        },
        {
            "type": "text",
            "bbox": [
                0.166,
                0.779,
                0.976,
                0.797
            ],
            "angle": 0,
            "content": "例12有多少种方式从10个选手的网球队中选择5个选手外出参加在另一个学校的比赛？"
        },
        {
            "type": "text",
            "bbox": [
                0.166,
                0.802,
                0.797,
                0.818
            ],
            "angle": 0,
            "content": "解 答案由10元素集合的5组合数给出。根据定理2，这个组合数是"
        },
        {
            "type": "equation",
            "bbox": [
                0.446,
                0.821,
                0.663,
                0.851
            ],
            "angle": 0,
            "content": "\\[\nC (1 0, 5) = \\frac {1 0 !}{5 ! 5 !} = 2 5 2\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.129,
                0.857,
                0.979,
                0.896
            ],
            "angle": 0,
            "content": "例13一组30个人被培训作为宇航员去完成首次登陆火星的任务。有多少种方式选出6个人的小组来完成这个任务（假设所有的小组成员有同样的工作）？"
        },
        {
            "type": "text",
            "bbox": [
                0.129,
                0.899,
                0.979,
                0.935
            ],
            "angle": 0,
            "content": "解因为不考虑这些人被选的次序，所以从30个人中选6个人的小组的方式数是30元素集合的6组合数。根据定理2，这个组合数是"
        },
        {
            "type": "aside_text",
            "bbox": [
                0.053,
                0.777,
                0.117,
                0.794
            ],
            "angle": 0,
            "content": "Extra Examples"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.698,
                0.036,
                0.789,
                0.051
            ],
            "angle": 0,
            "content": "计数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.834,
                0.037,
                0.87,
                0.05
            ],
            "angle": 0,
            "content": "365"
        },
        {
            "type": "equation",
            "bbox": [
                0.219,
                0.092,
                0.731,
                0.122
            ],
            "angle": 0,
            "content": "\\[\nC (3 0, 6) = \\frac {3 0 !}{6 ! 2 4 !} = \\frac {3 0 \\cdot 2 9 \\cdot 2 8 \\cdot 2 7 \\cdot 2 6 \\cdot 2 5}{6 \\cdot 5 \\cdot 4 \\cdot 3 \\cdot 2 \\cdot 1} = 5 9 3 7 7 5\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.128,
                0.556,
                0.146
            ],
            "angle": 0,
            "content": "例14 有多少个长度为 \\(n\\) 的比特串恰好包含 \\(r\\) 个1？"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.15,
                0.901,
                0.187
            ],
            "angle": 0,
            "content": "解 在长度为 \\(n\\) 的比特串中 \\(r\\) 个1的位置构成了集合 \\(\\{1,2,\\dots ,n\\}\\) 的 \\(r\\) 组合。因此，有\\(C(n,r)\\) 个长度为 \\(n\\) 的比特串恰好包含 \\(r\\) 个1。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.191,
                0.901,
                0.249
            ],
            "angle": 0,
            "content": "例15 为开发学校的离散数学课程要选出一个委员会。如果数学系有9个教师，计算机科学系有11个教师。而这个委员会要由3个数学系的教师和4个计算机科学系的教师组成，那么有多少种选择方式？"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.252,
                0.901,
                0.288
            ],
            "angle": 0,
            "content": "解 由乘积法则，答案是9元素集合的3组合数与11元素集合的4组合数之积。根据定理2，选择这个委员会的方式数是"
        },
        {
            "type": "equation",
            "bbox": [
                0.235,
                0.291,
                0.721,
                0.321
            ],
            "angle": 0,
            "content": "\\[\nC (9, 3) \\cdot C (1 1, 4) = \\frac {9 !}{3 ! 6 !} \\cdot \\frac {1 1 !}{4 ! 7 !} = 8 4 \\cdot 3 3 0 = 2 7 7 2 0\n\\]"
        },
        {
            "type": "title",
            "bbox": [
                0.056,
                0.334,
                0.101,
                0.349
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.353,
                0.299,
                0.368
            ],
            "angle": 0,
            "content": "1. 列出 \\(\\{a, b, c\\}\\) 的所有排列。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.371,
                0.431,
                0.386
            ],
            "angle": 0,
            "content": "2. 集合 \\(\\{a, b, c, d, e, f, g\\}\\) 有多少个排列？"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.389,
                0.464,
                0.404
            ],
            "angle": 0,
            "content": "3. \\(\\{a, b, c, d, e, f, g\\}\\) 有多少个排列以 \\( a \\) 结尾？"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.407,
                0.279,
                0.421
            ],
            "angle": 0,
            "content": "4. 令 \\( S = \\{1,2,3,4,5\\} \\)"
        },
        {
            "type": "list",
            "bbox": [
                0.055,
                0.353,
                0.464,
                0.421
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.424,
                0.276,
                0.44
            ],
            "angle": 0,
            "content": "a) 列出 \\(S\\) 的所有 3 排列。"
        },
        {
            "type": "text",
            "bbox": [
                0.468,
                0.424,
                0.666,
                0.439
            ],
            "angle": 0,
            "content": "b) 列出 \\(S\\) 的所有 3 组合。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.442,
                0.238,
                0.457
            ],
            "angle": 0,
            "content": "5. 求出下面的每个值。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.461,
                0.166,
                0.474
            ],
            "angle": 0,
            "content": "a) \\(P(6,3)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.469,
                0.461,
                0.556,
                0.474
            ],
            "angle": 0,
            "content": "b) \\(P(6,5)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.478,
                0.165,
                0.491
            ],
            "angle": 0,
            "content": "c) \\(P(8,1)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.469,
                0.478,
                0.557,
                0.491
            ],
            "angle": 0,
            "content": "d) \\(P(8,5)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.496,
                0.165,
                0.509
            ],
            "angle": 0,
            "content": "e) \\(P(8, 8)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.47,
                0.497,
                0.564,
                0.509
            ],
            "angle": 0,
            "content": "f) \\(P(10,9)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.514,
                0.24,
                0.528
            ],
            "angle": 0,
            "content": "6. 求出下面的每个值。"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.532,
                0.167,
                0.544
            ],
            "angle": 0,
            "content": "a) \\(C(5,1)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.47,
                0.532,
                0.558,
                0.544
            ],
            "angle": 0,
            "content": "b) \\(C(5,3)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.55,
                0.167,
                0.562
            ],
            "angle": 0,
            "content": "c) \\(C(8,4)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.472,
                0.55,
                0.559,
                0.562
            ],
            "angle": 0,
            "content": "d) \\(C(8, 8)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.081,
                0.568,
                0.167,
                0.58
            ],
            "angle": 0,
            "content": "e) \\(C(8,0)\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.472,
                0.568,
                0.566,
                0.58
            ],
            "angle": 0,
            "content": "f)C(12，6)"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.584,
                0.316,
                0.599
            ],
            "angle": 0,
            "content": "7. 求出9元素集合的5排列数。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.601,
                0.728,
                0.617
            ],
            "angle": 0,
            "content": "8. 如果不允许并列名次，在结束比赛时5个赛跑运动员有多少种不同的排名次序？"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.62,
                0.908,
                0.652
            ],
            "angle": 0,
            "content": "9. 在一场12匹马的赛马中，如果所有的比赛结果都是可能的，对于第一名、第二名和第三名有多少种可能性？"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.655,
                0.718,
                0.67
            ],
            "angle": 0,
            "content": "10. 有6个不同的人竞选州长。有多少种不同的次序在选票上打印竞选者的名字？"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.673,
                0.29,
                0.687
            ],
            "angle": 0,
            "content": "11. 多少个 10 位比特串包含"
        },
        {
            "type": "list",
            "bbox": [
                0.059,
                0.584,
                0.908,
                0.687
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.691,
                0.212,
                0.705
            ],
            "angle": 0,
            "content": "a)恰好4个1？"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.691,
                0.593,
                0.705
            ],
            "angle": 0,
            "content": "b)至多4个1？"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.709,
                0.211,
                0.722
            ],
            "angle": 0,
            "content": "c)至少4个1？"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.709,
                0.704,
                0.723
            ],
            "angle": 0,
            "content": "d)0的个数和1的个数相等？"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.726,
                0.29,
                0.741
            ],
            "angle": 0,
            "content": "12. 多少个 12 位比特串包含"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.745,
                0.212,
                0.759
            ],
            "angle": 0,
            "content": "a)恰好3个1？"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.744,
                0.594,
                0.758
            ],
            "angle": 0,
            "content": "b)至多3个1？"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.763,
                0.211,
                0.776
            ],
            "angle": 0,
            "content": "c)至少3个1？"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.762,
                0.704,
                0.776
            ],
            "angle": 0,
            "content": "d)0的个数和1的个数相等？"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.78,
                0.756,
                0.794
            ],
            "angle": 0,
            "content": "13. 一个组有 \\( n \\) 个男士和 \\( n \\) 个女士。如果把他们男女相间地排成一排，有多少种方式？"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.797,
                0.497,
                0.811
            ],
            "angle": 0,
            "content": "14. 有多少种不同的方式选择两个小于 100 的正整数？"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.815,
                0.516,
                0.829
            ],
            "angle": 0,
            "content": "15. 有多少种不同的方式从英语字母表中选择 5 个字母？"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.833,
                0.525,
                0.847
            ],
            "angle": 0,
            "content": "16. 一个 10 个元素的集合有多少个子集含有奇数个元素？"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.851,
                0.571,
                0.864
            ],
            "angle": 0,
            "content": "17. 一个 100 个元素的集合有多少个子集包含的元素多于 2 个？"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.868,
                0.691,
                0.882
            ],
            "angle": 0,
            "content": "18. 一个硬币被掷 8 次，每次可能出现头像或者非头像。有多少种可能的结果"
        },
        {
            "type": "list",
            "bbox": [
                0.062,
                0.78,
                0.756,
                0.882
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.886,
                0.292,
                0.9
            ],
            "angle": 0,
            "content": "a)包含各种不同的情况？"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.886,
                0.655,
                0.9
            ],
            "angle": 0,
            "content": "b)包含恰好3个头像？"
        },
        {
            "type": "text",
            "bbox": [
                0.092,
                0.904,
                0.273,
                0.918
            ],
            "angle": 0,
            "content": "c)包含至少3个头像？"
        },
        {
            "type": "text",
            "bbox": [
                0.474,
                0.904,
                0.711,
                0.918
            ],
            "angle": 0,
            "content": "d)头像和非头像的数目相等？"
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.921,
                0.701,
                0.936
            ],
            "angle": 0,
            "content": "19. 一个硬币被掷10次，每次可能出现头像或者非头像。有多少种可能的结果"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.139,
                0.035,
                0.176,
                0.048
            ],
            "angle": 0,
            "content": "366"
        },
        {
            "type": "header",
            "bbox": [
                0.221,
                0.033,
                0.288,
                0.049
            ],
            "angle": 0,
            "content": "第6章"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.09,
                0.341,
                0.105
            ],
            "angle": 0,
            "content": "a)包含各种不同的情况？"
        },
        {
            "type": "text",
            "bbox": [
                0.526,
                0.091,
                0.705,
                0.104
            ],
            "angle": 0,
            "content": "b)包含恰好2个头像？"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.108,
                0.341,
                0.122
            ],
            "angle": 0,
            "content": "c)至多有3个不是头像？"
        },
        {
            "type": "text",
            "bbox": [
                0.526,
                0.108,
                0.761,
                0.122
            ],
            "angle": 0,
            "content": "d)头像和非头像的数目相等？"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.126,
                0.304,
                0.139
            ],
            "angle": 0,
            "content": "20. 多少个10位比特串"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.143,
                0.282,
                0.157
            ],
            "angle": 0,
            "content": "a)恰好有3个0？"
        },
        {
            "type": "text",
            "bbox": [
                0.526,
                0.143,
                0.626,
                0.156
            ],
            "angle": 0,
            "content": "b)0比1多？"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.161,
                0.28,
                0.174
            ],
            "angle": 0,
            "content": "c)至少有7个1？"
        },
        {
            "type": "text",
            "bbox": [
                0.526,
                0.161,
                0.663,
                0.174
            ],
            "angle": 0,
            "content": "d)至少有3个1？"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.178,
                0.427,
                0.192
            ],
            "angle": 0,
            "content": "21. 字母 ABCDEFG 有多少个排列包含"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.196,
                0.234,
                0.21
            ],
            "angle": 0,
            "content": "a) 串 BCD?"
        },
        {
            "type": "text",
            "bbox": [
                0.526,
                0.196,
                0.63,
                0.209
            ],
            "angle": 0,
            "content": "b) 串 CFGA?"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.214,
                0.274,
                0.227
            ],
            "angle": 0,
            "content": "c) 串 BA 和 GF?"
        },
        {
            "type": "text",
            "bbox": [
                0.526,
                0.214,
                0.668,
                0.227
            ],
            "angle": 0,
            "content": "d) 串 ABC 和 DE?"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.232,
                0.297,
                0.244
            ],
            "angle": 0,
            "content": "e)串ABC和CDE?"
        },
        {
            "type": "text",
            "bbox": [
                0.526,
                0.232,
                0.677,
                0.244
            ],
            "angle": 0,
            "content": "f)串CBA和BED?"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.248,
                0.442,
                0.262
            ],
            "angle": 0,
            "content": "22. 字母 ABCDEFGH 有多少个排列包含"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.267,
                0.222,
                0.28
            ],
            "angle": 0,
            "content": "a)串ED?"
        },
        {
            "type": "text",
            "bbox": [
                0.526,
                0.267,
                0.616,
                0.28
            ],
            "angle": 0,
            "content": "b) 串 CDE?"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.284,
                0.289,
                0.297
            ],
            "angle": 0,
            "content": "c)串BA和FGH？"
        },
        {
            "type": "text",
            "bbox": [
                0.526,
                0.284,
                0.704,
                0.297
            ],
            "angle": 0,
            "content": "d) 串 AB、DE 和 GH?"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.302,
                0.296,
                0.314
            ],
            "angle": 0,
            "content": "e)串CAB和BED?"
        },
        {
            "type": "text",
            "bbox": [
                0.526,
                0.302,
                0.678,
                0.314
            ],
            "angle": 0,
            "content": "f) 串 BCA 和 ABF?"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.319,
                0.959,
                0.351
            ],
            "angle": 0,
            "content": "23. 有多少种方式使得8个男士和5个女士站成一排并且没有两个女士彼此相邻？[提示：先排男士，然后考虑女士可能的位置。]"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.354,
                0.957,
                0.386
            ],
            "angle": 0,
            "content": "24. 有多少种方式使得10个女士和6个男士站成一排并且没有两个男士彼此相邻？[提示：先排女士，然后考虑男士可能的位置。]"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.389,
                0.573,
                0.404
            ],
            "angle": 0,
            "content": "25. 有多少种方式使得4个男士和5个女士站成一排，且"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.408,
                0.322,
                0.421
            ],
            "angle": 0,
            "content": "a)所有男士站在一起？"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.425,
                0.323,
                0.438
            ],
            "angle": 0,
            "content": "b)所有女士站在一起？"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.442,
                0.591,
                0.456
            ],
            "angle": 0,
            "content": "26. 有多少种方式使得3只海鹦鹉和6只企鹅站成一排，且"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.46,
                0.339,
                0.473
            ],
            "angle": 0,
            "content": "c)所有海鹦鹉站在一起？"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.478,
                0.323,
                0.491
            ],
            "angle": 0,
            "content": "d)所有企鹅站在一起？"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.494,
                0.957,
                0.527
            ],
            "angle": 0,
            "content": "27. 把编号为 1, 2, …, 100 的 100 张票卖给 100 个不同的人来抽奖。有 4 项不同的奖，包括 1 项大奖（到塔希提岛旅游）。如果满足下面的条件，有多少种不同的抽奖方式？"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.53,
                0.246,
                0.544
            ],
            "angle": 0,
            "content": "a)没有限制。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.548,
                0.368,
                0.561
            ],
            "angle": 0,
            "content": "b)拿47号票的人赢了大奖。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.566,
                0.384,
                0.579
            ],
            "angle": 0,
            "content": "c)拿47号票的人赢了一项奖。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.583,
                0.349,
                0.597
            ],
            "angle": 0,
            "content": "d)拿47号票的人没赢奖。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.601,
                0.411,
                0.614
            ],
            "angle": 0,
            "content": "e)拿19和47号票的人都赢了奖。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.618,
                0.448,
                0.632
            ],
            "angle": 0,
            "content": "f)拿19、47和73号票的人都赢了奖。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.636,
                0.486,
                0.649
            ],
            "angle": 0,
            "content": "g)拿19、47、73和97号票的人都赢了奖。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.653,
                0.487,
                0.666
            ],
            "angle": 0,
            "content": "h)拿19、47、73和97号票的人都没赢奖。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.671,
                0.483,
                0.684
            ],
            "angle": 0,
            "content": "i)拿19、47、73或97号票的人赢了大奖。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.688,
                0.651,
                0.702
            ],
            "angle": 0,
            "content": "j)拿19和47号票的人赢了奖，但拿73和97号票的人没赢奖。"
        },
        {
            "type": "list",
            "bbox": [
                0.143,
                0.53,
                0.651,
                0.702
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.706,
                0.442,
                0.719
            ],
            "angle": 0,
            "content": "28. 一个垒球队的13个人出席一场比赛。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.724,
                0.424,
                0.737
            ],
            "angle": 0,
            "content": "a)有多少种方式选10个选手上场？"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.741,
                0.62,
                0.754
            ],
            "angle": 0,
            "content": "b)有多少种方式从13个在场的人中分配10个选手的位置？"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.758,
                0.958,
                0.79
            ],
            "angle": 0,
            "content": "c)13个出席的人中有3个女士。如果上场的选手中要求至少有一个女士，那么有多少种方式选择10个选手？"
        },
        {
            "type": "list",
            "bbox": [
                0.143,
                0.724,
                0.958,
                0.79
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.794,
                0.35,
                0.808
            ],
            "angle": 0,
            "content": "29. 一个俱乐部有25个成员。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.811,
                0.543,
                0.825
            ],
            "angle": 0,
            "content": "a)有多少种方式从中选择4个人作为董事会成员。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.829,
                0.658,
                0.842
            ],
            "angle": 0,
            "content": "b)有多少种方式从中选出俱乐部的主席、副主席、书记和会计？"
        },
        {
            "type": "list",
            "bbox": [
                0.143,
                0.811,
                0.658,
                0.842
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.846,
                0.957,
                0.878
            ],
            "angle": 0,
            "content": "30. 一个教授写了40道离散数学的真假判定题。在这些题中有17个语句为真。如果可以按照任意次序排列这些题，可能有多少种不同的答案？"
        },
        {
            "type": "text",
            "bbox": [
                0.096,
                0.881,
                0.891,
                0.895
            ],
            "angle": 0,
            "content": "* 31. 用不超过 100 的正整数构成 4 排列, 其中有多少个排列包含 3 个连续的整数 \\( k \\) 、 \\( k + 1 \\) 、 \\( k + 2 \\)?"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.899,
                0.858,
                0.913
            ],
            "angle": 0,
            "content": "a) 这里的连续指按照整数通常的顺序，并且这些连续整数可能被排列中的其他整数分开。"
        },
        {
            "type": "text",
            "bbox": [
                0.143,
                0.917,
                0.748,
                0.93
            ],
            "angle": 0,
            "content": "b)这里的连续不但指整数是连续的，而且它们在排列中的位置也是连续的。"
        },
        {
            "type": "list",
            "bbox": [
                0.143,
                0.899,
                0.858,
                0.93
            ],
            "angle": 0,
            "content": null
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.695,
                0.039,
                0.785,
                0.054
            ],
            "angle": 0,
            "content": "计数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.83,
                0.04,
                0.868,
                0.054
            ],
            "angle": 0,
            "content": "367"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.095,
                0.461,
                0.11
            ],
            "angle": 0,
            "content": "32.一所学校的数学系有7名女教师和9名男教师。"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.114,
                0.648,
                0.128
            ],
            "angle": 0,
            "content": "a)有多少种方式从中选出5人的委员会并使其中包含至少1名女教师？"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.132,
                0.794,
                0.146
            ],
            "angle": 0,
            "content": "b)有多少种方式从中选出5人的委员会并使其中包含至少1名女教师和至少1名男教师。"
        },
        {
            "type": "list",
            "bbox": [
                0.076,
                0.114,
                0.794,
                0.146
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.149,
                0.895,
                0.182
            ],
            "angle": 0,
            "content": "33. 英语字母表中包含 21 个辅音和 5 个元音。由英语字母表的 6 个小写字母可构成多少字符串使得它们包含"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.185,
                0.22,
                0.2
            ],
            "angle": 0,
            "content": "a)恰好1个元音？"
        },
        {
            "type": "text",
            "bbox": [
                0.459,
                0.185,
                0.602,
                0.2
            ],
            "angle": 0,
            "content": "b)恰好2个元音？"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.203,
                0.219,
                0.217
            ],
            "angle": 0,
            "content": "c)至少1个元音？"
        },
        {
            "type": "text",
            "bbox": [
                0.459,
                0.203,
                0.602,
                0.217
            ],
            "angle": 0,
            "content": "d)至少2个元音？"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.221,
                0.601,
                0.235
            ],
            "angle": 0,
            "content": "34. 由英语字母表中的6个小写字母可构成多少字符串使得它们包含"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.239,
                0.16,
                0.253
            ],
            "angle": 0,
            "content": "a)字母a？"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.256,
                0.197,
                0.27
            ],
            "angle": 0,
            "content": "b)字母a和b？"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.274,
                0.658,
                0.289
            ],
            "angle": 0,
            "content": "c)字母a和b，其中a在b前边的邻接位置，同时所有的字母都不相同？"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.292,
                0.661,
                0.307
            ],
            "angle": 0,
            "content": "d)字母a和b，其中a在b左边的某个位置，同时所有的字母都不相同？"
        },
        {
            "type": "list",
            "bbox": [
                0.076,
                0.239,
                0.661,
                0.307
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.31,
                0.895,
                0.342
            ],
            "angle": 0,
            "content": "35. 假定某个系包含 10 名男士和 15 名女士。有多少种方式组成一个 6 人委员会且使得它含有相同数量的男士和女士？"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.345,
                0.894,
                0.378
            ],
            "angle": 0,
            "content": "36. 假定某个系包含 10 名男士和 15 名女士。有多少种方式组成一个 6 人委员会且使得它含有的女士比男士多？"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.381,
                0.685,
                0.395
            ],
            "angle": 0,
            "content": "37. 有多少个比特串恰好包含8个0和10个1，如果每个0后面紧跟着1个1？"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.399,
                0.685,
                0.414
            ],
            "angle": 0,
            "content": "38. 有多少个比特串恰好包含5个0和14个1，如果每个0后面紧跟着2个1？"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.417,
                0.503,
                0.431
            ],
            "angle": 0,
            "content": "39. 有多少个10位比特串包含至少3个1和至少3个0？"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.435,
                0.895,
                0.467
            ],
            "angle": 0,
            "content": "40. 有多少种方式从联合国中选择 12 个国家成为理事国且使得 3 个选自 45 个国家的一组，4 个选自 57 个国家的一组，其他的选自剩下的 69 个国家？"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.47,
                0.74,
                0.485
            ],
            "angle": 0,
            "content": "41. 有多少种方式用3个字母后跟3个数字组成汽车牌照且没有字母和数字出现2次？"
        },
        {
            "type": "list",
            "bbox": [
                0.047,
                0.31,
                0.895,
                0.485
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.489,
                0.894,
                0.521
            ],
            "angle": 0,
            "content": "\\(n\\) 个人的 \\(r\\) 圆排列是 \\(n\\) 个人中取 \\(r\\) 个人安排在圆桌旁坐下的方式，如果圆桌转动能使得两个方案成为同一方案，那么这两种方案只算一种。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.524,
                0.273,
                0.538
            ],
            "angle": 0,
            "content": "42. 计算5个人的3圆排列。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.542,
                0.309,
                0.556
            ],
            "angle": 0,
            "content": "43. 找到 \\(n\\) 个人的 \\(r\\) 圆排列公式。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.56,
                0.81,
                0.574
            ],
            "angle": 0,
            "content": "44. 找到 \\( n \\) 个人取 \\( r \\) 人围坐圆桌的安排方式，当每个人有相同邻座不考虑左右时只算一种方式。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.578,
                0.807,
                0.592
            ],
            "angle": 0,
            "content": "45. 如果允许出现并列名次，3匹马参加马赛有多少种结果？[注意：可以2匹或3匹马并列。]"
        },
        {
            "type": "text",
            "bbox": [
                0.035,
                0.595,
                0.891,
                0.628
            ],
            "angle": 0,
            "content": "* 46. 如果允许并列名次，4匹马参加马赛有多少种结果？[注意：由于允许并列名次，4匹马中多少匹并列都是可能的。]"
        },
        {
            "type": "text",
            "bbox": [
                0.034,
                0.631,
                0.891,
                0.664
            ],
            "angle": 0,
            "content": "* 47. 有6名运动员参加百米赛跑。如果允许并列名次，有多少种方式授予3块奖牌？（跑得最快的运动员得金牌，恰好只被一个运动员超过的运动员得银牌，恰好被2个运动员超过的运动员得铜牌。）"
        },
        {
            "type": "text",
            "bbox": [
                0.034,
                0.667,
                0.894,
                0.735
            ],
            "angle": 0,
            "content": "* 48. 为了避免世界杯足球锦标赛总决赛中出现并列名次，通常采用下述过程：每个队按照预定的顺序选出5名球员。每名球员罚一个球，第一队的球员先罚，接着第二队的球员再罚，依照指定的顺序依次交替罚球。如果在10次罚球后得分还相等，再次重复这个过程。如果在20次罚球后得分仍旧相等，进行加赛时间的射门，第一个得分的队得胜。"
        },
        {
            "type": "list",
            "bbox": [
                0.034,
                0.595,
                0.894,
                0.735
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.738,
                0.891,
                0.771
            ],
            "angle": 0,
            "content": "a)如果比赛进行第一轮的10个罚球，并且这轮比赛结束时一个队不可能与另一个队得分相等，那么有多少种不同的得分场面？"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.774,
                0.803,
                0.788
            ],
            "angle": 0,
            "content": "b)如果比赛进行第二轮的10个罚球，对第一和第二轮罚球可能有多少种不同的得分场面？"
        },
        {
            "type": "text",
            "bbox": [
                0.076,
                0.792,
                0.886,
                0.806
            ],
            "angle": 0,
            "content": "c)如果比赛在两轮每队罚5个球的加赛以后最多再射门10次，那么整个加赛过程可能有多少种得分场面？"
        },
        {
            "type": "list",
            "bbox": [
                0.076,
                0.738,
                0.891,
                0.806
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.047,
                0.822,
                0.351,
                0.84
            ],
            "angle": 0,
            "content": "6.4 二项式系数和恒等式"
        },
        {
            "type": "text",
            "bbox": [
                0.046,
                0.854,
                0.894,
                0.941
            ],
            "angle": 0,
            "content": "正如在6.3节谈到的，具有 \\(n\\) 个元素的集合的 \\(r\\) 组合数常常记作 \\(\\binom{n}{r}\\) 。由于这些数出现在二项式的幂 \\((a + b)^n\\) 的展开式中作为系数，所以这些数叫作二项式系数。我们将讨论二项式定理，这个定理将二项式的幂表示成与二项式系数有关的项之和。我们将用组合证明来证明这个定理。我们也将说明怎样用组合证明来建立某些恒等式，它们是表示二项式系数之间关系的许"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.14,
                0.038,
                0.176,
                0.052
            ],
            "angle": 0,
            "content": "368"
        },
        {
            "type": "header",
            "bbox": [
                0.223,
                0.037,
                0.288,
                0.052
            ],
            "angle": 0,
            "content": "第6章"
        },
        {
            "type": "text",
            "bbox": [
                0.112,
                0.094,
                0.352,
                0.11
            ],
            "angle": 0,
            "content": "多不同恒等式中的一部分。"
        },
        {
            "type": "title",
            "bbox": [
                0.111,
                0.121,
                0.31,
                0.138
            ],
            "angle": 0,
            "content": "6.4.1 二项式定理"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.141,
                0.962,
                0.176
            ],
            "angle": 0,
            "content": "二项式定理给出了二项式幂的展开式的系数。一个二项式只不过是两项的和，例如 \\(x + y\\)。（这些项可以是常数与变量的积，但这里先不考虑。）"
        },
        {
            "type": "text",
            "bbox": [
                0.152,
                0.179,
                0.786,
                0.196
            ],
            "angle": 0,
            "content": "例1说明怎样计算典型展开式中的系数，为二项式定理的表述做准备。"
        },
        {
            "type": "text",
            "bbox": [
                0.111,
                0.2,
                0.967,
                0.391
            ],
            "angle": 0,
            "content": "例1 \\((x + y)^{3}\\) 的展开式可以使用组合推理而不是用三个项的乘法得到。当 \\((x + y)^{3} = (x + y)(x + y)(x + y)\\) 被展开时，把所有由第一个和的一项、第二个和的一项与第三个和的一项产生的乘积加起来。从而出现了形如 \\(x^{3}, x^{2}y, xy^{2}\\) 和 \\(y^{3}\\) 的项。为得到形如 \\(x^{3}\\) 的项，在每个和中必须选择一个 \\(x\\) ，只有一种方式能做到这一点。因此，乘积中 \\(x^{3}\\) 项的系数是1。为得到形如 \\(x^{2}y\\) 的项，必须从三个和中的两个和中选择 \\(x\\) （而因此在另一个和中选择 \\(y\\) 。于是，这种项的个数是三个对象的2组合数，即 \\(\\binom{3}{2}\\) 。类似地，形如 \\(xy^{2}\\) 项的个数是三个和中选一个来提供 \\(x\\) 的方式数（而另两个和中都要选 \\(y\\) ），有 \\(\\binom{3}{1}\\) 种方式能够做到这一点。最后，得到 \\(y^{3}\\) 的唯一方式是三个和的每一个都选择 \\(y\\) ，恰好有一种方式能够做到这一点。因此得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.245,
                0.395,
                0.839,
                0.448
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} (x + y) ^ {3} = (x + y) (x + y) (x + y) = (x x + x y + y x + y y) (x + y) \\\\ = x x x + x x y + x y x + x y y + y x x + y x y + y y x + y y y \\\\ = x ^ {3} + 3 x ^ {2} y + 3 x y ^ {2} + y ^ {3} \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.157,
                0.451,
                0.357,
                0.467
            ],
            "angle": 0,
            "content": "现在叙述二项式定理。"
        },
        {
            "type": "text",
            "bbox": [
                0.167,
                0.476,
                0.708,
                0.493
            ],
            "angle": 0,
            "content": "定理1二项式定理 设 \\(x\\) 和 \\(y\\) 是变量，\\(n\\) 是非负整数，那么"
        },
        {
            "type": "equation",
            "bbox": [
                0.195,
                0.497,
                0.887,
                0.532
            ],
            "angle": 0,
            "content": "\\[\n(x + y) ^ {n} = \\sum_ {j = 0} ^ {n} {\\binom {n} {j}} x ^ {n - j} y ^ {j} = {\\binom {n} {0}} x ^ {n} + {\\binom {n} {1}} x ^ {n - 1} y + \\dots + {\\binom {n} {n - 1}} x y ^ {n - 1} + {\\binom {n} {n}} y ^ {n}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.116,
                0.541,
                0.968,
                0.614
            ],
            "angle": 0,
            "content": "证明 这里给出定理的组合证明。当乘积被展开时其中的项都是下述形式：\\(x^{n - j}y^j (j = 0,1,2,\\dots ,n)\\) 。为计数形如 \\(x^{n - j}y^{j}\\) 的项数，必须从 \\(n\\) 个和中选 \\(n - j\\) 个 \\(x\\) （从而乘积中其他的 \\(j\\) 个项都是 \\(y\\) )才能得到这种项。因此，\\(x^{n - j}y^{j}\\) 的系数是 \\(\\binom{n}{n-j}\\)，它等于 \\(\\binom{n}{j}\\)，定理得证。"
        },
        {
            "type": "text",
            "bbox": [
                0.157,
                0.617,
                0.472,
                0.633
            ],
            "angle": 0,
            "content": "例 \\(2\\sim 4\\) 说明了二项式定理的应用。"
        },
        {
            "type": "text",
            "bbox": [
                0.157,
                0.638,
                0.452,
                0.656
            ],
            "angle": 0,
            "content": "例2 \\((x + y)^4\\) 的展开式是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.158,
                0.66,
                0.371,
                0.676
            ],
            "angle": 0,
            "content": "解 由二项式定理得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.286,
                0.681,
                0.805,
                0.772
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} (x + y) ^ {4} = \\sum_ {j = 0} ^ {4} \\binom {4} {j} x ^ {4 - j} y ^ {j} \\\\ = \\binom {4} {0} x ^ {4} + \\binom {4} {1} x ^ {3} y + \\binom {4} {2} x ^ {2} y ^ {2} + \\binom {4} {3} x y ^ {3} + \\binom {4} {4} y ^ {4} \\\\ = x ^ {4} + 4 x ^ {3} y + 6 x ^ {2} y ^ {2} + 4 x y ^ {3} + y ^ {4} \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.158,
                0.778,
                0.611,
                0.795
            ],
            "angle": 0,
            "content": "例3 在 \\((x + y)^{25}\\) 的展开式中 \\(x^{12}y^{13}\\) 的系数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.158,
                0.801,
                0.475,
                0.816
            ],
            "angle": 0,
            "content": "解 由二项式定理得到这个系数是"
        },
        {
            "type": "equation",
            "bbox": [
                0.425,
                0.821,
                0.672,
                0.853
            ],
            "angle": 0,
            "content": "\\[\n\\binom {2 5} {1 3} = \\frac {2 5 !}{1 3 ! 1 2 !} = 5 2 0 0 3 0 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.159,
                0.859,
                0.633,
                0.876
            ],
            "angle": 0,
            "content": "例4 在 \\((2x - 3y)^{25}\\) 的展开式中 \\(x^{12}y^{13}\\) 的系数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.158,
                0.882,
                0.819,
                0.898
            ],
            "angle": 0,
            "content": "解 首先注意到这个表达式等于 \\((2x + (-3y))^{25}\\) 。由二项式定理，我们有"
        },
        {
            "type": "equation",
            "bbox": [
                0.352,
                0.901,
                0.743,
                0.936
            ],
            "angle": 0,
            "content": "\\[\n(2 x + (- 3 y)) ^ {2 5} = \\sum_ {j = 0} ^ {2 5} \\binom {2 5} {j} (2 x) ^ {2 5 - j} (- 3 y) ^ {j}\n\\]"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.685,
                0.037,
                0.778,
                0.052
            ],
            "angle": 0,
            "content": "计数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.821,
                0.037,
                0.857,
                0.052
            ],
            "angle": 0,
            "content": "369"
        },
        {
            "type": "text",
            "bbox": [
                0.037,
                0.093,
                0.485,
                0.11
            ],
            "angle": 0,
            "content": "因此，当 \\(j = 13\\) 时得到展开式中 \\(x^{12}y^{13}\\) 的系数，即"
        },
        {
            "type": "equation",
            "bbox": [
                0.313,
                0.113,
                0.611,
                0.144
            ],
            "angle": 0,
            "content": "\\[\n\\binom {2 5} {1 3} 2 ^ {1 2} (- 3) ^ {1 3} = - \\frac {2 5 !}{1 3 ! 1 2 !} 2 ^ {1 2} 3 ^ {1 3}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.077,
                0.148,
                0.741,
                0.166
            ],
            "angle": 0,
            "content": "我们可以用二项式定理证明某些有用的恒等式。正如推论1、2和3所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.089,
                0.174,
                0.374,
                0.191
            ],
            "angle": 0,
            "content": "推论1 设 \\(n\\) 为非负整数，那么"
        },
        {
            "type": "equation",
            "bbox": [
                0.404,
                0.196,
                0.518,
                0.228
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {k = 0} ^ {n} \\binom {n} {k} = 2 ^ {n}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.239,
                0.512,
                0.255
            ],
            "angle": 0,
            "content": "证明 用二项式定理，令 \\(x = 1\\) 和 \\(y = 1\\) ，我们有"
        },
        {
            "type": "equation",
            "bbox": [
                0.275,
                0.259,
                0.651,
                0.292
            ],
            "angle": 0,
            "content": "\\[\n2 ^ {n} = (1 + 1) ^ {n} = \\sum_ {k = 0} ^ {n} \\binom {n} {k} 1 ^ {k} 1 ^ {n - k} = \\sum_ {k = 0} ^ {n} \\binom {n} {k}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.04,
                0.295,
                0.238,
                0.311
            ],
            "angle": 0,
            "content": "这正是所需要的结果。"
        },
        {
            "type": "text",
            "bbox": [
                0.078,
                0.314,
                0.589,
                0.33
            ],
            "angle": 0,
            "content": "推论1也有一个好的组合证明，我们现在给出这个证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.04,
                0.332,
                0.892,
                0.422
            ],
            "angle": 0,
            "content": "证明 一个 \\(n\\) 元素集合有 \\(2^n\\) 个不同的子集。每个子集有0个元素，1个元素，2个元素，…，\\(n\\) 个元素。具有0个元素的子集有 \\(\\binom{n}{0}\\) 个，1个元素的子集有 \\(\\binom{n}{1}\\) 个，2个元素的子集有 \\(\\binom{n}{2}\\) 个，…，\\(n\\) 个元素的子集有 \\(\\binom{n}{n}\\) 个。于是"
        },
        {
            "type": "equation",
            "bbox": [
                0.431,
                0.427,
                0.502,
                0.46
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {k = 0} ^ {n} \\left( \\begin{array}{c} n \\\\ k \\end{array} \\right)\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.043,
                0.462,
                0.414,
                0.479
            ],
            "angle": 0,
            "content": "计数了 \\(n\\) 元素集合的子集总数。这证明了"
        },
        {
            "type": "equation",
            "bbox": [
                0.411,
                0.483,
                0.524,
                0.516
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {k = 0} ^ {n} \\binom {n} {k} = 2 ^ {n}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.525,
                0.357,
                0.541
            ],
            "angle": 0,
            "content": "推论2 设 \\(n\\) 是正整数，那么"
        },
        {
            "type": "equation",
            "bbox": [
                0.384,
                0.546,
                0.55,
                0.579
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {k = 0} ^ {n} (- 1) ^ {k} \\binom {n} {k} = 0\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.59,
                0.315,
                0.606
            ],
            "angle": 0,
            "content": "证明 由二项式定理得出"
        },
        {
            "type": "equation",
            "bbox": [
                0.19,
                0.608,
                0.745,
                0.643
            ],
            "angle": 0,
            "content": "\\[\n0 = 0 ^ {n} = ((- 1) + 1) ^ {n} = \\sum_ {k = 0} ^ {n} \\binom {n} {k} (- 1) ^ {k} 1 ^ {n - k} = \\sum_ {k = 0} ^ {n} \\binom {n} {k} (- 1) ^ {k}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.646,
                0.202,
                0.661
            ],
            "angle": 0,
            "content": "从而证明了推论。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.671,
                0.254,
                0.687
            ],
            "angle": 0,
            "content": "评注 推论2推出"
        },
        {
            "type": "equation",
            "bbox": [
                0.265,
                0.691,
                0.679,
                0.723
            ],
            "angle": 0,
            "content": "\\[\n\\binom {n} {0} + \\binom {n} {2} + \\binom {n} {4} + \\dots = \\binom {n} {1} + \\binom {n} {3} + \\binom {n} {5} + \\dots\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.746,
                0.383,
                0.762
            ],
            "angle": 0,
            "content": "推论3 设 \\(n\\) 是非负整数，那么"
        },
        {
            "type": "equation",
            "bbox": [
                0.402,
                0.766,
                0.537,
                0.801
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {k = 0} ^ {n} 2 ^ {k} \\binom {n} {k} = 3 ^ {n}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.05,
                0.809,
                0.897,
                0.844
            ],
            "angle": 0,
            "content": "证明 这个公式的左边是二项式定理提供的对 \\((1 + 2)^n\\) 的展开式，因此，由二项式定理可以看出"
        },
        {
            "type": "equation",
            "bbox": [
                0.301,
                0.848,
                0.644,
                0.881
            ],
            "angle": 0,
            "content": "\\[\n(1 + 2) ^ {n} = \\sum_ {k = 0} ^ {n} \\binom {n} {k} 1 ^ {n - k} 2 ^ {k} = \\sum_ {k = 0} ^ {n} \\binom {n} {k} 2 ^ {k}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.052,
                0.885,
                0.097,
                0.9
            ],
            "angle": 0,
            "content": "因此"
        },
        {
            "type": "equation",
            "bbox": [
                0.406,
                0.904,
                0.543,
                0.937
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {k = 0} ^ {n} 2 ^ {k} \\binom {n} {k} = 3 ^ {n}\n\\]"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.151,
                0.038,
                0.186,
                0.052
            ],
            "angle": 0,
            "content": "370"
        },
        {
            "type": "header",
            "bbox": [
                0.232,
                0.037,
                0.298,
                0.053
            ],
            "angle": 0,
            "content": "第6章"
        },
        {
            "type": "title",
            "bbox": [
                0.12,
                0.102,
                0.431,
                0.119
            ],
            "angle": 0,
            "content": "6.4.2 帕斯卡恒等式和三角形"
        },
        {
            "type": "text",
            "bbox": [
                0.162,
                0.122,
                0.856,
                0.139
            ],
            "angle": 0,
            "content": "二项式系数满足许多不同的恒等式。现在我们介绍其中最重要的一些恒等式。"
        },
        {
            "type": "text",
            "bbox": [
                0.17,
                0.147,
                0.757,
                0.165
            ],
            "angle": 0,
            "content": "定理2 帕斯卡恒等式 设 \\(n\\) 和 \\(k\\) 是满足 \\(n \\geqslant k\\) 的正整数，那么有"
        },
        {
            "type": "equation",
            "bbox": [
                0.433,
                0.168,
                0.657,
                0.201
            ],
            "angle": 0,
            "content": "\\[\n\\binom {n + 1} {k} = \\binom {n} {k - 1} + \\binom {n} {k}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.212,
                0.972,
                0.359
            ],
            "angle": 0,
            "content": "证明 我们将采用组合证明方法。假定 \\(T\\) 是包含 \\(n + 1\\) 个元素的集合。令 \\(a\\) 是 \\(T\\) 的一个元素且 \\(S = T - \\{a\\}\\) 。注意，\\(T\\) 的包含 \\(k\\) 个元素的子集有 \\(\\binom{n+1}{k}\\) 个。然而 \\(T\\) 的包含 \\(k\\) 个元素的子集或者包含 \\(a\\) 和 \\(S\\) 中的 \\(k - 1\\) 个元素，或者不包含 \\(a\\) 但包含 \\(S\\) 中的 \\(k\\) 个元素。由于 \\(S\\) 的 \\(k - 1\\) 元子集有 \\(\\binom{n}{k-1}\\) 个，所以 \\(T\\) 含 \\(a\\) 在内的 \\(k\\) 元子集有 \\(\\binom{n}{k-1}\\) 个。又由于 \\(S\\) 的 \\(k\\) 元子集有 \\(\\binom{n}{k}\\) 个，所以 \\(T\\) 的不含 \\(a\\) 的 \\(k\\) 元子集有 \\(\\binom{n}{k}\\) 个。从而得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.433,
                0.365,
                0.66,
                0.398
            ],
            "angle": 0,
            "content": "\\[\n\\binom {n + 1} {k} = \\binom {n} {k - 1} + \\binom {n} {k}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.119,
                0.409,
                0.968,
                0.457
            ],
            "angle": 0,
            "content": "评注这里给出了帕斯卡恒等式的一个组合证明。也可以从关于 \\(\\binom{n}{r}\\) 的公式通过代数推导来证明这个恒等式（见本节练习23）。"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.464,
                0.967,
                0.514
            ],
            "angle": 0,
            "content": "评注 对所有整数 \\(n\\)，可以用帕斯卡恒等式和初始条件 \\(\\binom{n}{0}=\\binom{n}{n}=1\\) 递归地定义二项式系数。这些递归定义用于计算二项式系数，因为使用这些递归定义只需要整数加法。"
        },
        {
            "type": "text",
            "bbox": [
                0.157,
                0.523,
                0.832,
                0.539
            ],
            "angle": 0,
            "content": "帕斯卡恒等式是二项式系数以三角形表示的几何排列的基础，如图1所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.358,
                0.546,
                0.393,
                0.567
            ],
            "angle": 0,
            "content": "(0)"
        },
        {
            "type": "text",
            "bbox": [
                0.338,
                0.573,
                0.411,
                0.596
            ],
            "angle": 0,
            "content": "(1) (1)"
        },
        {
            "type": "text",
            "bbox": [
                0.318,
                0.6,
                0.43,
                0.623
            ],
            "angle": 0,
            "content": "\\(\\binom{2}{0}\\binom{2}{1}\\binom{2}{2}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.297,
                0.627,
                0.45,
                0.65
            ],
            "angle": 0,
            "content": "(3) (3) (3) (3)"
        },
        {
            "type": "text",
            "bbox": [
                0.277,
                0.656,
                0.47,
                0.678
            ],
            "angle": 0,
            "content": "(4) (4) (4) (4) (4)"
        },
        {
            "type": "text",
            "bbox": [
                0.258,
                0.683,
                0.489,
                0.706
            ],
            "angle": 0,
            "content": "(5) (5) (5) (5) (5) (5)"
        },
        {
            "type": "text",
            "bbox": [
                0.236,
                0.711,
                0.509,
                0.734
            ],
            "angle": 0,
            "content": "(6) (6) (6) (6) (6) (6) (6)"
        },
        {
            "type": "text",
            "bbox": [
                0.215,
                0.739,
                0.525,
                0.762
            ],
            "angle": 0,
            "content": "(7) (7) (7) (7) (7) (7) (7) (7) (7)"
        },
        {
            "type": "text",
            "bbox": [
                0.195,
                0.767,
                0.545,
                0.79
            ],
            "angle": 0,
            "content": "(8) (8) (8) (8) (8) (8) (8) (8) (8) (8) (8)"
        },
        {
            "type": "text",
            "bbox": [
                0.364,
                0.821,
                0.385,
                0.832
            ],
            "angle": 0,
            "content": "a）"
        },
        {
            "type": "text",
            "bbox": [
                0.509,
                0.609,
                0.634,
                0.625
            ],
            "angle": 0,
            "content": "由帕斯卡恒等式："
        },
        {
            "type": "text",
            "bbox": [
                0.507,
                0.628,
                0.636,
                0.649
            ],
            "angle": 0,
            "content": "\\(\\binom{6}{4}+\\binom{6}{5}=\\binom{7}{5}\\)"
        },
        {
            "type": "text",
            "bbox": [
                0.678,
                0.608,
                0.789,
                0.621
            ],
            "angle": 0,
            "content": "1 2 1"
        },
        {
            "type": "text",
            "bbox": [
                0.695,
                0.634,
                0.806,
                0.647
            ],
            "angle": 0,
            "content": "1 3 3 1"
        },
        {
            "type": "text",
            "bbox": [
                0.678,
                0.663,
                0.823,
                0.676
            ],
            "angle": 0,
            "content": "1 4 6 4 1"
        },
        {
            "type": "text",
            "bbox": [
                0.663,
                0.69,
                0.839,
                0.702
            ],
            "angle": 0,
            "content": "1 5 10 10 5 1"
        },
        {
            "type": "text",
            "bbox": [
                0.648,
                0.717,
                0.855,
                0.731
            ],
            "angle": 0,
            "content": "1 6 15 20 15 6 1"
        },
        {
            "type": "text",
            "bbox": [
                0.634,
                0.747,
                0.875,
                0.76
            ],
            "angle": 0,
            "content": "1 7 21 35 35 21 7 1"
        },
        {
            "type": "text",
            "bbox": [
                0.613,
                0.775,
                0.89,
                0.787
            ],
            "angle": 0,
            "content": "1 8 28 56 70 56 28 8 1"
        },
        {
            "type": "text",
            "bbox": [
                0.736,
                0.821,
                0.756,
                0.832
            ],
            "angle": 0,
            "content": "b）"
        },
        {
            "type": "image_caption",
            "bbox": [
                0.456,
                0.843,
                0.625,
                0.858
            ],
            "angle": 0,
            "content": "图1 帕斯卡三角形"
        },
        {
            "type": "text",
            "bbox": [
                0.156,
                0.868,
                0.472,
                0.884
            ],
            "angle": 0,
            "content": "这个三角形的第 \\(n\\) 行由二项式系数"
        },
        {
            "type": "equation",
            "bbox": [
                0.451,
                0.891,
                0.637,
                0.922
            ],
            "angle": 0,
            "content": "\\[\n\\binom {n} {k} \\quad k = 0, 1, \\dots , n\n\\]"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.693,
                0.038,
                0.78,
                0.051
            ],
            "angle": 0,
            "content": "计数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.828,
                0.039,
                0.86,
                0.051
            ],
            "angle": 0,
            "content": "371"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.093,
                0.893,
                0.129
            ],
            "angle": 0,
            "content": "组成。这个三角形叫作帕斯卡三角形。帕斯卡恒等式证明，当这个三角形中两个相邻的二项式系数相加时，就产生了下一行在这两个系数之间的二项式系数。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.131,
                0.894,
                0.244
            ],
            "angle": 0,
            "content": "在帕斯卡发现帕斯卡三角形的多个世纪之前，这个三角形有一段漫长和古老的历史。在东方，二次项系数和帕斯卡恒等式在公元前2世纪就被印度数学家平伽拉发现。此后，印度数学家将关于帕斯卡三角形的论述写在上个千年前半叶出版的书籍中。波斯数学家卡拉吉和多才多艺的奥马尔·哈耶姆分别在11世纪和12世纪写过关于帕斯卡三角形的内容。在伊朗，帕斯卡三角形被称为哈亚姆三角形。这个三角形在11世纪由中国数学家贾宪发现，13世纪杨辉就写过关于这种三角的描述。在中国，帕斯卡三角通常被称为杨辉三角。"
        },
        {
            "type": "text",
            "bbox": [
                0.047,
                0.246,
                0.894,
                0.359
            ],
            "angle": 0,
            "content": "在西方，帕斯卡三角形出现在一本1527年的商业计算书的首页。作者是德国学者佩特鲁斯·阿皮纳斯。在意大利，帕斯卡三角被称为塔塔格里亚三角，以意大利数学家尼科罗·方塔纳·塔塔格里亚的名字命名，他1556年出版的书中列出了三角形的前几排。帕斯卡的著作《三角算术》(1655年去世后出版)介绍了这个三角形。帕斯卡搜集了几个关于它的结果，并以此解决一些概率论上的问题。后来法国数学家以帕斯卡命名这个三角形。1730年，亚伯拉罕·德莫伊夫尔创造了“帕斯卡的算术三角形”这一表述，后来成为“帕斯卡三角形”。"
        },
        {
            "type": "title",
            "bbox": [
                0.047,
                0.369,
                0.373,
                0.387
            ],
            "angle": 0,
            "content": "6.4.3 其他的二项式系数恒等式"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.389,
                0.879,
                0.406
            ],
            "angle": 0,
            "content": "我们从众多二项式系数恒等式中选择两个恒等式，用它们的组合证明来作为本节的结束。"
        },
        {
            "type": "text",
            "bbox": [
                0.095,
                0.415,
                0.822,
                0.432
            ],
            "angle": 0,
            "content": "定理3 范德蒙德恒等式 设 \\(m, n\\) 和 \\(r\\) 是非负整数，其中 \\(r\\) 不超过 \\(m\\) 或 \\(n\\) ，那么"
        },
        {
            "type": "equation",
            "bbox": [
                0.347,
                0.436,
                0.586,
                0.47
            ],
            "angle": 0,
            "content": "\\[\n\\binom {m + n} {r} = \\sum_ {k = 0} ^ {r} \\binom {m} {r - k} \\binom {n} {k}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.48,
                0.755,
                0.496
            ],
            "angle": 0,
            "content": "评注 这个恒等式是由18世纪数学家亚历山大-舍费尔·范德蒙德发现的。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.499,
                0.891,
                0.551
            ],
            "angle": 0,
            "content": "证明 假定在第一个集合中有 \\(m\\) 项，第二个集合中有 \\(n\\) 项。从这两个集合的并集中取 \\(r\\) 个元素的方式数是 \\(\\binom{m+n}{r}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.556,
                0.894,
                0.668
            ],
            "angle": 0,
            "content": "从并集中取 \\(r\\) 个元素的另一种方式是先从第一个集合中取 \\(k\\) 个元素，接着从第二个集合中取 \\(r - k\\) 个元素，其中 \\(k\\) 是满足 \\(0 \\leqslant k \\leqslant r\\) 的整数。因为从第二个集合中选取 \\(k\\) 个元素的方法是 \\(\\binom{n}{k}\\)，从第一个集合中选取 \\(r - k\\) 个元素的方法是 \\(\\binom{m}{r-k}\\)，所以由乘积法则，这可以用 \\(\\binom{m}{r-k} \\binom{n}{k}\\) 种方式完成。所以，从这个并集中选取 \\(r\\) 个元素的总方式数等于 \\(\\sum_{k=0}^{r} \\binom{m}{r-k} \\binom{n}{k}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.048,
                0.67,
                0.891,
                0.707
            ],
            "angle": 0,
            "content": "我们已经找到从一个 \\(m\\) 个元素集合和一个 \\(n\\) 元素集合并集中取 \\(r\\) 个元素的方法数的两种表达式。这就证明了范德蒙德恒等式。"
        },
        {
            "type": "text",
            "bbox": [
                0.086,
                0.709,
                0.343,
                0.726
            ],
            "angle": 0,
            "content": "推论4来自范德蒙德恒等式。"
        },
        {
            "type": "title",
            "bbox": [
                0.046,
                0.763,
                0.087,
                0.779
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "image",
            "bbox": [
                0.05,
                0.796,
                0.186,
                0.908
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.046,
                0.912,
                0.182,
                0.932
            ],
            "angle": 0,
            "content": "Source: National Library of Medicine"
        },
        {
            "type": "text",
            "bbox": [
                0.204,
                0.795,
                0.894,
                0.936
            ],
            "angle": 0,
            "content": "布莱斯·帕斯卡（Blaise Pascal，1623—1662）帕斯卡在幼年时就显现出他的才能，虽然他的父亲（对解析几何有过多项建树）为了鼓励他在其他方面的兴趣，不让他接触数学书。帕斯卡16岁时就发现了圆锥截面中的一个重要结果。18岁时他设计了一部计算机器，建造后将其卖出。帕斯卡和费马一起奠定了现代概率论的基础。在他的工作中有对现今称为帕斯卡三角形的一些发现。1654年帕斯卡放弃了对数学的追求，转而研究神学。在那以后，他只有一次重返数学。一天晚上，他因剧烈牙痛而心烦意乱。他想通过研究摆线性质来缓解疼痛。不可思议的是牙疼居然减退了，他把这一点看成上天赞成他研究数学的暗示。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.145,
                0.037,
                0.182,
                0.051
            ],
            "angle": 0,
            "content": "372"
        },
        {
            "type": "header",
            "bbox": [
                0.226,
                0.036,
                0.292,
                0.051
            ],
            "angle": 0,
            "content": "第6章"
        },
        {
            "type": "text",
            "bbox": [
                0.167,
                0.099,
                0.516,
                0.115
            ],
            "angle": 0,
            "content": "推论4 如果 \\(n\\) 是一个非负整数，那么"
        },
        {
            "type": "equation",
            "bbox": [
                0.466,
                0.117,
                0.614,
                0.153
            ],
            "angle": 0,
            "content": "\\[\n\\binom {2 n} {n} = \\sum_ {k = 0} ^ {n} \\binom {n} {k} ^ {2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.157,
                0.163,
                0.574,
                0.179
            ],
            "angle": 0,
            "content": "证明 在范德蒙德恒等式中令 \\(m = r = n\\) ，得到"
        },
        {
            "type": "equation",
            "bbox": [
                0.388,
                0.182,
                0.697,
                0.218
            ],
            "angle": 0,
            "content": "\\[\n\\binom {2 n} {n} = \\sum_ {k = 0} ^ {n} \\binom {n} {n - k} \\binom {n} {k} = \\sum_ {k = 0} ^ {n} \\binom {n} {k} ^ {2}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.224,
                0.522,
                0.254
            ],
            "angle": 0,
            "content": "最后一步的相等使用了恒等式 \\(\\binom{n}{k}=\\binom{n}{n-k}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.158,
                0.258,
                0.912,
                0.275
            ],
            "angle": 0,
            "content": "我们可以通过计数具有不同性质的比特串来证明组合恒等式，如定理4的证明所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.169,
                0.284,
                0.554,
                0.3
            ],
            "angle": 0,
            "content": "定理4 设 \\(n\\) 和 \\(r\\) 是非负整数，\\(r \\leqslant n\\)，那么"
        },
        {
            "type": "equation",
            "bbox": [
                0.46,
                0.304,
                0.624,
                0.339
            ],
            "angle": 0,
            "content": "\\[\n\\binom {n + 1} {r + 1} = \\sum_ {j = r} ^ {n} \\binom {j} {r}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.35,
                0.966,
                0.402
            ],
            "angle": 0,
            "content": "证明 我们使用组合证明。由6.3节例14，左边 \\(\\binom{n+1}{r+1}\\) 计数了长度为 \\(n+1\\) 的比特串包含了 \\(r+1\\) 个1。"
        },
        {
            "type": "text",
            "bbox": [
                0.12,
                0.405,
                0.971,
                0.496
            ],
            "angle": 0,
            "content": "我们证明在具有 \\(r + 1\\) 个1的比特串中，通过考虑与最后一个1可能位置的相关情况，等式右边计数了同样的对象。这最后一个1一定出现在位置 \\(r + 1\\) ， \\(r + 2\\) ，…，或者 \\(n + 1\\) 。此外，如果最后一个1出现在第 \\(k\\) 位，那么一定有 \\(r\\) 个1出现在前 \\(k - 1\\) 位。因此，根据6.3节例14，这样的比特串有 \\(\\binom{k-1}{r}\\) 个，对所有的 \\(k\\) 求和，其中 \\(r + 1 \\leqslant k \\leqslant n + 1\\) ，我们发现有"
        },
        {
            "type": "equation",
            "bbox": [
                0.446,
                0.499,
                0.646,
                0.535
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {k = r + 1} ^ {n + 1} \\binom {k - 1} {r} = \\sum_ {j = r} ^ {n} \\binom {j} {r}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.121,
                0.537,
                0.969,
                0.575
            ],
            "angle": 0,
            "content": "个 \\(n\\) 位比特串恰含有 \\(r + 1\\) 个1。（注意，最后一步是改变变量 \\(j = k - 1\\) 的结果。）由于左边和右边计数了同样的对象，因此相等。这就完成了证明。"
        },
        {
            "type": "title",
            "bbox": [
                0.124,
                0.585,
                0.171,
                0.6
            ],
            "angle": 0,
            "content": "练习"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.605,
                0.322,
                0.618
            ],
            "angle": 0,
            "content": "1. 求 \\((x + y)^4\\) 的展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.145,
                0.622,
                0.398,
                0.636
            ],
            "angle": 0,
            "content": "a)使用组合理由，如例1所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.554,
                0.622,
                0.713,
                0.636
            ],
            "angle": 0,
            "content": "b)使用二项式定理。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.64,
                0.322,
                0.653
            ],
            "angle": 0,
            "content": "2. 求 \\((x + y)^5\\) 的展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.146,
                0.657,
                0.398,
                0.671
            ],
            "angle": 0,
            "content": "a)使用组合理由，如例1所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.554,
                0.657,
                0.713,
                0.671
            ],
            "angle": 0,
            "content": "b)使用二项式定理。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.674,
                0.322,
                0.687
            ],
            "angle": 0,
            "content": "3. 求 \\((x + y)^6\\) 的展开式。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.692,
                0.461,
                0.705
            ],
            "angle": 0,
            "content": "4. 求在 \\((x + y)^{13}\\) 的展开式中 \\(x^{5}y^{8}\\) 的系数。"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.709,
                0.423,
                0.723
            ],
            "angle": 0,
            "content": "5. 在 \\((x + y)^{100}\\) 的展开式中有多少项？"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.727,
                0.408,
                0.74
            ],
            "angle": 0,
            "content": "6. 在 \\((1 + x)^{11}\\) 中 \\(x^7\\) 的系数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.744,
                0.408,
                0.757
            ],
            "angle": 0,
            "content": "7. 在 \\((2 - x)^{19}\\) 中 \\(x^9\\) 的系数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.762,
                0.445,
                0.775
            ],
            "angle": 0,
            "content": "8. 在 \\((3x + 2y)^{17}\\) 中 \\(x^{8}y^{9}\\) 的系数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.779,
                0.462,
                0.793
            ],
            "angle": 0,
            "content": "9. 在 \\((2x - 3y)^{200}\\) 中 \\(x^{101}y^{99}\\) 的系数是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.123,
                0.796,
                0.842,
                0.811
            ],
            "angle": 0,
            "content": "10. 使用二次项定理展开 \\((3x - y^2)^4\\)，每一项形式为 \\(cx^a y^b\\)，\\(c\\) 为实数，\\(a\\) 和 \\(b\\) 为非负整数。"
        },
        {
            "type": "list",
            "bbox": [
                0.123,
                0.674,
                0.842,
                0.811
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.125,
                0.821,
                0.171,
                0.837
            ],
            "angle": 0,
            "content": "Links"
        },
        {
            "type": "text",
            "bbox": [
                0.125,
                0.846,
                0.976,
                0.934
            ],
            "angle": 0,
            "content": "亚历山大-舍费尔·范德蒙德（Alexandre-ThéophileVandermonde，1735—1796）范德蒙德年幼时体弱多病，作为医生的父亲让他从事音乐职业。但是后来，他对数学越来越感兴趣。他完整的数学工作包含在\\(1771\\sim 1772\\) 年发表的4篇论文中。这些论文包含了在方程求根、行列式理论以及骑士旅行问题(在10.5节的练习中介绍)方面的基础贡献。范德蒙德对数学的兴趣只持续了两年。后来，他在和声学、寒冷实验以及钢的制造等方面发表论文。他也对政治产生了兴趣，参加了法国革命，并且在政府中担任了几个不同的职务。"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.698,
                0.035,
                0.787,
                0.049
            ],
            "angle": 0,
            "content": "计数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.834,
                0.036,
                0.869,
                0.049
            ],
            "angle": 0,
            "content": "373"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.09,
                0.787,
                0.106
            ],
            "angle": 0,
            "content": "11. 使用二次项定理展开 \\((3x^{4} - 2y^{3})^{5}\\)，每一项形式为 \\(cx^a y^b\\)，\\(c\\) 为实数，\\(a\\) 和 \\(b\\) 为非负整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.108,
                0.535,
                0.123
            ],
            "angle": 0,
            "content": "12. 使用二次项定理找到 \\((5x^{2} + 2y^{3})^{6}\\) 展开式中 \\(x^{a}y^{b}\\) 的系数。"
        },
        {
            "type": "equation",
            "bbox": [
                0.087,
                0.127,
                0.605,
                0.173
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} \\mathrm {a}) a = 6, b = 9 \\\\ \\mathrm {b}) a = 2, b = 1 5 \\\\ \\mathrm {c}) a = 3, b = 1 2 \\\\ \\mathrm {d}) a = 1 2, b = 0 \\\\ e) a = 8, b = 9 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.177,
                0.535,
                0.192
            ],
            "angle": 0,
            "content": "13. 使用二次项定理找到 \\((2x^{3} - 4y^{2})^{7}\\) 展开式中 \\(x^{a}y^{b}\\) 的系数。"
        },
        {
            "type": "equation",
            "bbox": [
                0.087,
                0.196,
                0.605,
                0.242
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{l} \\mathrm {a}) a = 9, b = 8 \\\\ \\mathrm {b}) a = 8, b = 0 \\\\ \\mathrm {c}) a = 0, b = 1 4 \\\\ \\mathrm {d}) a = 1 2, b = 6 \\\\ e) a = 1 8, b = 2 \\\\ \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.246,
                0.648,
                0.262
            ],
            "angle": 0,
            "content": "* 14. 给出一个关于 \\((x + 1 / x)^{100}\\) 的展开式中 \\(x^k\\) 系数的公式，其中 \\(k\\) 是整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.264,
                0.655,
                0.28
            ],
            "angle": 0,
            "content": "* 15. 给出一个关于 \\((x^{2} - 1 / x)^{100}\\) 的展开式中 \\(x^{k}\\) 系数的公式，其中 \\(k\\) 是整数。"
        },
        {
            "type": "list",
            "bbox": [
                0.041,
                0.246,
                0.655,
                0.28
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.284,
                0.545,
                0.312
            ],
            "angle": 0,
            "content": "16. 帕斯卡三角形中包含二项式系数 \\(\\binom{10}{k} (0 \\leqslant k \\leqslant 10)\\) 的行是"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.316,
                0.507,
                0.329
            ],
            "angle": 0,
            "content": "1 10 45 120 210 252 210 120 45 10 1"
        },
        {
            "type": "text",
            "bbox": [
                0.088,
                0.333,
                0.602,
                0.348
            ],
            "angle": 0,
            "content": "用帕斯卡恒等式计算在帕斯卡三角形中紧接这行下面的另一行。"
        },
        {
            "type": "text",
            "bbox": [
                0.056,
                0.352,
                0.574,
                0.381
            ],
            "angle": 0,
            "content": "17. 帕斯卡三角形中包含二项式系数 \\(\\binom{9}{k} (0 \\leqslant k \\leqslant 9)\\) 的行是什么？"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.385,
                0.316,
                0.4
            ],
            "angle": 0,
            "content": "18. 证明：如果 \\( n \\) 是正整数，则"
        },
        {
            "type": "list",
            "bbox": [
                0.056,
                0.352,
                0.574,
                0.4
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "equation",
            "bbox": [
                0.19,
                0.405,
                0.772,
                0.436
            ],
            "angle": 0,
            "content": "\\[\n1 = \\binom {n} {0} <   \\binom {n} {1} <   \\dots <   \\binom {n} {\\lfloor n / 2 \\rfloor} = \\binom {n} {\\lceil n / 2 \\rceil} > \\dots > \\binom {n} {n - 1} > \\binom {n} {n} = 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.44,
                0.492,
                0.468
            ],
            "angle": 0,
            "content": "19. 证明：对一切正整数 \\(n\\) 和 \\(k (0 \\leqslant k \\leqslant n)\\)，\\(\\binom{n}{k} \\leqslant 2^n\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.475,
                0.673,
                0.505
            ],
            "angle": 0,
            "content": "20. a) 用练习14和推论1证明如果 \\(n\\) 是大于1的整数，那么 \\(\\binom{n}{\\lfloor n/2 \\rfloor} \\geqslant 2^n / n\\)。"
        },
        {
            "type": "list",
            "bbox": [
                0.058,
                0.44,
                0.673,
                0.505
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.09,
                0.508,
                0.487,
                0.536
            ],
            "angle": 0,
            "content": "b)从a确定如果 \\(n\\) 是正整数，那么 \\(\\binom{2n}{n} \\geqslant 4^n / 2n\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.027,
                0.545,
                0.601,
                0.571
            ],
            "angle": 0,
            "content": "21. 证明：如果 \\(n\\) 和 \\(k\\) 是整数，其中 \\(1 \\leqslant k \\leqslant n\\)，那么 \\(\\binom{n}{k} \\leqslant n^k / 2^{k-1}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.575,
                0.906,
                0.607
            ],
            "angle": 0,
            "content": "22. 设 \\(b\\) 是整数，\\(b \\geq 7\\)。使用二项式定理和帕斯卡三角形中适当的行找出 \\((11)_{b}^{4}\\) 的以 \\(b\\) 为基的展开式[就是以 \\(b\\) 为基的数 \\((11)_{b}\\) 的4次方]。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.614,
                0.418,
                0.639
            ],
            "angle": 0,
            "content": "23. 使用关于 \\(\\binom{n}{r}\\) 的公式证明帕斯卡恒等式。"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.644,
                0.477,
                0.659
            ],
            "angle": 0,
            "content": "24. 设 \\(k\\) 和 \\(n\\) 是整数，\\(1 \\leqslant k < n\\)，证明六边形恒等式"
        },
        {
            "type": "list",
            "bbox": [
                0.027,
                0.545,
                0.906,
                0.659
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "equation",
            "bbox": [
                0.288,
                0.662,
                0.713,
                0.693
            ],
            "angle": 0,
            "content": "\\[\n\\binom {n - 1} {k - 1} \\binom {n} {k + 1} \\binom {n + 1} {k} = \\binom {n - 1} {k} \\binom {n} {k - 1} \\binom {n + 1} {k + 1}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.696,
                0.403,
                0.711
            ],
            "angle": 0,
            "content": "这些项在帕斯卡三角形中构成六边形。"
        },
        {
            "type": "text",
            "bbox": [
                0.03,
                0.716,
                0.588,
                0.744
            ],
            "angle": 0,
            "content": "25. 证明：如果 \\(n\\) 和 \\(k\\) 是整数，\\(1 \\leqslant k \\leqslant n\\)，那么 \\(k\\binom{n}{k}=n\\binom{n-1}{k-1}\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.748,
                0.909,
                0.78
            ],
            "angle": 0,
            "content": "a)使用组合证明。[提示：证明恒等式两边计数了从一个 \\(n\\) 元素集合中选 \\(k\\) 个元素，然后从这个子集中再选1个元素的方法。]"
        },
        {
            "type": "text",
            "bbox": [
                0.093,
                0.787,
                0.531,
                0.812
            ],
            "angle": 0,
            "content": "b)使用基于6.3节定理2给出的 \\(\\binom{n}{r}\\) 公式的代数证明。"
        },
        {
            "type": "list",
            "bbox": [
                0.091,
                0.748,
                0.909,
                0.812
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.062,
                0.819,
                0.728,
                0.848
            ],
            "angle": 0,
            "content": "26. 证明恒等式 \\(\\binom{n}{r}\\binom{r}{k}=\\binom{n}{k}\\binom{n-k}{r-k}\\)，其中 \\(n\\)、\\(r\\) 和 \\(k\\) 是非负整数且 \\(r\\leqslant n\\)，\\(k\\leqslant r\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.852,
                0.236,
                0.866
            ],
            "angle": 0,
            "content": "a)使用组合证明。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.869,
                0.514,
                0.883
            ],
            "angle": 0,
            "content": "b)使用以 \\(n\\) 元素集合的 \\(r\\) 组合数公式为基础的论证。"
        },
        {
            "type": "list",
            "bbox": [
                0.094,
                0.852,
                0.514,
                0.883
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.064,
                0.887,
                0.377,
                0.901
            ],
            "angle": 0,
            "content": "27. 证明：如果 \\(n\\) 和 \\(k\\) 是正整数，那么"
        },
        {
            "type": "equation",
            "bbox": [
                0.395,
                0.905,
                0.617,
                0.935
            ],
            "angle": 0,
            "content": "\\[\n\\binom {n + 1} {k} = (n + 1) \\binom {n} {k - 1} / k\n\\]"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.128,
                0.037,
                0.164,
                0.051
            ],
            "angle": 0,
            "content": "374"
        },
        {
            "type": "header",
            "bbox": [
                0.21,
                0.036,
                0.275,
                0.051
            ],
            "angle": 0,
            "content": "第6章"
        },
        {
            "type": "text",
            "bbox": [
                0.132,
                0.092,
                0.533,
                0.107
            ],
            "angle": 0,
            "content": "使用这个恒等式构造一个二项式系数的归纳定义。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.114,
                0.708,
                0.141
            ],
            "angle": 0,
            "content": "28. 证明：如果 \\( p \\) 是素数，\\( k \\) 是满足 \\( 1 \\leqslant k \\leqslant p - 1 \\) 的整数，那么 \\( p \\) 整除 \\( \\binom{p}{k} \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.145,
                0.301,
                0.16
            ],
            "angle": 0,
            "content": "29. 设 \\(n\\) 是正整数，证明"
        },
        {
            "type": "equation",
            "bbox": [
                0.406,
                0.163,
                0.643,
                0.195
            ],
            "angle": 0,
            "content": "\\[\n\\binom {2 n} {n + 1} + \\binom {2 n} {n} = \\binom {2 n + 2} {n + 1} / 2\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.198,
                0.404,
                0.212
            ],
            "angle": 0,
            "content": "* 30. 设 \\( n \\) 和 \\( k \\) 是整数, \\( 1 \\leqslant k \\leqslant n \\), 证明"
        },
        {
            "type": "equation",
            "bbox": [
                0.363,
                0.216,
                0.68,
                0.248
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {k = 1} ^ {n} \\binom {n} {k} \\binom {n} {k - 1} = \\binom {2 n + 2} {n + 1} / 2 - \\binom {2 n} {n}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.251,
                0.172,
                0.265
            ],
            "angle": 0,
            "content": "*31. 证明"
        },
        {
            "type": "equation",
            "bbox": [
                0.428,
                0.268,
                0.648,
                0.302
            ],
            "angle": 0,
            "content": "\\[\n\\sum_ {k = 0} ^ {r} \\binom {n + k} {k} = \\binom {n + r + 1} {r}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.131,
                0.304,
                0.308,
                0.318
            ],
            "angle": 0,
            "content": "其中 \\(n\\) 和 \\(r\\) 是正整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.13,
                0.322,
                0.253,
                0.336
            ],
            "angle": 0,
            "content": "a)用组合论证。"
        },
        {
            "type": "text",
            "bbox": [
                0.13,
                0.339,
                0.29,
                0.353
            ],
            "angle": 0,
            "content": "b)用帕斯卡恒等式。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.358,
                0.507,
                0.388
            ],
            "angle": 0,
            "content": "32. 证明：如果 \\( n \\) 是正整数，则 \\( \\binom{2n}{2} = 2\\binom{n}{2} + n^2 \\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.128,
                0.392,
                0.263,
                0.406
            ],
            "angle": 0,
            "content": "a)使用组合论证"
        },
        {
            "type": "text",
            "bbox": [
                0.129,
                0.41,
                0.263,
                0.424
            ],
            "angle": 0,
            "content": "b) 通过代数推导"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.43,
                0.943,
                0.477
            ],
            "angle": 0,
            "content": "* 33. 给出关于 \\(\\sum_{k=1}^{n} k \\binom{n}{k} = n2^{n-1}\\) 的组合证明。[提示：以两种方法计数选择一个委员会，然后选择这个委员会领导的方式数。]"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.481,
                0.943,
                0.547
            ],
            "angle": 0,
            "content": "* 34. 给出关于 \\(\\sum_{k=1}^{n} k\\binom{n}{k}^2 = n\\binom{2n-1}{n-1}\\) 的组合证明。[提示：用两种方法计数选择一个委员会的方式数，如果这个委员会有 \\(n\\) 个成员，要求这些成员选自 \\(n\\) 个数学教授和 \\(n\\) 个计算机科学教授，并使得委员会的主席是数学教授。]"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.55,
                0.772,
                0.565
            ],
            "angle": 0,
            "content": "35. 证明：一个非空集合具有奇数个元素的子集数与具有偶数个元素的子集数相等。"
        },
        {
            "type": "text",
            "bbox": [
                0.082,
                0.568,
                0.401,
                0.582
            ],
            "angle": 0,
            "content": "* 36. 使用数学归纳法证明二项式定理。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.585,
                0.943,
                0.636
            ],
            "angle": 0,
            "content": "37. 在这个练习里，我们将要计数 \\(xy\\) 平面上在原点和 \\((m, n)\\) 点之间的路径数。这些路径由一系列步构成，其中每一步是向右或者向上移动一个单位（不允许向左或向下移动）。下图给出了两条这种从(0, 0)到(5, 3)的路径（用粗线标识）。"
        },
        {
            "type": "image",
            "bbox": [
                0.268,
                0.642,
                0.521,
                0.737
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image",
            "bbox": [
                0.565,
                0.642,
                0.806,
                0.737
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "text",
            "bbox": [
                0.125,
                0.743,
                0.941,
                0.776
            ],
            "angle": 0,
            "content": "a) 证明上述每条这种类型的路径可以用由 \\(m\\) 个 0 和 \\(n\\) 个 1 组成的比特串表示，其中 0 表示向右移动一个单位，1 表示向上移动一个单位。"
        },
        {
            "type": "text",
            "bbox": [
                0.126,
                0.781,
                0.503,
                0.81
            ],
            "angle": 0,
            "content": "b)从a推断存在着 \\(\\binom{m+n}{n}\\) 条所求类型的路径。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.819,
                0.941,
                0.863
            ],
            "angle": 0,
            "content": "38. 用练习37证明 \\(\\binom{n}{k}=\\binom{n}{n-k}\\)，其中 \\(k\\) 是整数，满足 \\(0 \\leqslant k \\leqslant n\\)。[提示：考虑在练习37中所述的从(0,0)到 \\((n-k, k)\\) 和从(0,0)到 \\((k, n-k)\\) 的路径数。]"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.866,
                0.941,
                0.899
            ],
            "angle": 0,
            "content": "39. 使用练习 37 证明定理 4。[提示：计数练习 37 所描述的那种 \\( n \\) 步路径数。每条路径必须在一个 \\((n - k, k)\\) 点结束，其中 \\( k = 0, 1, 2, \\dots, n \\)。]"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.902,
                0.941,
                0.935
            ],
            "angle": 0,
            "content": "40. 使用练习37证明帕斯卡恒等式。[提示：显示一条在练习37所描述的那种从(0，0)到 \\((n + 1 - k,k)\\) 并通过 \\((n + 1 - k\\) ， \\(k - 1)\\) 点或 \\((n - k\\) ， \\(k)\\) 点但不同时通过这两点的路径。]"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.704,
                0.04,
                0.793,
                0.055
            ],
            "angle": 0,
            "content": "计数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.839,
                0.041,
                0.874,
                0.054
            ],
            "angle": 0,
            "content": "375"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.096,
                0.904,
                0.165
            ],
            "angle": 0,
            "content": "41. 使用练习37证明练习31中的恒等式。[提示：首先注意从(0，0)到 \\((n + 1,r)\\) 的路径数等于\\(\\binom{n+1+r}{r}\\)。其次，按照开始向上恰好走 \\(k\\) 个单位分别计数每一类路径，其中 \\(k = 0,1,2,\\dots ,r,\\) 然后对结果求和。]"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.17,
                0.905,
                0.237
            ],
            "angle": 0,
            "content": "42. 如果 \\( n \\) 是正整数，则 \\( \\sum_{k=0}^{n} k^2 \\binom{n}{k} = n(n+1) 2^{n-2} \\)，给出组合证明。[提示：证明等式两边计数了从一个 \\( n \\) 元素集合中选一个子集，再从子集中选 2 个元素的方法，其中这 2 个元素可以相同。而且，等式右边可以表示成 \\( n(n-1) 2^{n-2} + n 2^{n-1} \\)。]"
        },
        {
            "type": "text",
            "bbox": [
                0.041,
                0.24,
                0.905,
                0.292
            ],
            "angle": 0,
            "content": "* 43. 如果一个序列的前若干项如下列出，对于它的第 \\( n \\) 项确定一个与二项式系数有关的公式。[提示：对帕斯卡三角形的观察有助于问题的求解。虽然以这一组给定的项作为开始的序列有无数多个，但下面列出的每个序列都是所求的那种序列的开始。]"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.295,
                0.501,
                0.309
            ],
            "angle": 0,
            "content": "a)1，3，6，10，15，21，28，36，45，55，66，…"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.313,
                0.501,
                0.327
            ],
            "angle": 0,
            "content": "b)1，4，10，20，35，56，84，120，165，220，…"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.331,
                0.563,
                0.345
            ],
            "angle": 0,
            "content": "c)1，2，6，20，70，252，924，3432，12870，48620，…"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.349,
                0.456,
                0.363
            ],
            "angle": 0,
            "content": "d)1，1，2，3，6，10，20，35，70，126，…"
        },
        {
            "type": "text",
            "bbox": [
                0.085,
                0.368,
                0.417,
                0.381
            ],
            "angle": 0,
            "content": "e)1，1，1，3，1，5，15，35，1，9，…"
        },
        {
            "type": "text",
            "bbox": [
                0.084,
                0.386,
                0.667,
                0.4
            ],
            "angle": 0,
            "content": "f)1，3，15，84，495、3003，18564，116280，735471，4686825，…"
        },
        {
            "type": "list",
            "bbox": [
                0.084,
                0.295,
                0.667,
                0.4
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "title",
            "bbox": [
                0.053,
                0.416,
                0.334,
                0.435
            ],
            "angle": 0,
            "content": "6.5 排列与组合的推广"
        },
        {
            "type": "title",
            "bbox": [
                0.053,
                0.443,
                0.18,
                0.459
            ],
            "angle": 0,
            "content": "6.5.1 引言"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.463,
                0.902,
                0.537
            ],
            "angle": 0,
            "content": "在许多计数问题中，元素可以被重复使用。例如，一个字母或一个数字可以在一个车牌中多次使用。当选择一打甜甜圈时，每种可以被重复地选择。这与本章前面讨论的计数问题形成对照，因为之前我们只考虑每项至多可以使用一次的排列和组合。在这一节我们将介绍怎样求解元素可以多次使用的计数问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.54,
                0.901,
                0.595
            ],
            "angle": 0,
            "content": "还有，某些计数问题涉及不可区别的元素。例如，为计数单词 SUCCESS 的字母可能被重新排列的方式数，必须考虑相同字母的放置。这又与前面讨论的所有元素都被认为是不同的计数问题大相径庭。在这一节，我们将描述怎样求解某些元素是不可区别的计数问题。"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.598,
                0.901,
                0.634
            ],
            "angle": 0,
            "content": "此外，这一节也将解释怎样求解另一类重要的计数问题，即计数把不同的元素放入盒子的方法数的问题。这种问题的一个例子是把扑克牌发给4个玩牌人的不同的方式数。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.636,
                0.9,
                0.691
            ],
            "angle": 0,
            "content": "把本章前面描述的方法与这一节引入的方法一起考虑，就构成一个求解广泛的计数问题的有用工具箱。当把第8章讨论的新方法再加到这个库时，你将能够求解在广泛的研究领域中产生的大多数计数问题。"
        },
        {
            "type": "title",
            "bbox": [
                0.053,
                0.701,
                0.267,
                0.718
            ],
            "angle": 0,
            "content": "6.5.2 有重复的排列"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.722,
                0.762,
                0.739
            ],
            "angle": 0,
            "content": "当元素允许重复时，使用乘积法则可以很容易地计数排列数，如例1所示。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.744,
                0.571,
                0.762
            ],
            "angle": 0,
            "content": "例1 用英文大写字母可以构成多少个 \\(r\\) 位的字符串？"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.766,
                0.899,
                0.802
            ],
            "angle": 0,
            "content": "解因为有26个大写字母，且每个字母可以被重复使用，所以由乘积法则可以看出存在\\(26^{r}\\) 个 \\(r\\) 位的字符串。"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.805,
                0.595,
                0.821
            ],
            "angle": 0,
            "content": "定理1给出了当允许重复时一个 \\(n\\) 元素集合的 \\(r\\) 排列数。"
        },
        {
            "type": "text",
            "bbox": [
                0.1,
                0.831,
                0.603,
                0.849
            ],
            "angle": 0,
            "content": "定理1 具有 \\(n\\) 个物体的集合允许重复的 \\(r\\) 排列数是 \\(n^r\\)。"
        },
        {
            "type": "text",
            "bbox": [
                0.051,
                0.857,
                0.899,
                0.894
            ],
            "angle": 0,
            "content": "证明 当允许重复时，在 \\(r\\) 排列中对 \\(r\\) 个位置中的每个位置有 \\(n\\) 种方式选择集合的元素，因为对每个选择，所有 \\(n\\) 个物体都是有效的。因此，由乘积法则，当允许重复时存在 \\(n^r\\) 个 \\(r\\) 排列。"
        },
        {
            "type": "title",
            "bbox": [
                0.051,
                0.904,
                0.267,
                0.921
            ],
            "angle": 0,
            "content": "6.5.3 有重复的组合"
        },
        {
            "type": "text",
            "bbox": [
                0.091,
                0.924,
                0.433,
                0.941
            ],
            "angle": 0,
            "content": "考虑下面允许元素重复的组合的实例。"
        }
    ],
    [
        {
            "type": "page_number",
            "bbox": [
                0.14,
                0.041,
                0.176,
                0.055
            ],
            "angle": 0,
            "content": "376"
        },
        {
            "type": "header",
            "bbox": [
                0.221,
                0.04,
                0.288,
                0.055
            ],
            "angle": 0,
            "content": "第6章"
        },
        {
            "type": "text",
            "bbox": [
                0.114,
                0.099,
                0.957,
                0.137
            ],
            "angle": 0,
            "content": "例2 从包含苹果、橙子和梨的碗里选4个水果。如果选择水果的顺序无关，且只关心水果的类型而不管是该类型的哪一个水果，那么当碗中每类水果至少有4个时有多少种选法？"
        },
        {
            "type": "text",
            "bbox": [
                0.151,
                0.141,
                0.874,
                0.157
            ],
            "angle": 0,
            "content": "解为了求解这个问题，我们列出选择水果的所有可能的方式。共有15种方式："
        },
        {
            "type": "table",
            "bbox": [
                0.139,
                0.16,
                0.936,
                0.252
            ],
            "angle": 0,
            "content": "<table><tr><td>4个苹果</td><td>4个橙子</td><td>4个梨</td></tr><tr><td>3个苹果，1个橙子</td><td>3个苹果，1个梨</td><td>3个橙子，1个苹果</td></tr><tr><td>3个橙子，1个梨</td><td>3个梨，1个苹果</td><td>3个梨，1个橙子</td></tr><tr><td>2个苹果，2个橙子</td><td>2个苹果，2个梨</td><td>2个橙子，2个梨</td></tr><tr><td>2个苹果，1个橙子，1个梨</td><td>2个橙子，1个苹果，1个梨</td><td>2个梨，1个苹果，1个橙子</td></tr></table>"
        },
        {
            "type": "text",
            "bbox": [
                0.156,
                0.255,
                0.783,
                0.271
            ],
            "angle": 0,
            "content": "这个解是从3个元素的集合{苹果，橙子，梨}中允许重复的4组合数。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.274,
                0.96,
                0.309
            ],
            "angle": 0,
            "content": "为求解这种类型的更复杂的计数问题，我们需要计数一个 \\(n\\) 元素集合的 \\(r\\) 组合的一般方法。在例3中，我们将给出这一方法。"
        },
        {
            "type": "text",
            "bbox": [
                0.117,
                0.314,
                0.962,
                0.372
            ],
            "angle": 0,
            "content": "例3 从包含1美元、2美元、5美元、10美元、20美元、50美元及100美元的钱袋中选5张纸币，有多少种方式？假定不管纸币被选的次序，同种币值的纸币都是不加区别的，并且至少每种纸币有5张。"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.374,
                0.962,
                0.43
            ],
            "angle": 0,
            "content": "解因为纸币被选的次序是无关的且7种不同类型的纸币都可以选5次，所以问题涉及的是计数从7个元素的集合中允许重复的5组合数。列出所有的可能性将是很乏味的，因为存在许多的解。相反，我们将给出一种方法来计数允许重复的组合数。"
        },
        {
            "type": "text",
            "bbox": [
                0.118,
                0.432,
                0.962,
                0.487
            ],
            "angle": 0,
            "content": "假设一个零钱盒子有7个隔间，每个隔间保存一种纸币，如图1所示。这些隔间被6块隔板分开，如图中所画的。每选择1张纸币就在相应的隔间里放置1个标记。图2针对选择5张纸币的3种不同方式给出了这种对应，其中的竖线表示6个隔板，星表示5张纸币。"
        },
        {
            "type": "image",
            "bbox": [
                0.278,
                0.493,
                0.812,
                0.616
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.416,
                0.625,
                0.674,
                0.64
            ],
            "angle": 0,
            "content": "图1有7种类型纸币的零钱盒"
        },
        {
            "type": "image",
            "bbox": [
                0.223,
                0.652,
                0.871,
                0.903
            ],
            "angle": 0,
            "content": null
        },
        {
            "type": "image_caption",
            "bbox": [
                0.418,
                0.91,
                0.679,
                0.926
            ],
            "angle": 0,
            "content": "图2 选择5张纸币的方式实例"
        }
    ],
    [
        {
            "type": "header",
            "bbox": [
                0.698,
                0.037,
                0.789,
                0.052
            ],
            "angle": 0,
            "content": "计数"
        },
        {
            "type": "page_number",
            "bbox": [
                0.832,
                0.038,
                0.871,
                0.052
            ],
            "angle": 0,
            "content": "377"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.093,
                0.899,
                0.149
            ],
            "angle": 0,
            "content": "选择5张纸币的方法数对应了在总共11个位置的一行中安排6条竖线和5颗星的方法数。因此，选择5张纸币的方法数就是从11个可能的位置选5颗星位置的方法数。这对应了从含11个元素的集合中无序地选择5个元素的方法数，可以有 \\(C(11, 5)\\) 种方式。因此存在"
        },
        {
            "type": "equation",
            "bbox": [
                0.371,
                0.153,
                0.584,
                0.182
            ],
            "angle": 0,
            "content": "\\[\nC (1 1, 5) = \\frac {1 1 !}{5 ! 6 !} = 4 6 2\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.053,
                0.186,
                0.435,
                0.203
            ],
            "angle": 0,
            "content": "种方式从有7类纸币的袋中选择5张纸币。"
        },
        {
            "type": "text",
            "bbox": [
                0.094,
                0.206,
                0.332,
                0.222
            ],
            "angle": 0,
            "content": "定理2将这个讨论一般化。"
        },
        {
            "type": "text",
            "bbox": [
                0.103,
                0.232,
                0.88,
                0.249
            ],
            "angle": 0,
            "content": "定理2 \\(n\\) 个元素的集合中允许重复的 \\(r\\) 组合有 \\(C(n + r - 1, r) = C(n + r - 1, n - 1)\\) 个。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.258,
                0.902,
                0.314
            ],
            "angle": 0,
            "content": "证明 当允许重复时，\\(n\\) 元素集合的每个 \\(r\\) 组合可以用 \\(n - 1\\) 条竖线和 \\(r\\) 颗星的列表来表示。这 \\(n - 1\\) 条竖线用来标记 \\(n\\) 个不同的单元。当集合的第 \\(i\\) 个元素出现在组合中时，第 \\(i\\) 个单元就包含 1 颗星。例如，4 元素集合的一个 6 组合用 3 条竖线和 6 颗星来表示。这里"
        },
        {
            "type": "equation",
            "bbox": [
                0.397,
                0.318,
                0.56,
                0.332
            ],
            "angle": 0,
            "content": "\\[\n\\begin{array}{c c c c} \\ast & \\ast & \\ast & \\end{array}\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.336,
                0.794,
                0.353
            ],
            "angle": 0,
            "content": "代表了恰包含2个第一元素、1个第二元素、0个第三元素和3个第四元素的组合。"
        },
        {
            "type": "text",
            "bbox": [
                0.055,
                0.355,
                0.902,
                0.431
            ],
            "angle": 0,
            "content": "正如我们已经看到的，包含 \\(n - 1\\) 条竖线和 \\(r\\) 颗星的每一个不同的表对应了 \\(n\\) 元素集合的允许重复的一个 \\(r\\) 组合。这种表的个数是 \\(C(n - 1 + r, r)\\)，因为每个表对应了从包含 \\(r\\) 颗星和 \\(n - 1\\) 条竖线的 \\(n - 1 + r\\) 个位置中取 \\(r\\) 个位置来放 \\(r\\) 颗星的一种选择。这种表的个数还等于 \\(C(n - 1 + r, n - 1)\\)，因为每个表对应于取 \\(n - 1\\) 个位置来放 \\(n - 1\\) 条竖线的一种选择。"
        },
        {
            "type": "text",
            "bbox": [
                0.098,
                0.433,
                0.36,
                0.45
            ],
            "angle": 0,
            "content": "例 \\(4\\sim 6\\) 说明怎样使用定理2。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.455,
                0.902,
                0.495
            ],
            "angle": 0,
            "content": "例4设一家甜点店有4种不同类型的甜点，那么从中选6块甜点有多少种不同的方式？假定只关心甜点的类型，而不管是哪一块甜点或者选择的次序。"
        },
        {
            "type": "text",
            "bbox": [
                0.057,
                0.497,
                0.902,
                0.533
            ],
            "angle": 0,
            "content": "解 选择6块甜点的方式数是具有4元素集合的6组合数。由定理2，这等于 \\(C(4 + 6 - 1, 6) = C(9, 6)\\) 。由于"
        },
        {
            "type": "equation",
            "bbox": [
                0.323,
                0.537,
                0.639,
                0.566
            ],
            "angle": 0,
            "content": "\\[\nC (9, 6) = C (9, 3) = \\frac {9 \\cdot 8 \\cdot 7}{1 \\cdot 2 \\cdot 3} = 8 4\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.058,
                0.571,
                0.45,
                0.588
            ],
            "angle": 0,
            "content": "所以，选择6块甜点的不同方式数有84种。"
        },
        {
            "type": "text",
            "bbox": [
                0.097,
                0.59,
                0.767,
                0.608
            ],
            "angle": 0,
            "content": "定理2也可以用于求给定线性方程的整数解的个数。这可以由例5来说明。"
        },
        {
            "type": "text",
            "bbox": [
                0.099,
                0.613,
                0.197,
                0.63
            ],
            "angle": 0,
            "content": "例5 方程"
        },
        {
            "type": "equation",
            "bbox": [
                0.409,
                0.637,
                0.553,
                0.653
            ],
            "angle": 0,
            "content": "\\[\nx _ {1} + x _ {2} + x _ {3} = 1 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.656,
                0.458,
                0.673
            ],
            "angle": 0,
            "content": "有多少个解？其中 \\(x_{1}\\) 、 \\(x_{2}\\) 和 \\(x_{3}\\) 是非负整数。"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.675,
                0.907,
                0.732
            ],
            "angle": 0,
            "content": "解 为计数解的个数，注意到一个解对应了从3元素集合中选11个元素的方式，以使得 \\( x_{1} \\) 选自第一类、 \\( x_{2} \\) 选自第二类、 \\( x_{3} \\) 选自第三类。因此，解的个数等于3元素集合允许重复的11组合数。由定理2，存在解的个数为"
        },
        {
            "type": "equation",
            "bbox": [
                0.223,
                0.735,
                0.745,
                0.765
            ],
            "angle": 0,
            "content": "\\[\nC (3 + 1 1 - 1, 1 1) = C (1 3, 1 1) = C (1 3, 2) = \\frac {1 3 \\cdot 1 2}{1 \\cdot 2} = 7 8\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.059,
                0.769,
                0.907,
                0.866
            ],
            "angle": 0,
            "content": "当对变量加上限制时，也可以求出这个方程的解的个数。例如，当变量是满足 \\(x_{1} \\geqslant 1\\)、\\(x_{2} \\geqslant 2\\) 且 \\(x_{3} \\geqslant 3\\) 的整数时，也可以求出这个方程的解的个数。满足此限制的方程的解对应于11项的选择，使得项 \\(x_{1}\\) 取自第一类、项 \\(x_{2}\\) 取自第二类、项 \\(x_{3}\\) 取自第三类，并且第一类元素至少取1个、第二类元素至少取2个、第三类元素至少取3个。因此，先选1个第一类的元素，2个第二类的元素，3个第三类的元素；然后再多选5个元素。由定理2，可以用"
        },
        {
            "type": "equation",
            "bbox": [
                0.259,
                0.868,
                0.71,
                0.897
            ],
            "angle": 0,
            "content": "\\[\nC (3 + 5 - 1, 5) = C (7, 5) = C (7, 2) = \\frac {7 \\cdot 6}{1 \\cdot 2} = 2 1\n\\]"
        },
        {
            "type": "text",
            "bbox": [
                0.06,
                0.902,
                0.534,
                0.92
            ],
            "angle": 0,
            "content": "种方式做到。于是，对给定限制的方程存在21个解。"
        }
    ]
]